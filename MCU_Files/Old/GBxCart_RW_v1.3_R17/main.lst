   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R17
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 21/01/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 146:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 147:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 148:setup.c       **** 
 149:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 150:setup.c       **** 
 151:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 152:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 153:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 154:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 155:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 156:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 157:setup.c       **** 
 158:setup.c       **** #define D0D1_NOT_SWAPPED 0
 159:setup.c       **** #define D0D1_SWAPPED 1
 160:setup.c       **** 
 161:setup.c       **** // General commands
 162:setup.c       **** #define SEND_ACK '1'
 163:setup.c       **** #define CART_MODE 'C'
 164:setup.c       **** #define SET_INPUT 'I'
 165:setup.c       **** #define SET_OUTPUT 'O'
 166:setup.c       **** #define SET_OUTPUT_LOW 'L'
 167:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 168:setup.c       **** #define READ_INPUT 'D'
 169:setup.c       **** #define RESET_COMMON_LINES 'M'
 170:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 171:setup.c       **** #define READ_PCB_VERSION 'h'
 172:setup.c       **** #define VOLTAGE_3_3V '3'
 173:setup.c       **** #define VOLTAGE_5V '5'
 174:setup.c       **** 
 175:setup.c       **** #define RESET_AVR '*'
 176:setup.c       **** #define RESET_VALUE 0x7E5E1
 177:setup.c       **** 
 178:setup.c       **** 
 179:setup.c       **** char receivedBuffer[256];
 180:setup.c       **** char receivedChar;
 181:setup.c       **** uint8_t eepromBuffer[8];
 182:setup.c       **** uint8_t flashChipIdBuffer[2];
 183:setup.c       **** 
 184:setup.c       **** char flashWriteWePin;
 185:setup.c       **** uint16_t flashWriteCycle[3][2];
 186:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 187:setup.c       **** uint8_t lastBankAccessed = 0;
 188:setup.c       **** 
 189:setup.c       **** uint8_t cartMode = GBA_MODE;
 190:setup.c       **** 
 191:setup.c       **** // Receive USART data
 192:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 192 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 193:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 193 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 194:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 194 0
  26 0004 8CB1      		in r24,0xc
 195:setup.c       **** }
  27               		.loc 1 195 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 196:setup.c       **** 
 197:setup.c       **** // Transmit USART data
 198:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 198 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 199:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 199 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 200:setup.c       **** 	UDR = data;
  47               		.loc 1 200 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 201:setup.c       **** }
 202:setup.c       **** 
 203:setup.c       **** // Read 1-256 bytes from the USART 
 204:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 204 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB135:
 205:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 205 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 205 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 206:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 206 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE135:
 207:setup.c       **** 	}
 208:setup.c       **** }
 106               		.loc 1 208 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 209:setup.c       **** 
 210:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 211:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 211 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 212:setup.c       **** 	int x = 0;
 213:setup.c       **** 	while (1) {
 214:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 214 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 215:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 215 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 216:setup.c       **** 			break;
 217:setup.c       **** 		}
 218:setup.c       **** 		x++;
 219:setup.c       **** 	}
 220:setup.c       **** }
 148               		.loc 1 220 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 221:setup.c       **** 
 222:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 223:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 223 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 224:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 224 0
 167 0050 3A9A      		sbi 0x7,2
 225:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 225 0
 169 0052 949A      		sbi 0x12,4
 226:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 226 0
 171 0054 959A      		sbi 0x12,5
 227:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 227 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 228:setup.c       **** }
 229:setup.c       **** 
 230:setup.c       **** 
 231:setup.c       **** 
 232:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 233:setup.c       **** 
 234:setup.c       **** // Set Gameboy mode
 235:setup.c       **** void gb_mode(void) {
 182               		.loc 1 235 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 236:setup.c       **** 	// Set inputs
 237:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 237 0
 189 005a 15BA      		out 0x15,__zero_reg__
 238:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 238 0
 191 005c 14BA      		out 0x14,__zero_reg__
 239:setup.c       **** 	
 240:setup.c       **** 	// Set outputs
 241:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 241 0
 193 005e 18BA      		out 0x18,__zero_reg__
 242:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 242 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 243:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 243 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 244:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 244 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 245:setup.c       **** }
 246:setup.c       **** 
 247:setup.c       **** // Set the 16 bit address on A15-0
 248:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 248 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 249:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 249 0
 217 006a 9BBB      		out 0x1b,r25
 250:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 250 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 251:setup.c       **** }
 252:setup.c       **** 
 253:setup.c       **** // Set the address and read a byte from the 8 bit data line
 254:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 254 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 255:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 255 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 256:setup.c       **** 	
 257:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 257 0
 239 0072 9498      		cbi 0x12,4
 258:setup.c       **** 	rdPin_low;
 240               		.loc 1 258 0
 241 0074 9598      		cbi 0x12,5
 259:setup.c       **** 	
 260:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 260 0
 243               	/* #APP */
 244               	 ;  260 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 261:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 261 0
 248               	 ;  261 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 262:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 262 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 263:setup.c       **** 	
 264:setup.c       **** 	rdPin_high;
 255               		.loc 1 264 0
 256 007c 959A      		sbi 0x12,5
 265:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 265 0
 258 007e 949A      		sbi 0x12,4
 266:setup.c       **** 	
 267:setup.c       **** 	return data;
 268:setup.c       **** }
 259               		.loc 1 268 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 269:setup.c       **** 
 270:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 271:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 271 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 272:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 272 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 273:setup.c       **** 	
 274:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 274 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 275:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 275 0
 292 0090 D5BB      		out 0x15,r29
 276:setup.c       **** 	
 277:setup.c       **** 	// Pulse WR and mREQ if the type matches
 278:setup.c       **** 	wrPin_low;
 293               		.loc 1 278 0
 294 0092 9698      		cbi 0x12,6
 279:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 279 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 280:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 280 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 281:setup.c       **** 	}
 282:setup.c       **** 	
 283:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 283 0
 302               	/* #APP */
 303               	 ;  283 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 284:setup.c       **** 	
 285:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 285 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 286:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 286 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 287:setup.c       **** 	}
 288:setup.c       **** 	wrPin_high;
 313               		.loc 1 288 0
 314 00a2 969A      		sbi 0x12,6
 289:setup.c       **** 	
 290:setup.c       **** 	// Clear data outputs and set data pins as inputs
 291:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 291 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 292:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 292 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 293:setup.c       **** }
 320               		.loc 1 293 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 294:setup.c       **** 
 295:setup.c       **** 
 296:setup.c       **** 
 297:setup.c       **** // ****** Gameboy Advance functions ****** 
 298:setup.c       **** 
 299:setup.c       **** // Set GBA mode
 300:setup.c       **** void gba_mode(void) {
 333               		.loc 1 300 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 301:setup.c       **** 	// Set outputs for reading ROM addresses as default
 302:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 302 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 303:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 303 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 304:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 304 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 305:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 305 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 306:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 306 0
 349 00b8 8ABB      		out 0x1a,r24
 307:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 307 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 308:setup.c       **** }
 309:setup.c       **** 
 310:setup.c       **** // Set the 24 bit address on A23-0
 311:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 311 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 312:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 312 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 313:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 313 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 314:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 314 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 315:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 315 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 316:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 316 0
 385 00cc 2ABB      		out 0x1a,r18
 317:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 317 0
 387 00ce 27BB      		out 0x17,r18
 318:setup.c       **** 	
 319:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 319 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 320:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 320 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 321:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 321 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 322:setup.c       **** }
 402               		.loc 1 322 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 323:setup.c       **** 
 324:setup.c       **** 
 325:setup.c       **** 
 326:setup.c       **** // ---------- ROM/SRAM ----------
 327:setup.c       **** 
 328:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 329:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 329 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 330:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 330 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 331:setup.c       **** 	
 332:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 332 0
 424 00ec 9498      		cbi 0x12,4
 333:setup.c       **** 	
 334:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 334 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 335:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 335 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 336:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 336 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 337:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 337 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 338:setup.c       **** 	
 339:setup.c       **** 	rdPin_low;
 433               		.loc 1 339 0
 434 00f6 9598      		cbi 0x12,5
 340:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 340 0
 436               	/* #APP */
 437               	 ;  340 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 341:setup.c       **** 	
 342:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 342 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 343:setup.c       **** 	
 344:setup.c       **** 	rdPin_high;
 445               		.loc 1 344 0
 446 00fe 959A      		sbi 0x12,5
 345:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 345 0
 448 0100 949A      		sbi 0x12,4
 346:setup.c       **** 	
 347:setup.c       **** 	return data;
 449               		.loc 1 347 0
 450 0102 90E0      		ldi r25,0
 348:setup.c       **** }
 451               		.loc 1 348 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 349:setup.c       **** 
 350:setup.c       **** // Set the address and read a byte from the 8 bit data line
 351:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 351 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 352:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 352 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 353:setup.c       **** 	
 354:setup.c       **** 	rdPin_low;
 471               		.loc 1 354 0
 472 010a 9598      		cbi 0x12,5
 355:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 355 0
 474 010c 3A98      		cbi 0x7,2
 356:setup.c       **** 	
 357:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 357 0
 476               	/* #APP */
 477               	 ;  357 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 358:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 358 0
 481               	 ;  358 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 359:setup.c       **** 	
 360:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 360 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 361:setup.c       **** 	
 362:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 362 0
 489 0114 3A9A      		sbi 0x7,2
 363:setup.c       **** 	rdPin_high;
 490               		.loc 1 363 0
 491 0116 959A      		sbi 0x12,5
 364:setup.c       **** 	
 365:setup.c       **** 	return data;
 366:setup.c       **** }
 492               		.loc 1 366 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 367:setup.c       **** 
 368:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 369:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 369 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 370:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 370 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 371:setup.c       **** 	
 372:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 372 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 373:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 373 0
 520 0124 C5BB      		out 0x15,r28
 374:setup.c       **** 	
 375:setup.c       **** 	// Pulse WR
 376:setup.c       **** 	wrPin_low;
 521               		.loc 1 376 0
 522 0126 9698      		cbi 0x12,6
 377:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 377 0
 524 0128 3A98      		cbi 0x7,2
 378:setup.c       **** 	
 379:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 379 0
 526               	/* #APP */
 527               	 ;  379 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 380:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 380 0
 531               	 ;  380 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 381:setup.c       **** 	
 382:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 382 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 383:setup.c       **** 	wrPin_high;
 537               		.loc 1 383 0
 538 0130 969A      		sbi 0x12,6
 384:setup.c       **** 	
 385:setup.c       **** 	// Clear data outputs and set data pins as inputs
 386:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 386 0
 540 0132 15BA      		out 0x15,__zero_reg__
 387:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 387 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 388:setup.c       **** }
 544               		.loc 1 388 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 389:setup.c       **** 
 390:setup.c       **** 
 391:setup.c       **** 
 392:setup.c       **** // ---------- EEPROM ----------
 393:setup.c       **** 
 394:setup.c       **** // Set address/data all high (includes AD0/A23)
 395:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 395 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 396:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 396 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 397:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 397 0
 565 013e 8ABB      		out 0x1a,r24
 398:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 398 0
 567 0140 84BB      		out 0x14,r24
 399:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 399 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 400:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 400 0
 572 0146 8BBB      		out 0x1b,r24
 401:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 401 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 402:setup.c       **** }
 403:setup.c       **** 
 404:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 405:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 405 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 406:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 406 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 407:setup.c       **** 	
 408:setup.c       **** 	int8_t x = 0;
 409:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 409 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 410:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 410 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 411:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 411 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 412:setup.c       **** 		}
 413:setup.c       **** 		else {
 414:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 415:setup.c       **** 		}
 416:setup.c       **** 		x = 15;
 603               		.loc 1 416 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 417:setup.c       **** 	}
 418:setup.c       **** 	else {
 419:setup.c       **** 		if (command == EEPROM_READ) {
 420:setup.c       **** 			address |= (1<<7) | (1<<6);
 421:setup.c       **** 		}
 422:setup.c       **** 		else {
 423:setup.c       **** 			address |= (1<<7);
 424:setup.c       **** 		}
 425:setup.c       **** 		x = 7;
 426:setup.c       **** 	}
 427:setup.c       **** 	
 428:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 429:setup.c       **** 	while (x >= 0) {
 430:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 430 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 414:setup.c       **** 		}
 613               		.loc 1 414 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 419:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 419 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 420:setup.c       **** 		}
 621               		.loc 1 420 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 423:setup.c       **** 		}
 626               		.loc 1 423 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 425:setup.c       **** 	}
 630               		.loc 1 425 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 431:setup.c       **** 			ad0Pin_high;
 432:setup.c       **** 		}
 433:setup.c       **** 		else {
 434:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 434 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 435:setup.c       **** 		}
 436:setup.c       **** 		
 437:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 437 0
 639 0174 9698      		cbi 0x12,6
 438:setup.c       **** 		asm ("nop");
 640               		.loc 1 438 0
 641               	/* #APP */
 642               	 ;  438 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 439:setup.c       **** 		asm ("nop");
 645               		.loc 1 439 0
 646               	 ;  439 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 440:setup.c       **** 		wrPin_high; 
 649               		.loc 1 440 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 441:setup.c       **** 		asm ("nop");
 652               		.loc 1 441 0
 653               	/* #APP */
 654               	 ;  441 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 442:setup.c       **** 		asm ("nop");
 657               		.loc 1 442 0
 658               	 ;  442 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 429:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 429 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 430:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 430 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 431:setup.c       **** 		}
 682               		.loc 1 431 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 443:setup.c       **** 		
 444:setup.c       **** 		x--;
 445:setup.c       **** 	}
 446:setup.c       **** 	
 447:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 448:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 448 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 449:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 449 0
 690 01a4 C098      		cbi 0x18,0
 450:setup.c       **** 		asm ("nop");
 691               		.loc 1 450 0
 692               	/* #APP */
 693               	 ;  450 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 451:setup.c       **** 		wrPin_low;
 696               		.loc 1 451 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 452:setup.c       **** 		asm ("nop");
 699               		.loc 1 452 0
 700               	/* #APP */
 701               	 ;  452 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 453:setup.c       **** 		asm ("nop");
 704               		.loc 1 453 0
 705               	 ;  453 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 454:setup.c       **** 		
 455:setup.c       **** 		wrPin_high;
 708               		.loc 1 455 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 456:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 456 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 457:setup.c       **** 	}
 458:setup.c       **** }
 459:setup.c       **** 
 460:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 461:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 461 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 462:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 462 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 463:setup.c       **** 	
 464:setup.c       **** 	// Set AD0 pin as input
 465:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 465 0
 734 01b8 C098      		cbi 0x18,0
 466:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 466 0
 736 01ba B898      		cbi 0x17,0
 467:setup.c       **** 	
 468:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 468 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB136:
 469:setup.c       **** 	
 470:setup.c       **** 	// Ignore first 4 bits
 471:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 472:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 472 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 473:setup.c       **** 		asm ("nop");
 746               		.loc 1 473 0 discriminator 3
 747               	/* #APP */
 748               	 ;  473 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 474:setup.c       **** 		asm ("nop");
 751               		.loc 1 474 0 discriminator 3
 752               	 ;  474 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 475:setup.c       **** 		rdPin_high; 
 755               		.loc 1 475 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 476:setup.c       **** 		asm ("nop");
 758               		.loc 1 476 0 discriminator 3
 759               	/* #APP */
 760               	 ;  476 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 477:setup.c       **** 		asm ("nop");
 763               		.loc 1 477 0 discriminator 3
 764               	 ;  477 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 471:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 471 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE136:
 776               	.LBB137:
 777               	.LBB138:
 778               	.LBB139:
 478:setup.c       **** 	}
 479:setup.c       **** 	
 480:setup.c       **** 	// Read out 64 bits
 481:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 482:setup.c       **** 		uint8_t data = 0;
 483:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 484:setup.c       **** 			rdPin_low; // CLK
 485:setup.c       **** 			asm ("nop");
 486:setup.c       **** 			asm ("nop");
 487:setup.c       **** 			rdPin_high;
 488:setup.c       **** 			
 489:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 490:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 490 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE139:
 785               	.LBE138:
 786               	.LBE137:
 468:setup.c       **** 	
 787               		.loc 1 468 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB142:
 794               	.LBB141:
 795               	.LBB140:
 484:setup.c       **** 			asm ("nop");
 796               		.loc 1 484 0
 797 01de 9598      		cbi 0x12,5
 485:setup.c       **** 			asm ("nop");
 798               		.loc 1 485 0
 799               	/* #APP */
 800               	 ;  485 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 486:setup.c       **** 			rdPin_high;
 803               		.loc 1 486 0
 804               	 ;  486 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 487:setup.c       **** 			
 807               		.loc 1 487 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 489:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 489 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 490 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE140:
 491:setup.c       **** 			}
 492:setup.c       **** 		}
 493:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 493 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE141:
 481:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 481 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE142:
 494:setup.c       **** 	}
 495:setup.c       **** 	
 496:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 496 0
 841 0206 949A      		sbi 0x12,4
 497:setup.c       **** 	
 498:setup.c       **** 	// Set AD0 pin as output
 499:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 499 0
 843 0208 C09A      		sbi 0x18,0
 500:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 500 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 501:setup.c       **** }
 502:setup.c       **** 
 503:setup.c       **** // Write 8 bytes to the EEPROM address
 504:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 504 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 505:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 505 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 504:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 504 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB143:
 876               	.LBB144:
 506:setup.c       **** 	
 507:setup.c       **** 	// Write 64 bits
 508:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 509:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 510:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 510 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 511:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 511 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 512:setup.c       **** 			}
 513:setup.c       **** 			else {
 514:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 514 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 515:setup.c       **** 			}
 516:setup.c       **** 			
 517:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 517 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 518:setup.c       **** 			asm ("nop");
 899               		.loc 1 518 0 discriminator 2
 900               	/* #APP */
 901               	 ;  518 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 519:setup.c       **** 			asm ("nop");
 904               		.loc 1 519 0 discriminator 2
 905               	 ;  519 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 520:setup.c       **** 			wrPin_high; 
 908               		.loc 1 520 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 521:setup.c       **** 			asm ("nop");
 911               		.loc 1 521 0 discriminator 2
 912               	/* #APP */
 913               	 ;  521 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 522:setup.c       **** 			asm ("nop");
 916               		.loc 1 522 0 discriminator 2
 917               	 ;  522 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE144:
 508:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 508 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE143:
 523:setup.c       **** 		}
 524:setup.c       **** 	}
 525:setup.c       **** 	
 526:setup.c       **** 	// Last bit low
 527:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 527 0
 935 0250 C098      		cbi 0x18,0
 528:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 528 0
 937 0252 9698      		cbi 0x12,6
 529:setup.c       **** 	asm ("nop");
 938               		.loc 1 529 0
 939               	/* #APP */
 940               	 ;  529 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 530:setup.c       **** 	asm ("nop");
 943               		.loc 1 530 0
 944               	 ;  530 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 531:setup.c       **** 	wrPin_high; 
 947               		.loc 1 531 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 532:setup.c       **** 	asm ("nop");
 950               		.loc 1 532 0
 951               	/* #APP */
 952               	 ;  532 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 533:setup.c       **** 	asm ("nop");
 955               		.loc 1 533 0
 956               	 ;  533 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 534:setup.c       **** 	
 535:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 535 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 536:setup.c       **** }
 537:setup.c       **** 
 538:setup.c       **** 
 539:setup.c       **** 
 540:setup.c       **** // ---------- FLASH ----------
 541:setup.c       **** 
 542:setup.c       **** // Set the address and data for the write byte cycle to the flash
 543:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 543 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 544:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 544 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 545:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 545 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 546:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 546 0
 989 026c C5BB      		out 0x15,r28
 547:setup.c       **** 	
 548:setup.c       **** 	wrPin_low;
 990               		.loc 1 548 0
 991 026e 9698      		cbi 0x12,6
 549:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 549 0
 993 0270 3A98      		cbi 0x7,2
 550:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 550 0
 995               	/* #APP */
 996               	 ;  550 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 551:setup.c       **** 	wrPin_high;
 999               		.loc 1 551 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 552:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 552 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 553:setup.c       **** }
 1005               		.loc 1 553 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 554:setup.c       **** 
 555:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 556:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 556 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 557:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 557 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 558:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 558 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 559:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 559 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB145:
 1049               	.LBB146:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE146:
 1060               	.LBE145:
 560:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 561:setup.c       **** 	
 562:setup.c       **** 	// Set data as inputs
 563:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 563 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 564:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 564 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 565:setup.c       **** 	
 566:setup.c       **** 	// Read and transmit the 2 bytes
 567:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 567 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 568:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 568 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 569:setup.c       **** 	
 570:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 570 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 571:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 571 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 572:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 572 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB147:
 1098               	.LBB148:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE148:
 1109               	.LBE147:
 573:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 574:setup.c       **** }
 1110               		.loc 1 574 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 575:setup.c       **** 
 576:setup.c       **** // Switch banks on the Flash
 577:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 577 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 578:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 578 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 579:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 579 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 580:setup.c       **** 	
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 581 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 582:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 582 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 583:setup.c       **** }
 1157               		.loc 1 583 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 582:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 582 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 584:setup.c       **** 
 585:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 586:setup.c       **** // Takes 25ms after last command to erase sector
 587:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 587 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 588:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 588 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 589:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 589 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 590:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 590 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 591:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 591 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 592:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 592 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 593:setup.c       **** 	
 594:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 594 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB149:
 1222               	.LBB150:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE150:
 1233               	.LBE149:
 595:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 596:setup.c       **** }
 1234               		.loc 1 596 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 597:setup.c       **** 
 598:setup.c       **** // Write a single byte to the Flash address
 599:setup.c       **** // Takes 20us to program Flash
 600:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 600 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 601:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 601 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 602:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 602 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 603:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 603 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 604:setup.c       **** 	
 605:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 605 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB151:
 1292               	.LBB152:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE152:
 1301               	.LBE151:
 606:setup.c       **** 	_delay_us(20); // Wait byte program time
 607:setup.c       **** }
 1302               		.loc 1 607 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 608:setup.c       **** 
 609:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 610:setup.c       **** // Takes 20ms for write cycle
 611:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 611 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 612:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 612 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 613:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 613 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 614:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 614 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB153:
 615:setup.c       **** 	
 616:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 617:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 618:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 618 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 618 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 617:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 617 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE153:
 1400               	.LBB154:
 1401               	.LBB155:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE155:
 1412               	.LBE154:
 619:setup.c       **** 	}
 620:setup.c       **** 	_delay_ms(20); // Wait sector program time
 621:setup.c       **** }
 1413               		.loc 1 621 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 622:setup.c       **** 
 623:setup.c       **** 
 624:setup.c       **** 
 625:setup.c       **** // ---------- GB FLASH CARTS ----------
 626:setup.c       **** 
 627:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 628:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 628 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 629:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 629 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 630:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 630 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 631:setup.c       **** 	
 632:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 632 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 633:setup.c       **** 	
 634:setup.c       **** 	rdPin_low;
 1443               		.loc 1 634 0
 1444 03fe 9598      		cbi 0x12,5
 635:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 635 0
 1446               	/* #APP */
 1447               	 ;  635 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 636:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 636 0
 1451               	 ;  636 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 637:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 637 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 638:setup.c       **** 	rdPin_high;
 1458               		.loc 1 638 0
 1459 0406 959A      		sbi 0x12,5
 639:setup.c       **** 	
 640:setup.c       **** 	return data;
 641:setup.c       **** }
 1460               		.loc 1 641 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_read_byte_fast
 1467               	gb_flash_read_byte_fast:
 1468               	.LFB37:
 642:setup.c       **** 
 643:setup.c       **** // No setting address or outputs, assuming already set
 644:setup.c       **** uint8_t gb_flash_read_byte_fast(void) {
 1469               		.loc 1 644 0
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 645:setup.c       **** 	rdPin_low;
 1475               		.loc 1 645 0
 1476 040a 9598      		cbi 0x12,5
 646:setup.c       **** 	asm volatile("nop"); // Delay a little
 1477               		.loc 1 646 0
 1478               	/* #APP */
 1479               	 ;  646 "setup.c" 1
 1480 040c 0000      		nop
 1481               	 ;  0 "" 2
 647:setup.c       **** 	asm volatile("nop");
 1482               		.loc 1 647 0
 1483               	 ;  647 "setup.c" 1
 1484 040e 0000      		nop
 1485               	 ;  0 "" 2
 648:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1486               		.loc 1 648 0
 1487               	/* #NOAPP */
 1488 0410 83B3      		in r24,0x13
 1489               	.LVL116:
 649:setup.c       **** 	rdPin_high;
 1490               		.loc 1 649 0
 1491 0412 959A      		sbi 0x12,5
 650:setup.c       **** 	
 651:setup.c       **** 	return data;
 652:setup.c       **** }
 1492               		.loc 1 652 0
 1493 0414 0895      		ret
 1494               		.cfi_endproc
 1495               	.LFE37:
 1497               	.global	gb_flash_write_bus_cycle
 1499               	gb_flash_write_bus_cycle:
 1500               	.LFB38:
 653:setup.c       **** 
 654:setup.c       **** // Set the address and data for the write byte cycle to the flash
 655:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1501               		.loc 1 655 0
 1502               		.cfi_startproc
 1503               	.LVL117:
 1504 0416 CF93      		push r28
 1505               	.LCFI25:
 1506               		.cfi_def_cfa_offset 3
 1507               		.cfi_offset 28, -2
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 1 */
 1511               	.L__stack_usage = 1
 1512 0418 C62F      		mov r28,r22
 656:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1513               		.loc 1 656 0
 1514 041a 2FEF      		ldi r18,lo8(-1)
 1515 041c 24BB      		out 0x14,r18
 657:setup.c       **** 	set_16bit_address(address);
 1516               		.loc 1 657 0
 1517 041e 00D0      		rcall set_16bit_address
 1518               	.LVL118:
 658:setup.c       **** 	PORT_DATA7_0 = data;
 1519               		.loc 1 658 0
 1520 0420 C5BB      		out 0x15,r28
 659:setup.c       **** 	
 660:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1521               		.loc 1 660 0
 1522 0422 8091 0000 		lds r24,flashWriteWePin
 1523 0426 8134      		cpi r24,lo8(65)
 1524 0428 01F4      		brne .L71
 661:setup.c       **** 		audioPin_low; // WE low
 1525               		.loc 1 661 0
 1526 042a 3998      		cbi 0x7,1
 662:setup.c       **** 		asm volatile("nop");
 1527               		.loc 1 662 0
 1528               	/* #APP */
 1529               	 ;  662 "setup.c" 1
 1530 042c 0000      		nop
 1531               	 ;  0 "" 2
 663:setup.c       **** 		asm volatile("nop");
 1532               		.loc 1 663 0
 1533               	 ;  663 "setup.c" 1
 1534 042e 0000      		nop
 1535               	 ;  0 "" 2
 664:setup.c       **** 		asm volatile("nop");
 1536               		.loc 1 664 0
 1537               	 ;  664 "setup.c" 1
 1538 0430 0000      		nop
 1539               	 ;  0 "" 2
 665:setup.c       **** 		audioPin_high; // WE high
 1540               		.loc 1 665 0
 1541               	/* #NOAPP */
 1542 0432 399A      		sbi 0x7,1
 1543 0434 00C0      		rjmp .L72
 1544               	.L71:
 666:setup.c       **** 	}
 667:setup.c       **** 	else { // WR pin
 668:setup.c       **** 		wrPin_low; // WE low
 1545               		.loc 1 668 0
 1546 0436 9698      		cbi 0x12,6
 669:setup.c       **** 		asm volatile("nop");
 1547               		.loc 1 669 0
 1548               	/* #APP */
 1549               	 ;  669 "setup.c" 1
 1550 0438 0000      		nop
 1551               	 ;  0 "" 2
 670:setup.c       **** 		asm volatile("nop");
 1552               		.loc 1 670 0
 1553               	 ;  670 "setup.c" 1
 1554 043a 0000      		nop
 1555               	 ;  0 "" 2
 671:setup.c       **** 		asm volatile("nop");
 1556               		.loc 1 671 0
 1557               	 ;  671 "setup.c" 1
 1558 043c 0000      		nop
 1559               	 ;  0 "" 2
 672:setup.c       **** 		wrPin_high; // WE high
 1560               		.loc 1 672 0
 1561               	/* #NOAPP */
 1562 043e 969A      		sbi 0x12,6
 1563               	.L72:
 673:setup.c       **** 	}
 674:setup.c       **** 	
 675:setup.c       **** 	// Clear data outputs and set data pins as inputs
 676:setup.c       **** 	PORT_DATA7_0 = 0;
 1564               		.loc 1 676 0
 1565 0440 15BA      		out 0x15,__zero_reg__
 677:setup.c       **** 	DDR_DATA7_0 = 0;
 1566               		.loc 1 677 0
 1567 0442 14BA      		out 0x14,__zero_reg__
 1568               	/* epilogue start */
 678:setup.c       **** }
 1569               		.loc 1 678 0
 1570 0444 CF91      		pop r28
 1571               	.LVL119:
 1572 0446 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE38:
 1576               	.global	gb_flash_write_bus_cycle_fast
 1578               	gb_flash_write_bus_cycle_fast:
 1579               	.LFB39:
 679:setup.c       **** 
 680:setup.c       **** void gb_flash_write_bus_cycle_fast(uint16_t address, uint8_t data) {
 1580               		.loc 1 680 0
 1581               		.cfi_startproc
 1582               	.LVL120:
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1585               	/* stack size = 0 */
 1586               	.L__stack_usage = 0
 681:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 1587               		.loc 1 681 0
 1588 0448 9BBB      		out 0x1b,r25
 682:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1589               		.loc 1 682 0
 1590 044a 88BB      		out 0x18,r24
 683:setup.c       **** 	PORT_DATA7_0 = data;
 1591               		.loc 1 683 0
 1592 044c 65BB      		out 0x15,r22
 684:setup.c       **** 	
 685:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1593               		.loc 1 685 0
 1594 044e 8091 0000 		lds r24,flashWriteWePin
 1595               	.LVL121:
 1596 0452 8134      		cpi r24,lo8(65)
 1597 0454 01F4      		brne .L74
 1598               	.LVL122:
 1599               	.LBB158:
 1600               	.LBB159:
 686:setup.c       **** 		audioPin_low; // WE low
 1601               		.loc 1 686 0
 1602 0456 3998      		cbi 0x7,1
 687:setup.c       **** 		asm volatile("nop");
 1603               		.loc 1 687 0
 1604               	/* #APP */
 1605               	 ;  687 "setup.c" 1
 1606 0458 0000      		nop
 1607               	 ;  0 "" 2
 688:setup.c       **** 		asm volatile("nop");
 1608               		.loc 1 688 0
 1609               	 ;  688 "setup.c" 1
 1610 045a 0000      		nop
 1611               	 ;  0 "" 2
 689:setup.c       **** 		asm volatile("nop");
 1612               		.loc 1 689 0
 1613               	 ;  689 "setup.c" 1
 1614 045c 0000      		nop
 1615               	 ;  0 "" 2
 690:setup.c       **** 		audioPin_high; // WE high
 1616               		.loc 1 690 0
 1617               	/* #NOAPP */
 1618 045e 399A      		sbi 0x7,1
 1619 0460 0895      		ret
 1620               	.LVL123:
 1621               	.L74:
 1622               	.LBE159:
 1623               	.LBE158:
 691:setup.c       **** 	}
 692:setup.c       **** 	else { // WR pin
 693:setup.c       **** 		wrPin_low; // WE low
 1624               		.loc 1 693 0
 1625 0462 9698      		cbi 0x12,6
 694:setup.c       **** 		asm volatile("nop");
 1626               		.loc 1 694 0
 1627               	/* #APP */
 1628               	 ;  694 "setup.c" 1
 1629 0464 0000      		nop
 1630               	 ;  0 "" 2
 695:setup.c       **** 		asm volatile("nop");
 1631               		.loc 1 695 0
 1632               	 ;  695 "setup.c" 1
 1633 0466 0000      		nop
 1634               	 ;  0 "" 2
 696:setup.c       **** 		asm volatile("nop");
 1635               		.loc 1 696 0
 1636               	 ;  696 "setup.c" 1
 1637 0468 0000      		nop
 1638               	 ;  0 "" 2
 697:setup.c       **** 		wrPin_high; // WE high
 1639               		.loc 1 697 0
 1640               	/* #NOAPP */
 1641 046a 969A      		sbi 0x12,6
 1642 046c 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE39:
 1646               	.global	gb_flash_write_byte
 1648               	gb_flash_write_byte:
 1649               	.LFB40:
 698:setup.c       **** 	}
 699:setup.c       **** }
 700:setup.c       **** 
 701:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 702:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1650               		.loc 1 702 0
 1651               		.cfi_startproc
 1652               	.LVL124:
 1653 046e 0F93      		push r16
 1654               	.LCFI26:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 0470 1F93      		push r17
 1658               	.LCFI27:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661 0472 CF93      		push r28
 1662               	.LCFI28:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 28, -4
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 3 */
 1668               	.L__stack_usage = 3
 1669 0474 8C01      		movw r16,r24
 1670 0476 C62F      		mov r28,r22
 703:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1671               		.loc 1 703 0
 1672 0478 8FEF      		ldi r24,lo8(-1)
 1673               	.LVL125:
 1674 047a 84BB      		out 0x14,r24
 704:setup.c       **** 	
 705:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1675               		.loc 1 705 0
 1676 047c 6091 0000 		lds r22,flashWriteCycle+2
 1677               	.LVL126:
 1678 0480 8091 0000 		lds r24,flashWriteCycle
 1679 0484 9091 0000 		lds r25,flashWriteCycle+1
 1680 0488 00D0      		rcall gb_flash_write_bus_cycle_fast
 1681               	.LVL127:
 706:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1682               		.loc 1 706 0
 1683 048a 6091 0000 		lds r22,flashWriteCycle+6
 1684 048e 8091 0000 		lds r24,flashWriteCycle+4
 1685 0492 9091 0000 		lds r25,flashWriteCycle+4+1
 1686 0496 00D0      		rcall gb_flash_write_bus_cycle_fast
 1687               	.LVL128:
 707:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1688               		.loc 1 707 0
 1689 0498 6091 0000 		lds r22,flashWriteCycle+10
 1690 049c 8091 0000 		lds r24,flashWriteCycle+8
 1691 04a0 9091 0000 		lds r25,flashWriteCycle+8+1
 1692 04a4 00D0      		rcall gb_flash_write_bus_cycle_fast
 1693               	.LVL129:
 708:setup.c       **** 	gb_flash_write_bus_cycle_fast(address, data);
 1694               		.loc 1 708 0
 1695 04a6 6C2F      		mov r22,r28
 1696 04a8 C801      		movw r24,r16
 1697 04aa 00D0      		rcall gb_flash_write_bus_cycle_fast
 1698               	.LVL130:
 1699               	.LBB160:
 1700               	.LBB161:
 1701               		.loc 2 276 0
 1702 04ac 8DE0      		ldi r24,lo8(13)
 1703 04ae 8A95      	1:	dec r24
 1704 04b0 01F4      		brne 1b
 1705 04b2 0000      		nop
 1706               	.LVL131:
 1707               	.LBE161:
 1708               	.LBE160:
 709:setup.c       **** 	_delay_us(5); // Wait byte program time
 710:setup.c       **** 	
 711:setup.c       **** 	// Set data pins inputs
 712:setup.c       **** 	PORT_DATA7_0 = 0;
 1709               		.loc 1 712 0
 1710 04b4 15BA      		out 0x15,__zero_reg__
 713:setup.c       **** 	DDR_DATA7_0 = 0;
 1711               		.loc 1 713 0
 1712 04b6 14BA      		out 0x14,__zero_reg__
 714:setup.c       **** 	
 715:setup.c       **** 	// Verify data
 716:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte_fast();
 1713               		.loc 1 716 0
 1714 04b8 00D0      		rcall gb_flash_read_byte_fast
 1715               	.LVL132:
 1716               	.L77:
 717:setup.c       **** 	while (data != dataVerify) {
 1717               		.loc 1 717 0
 1718 04ba 8C17      		cp r24,r28
 1719 04bc 01F0      		breq .L79
 718:setup.c       **** 		dataVerify = gb_flash_read_byte_fast();
 1720               		.loc 1 718 0
 1721 04be 00D0      		rcall gb_flash_read_byte_fast
 1722               	.LVL133:
 1723               	.LBB162:
 1724               	.LBB163:
 1725               		.loc 2 276 0
 1726 04c0 92E0      		ldi r25,lo8(2)
 1727 04c2 9A95      	1:	dec r25
 1728 04c4 01F4      		brne 1b
 1729 04c6 00C0      		rjmp .
 1730 04c8 00C0      		rjmp .L77
 1731               	.LVL134:
 1732               	.L79:
 1733               	/* epilogue start */
 1734               	.LBE163:
 1735               	.LBE162:
 719:setup.c       **** 		_delay_us(1);
 720:setup.c       **** 	}
 721:setup.c       **** }
 1736               		.loc 1 721 0
 1737 04ca CF91      		pop r28
 1738               	.LVL135:
 1739 04cc 1F91      		pop r17
 1740 04ce 0F91      		pop r16
 1741               	.LVL136:
 1742 04d0 0895      		ret
 1743               		.cfi_endproc
 1744               	.LFE40:
 1746               	.global	gb_flash_write_byte_special
 1748               	gb_flash_write_byte_special:
 1749               	.LFB41:
 722:setup.c       **** 
 723:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 724:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1750               		.loc 1 724 0
 1751               		.cfi_startproc
 1752               	.LVL137:
 1753 04d2 1F93      		push r17
 1754               	.LCFI29:
 1755               		.cfi_def_cfa_offset 3
 1756               		.cfi_offset 17, -2
 1757 04d4 CF93      		push r28
 1758               	.LCFI30:
 1759               		.cfi_def_cfa_offset 4
 1760               		.cfi_offset 28, -3
 1761 04d6 DF93      		push r29
 1762               	.LCFI31:
 1763               		.cfi_def_cfa_offset 5
 1764               		.cfi_offset 29, -4
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 3 */
 1768               	.L__stack_usage = 3
 1769 04d8 EC01      		movw r28,r24
 1770 04da 162F      		mov r17,r22
 725:setup.c       **** 	// Set bank back
 726:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1771               		.loc 1 726 0
 1772 04dc 8091 0000 		lds r24,flashBank1CommandWrites
 1773               	.LVL138:
 1774 04e0 8130      		cpi r24,lo8(1)
 1775 04e2 01F4      		brne .L81
 727:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1776               		.loc 1 727 0
 1777 04e4 40E0      		ldi r20,0
 1778 04e6 6091 0000 		lds r22,lastBankAccessed
 1779               	.LVL139:
 1780 04ea 80E0      		ldi r24,0
 1781 04ec 91E2      		ldi r25,lo8(33)
 1782 04ee 00D0      		rcall write_8bit_data
 1783               	.LVL140:
 1784               	.LBB164:
 1785               	.LBB165:
 1786               		.loc 2 276 0
 1787 04f0 85E8      		ldi r24,lo8(-123)
 1788 04f2 8A95      	1:	dec r24
 1789 04f4 01F4      		brne 1b
 1790 04f6 0000      		nop
 1791               	.LVL141:
 1792               	.L81:
 1793               	.LBE165:
 1794               	.LBE164:
 728:setup.c       **** 		_delay_us(50);
 729:setup.c       **** 	}
 730:setup.c       **** 	
 731:setup.c       **** 	// Write
 732:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1795               		.loc 1 732 0
 1796 04f8 6091 0000 		lds r22,flashWriteCycle+2
 1797 04fc 8091 0000 		lds r24,flashWriteCycle
 1798 0500 9091 0000 		lds r25,flashWriteCycle+1
 1799 0504 00D0      		rcall gb_flash_write_bus_cycle
 1800               	.LVL142:
 733:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1801               		.loc 1 733 0
 1802 0506 6091 0000 		lds r22,flashWriteCycle+6
 1803 050a 8091 0000 		lds r24,flashWriteCycle+4
 1804 050e 9091 0000 		lds r25,flashWriteCycle+4+1
 1805 0512 00D0      		rcall gb_flash_write_bus_cycle
 1806               	.LVL143:
 734:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1807               		.loc 1 734 0
 1808 0514 6091 0000 		lds r22,flashWriteCycle+10
 1809 0518 8091 0000 		lds r24,flashWriteCycle+8
 1810 051c 9091 0000 		lds r25,flashWriteCycle+8+1
 1811 0520 00D0      		rcall gb_flash_write_bus_cycle
 1812               	.LVL144:
 735:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1813               		.loc 1 735 0
 1814 0522 612F      		mov r22,r17
 1815 0524 CE01      		movw r24,r28
 1816 0526 00D0      		rcall gb_flash_write_bus_cycle
 1817               	.LVL145:
 1818               	.LBB166:
 1819               	.LBB167:
 1820               		.loc 2 276 0
 1821 0528 83EF      		ldi r24,lo8(499)
 1822 052a 91E0      		ldi r25,hi8(499)
 1823 052c 0197      	1:	sbiw r24,1
 1824 052e 01F4      		brne 1b
 1825 0530 00C0      		rjmp .
 1826 0532 0000      		nop
 1827               	.LVL146:
 1828               	.LBE167:
 1829               	.LBE166:
 736:setup.c       **** 	_delay_us(250); // Wait byte program time
 737:setup.c       **** 	
 738:setup.c       **** 	// Set data pins inputs
 739:setup.c       **** 	PORT_DATA7_0 = 0;
 1830               		.loc 1 739 0
 1831 0534 15BA      		out 0x15,__zero_reg__
 740:setup.c       **** 	DDR_DATA7_0 = 0;
 1832               		.loc 1 740 0
 1833 0536 14BA      		out 0x14,__zero_reg__
 741:setup.c       **** 	
 742:setup.c       **** 	// Pulse reset
 743:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1834               		.loc 1 743 0
 1835 0538 3A98      		cbi 0x7,2
 1836               	.LVL147:
 1837               	.LBB168:
 1838               	.LBB169:
 1839               		.loc 2 276 0
 1840 053a 95E8      		ldi r25,lo8(-123)
 1841 053c 9A95      	1:	dec r25
 1842 053e 01F4      		brne 1b
 1843 0540 0000      		nop
 1844               	.LVL148:
 1845               	.LBE169:
 1846               	.LBE168:
 744:setup.c       **** 	_delay_us(50);
 745:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1847               		.loc 1 745 0
 1848 0542 3A9A      		sbi 0x7,2
 1849               	.LVL149:
 1850               	.LBB170:
 1851               	.LBB171:
 1852               		.loc 2 276 0
 1853 0544 85E8      		ldi r24,lo8(-123)
 1854 0546 8A95      	1:	dec r24
 1855 0548 01F4      		brne 1b
 1856 054a 0000      		nop
 1857               	.LVL150:
 1858               	/* epilogue start */
 1859               	.LBE171:
 1860               	.LBE170:
 746:setup.c       **** 	_delay_us(50);
 747:setup.c       **** }
 1861               		.loc 1 747 0
 1862 054c DF91      		pop r29
 1863 054e CF91      		pop r28
 1864               	.LVL151:
 1865 0550 1F91      		pop r17
 1866               	.LVL152:
 1867 0552 0895      		ret
 1868               		.cfi_endproc
 1869               	.LFE41:
 1871               	.global	gb_flash_write_byte_bank1_commands
 1873               	gb_flash_write_byte_bank1_commands:
 1874               	.LFB42:
 748:setup.c       **** 
 749:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 750:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 751:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1875               		.loc 1 751 0
 1876               		.cfi_startproc
 1877               	.LVL153:
 1878 0554 FF92      		push r15
 1879               	.LCFI32:
 1880               		.cfi_def_cfa_offset 3
 1881               		.cfi_offset 15, -2
 1882 0556 0F93      		push r16
 1883               	.LCFI33:
 1884               		.cfi_def_cfa_offset 4
 1885               		.cfi_offset 16, -3
 1886 0558 1F93      		push r17
 1887               	.LCFI34:
 1888               		.cfi_def_cfa_offset 5
 1889               		.cfi_offset 17, -4
 1890 055a CF93      		push r28
 1891               	.LCFI35:
 1892               		.cfi_def_cfa_offset 6
 1893               		.cfi_offset 28, -5
 1894 055c DF93      		push r29
 1895               	.LCFI36:
 1896               		.cfi_def_cfa_offset 7
 1897               		.cfi_offset 29, -6
 1898               	/* prologue: function */
 1899               	/* frame size = 0 */
 1900               	/* stack size = 5 */
 1901               	.L__stack_usage = 5
 1902 055e EC01      		movw r28,r24
 1903 0560 162F      		mov r17,r22
 752:setup.c       **** 	// Set bank 1
 753:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1904               		.loc 1 753 0
 1905 0562 FF24      		clr r15
 1906 0564 FA94      		dec r15
 1907 0566 F4BA      		out 0x14,r15
 1908               	.LVL154:
 1909               	.LBB172:
 1910               	.LBB173:
 249:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1911               		.loc 1 249 0
 1912 0568 01E2      		ldi r16,lo8(33)
 1913 056a 0BBB      		out 0x1b,r16
 250:setup.c       **** }
 1914               		.loc 1 250 0
 1915 056c 18BA      		out 0x18,__zero_reg__
 1916               	.LVL155:
 1917               	.LBE173:
 1918               	.LBE172:
 754:setup.c       **** 	set_16bit_address(0x2100);
 755:setup.c       **** 	PORT_DATA7_0 = 1;
 1919               		.loc 1 755 0
 1920 056e 81E0      		ldi r24,lo8(1)
 1921               	.LVL156:
 1922 0570 85BB      		out 0x15,r24
 756:setup.c       **** 	wrPin_low; // Pulse WR
 1923               		.loc 1 756 0
 1924 0572 9698      		cbi 0x12,6
 757:setup.c       **** 	asm volatile("nop");
 1925               		.loc 1 757 0
 1926               	/* #APP */
 1927               	 ;  757 "setup.c" 1
 1928 0574 0000      		nop
 1929               	 ;  0 "" 2
 758:setup.c       **** 	wrPin_high;
 1930               		.loc 1 758 0
 1931               	/* #NOAPP */
 1932 0576 969A      		sbi 0x12,6
 759:setup.c       **** 	
 760:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1933               		.loc 1 760 0
 1934 0578 6091 0000 		lds r22,flashWriteCycle+2
 1935               	.LVL157:
 1936 057c 8091 0000 		lds r24,flashWriteCycle
 1937 0580 9091 0000 		lds r25,flashWriteCycle+1
 1938 0584 00D0      		rcall gb_flash_write_bus_cycle
 1939               	.LVL158:
 761:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1940               		.loc 1 761 0
 1941 0586 6091 0000 		lds r22,flashWriteCycle+6
 1942 058a 8091 0000 		lds r24,flashWriteCycle+4
 1943 058e 9091 0000 		lds r25,flashWriteCycle+4+1
 1944 0592 00D0      		rcall gb_flash_write_bus_cycle
 1945               	.LVL159:
 762:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1946               		.loc 1 762 0
 1947 0594 6091 0000 		lds r22,flashWriteCycle+10
 1948 0598 8091 0000 		lds r24,flashWriteCycle+8
 1949 059c 9091 0000 		lds r25,flashWriteCycle+8+1
 1950 05a0 00D0      		rcall gb_flash_write_bus_cycle
 1951               	.LVL160:
 763:setup.c       **** 	
 764:setup.c       **** 	
 765:setup.c       **** 	// Set bank back
 766:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1952               		.loc 1 766 0
 1953 05a2 F4BA      		out 0x14,r15
 1954               	.LVL161:
 1955               	.LBB174:
 1956               	.LBB175:
 249:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1957               		.loc 1 249 0
 1958 05a4 0BBB      		out 0x1b,r16
 250:setup.c       **** }
 1959               		.loc 1 250 0
 1960 05a6 18BA      		out 0x18,__zero_reg__
 1961               	.LVL162:
 1962               	.LBE175:
 1963               	.LBE174:
 767:setup.c       **** 	set_16bit_address(0x2100);
 768:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1964               		.loc 1 768 0
 1965 05a8 8091 0000 		lds r24,lastBankAccessed
 1966 05ac 85BB      		out 0x15,r24
 769:setup.c       **** 	wrPin_low; // Pulse WR
 1967               		.loc 1 769 0
 1968 05ae 9698      		cbi 0x12,6
 770:setup.c       **** 	asm volatile("nop");
 1969               		.loc 1 770 0
 1970               	/* #APP */
 1971               	 ;  770 "setup.c" 1
 1972 05b0 0000      		nop
 1973               	 ;  0 "" 2
 771:setup.c       **** 	wrPin_high;
 1974               		.loc 1 771 0
 1975               	/* #NOAPP */
 1976 05b2 969A      		sbi 0x12,6
 772:setup.c       **** 	
 773:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1977               		.loc 1 773 0
 1978 05b4 612F      		mov r22,r17
 1979 05b6 CE01      		movw r24,r28
 1980 05b8 00D0      		rcall gb_flash_write_bus_cycle
 1981               	.LVL163:
 1982               	.LBB176:
 1983               	.LBB177:
 1984               		.loc 2 276 0
 1985 05ba 8AE1      		ldi r24,lo8(26)
 1986 05bc 8A95      	1:	dec r24
 1987 05be 01F4      		brne 1b
 1988 05c0 00C0      		rjmp .
 1989               	.LVL164:
 1990               	.LBE177:
 1991               	.LBE176:
 774:setup.c       **** 	_delay_us(10); // Wait byte program time
 775:setup.c       **** 	
 776:setup.c       **** 	// Set data pins inputs
 777:setup.c       **** 	PORT_DATA7_0 = 0;
 1992               		.loc 1 777 0
 1993 05c2 15BA      		out 0x15,__zero_reg__
 778:setup.c       **** 	DDR_DATA7_0 = 0;
 1994               		.loc 1 778 0
 1995 05c4 14BA      		out 0x14,__zero_reg__
 779:setup.c       **** 	
 780:setup.c       **** 	// Verify data
 781:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1996               		.loc 1 781 0
 1997 05c6 CE01      		movw r24,r28
 1998 05c8 00D0      		rcall gb_flash_read_byte
 1999               	.LVL165:
 2000               	.L83:
 782:setup.c       **** 	while (data != dataVerify) {
 2001               		.loc 1 782 0
 2002 05ca 8117      		cp r24,r17
 2003 05cc 01F0      		breq .L85
 783:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2004               		.loc 1 783 0
 2005 05ce CE01      		movw r24,r28
 2006               	.LVL166:
 2007 05d0 00D0      		rcall gb_flash_read_byte
 2008               	.LVL167:
 2009               	.LBB178:
 2010               	.LBB179:
 2011               		.loc 2 276 0
 2012 05d2 9DE0      		ldi r25,lo8(13)
 2013 05d4 9A95      	1:	dec r25
 2014 05d6 01F4      		brne 1b
 2015 05d8 0000      		nop
 2016 05da 00C0      		rjmp .L83
 2017               	.LVL168:
 2018               	.L85:
 2019               	/* epilogue start */
 2020               	.LBE179:
 2021               	.LBE178:
 784:setup.c       **** 		_delay_us(5);
 785:setup.c       **** 	}
 786:setup.c       **** }
 2022               		.loc 1 786 0
 2023 05dc DF91      		pop r29
 2024 05de CF91      		pop r28
 2025               	.LVL169:
 2026 05e0 1F91      		pop r17
 2027               	.LVL170:
 2028 05e2 0F91      		pop r16
 2029 05e4 FF90      		pop r15
 2030 05e6 0895      		ret
 2031               		.cfi_endproc
 2032               	.LFE42:
 2034               	.global	gba_flash_write_bus_cycle
 2036               	gba_flash_write_bus_cycle:
 2037               	.LFB43:
 787:setup.c       **** 
 788:setup.c       **** 
 789:setup.c       **** 
 790:setup.c       **** // ---------- GBA FLASH CARTS ----------
 791:setup.c       **** 
 792:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 793:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2038               		.loc 1 793 0
 2039               		.cfi_startproc
 2040               	.LVL171:
 2041 05e8 0F93      		push r16
 2042               	.LCFI37:
 2043               		.cfi_def_cfa_offset 3
 2044               		.cfi_offset 16, -2
 2045 05ea 1F93      		push r17
 2046               	.LCFI38:
 2047               		.cfi_def_cfa_offset 4
 2048               		.cfi_offset 17, -3
 2049               	/* prologue: function */
 2050               	/* frame size = 0 */
 2051               	/* stack size = 2 */
 2052               	.L__stack_usage = 2
 794:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 2053               		.loc 1 794 0
 2054 05ec 8C01      		movw r16,r24
 2055 05ee 2227      		clr r18
 2056 05f0 3327      		clr r19
 2057 05f2 05BB      		out 0x15,r16
 795:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 2058               		.loc 1 795 0
 2059 05f4 072F      		mov r16,r23
 2060 05f6 182F      		mov r17,r24
 2061 05f8 292F      		mov r18,r25
 2062 05fa 3327      		clr r19
 2063 05fc 0BBB      		out 0x1b,r16
 796:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 2064               		.loc 1 796 0
 2065 05fe 68BB      		out 0x18,r22
 797:setup.c       **** 	
 798:setup.c       **** 	cs_mreqPin_low;
 2066               		.loc 1 798 0
 2067 0600 9498      		cbi 0x12,4
 799:setup.c       **** 	
 800:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2068               		.loc 1 800 0
 2069 0602 5BBB      		out 0x1b,r21
 801:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2070               		.loc 1 801 0
 2071 0604 48BB      		out 0x18,r20
 802:setup.c       **** 	
 803:setup.c       **** 	wrPin_low;
 2072               		.loc 1 803 0
 2073 0606 9698      		cbi 0x12,6
 804:setup.c       **** 	asm volatile("nop");
 2074               		.loc 1 804 0
 2075               	/* #APP */
 2076               	 ;  804 "setup.c" 1
 2077 0608 0000      		nop
 2078               	 ;  0 "" 2
 805:setup.c       **** 	asm volatile("nop");
 2079               		.loc 1 805 0
 2080               	 ;  805 "setup.c" 1
 2081 060a 0000      		nop
 2082               	 ;  0 "" 2
 806:setup.c       **** 	asm volatile("nop");
 2083               		.loc 1 806 0
 2084               	 ;  806 "setup.c" 1
 2085 060c 0000      		nop
 2086               	 ;  0 "" 2
 807:setup.c       **** 	wrPin_high;
 2087               		.loc 1 807 0
 2088               	/* #NOAPP */
 2089 060e 969A      		sbi 0x12,6
 808:setup.c       **** 	cs_mreqPin_high;
 2090               		.loc 1 808 0
 2091 0610 949A      		sbi 0x12,4
 2092               	/* epilogue start */
 809:setup.c       **** }
 2093               		.loc 1 809 0
 2094 0612 1F91      		pop r17
 2095 0614 0F91      		pop r16
 2096 0616 0895      		ret
 2097               		.cfi_endproc
 2098               	.LFE43:
 2100               	.global	gba_flash_write_cycle_start_swapped
 2102               	gba_flash_write_cycle_start_swapped:
 2103               	.LFB44:
 810:setup.c       **** 
 811:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 812:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2104               		.loc 1 812 0
 2105               		.cfi_startproc
 2106               	/* prologue: function */
 2107               	/* frame size = 0 */
 2108               	/* stack size = 0 */
 2109               	.L__stack_usage = 0
 813:setup.c       **** 	// Set outputs
 814:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2110               		.loc 1 814 0
 2111 0618 8FEF      		ldi r24,lo8(-1)
 2112 061a 84BB      		out 0x14,r24
 815:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2113               		.loc 1 815 0
 2114 061c 8ABB      		out 0x1a,r24
 816:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2115               		.loc 1 816 0
 2116 061e 87BB      		out 0x17,r24
 817:setup.c       **** 	
 818:setup.c       **** 	// 0x555, 0xA9
 819:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2117               		.loc 1 819 0
 2118 0620 15BA      		out 0x15,__zero_reg__
 820:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2119               		.loc 1 820 0
 2120 0622 95E0      		ldi r25,lo8(5)
 2121 0624 9BBB      		out 0x1b,r25
 821:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2122               		.loc 1 821 0
 2123 0626 85E5      		ldi r24,lo8(85)
 2124 0628 88BB      		out 0x18,r24
 822:setup.c       **** 	cs_mreqPin_low;
 2125               		.loc 1 822 0
 2126 062a 9498      		cbi 0x12,4
 823:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2127               		.loc 1 823 0
 2128 062c 1BBA      		out 0x1b,__zero_reg__
 824:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2129               		.loc 1 824 0
 2130 062e 29EA      		ldi r18,lo8(-87)
 2131 0630 28BB      		out 0x18,r18
 825:setup.c       **** 	wrPin_low;
 2132               		.loc 1 825 0
 2133 0632 9698      		cbi 0x12,6
 826:setup.c       **** 	asm volatile("nop");
 2134               		.loc 1 826 0
 2135               	/* #APP */
 2136               	 ;  826 "setup.c" 1
 2137 0634 0000      		nop
 2138               	 ;  0 "" 2
 827:setup.c       **** 	asm volatile("nop");
 2139               		.loc 1 827 0
 2140               	 ;  827 "setup.c" 1
 2141 0636 0000      		nop
 2142               	 ;  0 "" 2
 828:setup.c       **** 	asm volatile("nop");
 2143               		.loc 1 828 0
 2144               	 ;  828 "setup.c" 1
 2145 0638 0000      		nop
 2146               	 ;  0 "" 2
 829:setup.c       **** 	wrPin_high;
 2147               		.loc 1 829 0
 2148               	/* #NOAPP */
 2149 063a 969A      		sbi 0x12,6
 830:setup.c       **** 	cs_mreqPin_high;
 2150               		.loc 1 830 0
 2151 063c 949A      		sbi 0x12,4
 831:setup.c       **** 	
 832:setup.c       **** 	// 0x2AA, 0x56
 833:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2152               		.loc 1 833 0
 2153 063e 15BA      		out 0x15,__zero_reg__
 834:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2154               		.loc 1 834 0
 2155 0640 22E0      		ldi r18,lo8(2)
 2156 0642 2BBB      		out 0x1b,r18
 835:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2157               		.loc 1 835 0
 2158 0644 2AEA      		ldi r18,lo8(-86)
 2159 0646 28BB      		out 0x18,r18
 836:setup.c       **** 	cs_mreqPin_low;
 2160               		.loc 1 836 0
 2161 0648 9498      		cbi 0x12,4
 837:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2162               		.loc 1 837 0
 2163 064a 1BBA      		out 0x1b,__zero_reg__
 838:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2164               		.loc 1 838 0
 2165 064c 26E5      		ldi r18,lo8(86)
 2166 064e 28BB      		out 0x18,r18
 839:setup.c       **** 	wrPin_low;
 2167               		.loc 1 839 0
 2168 0650 9698      		cbi 0x12,6
 840:setup.c       **** 	asm volatile("nop");
 2169               		.loc 1 840 0
 2170               	/* #APP */
 2171               	 ;  840 "setup.c" 1
 2172 0652 0000      		nop
 2173               	 ;  0 "" 2
 841:setup.c       **** 	asm volatile("nop");
 2174               		.loc 1 841 0
 2175               	 ;  841 "setup.c" 1
 2176 0654 0000      		nop
 2177               	 ;  0 "" 2
 842:setup.c       **** 	asm volatile("nop");
 2178               		.loc 1 842 0
 2179               	 ;  842 "setup.c" 1
 2180 0656 0000      		nop
 2181               	 ;  0 "" 2
 843:setup.c       **** 	wrPin_high;
 2182               		.loc 1 843 0
 2183               	/* #NOAPP */
 2184 0658 969A      		sbi 0x12,6
 844:setup.c       **** 	cs_mreqPin_high;
 2185               		.loc 1 844 0
 2186 065a 949A      		sbi 0x12,4
 845:setup.c       **** 	
 846:setup.c       **** 	// 0x555, 0xA0;
 847:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2187               		.loc 1 847 0
 2188 065c 15BA      		out 0x15,__zero_reg__
 848:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2189               		.loc 1 848 0
 2190 065e 9BBB      		out 0x1b,r25
 849:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2191               		.loc 1 849 0
 2192 0660 88BB      		out 0x18,r24
 850:setup.c       **** 	cs_mreqPin_low;
 2193               		.loc 1 850 0
 2194 0662 9498      		cbi 0x12,4
 851:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2195               		.loc 1 851 0
 2196 0664 1BBA      		out 0x1b,__zero_reg__
 852:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2197               		.loc 1 852 0
 2198 0666 80EA      		ldi r24,lo8(-96)
 2199 0668 88BB      		out 0x18,r24
 853:setup.c       **** 	wrPin_low;
 2200               		.loc 1 853 0
 2201 066a 9698      		cbi 0x12,6
 854:setup.c       **** 	asm volatile("nop");
 2202               		.loc 1 854 0
 2203               	/* #APP */
 2204               	 ;  854 "setup.c" 1
 2205 066c 0000      		nop
 2206               	 ;  0 "" 2
 855:setup.c       **** 	asm volatile("nop");
 2207               		.loc 1 855 0
 2208               	 ;  855 "setup.c" 1
 2209 066e 0000      		nop
 2210               	 ;  0 "" 2
 856:setup.c       **** 	asm volatile("nop");
 2211               		.loc 1 856 0
 2212               	 ;  856 "setup.c" 1
 2213 0670 0000      		nop
 2214               	 ;  0 "" 2
 857:setup.c       **** 	wrPin_high;
 2215               		.loc 1 857 0
 2216               	/* #NOAPP */
 2217 0672 969A      		sbi 0x12,6
 858:setup.c       **** 	cs_mreqPin_high;
 2218               		.loc 1 858 0
 2219 0674 949A      		sbi 0x12,4
 2220 0676 0895      		ret
 2221               		.cfi_endproc
 2222               	.LFE44:
 2224               	.global	gba_flash_write_cycle_start
 2226               	gba_flash_write_cycle_start:
 2227               	.LFB45:
 859:setup.c       **** }
 860:setup.c       **** 
 861:setup.c       **** 
 862:setup.c       **** // Send the first 3 write cycles to the flash
 863:setup.c       **** void gba_flash_write_cycle_start(void) {
 2228               		.loc 1 863 0
 2229               		.cfi_startproc
 2230               	/* prologue: function */
 2231               	/* frame size = 0 */
 2232               	/* stack size = 0 */
 2233               	.L__stack_usage = 0
 864:setup.c       **** 	// Set outputs
 865:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2234               		.loc 1 865 0
 2235 0678 8FEF      		ldi r24,lo8(-1)
 2236 067a 84BB      		out 0x14,r24
 866:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2237               		.loc 1 866 0
 2238 067c 8ABB      		out 0x1a,r24
 867:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2239               		.loc 1 867 0
 2240 067e 87BB      		out 0x17,r24
 868:setup.c       **** 	
 869:setup.c       **** 	// 0x555, 0xAA
 870:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2241               		.loc 1 870 0
 2242 0680 15BA      		out 0x15,__zero_reg__
 871:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2243               		.loc 1 871 0
 2244 0682 95E0      		ldi r25,lo8(5)
 2245 0684 9BBB      		out 0x1b,r25
 872:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2246               		.loc 1 872 0
 2247 0686 85E5      		ldi r24,lo8(85)
 2248 0688 88BB      		out 0x18,r24
 873:setup.c       **** 	cs_mreqPin_low;
 2249               		.loc 1 873 0
 2250 068a 9498      		cbi 0x12,4
 874:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2251               		.loc 1 874 0
 2252 068c 1BBA      		out 0x1b,__zero_reg__
 875:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2253               		.loc 1 875 0
 2254 068e 2AEA      		ldi r18,lo8(-86)
 2255 0690 28BB      		out 0x18,r18
 876:setup.c       **** 	wrPin_low;
 2256               		.loc 1 876 0
 2257 0692 9698      		cbi 0x12,6
 877:setup.c       **** 	asm volatile("nop");
 2258               		.loc 1 877 0
 2259               	/* #APP */
 2260               	 ;  877 "setup.c" 1
 2261 0694 0000      		nop
 2262               	 ;  0 "" 2
 878:setup.c       **** 	asm volatile("nop");
 2263               		.loc 1 878 0
 2264               	 ;  878 "setup.c" 1
 2265 0696 0000      		nop
 2266               	 ;  0 "" 2
 879:setup.c       **** 	asm volatile("nop");
 2267               		.loc 1 879 0
 2268               	 ;  879 "setup.c" 1
 2269 0698 0000      		nop
 2270               	 ;  0 "" 2
 880:setup.c       **** 	wrPin_high;
 2271               		.loc 1 880 0
 2272               	/* #NOAPP */
 2273 069a 969A      		sbi 0x12,6
 881:setup.c       **** 	cs_mreqPin_high;
 2274               		.loc 1 881 0
 2275 069c 949A      		sbi 0x12,4
 882:setup.c       **** 	
 883:setup.c       **** 	// 0x2AA, 0x55
 884:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2276               		.loc 1 884 0
 2277 069e 15BA      		out 0x15,__zero_reg__
 885:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2278               		.loc 1 885 0
 2279 06a0 32E0      		ldi r19,lo8(2)
 2280 06a2 3BBB      		out 0x1b,r19
 886:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2281               		.loc 1 886 0
 2282 06a4 28BB      		out 0x18,r18
 887:setup.c       **** 	cs_mreqPin_low;
 2283               		.loc 1 887 0
 2284 06a6 9498      		cbi 0x12,4
 888:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2285               		.loc 1 888 0
 2286 06a8 1BBA      		out 0x1b,__zero_reg__
 889:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2287               		.loc 1 889 0
 2288 06aa 88BB      		out 0x18,r24
 890:setup.c       **** 	wrPin_low;
 2289               		.loc 1 890 0
 2290 06ac 9698      		cbi 0x12,6
 891:setup.c       **** 	asm volatile("nop");
 2291               		.loc 1 891 0
 2292               	/* #APP */
 2293               	 ;  891 "setup.c" 1
 2294 06ae 0000      		nop
 2295               	 ;  0 "" 2
 892:setup.c       **** 	asm volatile("nop");
 2296               		.loc 1 892 0
 2297               	 ;  892 "setup.c" 1
 2298 06b0 0000      		nop
 2299               	 ;  0 "" 2
 893:setup.c       **** 	asm volatile("nop");
 2300               		.loc 1 893 0
 2301               	 ;  893 "setup.c" 1
 2302 06b2 0000      		nop
 2303               	 ;  0 "" 2
 894:setup.c       **** 	wrPin_high;
 2304               		.loc 1 894 0
 2305               	/* #NOAPP */
 2306 06b4 969A      		sbi 0x12,6
 895:setup.c       **** 	cs_mreqPin_high;
 2307               		.loc 1 895 0
 2308 06b6 949A      		sbi 0x12,4
 896:setup.c       **** 	
 897:setup.c       **** 	// 0x555, 0xA0;
 898:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2309               		.loc 1 898 0
 2310 06b8 15BA      		out 0x15,__zero_reg__
 899:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2311               		.loc 1 899 0
 2312 06ba 9BBB      		out 0x1b,r25
 900:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2313               		.loc 1 900 0
 2314 06bc 88BB      		out 0x18,r24
 901:setup.c       **** 	cs_mreqPin_low;
 2315               		.loc 1 901 0
 2316 06be 9498      		cbi 0x12,4
 902:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2317               		.loc 1 902 0
 2318 06c0 1BBA      		out 0x1b,__zero_reg__
 903:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2319               		.loc 1 903 0
 2320 06c2 80EA      		ldi r24,lo8(-96)
 2321 06c4 88BB      		out 0x18,r24
 904:setup.c       **** 	wrPin_low;
 2322               		.loc 1 904 0
 2323 06c6 9698      		cbi 0x12,6
 905:setup.c       **** 	asm volatile("nop");
 2324               		.loc 1 905 0
 2325               	/* #APP */
 2326               	 ;  905 "setup.c" 1
 2327 06c8 0000      		nop
 2328               	 ;  0 "" 2
 906:setup.c       **** 	asm volatile("nop");
 2329               		.loc 1 906 0
 2330               	 ;  906 "setup.c" 1
 2331 06ca 0000      		nop
 2332               	 ;  0 "" 2
 907:setup.c       **** 	asm volatile("nop");
 2333               		.loc 1 907 0
 2334               	 ;  907 "setup.c" 1
 2335 06cc 0000      		nop
 2336               	 ;  0 "" 2
 908:setup.c       **** 	wrPin_high;
 2337               		.loc 1 908 0
 2338               	/* #NOAPP */
 2339 06ce 969A      		sbi 0x12,6
 909:setup.c       **** 	cs_mreqPin_high;
 2340               		.loc 1 909 0
 2341 06d0 949A      		sbi 0x12,4
 2342 06d2 0895      		ret
 2343               		.cfi_endproc
 2344               	.LFE45:
 2346               	.global	gba_flash_write_byte
 2348               	gba_flash_write_byte:
 2349               	.LFB46:
 910:setup.c       **** }	
 911:setup.c       **** 
 912:setup.c       **** 
 913:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 914:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 915:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2350               		.loc 1 915 0
 2351               		.cfi_startproc
 2352               	.LVL172:
 2353 06d4 CF92      		push r12
 2354               	.LCFI39:
 2355               		.cfi_def_cfa_offset 3
 2356               		.cfi_offset 12, -2
 2357 06d6 DF92      		push r13
 2358               	.LCFI40:
 2359               		.cfi_def_cfa_offset 4
 2360               		.cfi_offset 13, -3
 2361 06d8 EF92      		push r14
 2362               	.LCFI41:
 2363               		.cfi_def_cfa_offset 5
 2364               		.cfi_offset 14, -4
 2365 06da FF92      		push r15
 2366               	.LCFI42:
 2367               		.cfi_def_cfa_offset 6
 2368               		.cfi_offset 15, -5
 2369 06dc CF93      		push r28
 2370               	.LCFI43:
 2371               		.cfi_def_cfa_offset 7
 2372               		.cfi_offset 28, -6
 2373 06de DF93      		push r29
 2374               	.LCFI44:
 2375               		.cfi_def_cfa_offset 8
 2376               		.cfi_offset 29, -7
 2377               	/* prologue: function */
 2378               	/* frame size = 0 */
 2379               	/* stack size = 6 */
 2380               	.L__stack_usage = 6
 2381 06e0 6B01      		movw r12,r22
 2382 06e2 7C01      		movw r14,r24
 2383 06e4 EA01      		movw r28,r20
 916:setup.c       **** 	if (isD0D1Swapped == 0) {
 2384               		.loc 1 916 0
 2385 06e6 2111      		cpse r18,__zero_reg__
 2386 06e8 00C0      		rjmp .L90
 917:setup.c       **** 		gba_flash_write_cycle_start();
 2387               		.loc 1 917 0
 2388 06ea 00D0      		rcall gba_flash_write_cycle_start
 2389               	.LVL173:
 2390 06ec 00C0      		rjmp .L91
 2391               	.LVL174:
 2392               	.L90:
 918:setup.c       **** 	}
 919:setup.c       **** 	else {
 920:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2393               		.loc 1 920 0
 2394 06ee 00D0      		rcall gba_flash_write_cycle_start_swapped
 2395               	.LVL175:
 2396               	.L91:
 921:setup.c       **** 	}
 922:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2397               		.loc 1 922 0
 2398 06f0 AE01      		movw r20,r28
 2399 06f2 C701      		movw r24,r14
 2400 06f4 B601      		movw r22,r12
 2401 06f6 00D0      		rcall gba_flash_write_bus_cycle
 2402               	.LVL176:
 2403               	.LBB180:
 2404               	.LBB181:
 2405               		.loc 2 276 0
 2406 06f8 25E0      		ldi r18,lo8(5)
 2407 06fa 2A95      	1:	dec r18
 2408 06fc 01F4      		brne 1b
 2409 06fe 0000      		nop
 2410               	.LVL177:
 2411               	.LBE181:
 2412               	.LBE180:
 923:setup.c       **** 	_delay_us(2); // Wait byte program time
 924:setup.c       **** 	
 925:setup.c       **** 	// Verify data
 926:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2413               		.loc 1 926 0
 2414 0700 C701      		movw r24,r14
 2415 0702 B601      		movw r22,r12
 2416 0704 00D0      		rcall gba_read_16bit_data
 2417               	.LVL178:
 2418               	.L92:
 927:setup.c       **** 	while (data != dataVerify) {
 2419               		.loc 1 927 0
 2420 0706 8C17      		cp r24,r28
 2421 0708 9D07      		cpc r25,r29
 2422 070a 01F0      		breq .L94
 928:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2423               		.loc 1 928 0
 2424 070c C701      		movw r24,r14
 2425 070e B601      		movw r22,r12
 2426 0710 00D0      		rcall gba_read_16bit_data
 2427               	.LVL179:
 2428               	.LBB182:
 2429               	.LBB183:
 2430               		.loc 2 276 0
 2431 0712 25E0      		ldi r18,lo8(5)
 2432 0714 2A95      	1:	dec r18
 2433 0716 01F4      		brne 1b
 2434 0718 0000      		nop
 2435 071a 00C0      		rjmp .L92
 2436               	.LVL180:
 2437               	.L94:
 2438               	/* epilogue start */
 2439               	.LBE183:
 2440               	.LBE182:
 929:setup.c       **** 		_delay_us(2);
 930:setup.c       **** 	}
 931:setup.c       **** }
 2441               		.loc 1 931 0
 2442 071c DF91      		pop r29
 2443 071e CF91      		pop r28
 2444               	.LVL181:
 2445 0720 FF90      		pop r15
 2446 0722 EF90      		pop r14
 2447 0724 DF90      		pop r13
 2448 0726 CF90      		pop r12
 2449               	.LVL182:
 2450 0728 0895      		ret
 2451               		.cfi_endproc
 2452               	.LFE46:
 2454               	.global	setup
 2456               	setup:
 2457               	.LFB47:
 932:setup.c       **** 
 933:setup.c       **** 
 934:setup.c       **** // Setup
 935:setup.c       **** void setup(void) {
 2458               		.loc 1 935 0
 2459               		.cfi_startproc
 2460               	/* prologue: function */
 2461               	/* frame size = 0 */
 2462               	/* stack size = 0 */
 2463               	.L__stack_usage = 0
 936:setup.c       **** 	// Turn off watchdog
 937:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2464               		.loc 1 937 0
 2465 072a 84B7      		in r24,0x34
 2466 072c 877F      		andi r24,lo8(-9)
 2467 072e 84BF      		out 0x34,r24
 938:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2468               		.loc 1 938 0
 2469 0730 88E1      		ldi r24,lo8(24)
 2470 0732 81BD      		out 0x21,r24
 939:setup.c       **** 	WDTCR = 0;
 2471               		.loc 1 939 0
 2472 0734 11BC      		out 0x21,__zero_reg__
 940:setup.c       **** 	
 941:setup.c       **** 	// Reset common lines
 942:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2473               		.loc 1 942 0
 2474 0736 00D0      		rcall rd_wr_csmreq_cs2_reset
 2475               	.LVL183:
 943:setup.c       **** 	
 944:setup.c       **** 	// Set outputs
 945:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2476               		.loc 1 945 0
 2477 0738 81B3      		in r24,0x11
 2478 073a 8C6F      		ori r24,lo8(-4)
 2479 073c 81BB      		out 0x11,r24
 946:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2480               		.loc 1 946 0
 2481 073e 86B1      		in r24,0x6
 2482 0740 8560      		ori r24,lo8(5)
 2483 0742 86B9      		out 0x6,r24
 947:setup.c       **** 	
 948:setup.c       **** 	// Set all pins as inputs
 949:setup.c       **** 	PORT_DATA7_0 = 0;
 2484               		.loc 1 949 0
 2485 0744 15BA      		out 0x15,__zero_reg__
 950:setup.c       **** 	DDR_DATA7_0 = 0;
 2486               		.loc 1 950 0
 2487 0746 14BA      		out 0x14,__zero_reg__
 951:setup.c       **** 	PORT_ADDR7_0 = 0;
 2488               		.loc 1 951 0
 2489 0748 18BA      		out 0x18,__zero_reg__
 952:setup.c       **** 	DDR_ADDR7_0 = 0;
 2490               		.loc 1 952 0
 2491 074a 17BA      		out 0x17,__zero_reg__
 953:setup.c       **** 	PORT_ADDR15_8 = 0;
 2492               		.loc 1 953 0
 2493 074c 1BBA      		out 0x1b,__zero_reg__
 954:setup.c       **** 	DDR_ADDR15_8 = 0;
 2494               		.loc 1 954 0
 2495 074e 1ABA      		out 0x1a,__zero_reg__
 955:setup.c       **** 	
 956:setup.c       **** 	// Light up 3.3V or 5V
 957:setup.c       **** 	if (cartMode == GB_MODE) {
 2496               		.loc 1 957 0
 2497 0750 8091 0000 		lds r24,cartMode
 2498 0754 8130      		cpi r24,lo8(1)
 2499 0756 01F4      		brne .L96
 958:setup.c       **** 		PORTD |= (1<<LED_5V);
 2500               		.loc 1 958 0
 2501 0758 979A      		sbi 0x12,7
 959:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2502               		.loc 1 959 0
 2503 075a 3898      		cbi 0x7,0
 2504 075c 00C0      		rjmp .L97
 2505               	.L96:
 960:setup.c       **** 	}
 961:setup.c       **** 	else {
 962:setup.c       **** 		PORTE |= (1<<LED_3V);
 2506               		.loc 1 962 0
 2507 075e 389A      		sbi 0x7,0
 963:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2508               		.loc 1 963 0
 2509 0760 9798      		cbi 0x12,7
 2510               	.L97:
 964:setup.c       **** 	}
 965:setup.c       **** 	
 966:setup.c       **** 	// Light LED
 967:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2511               		.loc 1 967 0
 2512 0762 939A      		sbi 0x12,3
 2513               	.LVL184:
 2514               	.LBB184:
 2515               	.LBB185:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2516               		.loc 2 187 0
 2517 0764 2FEF      		ldi r18,lo8(799999)
 2518 0766 84E3      		ldi r24,hi8(799999)
 2519 0768 9CE0      		ldi r25,hlo8(799999)
 2520 076a 2150      	1:	subi r18,1
 2521 076c 8040      		sbci r24,0
 2522 076e 9040      		sbci r25,0
 2523 0770 01F4      		brne 1b
 2524 0772 00C0      		rjmp .
 2525 0774 0000      		nop
 2526               	.LVL185:
 2527               	.LBE185:
 2528               	.LBE184:
 968:setup.c       **** 	_delay_ms(500);
 969:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2529               		.loc 1 969 0
 2530 0776 9398      		cbi 0x12,3
 970:setup.c       **** 	
 971:setup.c       **** 	// Setup USART
 972:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2531               		.loc 1 972 0
 2532 0778 19B8      		out 0x9,__zero_reg__
 973:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2533               		.loc 1 973 0
 2534 077a 599A      		sbi 0xb,1
 974:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2535               		.loc 1 974 0
 2536 077c 539A      		sbi 0xa,3
 975:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2537               		.loc 1 975 0
 2538 077e 549A      		sbi 0xa,4
 976:setup.c       **** 	
 977:setup.c       **** 	// Turn on interrupts
 978:setup.c       **** 	sei();
 2539               		.loc 1 978 0
 2540               	/* #APP */
 2541               	 ;  978 "setup.c" 1
 2542 0780 7894      		sei
 2543               	 ;  0 "" 2
 2544               	/* #NOAPP */
 2545 0782 0895      		ret
 2546               		.cfi_endproc
 2547               	.LFE47:
 2549               		.section	.text.startup,"ax",@progbits
 2550               	.global	main
 2552               	main:
 2553               	.LFB48:
 2554               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R17
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 21/01/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 4
  53:main.c        **** #define FIRMWARE_VERSION 17
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2555               		.loc 3 66 0
 2556               		.cfi_startproc
 2557               	/* prologue: function */
 2558               	/* frame size = 0 */
 2559               	/* stack size = 0 */
 2560               	.L__stack_usage = 0
  67:main.c        **** 	setup();
 2561               		.loc 3 67 0
 2562 0000 00D0      		rcall setup
 2563               	.LVL186:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2564               		.loc 3 71 0
 2565 0002 2224      		clr r2
 2566 0004 2394      		inc r2
  70:main.c        **** 	uint8_t resetCommonLines = 1;
 2567               		.loc 3 70 0
 2568 0006 D1E0      		ldi r29,lo8(1)
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2569               		.loc 3 69 0
 2570 0008 C12C      		mov r12,__zero_reg__
 2571 000a D12C      		mov r13,__zero_reg__
 2572 000c 7601      		movw r14,r12
 2573               	.LBB186:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  78:main.c        **** 		
  79:main.c        **** 		// Return the cart mode in use
  80:main.c        **** 		if (receivedChar == CART_MODE) {
  81:main.c        **** 			USART_Transmit(cartMode);
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		// Change to GB mode or GBA mode if requested
  85:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  86:main.c        **** 			gb_mode();
  87:main.c        **** 		}
  88:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
  89:main.c        **** 			gba_mode();
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Switch voltage if requested
  93:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
  94:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
  95:main.c        **** 			cartMode = GBA_MODE;
  96:main.c        **** 			PORTE |= (1<<LED_3V);
  97:main.c        **** 			PORTD &= ~(1<<LED_5V);
  98:main.c        **** 		}
  99:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
 100:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 101:main.c        **** 			cartMode = GB_MODE;
 102:main.c        **** 			PORTD |= (1<<LED_5V);
 103:main.c        **** 			PORTE &= ~(1<<LED_3V);
 104:main.c        **** 		}
 105:main.c        **** 		
 106:main.c        **** 		
 107:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 108:main.c        **** 		
 109:main.c        **** 		// Set address
 110:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 111:main.c        **** 			usart_read_chars(); // Read start address
 112:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 116:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 117:main.c        **** 			gb_mode();
 118:main.c        **** 			receivedChar = '1';
 119:main.c        **** 			while (receivedChar == '1') {
 120:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 121:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 122:main.c        **** 					USART_Transmit(read_8bit_data(address));
 123:main.c        **** 					address++;
 124:main.c        **** 				}
 125:main.c        **** 				
 126:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 127:main.c        **** 				receivedChar = USART_Receive();
 128:main.c        **** 			}
 129:main.c        **** 		}
 130:main.c        **** 		
 131:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 132:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 133:main.c        **** 			gb_mode();
 134:main.c        **** 			
 135:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 136:main.c        **** 			usart_read_bytes(64);
 137:main.c        **** 			
 138:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 139:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 140:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 141:main.c        **** 				address++;
 142:main.c        **** 			}
 143:main.c        **** 			
 144:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 145:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 146:main.c        **** 		}
 147:main.c        **** 		
 148:main.c        **** 		// Set bank address and write a byte
 149:main.c        **** 		else if (receivedChar == SET_BANK) {
 150:main.c        **** 			gb_mode();
 151:main.c        **** 			
 152:main.c        **** 			usart_read_chars(); // Read start address
 153:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 154:main.c        **** 			
 155:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 156:main.c        **** 			if (receivedChar == 'B') {
 157:main.c        **** 				usart_read_chars(); // Read data
 158:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 159:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 160:main.c        **** 				
 161:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 162:main.c        **** 			}
 163:main.c        **** 		}
 164:main.c        **** 		
 165:main.c        **** 		
 166:main.c        **** 		// ****** Gameboy Advance ******
 167:main.c        **** 		
 168:main.c        **** 		// ---------- ROM ----------
 169:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 170:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 171:main.c        **** 			gba_mode();
 172:main.c        **** 			
 173:main.c        **** 			uint8_t readEnd = 32;
 174:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 175:main.c        **** 				readEnd = 128;
 176:main.c        **** 			}
 177:main.c        **** 			
 178:main.c        **** 			receivedChar = '1';
 2574               		.loc 3 178 0
 2575 000e 81E3      		ldi r24,lo8(49)
 2576 0010 382E      		mov r3,r24
 2577               	.LBE186:
 2578               	.LBB189:
 2579               	.LBB190:
 179:main.c        **** 			while (receivedChar == '1') {
 180:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 181:main.c        **** 				
 182:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 183:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 184:main.c        **** 					
 185:main.c        **** 					// Low byte & High byte
 186:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 187:main.c        **** 					USART_Transmit(dataRead >> 8);
 188:main.c        **** 					
 189:main.c        **** 					address++;
 190:main.c        **** 				}
 191:main.c        **** 				
 192:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 193:main.c        **** 				receivedChar = USART_Receive();
 194:main.c        **** 			}
 195:main.c        **** 		}
 196:main.c        **** 		
 197:main.c        **** 		// ---------- SRAM ----------
 198:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 199:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 200:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 201:main.c        **** 			
 202:main.c        **** 			receivedChar = '1';
 203:main.c        **** 			while (receivedChar == '1') {
 204:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 205:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 206:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 207:main.c        **** 					address++;
 208:main.c        **** 				}
 209:main.c        **** 				
 210:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 211:main.c        **** 				receivedChar = USART_Receive();
 212:main.c        **** 			}
 213:main.c        **** 			
 214:main.c        **** 			gba_mode(); // Set back
 215:main.c        **** 		}
 216:main.c        **** 		
 217:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 218:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 219:main.c        **** 			gb_mode();
 220:main.c        **** 			
 221:main.c        **** 			usart_read_bytes(64);
 222:main.c        **** 			
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 224:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 225:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 226:main.c        **** 				address++;
 227:main.c        **** 			}
 228:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 229:main.c        **** 			
 230:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 231:main.c        **** 			gba_mode(); // Set back
 232:main.c        **** 		}
 233:main.c        **** 		
 234:main.c        **** 		// Write 1 byte to SRAM address
 235:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 236:main.c        **** 			gb_mode();
 237:main.c        **** 			
 238:main.c        **** 			uint8_t data = USART_Receive();
 239:main.c        **** 			gba_write_ram_8bit_data(address, data);
 240:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 241:main.c        **** 			
 242:main.c        **** 			gba_mode(); // Set back
 243:main.c        **** 		}
 244:main.c        **** 		
 245:main.c        **** 		
 246:main.c        **** 		// ---------- FLASH ----------
 247:main.c        **** 		// Read the Flash Manufacturer and Device ID
 248:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 249:main.c        **** 			gb_mode();
 250:main.c        **** 			
 251:main.c        **** 			flash_read_chip_id();
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 253:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 254:main.c        **** 			
 255:main.c        **** 			gba_mode(); // Set back
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Change bank
 259:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 260:main.c        **** 			usart_read_chars(); // Read data
 261:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 262:main.c        **** 			
 263:main.c        **** 			gb_mode();
 264:main.c        **** 			flash_switch_bank(bank);
 265:main.c        **** 			
 266:main.c        **** 			gba_mode(); // Set back
 267:main.c        **** 		}
 268:main.c        **** 		
 269:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 270:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 271:main.c        **** 			gb_mode();
 272:main.c        **** 			
 273:main.c        **** 			usart_read_chars(); // Read sector
 274:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 275:main.c        **** 			
 276:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 277:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 278:main.c        **** 			
 279:main.c        **** 			gba_mode(); // Set back
 280:main.c        **** 		}
 281:main.c        **** 		
 282:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 283:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 284:main.c        **** 			gb_mode();
 285:main.c        **** 			
 286:main.c        **** 			usart_read_bytes(64);
 287:main.c        **** 			
 288:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 289:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 290:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 291:main.c        **** 				address++;
 292:main.c        **** 			}
 293:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 294:main.c        **** 			
 295:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 296:main.c        **** 			gba_mode(); // Set back
 297:main.c        **** 		}
 298:main.c        **** 		
 299:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 300:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 301:main.c        **** 			gb_mode();
 302:main.c        **** 			
 303:main.c        **** 			usart_read_bytes(128);
 304:main.c        **** 			
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 306:main.c        **** 			flash_write_sector(address); // Address used as sector number
 307:main.c        **** 			address++;
 308:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 309:main.c        **** 			
 310:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		
 315:main.c        **** 		// ---------- EEPROM ----------
 316:main.c        **** 		// Set EEPROM size
 317:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 318:main.c        **** 			usart_read_chars(); // Read size
 319:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 320:main.c        **** 		}
 321:main.c        **** 		
 322:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 323:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 324:main.c        **** 			gba_eeprom_mode();
 325:main.c        **** 			
 326:main.c        **** 			receivedChar = '1';
 327:main.c        **** 			while (receivedChar == '1') {
 328:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 329:main.c        **** 				gba_eeprom_read(address, eepromSize);
 330:main.c        **** 				
 331:main.c        **** 				// Send back the 8 bytes of data
 332:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 333:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 334:main.c        **** 				}
 335:main.c        **** 				address++; // Increment to next 8 bytes
 336:main.c        **** 				
 337:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 338:main.c        **** 				receivedChar = USART_Receive();
 339:main.c        **** 			}
 340:main.c        **** 			
 341:main.c        **** 			gba_mode(); // Set back
 342:main.c        **** 		}
 343:main.c        **** 		
 344:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 345:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 346:main.c        **** 			gba_eeprom_mode();
 347:main.c        **** 			
 348:main.c        **** 			// Read 8 bytes from USART and place in buffer
 349:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 350:main.c        **** 				eepromBuffer[x] = USART_Receive();
 351:main.c        **** 			}
 352:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 353:main.c        **** 			
 354:main.c        **** 			gba_eeprom_write(address, eepromSize);
 355:main.c        **** 			address++;
 356:main.c        **** 			
 357:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 358:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 359:main.c        **** 			
 360:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 361:main.c        **** 			gba_mode(); // Set back
 362:main.c        **** 		}
 363:main.c        **** 		
 364:main.c        **** 		
 365:main.c        **** 		// ---------- GB FLASH CARTS ----------
 366:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 367:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 368:main.c        **** 			flashWriteWePin = USART_Receive();
 369:main.c        **** 			
 370:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 371:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 372:main.c        **** 				audioPin_high;
 373:main.c        **** 			}
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 377:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 378:main.c        **** 			flashBank1CommandWrites = 1;
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Load the program method to use
 382:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 383:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 384:main.c        **** 				usart_read_chars(); // Address
 385:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 386:main.c        **** 				USART_Transmit(SEND_ACK);
 387:main.c        **** 				
 388:main.c        **** 				usart_read_chars(); // Data
 389:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 390:main.c        **** 				USART_Transmit(SEND_ACK);
 391:main.c        **** 			}
 392:main.c        **** 		}
 393:main.c        **** 		
 394:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 395:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 396:main.c        **** 			usart_read_chars(); // Read address
 397:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 398:main.c        **** 			
 399:main.c        **** 			usart_read_chars(); // Read data byte
 400:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 401:main.c        **** 			
 402:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 403:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 404:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 405:main.c        **** 			
 406:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 407:main.c        **** 		}
 408:main.c        **** 		
 409:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 410:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 411:main.c        **** 			usart_read_bytes(64);
 412:main.c        **** 			
 413:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 414:main.c        **** 			if (flashBank1CommandWrites == 0) {
 415:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 416:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 417:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 418:main.c        **** 					}
 419:main.c        **** 					address++;
 420:main.c        **** 				}
 421:main.c        **** 			}
 422:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 423:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 424:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 425:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 426:main.c        **** 					}
 427:main.c        **** 					address++;
 428:main.c        **** 				}
 429:main.c        **** 			}
 430:main.c        **** 			
 431:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 432:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 433:main.c        **** 		}
 434:main.c        **** 		
 435:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 436:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 437:main.c        **** 			usart_read_bytes(32);
 438:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 439:main.c        **** 			
 440:main.c        **** 			// Setup buffered write
 441:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 442:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 443:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 444:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 445:main.c        **** 			_delay_us(1);
 446:main.c        **** 			
 447:main.c        **** 			// Write data
 448:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 449:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 450:main.c        **** 				address++;
 451:main.c        **** 			}
 452:main.c        **** 			
 453:main.c        **** 			// Write buffer to flash
 454:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 455:main.c        **** 			_delay_us(200);
 456:main.c        **** 			
 457:main.c        **** 			// Verify last byte written
 458:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 459:main.c        **** 			uint8_t verifyCount = 0;
 460:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 461:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 462:main.c        **** 				_delay_us(5);
 463:main.c        **** 				verifyCount++;
 464:main.c        **** 				if (verifyCount >= 200) {
 465:main.c        **** 					_delay_ms(500);
 466:main.c        **** 					break;
 467:main.c        **** 				}
 468:main.c        **** 			}
 469:main.c        **** 			
 470:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 471:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 472:main.c        **** 		}
 473:main.c        **** 		
 474:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 475:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 476:main.c        **** 			usart_read_bytes(64);
 477:main.c        **** 			
 478:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 479:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 480:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 481:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 482:main.c        **** 				}
 483:main.c        **** 				address++;
 484:main.c        **** 			}
 485:main.c        **** 			
 486:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 487:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 488:main.c        **** 		}
 489:main.c        **** 		
 490:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 491:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 492:main.c        **** 			usart_read_bytes(256);
 493:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 494:main.c        **** 			
 495:main.c        **** 			// Setup buffered write
 496:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 497:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 498:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 499:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 500:main.c        **** 			_delay_us(50);
 501:main.c        **** 			
 502:main.c        **** 			// Write data
 503:main.c        **** 			for (int x = 0; x < 256; x++) {
 504:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 505:main.c        **** 				address++;
 506:main.c        **** 			}
 507:main.c        **** 			
 508:main.c        **** 			// Write buffer to flash
 509:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 510:main.c        **** 			
 511:main.c        **** 			// Verify last byte written
 512:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 513:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 514:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 515:main.c        **** 				_delay_us(5);
 516:main.c        **** 			}
 517:main.c        **** 			
 518:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 519:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 520:main.c        **** 		}
 521:main.c        **** 		
 522:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 523:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 524:main.c        **** 			usart_read_bytes(128);
 525:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 526:main.c        **** 			
 527:main.c        **** 			// Enable flash chip access
 528:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 529:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 530:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 531:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 532:main.c        **** 			_delay_us(5);
 533:main.c        **** 			
 534:main.c        **** 			// Re-Enable writes to MBC registers
 535:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 536:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 537:main.c        **** 			_delay_us(5);
 538:main.c        **** 			
 539:main.c        **** 			// Bank 1 for commands
 540:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			
 544:main.c        **** 			// Write setup
 545:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 546:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 547:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 548:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 553:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 554:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 555:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 556:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 557:main.c        **** 			_delay_us(5);
 558:main.c        **** 			
 559:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 560:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 561:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 562:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 563:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 564:main.c        **** 			_delay_us(5);
 565:main.c        **** 			
 566:main.c        **** 			// Set bank back
 567:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 568:main.c        **** 			_delay_us(5);
 569:main.c        **** 			
 570:main.c        **** 			// Disable writes to MBC registers
 571:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 572:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 573:main.c        **** 			_delay_us(5);
 574:main.c        **** 			
 575:main.c        **** 			// Undo Wakeup
 576:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 577:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 578:main.c        **** 			_delay_us(5);
 579:main.c        **** 			
 580:main.c        **** 			
 581:main.c        **** 			// Write data
 582:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 583:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 584:main.c        **** 				_delay_us(5);
 585:main.c        **** 				address++;
 586:main.c        **** 			}
 587:main.c        **** 			
 588:main.c        **** 			// Write buffer to flash
 589:main.c        **** 			address--;
 590:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 591:main.c        **** 			address++;
 592:main.c        **** 			_delay_ms(10);
 593:main.c        **** 			
 594:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 595:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 596:main.c        **** 		}
 597:main.c        **** 		
 598:main.c        **** 		
 599:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 600:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 601:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 602:main.c        **** 			usart_read_chars(); // Read address
 603:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 604:main.c        **** 			
 605:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 606:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 607:main.c        **** 				usart_read_chars(); // Read data
 608:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 609:main.c        **** 				
 610:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 611:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 612:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 613:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 614:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 615:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 616:main.c        **** 				
 617:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 618:main.c        **** 			}
 619:main.c        **** 		}
 620:main.c        **** 		
 621:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 622:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 623:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 624:main.c        **** 			
 625:main.c        **** 			int readLength = 64;
 626:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 627:main.c        **** 				readLength = 256;
 628:main.c        **** 			}
 629:main.c        **** 			usart_read_bytes(readLength);
 630:main.c        **** 			
 631:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 632:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 633:main.c        **** 				if (combinedBytes != 0xFFFF) {
 634:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 635:main.c        **** 				}
 636:main.c        **** 				address++;
 637:main.c        **** 			}
 638:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 639:main.c        **** 			
 640:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 641:main.c        **** 		}
 642:main.c        **** 		
 643:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 644:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 645:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 646:main.c        **** 			
 647:main.c        **** 			int readLength = 256;
 648:main.c        **** 			usart_read_bytes(readLength);
 649:main.c        **** 			
 650:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 651:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 652:main.c        **** 				if (combinedBytes != 0xFFFF) {
 653:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 654:main.c        **** 				}
 655:main.c        **** 				address++;
 656:main.c        **** 			}
 657:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 658:main.c        **** 			
 659:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 660:main.c        **** 		}
 661:main.c        **** 		
 662:main.c        **** 		// Intel flash command based chips
 663:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 664:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 665:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 666:main.c        **** 			usart_read_bytes(64);
 667:main.c        **** 			
 668:main.c        **** 			// Set address lines as outputs
 669:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 670:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 671:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 672:main.c        **** 			
 673:main.c        **** 			// Unlock
 674:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 675:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 676:main.c        **** 			
 677:main.c        **** 			// Buffered write command
 678:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 679:main.c        **** 			_delay_us(50);
 680:main.c        **** 			
 681:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 682:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 683:main.c        **** 			while (dataVerify != 0x0080) {
 684:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 685:main.c        **** 				_delay_us(50);
 686:main.c        **** 			}
 687:main.c        **** 			
 688:main.c        **** 			
 689:main.c        **** 			// Set address lines as outputs
 690:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 691:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 692:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 693:main.c        **** 			
 694:main.c        **** 			// Set length
 695:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 696:main.c        **** 			
 697:main.c        **** 			// Write data
 698:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 699:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 700:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 701:main.c        **** 				address++;
 702:main.c        **** 			}
 703:main.c        **** 			
 704:main.c        **** 			// Write buffer to flash
 705:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 706:main.c        **** 			_delay_us(440);
 707:main.c        **** 			
 708:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 709:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 710:main.c        **** 			while (dataVerify != 0x0080) {
 711:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 712:main.c        **** 				_delay_us(50);
 713:main.c        **** 			}
 714:main.c        **** 			
 715:main.c        **** 			
 716:main.c        **** 			// Set address lines as outputs
 717:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 718:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 719:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 720:main.c        **** 			
 721:main.c        **** 			// Back to reading mode
 722:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 723:main.c        **** 			
 724:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 725:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 726:main.c        **** 		}
 727:main.c        **** 		
 728:main.c        **** 		// Intel word programming
 729:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 730:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 731:main.c        **** 			usart_read_bytes(64);
 732:main.c        **** 			
 733:main.c        **** 			// Write data
 734:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 735:main.c        **** 				// Set address lines as outputs
 736:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2580               		.loc 3 736 0
 2581 0012 CFEF      		ldi r28,lo8(-1)
 2582               	.LVL187:
 2583               	.L99:
 2584               	.LBE190:
 2585               	.LBE189:
  74:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2586               		.loc 3 74 0
 2587 0014 21E0      		ldi r18,lo8(1)
 2588 0016 2212      		cpse r2,r18
 2589 0018 00C0      		rjmp .L100
 2590               	.LVL188:
 2591               	.L266:
  75:main.c        **** 		}
 2592               		.loc 3 75 0
 2593 001a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2594               	.LVL189:
 2595               	.L100:
  77:main.c        **** 		
 2596               		.loc 3 77 0
 2597 001c 00D0      		rcall USART_Receive
 2598               	.LVL190:
 2599 001e 8093 0000 		sts receivedChar,r24
  80:main.c        **** 			USART_Transmit(cartMode);
 2600               		.loc 3 80 0
 2601 0022 8334      		cpi r24,lo8(67)
 2602 0024 01F4      		brne .L101
  81:main.c        **** 		}
 2603               		.loc 3 81 0
 2604 0026 8091 0000 		lds r24,cartMode
 2605 002a 00C0      		rjmp .L267
 2606               	.L101:
  85:main.c        **** 			gb_mode();
 2607               		.loc 3 85 0
 2608 002c 8734      		cpi r24,lo8(71)
 2609 002e 01F4      		brne .L103
  86:main.c        **** 		}
 2610               		.loc 3 86 0
 2611 0030 00D0      		rcall gb_mode
 2612               	.LVL191:
 2613 0032 00C0      		rjmp .L99
 2614               	.L103:
  88:main.c        **** 			gba_mode();
 2615               		.loc 3 88 0
 2616 0034 8736      		cpi r24,lo8(103)
 2617 0036 01F4      		brne .+2
 2618 0038 00C0      		rjmp .L269
  93:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2619               		.loc 3 93 0
 2620 003a 8333      		cpi r24,lo8(51)
 2621 003c 01F4      		brne .L105
  94:main.c        **** 			cartMode = GBA_MODE;
 2622               		.loc 3 94 0
 2623 003e 9298      		cbi 0x12,2
  95:main.c        **** 			PORTE |= (1<<LED_3V);
 2624               		.loc 3 95 0
 2625 0040 82E0      		ldi r24,lo8(2)
 2626 0042 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2627               		.loc 3 96 0
 2628 0046 389A      		sbi 0x7,0
  97:main.c        **** 		}
 2629               		.loc 3 97 0
 2630 0048 9798      		cbi 0x12,7
 2631 004a 00C0      		rjmp .L99
 2632               	.L105:
  99:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2633               		.loc 3 99 0
 2634 004c 8533      		cpi r24,lo8(53)
 2635 004e 01F4      		brne .L106
 100:main.c        **** 			cartMode = GB_MODE;
 2636               		.loc 3 100 0
 2637 0050 929A      		sbi 0x12,2
 101:main.c        **** 			PORTD |= (1<<LED_5V);
 2638               		.loc 3 101 0
 2639 0052 81E0      		ldi r24,lo8(1)
 2640 0054 8093 0000 		sts cartMode,r24
 102:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2641               		.loc 3 102 0
 2642 0058 979A      		sbi 0x12,7
 103:main.c        **** 		}
 2643               		.loc 3 103 0
 2644 005a 3898      		cbi 0x7,0
 2645 005c 00C0      		rjmp .L99
 2646               	.L106:
 110:main.c        **** 			usart_read_chars(); // Read start address
 2647               		.loc 3 110 0
 2648 005e 8134      		cpi r24,lo8(65)
 2649 0060 01F4      		brne .L107
 111:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2650               		.loc 3 111 0
 2651 0062 00D0      		rcall usart_read_chars
 2652               	.LVL192:
 112:main.c        **** 		}
 2653               		.loc 3 112 0
 2654 0064 40E1      		ldi r20,lo8(16)
 2655 0066 50E0      		ldi r21,0
 2656 0068 60E0      		ldi r22,0
 2657 006a 70E0      		ldi r23,0
 2658 006c 80E0      		ldi r24,lo8(receivedBuffer)
 2659 006e 90E0      		ldi r25,hi8(receivedBuffer)
 2660 0070 00D0      		rcall strtol
 2661               	.LVL193:
 2662 0072 6B01      		movw r12,r22
 2663 0074 7C01      		movw r14,r24
 2664               	.LVL194:
 2665 0076 00C0      		rjmp .L99
 2666               	.L107:
 116:main.c        **** 			gb_mode();
 2667               		.loc 3 116 0
 2668 0078 8235      		cpi r24,lo8(82)
 2669 007a 01F4      		brne .L108
 117:main.c        **** 			receivedChar = '1';
 2670               		.loc 3 117 0
 2671 007c 00D0      		rcall gb_mode
 2672               	.LVL195:
 118:main.c        **** 			while (receivedChar == '1') {
 2673               		.loc 3 118 0
 2674 007e 3092 0000 		sts receivedChar,r3
 2675               	.LVL196:
 2676               	.L109:
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2677               		.loc 3 119 0
 2678 0082 8091 0000 		lds r24,receivedChar
 2679 0086 8133      		cpi r24,lo8(49)
 2680 0088 01F4      		brne .L99
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2681               		.loc 3 120 0
 2682 008a 939A      		sbi 0x12,3
 2683               	.LVL197:
 2684 008c 00E0      		ldi r16,0
 2685 008e 10E0      		ldi r17,0
 2686               	.LVL198:
 2687               	.L110:
 2688               	.LBB194:
 122:main.c        **** 					address++;
 2689               		.loc 3 122 0 discriminator 3
 2690 0090 C801      		movw r24,r16
 2691 0092 8C0D      		add r24,r12
 2692 0094 9D1D      		adc r25,r13
 2693 0096 00D0      		rcall read_8bit_data
 2694               	.LVL199:
 2695 0098 00D0      		rcall USART_Transmit
 2696               	.LVL200:
 2697 009a 0F5F      		subi r16,-1
 2698 009c 1F4F      		sbci r17,-1
 2699               	.LVL201:
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2700               		.loc 3 121 0 discriminator 3
 2701 009e 0034      		cpi r16,64
 2702 00a0 1105      		cpc r17,__zero_reg__
 2703 00a2 01F4      		brne .L110
 2704 00a4 90E4      		ldi r25,64
 2705 00a6 C90E      		add r12,r25
 2706 00a8 D11C      		adc r13,__zero_reg__
 2707 00aa E11C      		adc r14,__zero_reg__
 2708 00ac F11C      		adc r15,__zero_reg__
 2709               	.LBE194:
 126:main.c        **** 				receivedChar = USART_Receive();
 2710               		.loc 3 126 0
 2711 00ae 9398      		cbi 0x12,3
 127:main.c        **** 			}
 2712               		.loc 3 127 0
 2713 00b0 00D0      		rcall USART_Receive
 2714               	.LVL202:
 2715 00b2 8093 0000 		sts receivedChar,r24
 2716 00b6 00C0      		rjmp .L109
 2717               	.LVL203:
 2718               	.L108:
 132:main.c        **** 			gb_mode();
 2719               		.loc 3 132 0
 2720 00b8 8735      		cpi r24,lo8(87)
 2721 00ba 01F4      		brne .L112
 133:main.c        **** 			
 2722               		.loc 3 133 0
 2723 00bc 00D0      		rcall gb_mode
 2724               	.LVL204:
 136:main.c        **** 			
 2725               		.loc 3 136 0
 2726 00be 80E4      		ldi r24,lo8(64)
 2727 00c0 90E0      		ldi r25,0
 2728 00c2 00D0      		rcall usart_read_bytes
 2729               	.LVL205:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2730               		.loc 3 138 0
 2731 00c4 939A      		sbi 0x12,3
 2732               	.LVL206:
 2733 00c6 00E0      		ldi r16,lo8(receivedBuffer)
 2734 00c8 A02E      		mov r10,r16
 2735 00ca 00E0      		ldi r16,hi8(receivedBuffer)
 2736 00cc B02E      		mov r11,r16
 2737 00ce 00E0      		ldi r16,0
 2738 00d0 10E0      		ldi r17,0
 2739               	.LVL207:
 2740               	.L113:
 2741               	.LBB195:
 140:main.c        **** 				address++;
 2742               		.loc 3 140 0 discriminator 3
 2743 00d2 F501      		movw r30,r10
 2744 00d4 6191      		ld r22,Z+
 2745 00d6 5F01      		movw r10,r30
 2746 00d8 C801      		movw r24,r16
 2747 00da 8C0D      		add r24,r12
 2748 00dc 9D1D      		adc r25,r13
 2749 00de 41E0      		ldi r20,lo8(1)
 2750 00e0 00D0      		rcall write_8bit_data
 2751               	.LVL208:
 2752 00e2 0F5F      		subi r16,-1
 2753 00e4 1F4F      		sbci r17,-1
 2754               	.LVL209:
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2755               		.loc 3 139 0 discriminator 3
 2756 00e6 0034      		cpi r16,64
 2757 00e8 1105      		cpc r17,__zero_reg__
 2758 00ea 01F4      		brne .L113
 2759 00ec F0E4      		ldi r31,64
 2760 00ee CF0E      		add r12,r31
 2761 00f0 D11C      		adc r13,__zero_reg__
 2762 00f2 E11C      		adc r14,__zero_reg__
 2763 00f4 F11C      		adc r15,__zero_reg__
 2764 00f6 00C0      		rjmp .L287
 2765               	.LVL210:
 2766               	.L112:
 2767               	.LBE195:
 149:main.c        **** 			gb_mode();
 2768               		.loc 3 149 0
 2769 00f8 8234      		cpi r24,lo8(66)
 2770 00fa 01F4      		brne .L114
 2771               	.LBB196:
 150:main.c        **** 			
 2772               		.loc 3 150 0
 2773 00fc 00D0      		rcall gb_mode
 2774               	.LVL211:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2775               		.loc 3 152 0
 2776 00fe 00D0      		rcall usart_read_chars
 2777               	.LVL212:
 153:main.c        **** 			
 2778               		.loc 3 153 0
 2779 0100 40E1      		ldi r20,lo8(16)
 2780 0102 50E0      		ldi r21,0
 2781 0104 60E0      		ldi r22,0
 2782 0106 70E0      		ldi r23,0
 2783 0108 80E0      		ldi r24,lo8(receivedBuffer)
 2784 010a 90E0      		ldi r25,hi8(receivedBuffer)
 2785 010c 00D0      		rcall strtol
 2786               	.LVL213:
 2787 010e 4B01      		movw r8,r22
 2788 0110 5C01      		movw r10,r24
 2789               	.LVL214:
 155:main.c        **** 			if (receivedChar == 'B') {
 2790               		.loc 3 155 0
 2791 0112 00D0      		rcall USART_Receive
 2792               	.LVL215:
 2793 0114 8093 0000 		sts receivedChar,r24
 156:main.c        **** 				usart_read_chars(); // Read data
 2794               		.loc 3 156 0
 2795 0118 8234      		cpi r24,lo8(66)
 2796 011a 01F0      		breq .+2
 2797 011c 00C0      		rjmp .L99
 2798               	.LBB197:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2799               		.loc 3 157 0
 2800 011e 00D0      		rcall usart_read_chars
 2801               	.LVL216:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2802               		.loc 3 158 0
 2803 0120 80E0      		ldi r24,lo8(receivedBuffer)
 2804 0122 90E0      		ldi r25,hi8(receivedBuffer)
 2805 0124 00D0      		rcall atoi
 2806               	.LVL217:
 159:main.c        **** 				
 2807               		.loc 3 159 0
 2808 0126 8093 0000 		sts lastBankAccessed,r24
 161:main.c        **** 			}
 2809               		.loc 3 161 0
 2810 012a 40E0      		ldi r20,0
 2811 012c 682F      		mov r22,r24
 2812 012e C401      		movw r24,r8
 2813               	.LVL218:
 2814 0130 00D0      		rcall write_8bit_data
 2815               	.LVL219:
 2816 0132 00C0      		rjmp .L99
 2817               	.LVL220:
 2818               	.L114:
 2819               	.LBE197:
 2820               	.LBE196:
 170:main.c        **** 			gba_mode();
 2821               		.loc 3 170 0
 2822 0134 8237      		cpi r24,lo8(114)
 2823 0136 01F0      		breq .L115
 170:main.c        **** 			gba_mode();
 2824               		.loc 3 170 0 is_stmt 0 discriminator 1
 2825 0138 8A36      		cpi r24,lo8(106)
 2826 013a 01F4      		brne .L116
 2827               	.L115:
 2828               	.LBB198:
 171:main.c        **** 			
 2829               		.loc 3 171 0 is_stmt 1
 2830 013c 00D0      		rcall gba_mode
 2831               	.LVL221:
 174:main.c        **** 				readEnd = 128;
 2832               		.loc 3 174 0
 2833 013e 8091 0000 		lds r24,receivedChar
 2834 0142 8A36      		cpi r24,lo8(106)
 2835 0144 01F4      		brne .L220
 175:main.c        **** 			}
 2836               		.loc 3 175 0
 2837 0146 10E8      		ldi r17,lo8(-128)
 2838 0148 00C0      		rjmp .L117
 2839               	.L220:
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2840               		.loc 3 173 0
 2841 014a 10E2      		ldi r17,lo8(32)
 2842               	.L117:
 2843               	.LVL222:
 178:main.c        **** 			while (receivedChar == '1') {
 2844               		.loc 3 178 0
 2845 014c 3092 0000 		sts receivedChar,r3
 2846 0150 8824      		clr r8
 2847 0152 8A94      		dec r8
 2848 0154 810E      		add r8,r17
 2849 0156 912C      		mov r9,__zero_reg__
 2850 0158 A12C      		mov r10,__zero_reg__
 2851 015a B12C      		mov r11,__zero_reg__
 2852 015c 2FEF      		ldi r18,-1
 2853 015e 821A      		sub r8,r18
 2854 0160 920A      		sbc r9,r18
 2855 0162 A20A      		sbc r10,r18
 2856 0164 B20A      		sbc r11,r18
 2857               	.LVL223:
 2858               	.L118:
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2859               		.loc 3 179 0
 2860 0166 8091 0000 		lds r24,receivedChar
 2861 016a 8133      		cpi r24,lo8(49)
 2862 016c 01F0      		breq .+2
 2863 016e 00C0      		rjmp .L99
 180:main.c        **** 				
 2864               		.loc 3 180 0
 2865 0170 939A      		sbi 0x12,3
 2866               	.LVL224:
 2867 0172 2601      		movw r4,r12
 2868 0174 3701      		movw r6,r14
 2869               	.LVL225:
 2870               	.L119:
 2871               	.LBB187:
 2872               	.LBB188:
 183:main.c        **** 					
 2873               		.loc 3 183 0 discriminator 3
 2874 0176 C301      		movw r24,r6
 2875 0178 B201      		movw r22,r4
 2876 017a 00D0      		rcall gba_read_16bit_data
 2877               	.LVL226:
 2878 017c 092F      		mov r16,r25
 2879               	.LVL227:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2880               		.loc 3 186 0 discriminator 3
 2881 017e 00D0      		rcall USART_Transmit
 2882               	.LVL228:
 187:main.c        **** 					
 2883               		.loc 3 187 0 discriminator 3
 2884 0180 802F      		mov r24,r16
 2885 0182 00D0      		rcall USART_Transmit
 2886               	.LVL229:
 189:main.c        **** 				}
 2887               		.loc 3 189 0 discriminator 3
 2888 0184 8FEF      		ldi r24,-1
 2889 0186 481A      		sub r4,r24
 2890 0188 580A      		sbc r5,r24
 2891 018a 680A      		sbc r6,r24
 2892 018c 780A      		sbc r7,r24
 2893               	.LVL230:
 2894               	.LBE188:
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2895               		.loc 3 182 0 discriminator 3
 2896 018e 842D      		mov r24,r4
 2897 0190 8C19      		sub r24,r12
 2898 0192 8117      		cp r24,r17
 2899 0194 00F0      		brlo .L119
 2900 0196 C80C      		add r12,r8
 2901 0198 D91C      		adc r13,r9
 2902 019a EA1C      		adc r14,r10
 2903 019c FB1C      		adc r15,r11
 2904               	.LVL231:
 2905               	.LBE187:
 192:main.c        **** 				receivedChar = USART_Receive();
 2906               		.loc 3 192 0
 2907 019e 9398      		cbi 0x12,3
 193:main.c        **** 			}
 2908               		.loc 3 193 0
 2909 01a0 00D0      		rcall USART_Receive
 2910               	.LVL232:
 2911 01a2 8093 0000 		sts receivedChar,r24
 2912 01a6 00C0      		rjmp .L118
 2913               	.LVL233:
 2914               	.L116:
 2915               	.LBE198:
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2916               		.loc 3 199 0
 2917 01a8 8D36      		cpi r24,lo8(109)
 2918 01aa 01F4      		brne .L121
 200:main.c        **** 			
 2919               		.loc 3 200 0
 2920 01ac 00D0      		rcall gb_mode
 2921               	.LVL234:
 202:main.c        **** 			while (receivedChar == '1') {
 2922               		.loc 3 202 0
 2923 01ae 3092 0000 		sts receivedChar,r3
 2924               	.LVL235:
 2925               	.L122:
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2926               		.loc 3 203 0
 2927 01b2 8091 0000 		lds r24,receivedChar
 2928 01b6 8133      		cpi r24,lo8(49)
 2929 01b8 01F4      		brne .L269
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2930               		.loc 3 204 0
 2931 01ba 939A      		sbi 0x12,3
 2932               	.LVL236:
 2933 01bc 00E0      		ldi r16,0
 2934 01be 10E0      		ldi r17,0
 2935               	.LVL237:
 2936               	.L123:
 2937               	.LBB199:
 206:main.c        **** 					address++;
 2938               		.loc 3 206 0 discriminator 3
 2939 01c0 C801      		movw r24,r16
 2940 01c2 8C0D      		add r24,r12
 2941 01c4 9D1D      		adc r25,r13
 2942 01c6 00D0      		rcall gba_read_ram_8bit_data
 2943               	.LVL238:
 2944 01c8 00D0      		rcall USART_Transmit
 2945               	.LVL239:
 2946 01ca 0F5F      		subi r16,-1
 2947 01cc 1F4F      		sbci r17,-1
 2948               	.LVL240:
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2949               		.loc 3 205 0 discriminator 3
 2950 01ce 0034      		cpi r16,64
 2951 01d0 1105      		cpc r17,__zero_reg__
 2952 01d2 01F4      		brne .L123
 2953 01d4 90E4      		ldi r25,64
 2954 01d6 C90E      		add r12,r25
 2955 01d8 D11C      		adc r13,__zero_reg__
 2956 01da E11C      		adc r14,__zero_reg__
 2957 01dc F11C      		adc r15,__zero_reg__
 2958               	.LBE199:
 210:main.c        **** 				receivedChar = USART_Receive();
 2959               		.loc 3 210 0
 2960 01de 9398      		cbi 0x12,3
 211:main.c        **** 			}
 2961               		.loc 3 211 0
 2962 01e0 00D0      		rcall USART_Receive
 2963               	.LVL241:
 2964 01e2 8093 0000 		sts receivedChar,r24
 2965 01e6 00C0      		rjmp .L122
 2966               	.LVL242:
 2967               	.L121:
 218:main.c        **** 			gb_mode();
 2968               		.loc 3 218 0
 2969 01e8 8737      		cpi r24,lo8(119)
 2970 01ea 01F4      		brne .L125
 219:main.c        **** 			
 2971               		.loc 3 219 0
 2972 01ec 00D0      		rcall gb_mode
 2973               	.LVL243:
 221:main.c        **** 			
 2974               		.loc 3 221 0
 2975 01ee 80E4      		ldi r24,lo8(64)
 2976 01f0 90E0      		ldi r25,0
 2977 01f2 00D0      		rcall usart_read_bytes
 2978               	.LVL244:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2979               		.loc 3 223 0
 2980 01f4 939A      		sbi 0x12,3
 2981               	.LVL245:
 2982 01f6 10E0      		ldi r17,lo8(receivedBuffer)
 2983 01f8 A12E      		mov r10,r17
 2984 01fa 10E0      		ldi r17,hi8(receivedBuffer)
 2985 01fc B12E      		mov r11,r17
 2986 01fe 00E0      		ldi r16,0
 2987 0200 10E0      		ldi r17,0
 2988               	.LVL246:
 2989               	.L126:
 2990               	.LBB200:
 225:main.c        **** 				address++;
 2991               		.loc 3 225 0 discriminator 3
 2992 0202 F501      		movw r30,r10
 2993 0204 6191      		ld r22,Z+
 2994 0206 5F01      		movw r10,r30
 2995 0208 C801      		movw r24,r16
 2996 020a 8C0D      		add r24,r12
 2997 020c 9D1D      		adc r25,r13
 2998 020e 00D0      		rcall gba_write_ram_8bit_data
 2999               	.LVL247:
 3000 0210 0F5F      		subi r16,-1
 3001 0212 1F4F      		sbci r17,-1
 3002               	.LVL248:
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 3003               		.loc 3 224 0 discriminator 3
 3004 0214 0034      		cpi r16,64
 3005 0216 1105      		cpc r17,__zero_reg__
 3006 0218 01F4      		brne .L126
 3007               	.LVL249:
 3008               	.L272:
 3009 021a F0E4      		ldi r31,64
 3010 021c CF0E      		add r12,r31
 3011 021e D11C      		adc r13,__zero_reg__
 3012 0220 E11C      		adc r14,__zero_reg__
 3013 0222 F11C      		adc r15,__zero_reg__
 3014               	.L271:
 3015               	.LBE200:
 228:main.c        **** 			
 3016               		.loc 3 228 0
 3017 0224 81E3      		ldi r24,lo8(49)
 3018 0226 00D0      		rcall USART_Transmit
 3019               	.LVL250:
 230:main.c        **** 			gba_mode(); // Set back
 3020               		.loc 3 230 0
 3021 0228 9398      		cbi 0x12,3
 3022               	.L269:
 231:main.c        **** 		}
 3023               		.loc 3 231 0
 3024 022a 00D0      		rcall gba_mode
 3025               	.LVL251:
 3026 022c 00C0      		rjmp .L99
 3027               	.LVL252:
 3028               	.L125:
 235:main.c        **** 			gb_mode();
 3029               		.loc 3 235 0
 3030 022e 8F36      		cpi r24,lo8(111)
 3031 0230 01F4      		brne .L127
 3032               	.LBB201:
 236:main.c        **** 			
 3033               		.loc 3 236 0
 3034 0232 00D0      		rcall gb_mode
 3035               	.LVL253:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 3036               		.loc 3 238 0
 3037 0234 00D0      		rcall USART_Receive
 3038               	.LVL254:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3039               		.loc 3 239 0
 3040 0236 682F      		mov r22,r24
 3041 0238 C601      		movw r24,r12
 3042               	.LVL255:
 3043 023a 00D0      		rcall gba_write_ram_8bit_data
 3044               	.LVL256:
 3045 023c 00C0      		rjmp .L274
 3046               	.L127:
 3047               	.LBE201:
 248:main.c        **** 			gb_mode();
 3048               		.loc 3 248 0
 3049 023e 8936      		cpi r24,lo8(105)
 3050 0240 01F4      		brne .L128
 249:main.c        **** 			
 3051               		.loc 3 249 0
 3052 0242 00D0      		rcall gb_mode
 3053               	.LVL257:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 3054               		.loc 3 251 0
 3055 0244 00D0      		rcall flash_read_chip_id
 3056               	.LVL258:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 3057               		.loc 3 252 0
 3058 0246 8091 0000 		lds r24,flashChipIdBuffer
 3059 024a 00D0      		rcall USART_Transmit
 3060               	.LVL259:
 253:main.c        **** 			
 3061               		.loc 3 253 0
 3062 024c 8091 0000 		lds r24,flashChipIdBuffer+1
 3063               	.L273:
 3064 0250 00D0      		rcall USART_Transmit
 3065               	.LVL260:
 3066 0252 00C0      		rjmp .L269
 3067               	.L128:
 259:main.c        **** 			usart_read_chars(); // Read data
 3068               		.loc 3 259 0
 3069 0254 8B36      		cpi r24,lo8(107)
 3070 0256 01F4      		brne .L129
 3071               	.LBB202:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3072               		.loc 3 260 0
 3073 0258 00D0      		rcall usart_read_chars
 3074               	.LVL261:
 261:main.c        **** 			
 3075               		.loc 3 261 0
 3076 025a 80E0      		ldi r24,lo8(receivedBuffer)
 3077 025c 90E0      		ldi r25,hi8(receivedBuffer)
 3078 025e 00D0      		rcall atoi
 3079               	.LVL262:
 3080 0260 182F      		mov r17,r24
 3081               	.LVL263:
 263:main.c        **** 			flash_switch_bank(bank);
 3082               		.loc 3 263 0
 3083 0262 00D0      		rcall gb_mode
 3084               	.LVL264:
 264:main.c        **** 			
 3085               		.loc 3 264 0
 3086 0264 812F      		mov r24,r17
 3087 0266 00D0      		rcall flash_switch_bank
 3088               	.LVL265:
 3089 0268 00C0      		rjmp .L269
 3090               	.LVL266:
 3091               	.L129:
 3092               	.LBE202:
 270:main.c        **** 			gb_mode();
 3093               		.loc 3 270 0
 3094 026a 8337      		cpi r24,lo8(115)
 3095 026c 01F4      		brne .L130
 3096               	.LBB203:
 271:main.c        **** 			
 3097               		.loc 3 271 0
 3098 026e 00D0      		rcall gb_mode
 3099               	.LVL267:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3100               		.loc 3 273 0
 3101 0270 00D0      		rcall usart_read_chars
 3102               	.LVL268:
 274:main.c        **** 			
 3103               		.loc 3 274 0
 3104 0272 40E1      		ldi r20,lo8(16)
 3105 0274 50E0      		ldi r21,0
 3106 0276 60E0      		ldi r22,0
 3107 0278 70E0      		ldi r23,0
 3108 027a 80E0      		ldi r24,lo8(receivedBuffer)
 3109 027c 90E0      		ldi r25,hi8(receivedBuffer)
 3110 027e 00D0      		rcall strtol
 3111               	.LVL269:
 3112 0280 862F      		mov r24,r22
 3113               	.LVL270:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3114               		.loc 3 276 0
 3115 0282 00D0      		rcall flash_erase_4k_sector
 3116               	.LVL271:
 3117               	.L274:
 277:main.c        **** 			
 3118               		.loc 3 277 0
 3119 0284 81E3      		ldi r24,lo8(49)
 3120 0286 00C0      		rjmp .L273
 3121               	.L130:
 3122               	.LBE203:
 283:main.c        **** 			gb_mode();
 3123               		.loc 3 283 0
 3124 0288 8236      		cpi r24,lo8(98)
 3125 028a 01F4      		brne .L131
 284:main.c        **** 			
 3126               		.loc 3 284 0
 3127 028c 00D0      		rcall gb_mode
 3128               	.LVL272:
 286:main.c        **** 			
 3129               		.loc 3 286 0
 3130 028e 80E4      		ldi r24,lo8(64)
 3131 0290 90E0      		ldi r25,0
 3132 0292 00D0      		rcall usart_read_bytes
 3133               	.LVL273:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3134               		.loc 3 288 0
 3135 0294 939A      		sbi 0x12,3
 3136               	.LVL274:
 3137 0296 B0E0      		ldi r27,lo8(receivedBuffer)
 3138 0298 AB2E      		mov r10,r27
 3139 029a B0E0      		ldi r27,hi8(receivedBuffer)
 3140 029c BB2E      		mov r11,r27
 3141 029e 00E0      		ldi r16,0
 3142 02a0 10E0      		ldi r17,0
 3143               	.LVL275:
 3144               	.L132:
 3145               	.LBB204:
 290:main.c        **** 				address++;
 3146               		.loc 3 290 0 discriminator 3
 3147 02a2 F501      		movw r30,r10
 3148 02a4 6191      		ld r22,Z+
 3149 02a6 5F01      		movw r10,r30
 3150 02a8 C801      		movw r24,r16
 3151 02aa 8C0D      		add r24,r12
 3152 02ac 9D1D      		adc r25,r13
 3153 02ae 00D0      		rcall flash_write_byte
 3154               	.LVL276:
 3155 02b0 0F5F      		subi r16,-1
 3156 02b2 1F4F      		sbci r17,-1
 3157               	.LVL277:
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3158               		.loc 3 289 0 discriminator 3
 3159 02b4 0034      		cpi r16,64
 3160 02b6 1105      		cpc r17,__zero_reg__
 3161 02b8 01F4      		brne .L132
 3162 02ba 00C0      		rjmp .L272
 3163               	.LVL278:
 3164               	.L131:
 3165               	.LBE204:
 300:main.c        **** 			gb_mode();
 3166               		.loc 3 300 0
 3167 02bc 8136      		cpi r24,lo8(97)
 3168 02be 01F4      		brne .L133
 301:main.c        **** 			
 3169               		.loc 3 301 0
 3170 02c0 00D0      		rcall gb_mode
 3171               	.LVL279:
 303:main.c        **** 			
 3172               		.loc 3 303 0
 3173 02c2 80E8      		ldi r24,lo8(-128)
 3174 02c4 90E0      		ldi r25,0
 3175 02c6 00D0      		rcall usart_read_bytes
 3176               	.LVL280:
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3177               		.loc 3 305 0
 3178 02c8 939A      		sbi 0x12,3
 306:main.c        **** 			address++;
 3179               		.loc 3 306 0
 3180 02ca C601      		movw r24,r12
 3181 02cc 00D0      		rcall flash_write_sector
 3182               	.LVL281:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3183               		.loc 3 307 0
 3184 02ce 2FEF      		ldi r18,-1
 3185 02d0 C21A      		sub r12,r18
 3186 02d2 D20A      		sbc r13,r18
 3187 02d4 E20A      		sbc r14,r18
 3188 02d6 F20A      		sbc r15,r18
 3189               	.LVL282:
 3190 02d8 00C0      		rjmp .L271
 3191               	.L133:
 317:main.c        **** 			usart_read_chars(); // Read size
 3192               		.loc 3 317 0
 3193 02da 8335      		cpi r24,lo8(83)
 3194 02dc 01F4      		brne .L134
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3195               		.loc 3 318 0
 3196 02de 00D0      		rcall usart_read_chars
 3197               	.LVL283:
 319:main.c        **** 		}
 3198               		.loc 3 319 0
 3199 02e0 40E1      		ldi r20,lo8(16)
 3200 02e2 50E0      		ldi r21,0
 3201 02e4 60E0      		ldi r22,0
 3202 02e6 70E0      		ldi r23,0
 3203 02e8 80E0      		ldi r24,lo8(receivedBuffer)
 3204 02ea 90E0      		ldi r25,hi8(receivedBuffer)
 3205 02ec 00D0      		rcall strtol
 3206               	.LVL284:
 3207 02ee D62F      		mov r29,r22
 3208               	.LVL285:
 3209 02f0 00C0      		rjmp .L99
 3210               	.LVL286:
 3211               	.L134:
 323:main.c        **** 			gba_eeprom_mode();
 3212               		.loc 3 323 0
 3213 02f2 8536      		cpi r24,lo8(101)
 3214 02f4 01F4      		brne .L135
 324:main.c        **** 			
 3215               		.loc 3 324 0
 3216 02f6 00D0      		rcall gba_eeprom_mode
 3217               	.LVL287:
 326:main.c        **** 			while (receivedChar == '1') {
 3218               		.loc 3 326 0
 3219 02f8 3092 0000 		sts receivedChar,r3
 3220               	.L136:
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3221               		.loc 3 327 0
 3222 02fc 8091 0000 		lds r24,receivedChar
 3223 0300 8133      		cpi r24,lo8(49)
 3224 0302 01F0      		breq .+2
 3225 0304 00C0      		rjmp .L269
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3226               		.loc 3 328 0
 3227 0306 939A      		sbi 0x12,3
 329:main.c        **** 				
 3228               		.loc 3 329 0
 3229 0308 6D2F      		mov r22,r29
 3230 030a C601      		movw r24,r12
 3231 030c 00D0      		rcall gba_eeprom_read
 3232               	.LVL288:
 3233 030e 00E0      		ldi r16,lo8(eepromBuffer)
 3234 0310 10E0      		ldi r17,hi8(eepromBuffer)
 3235               	.LVL289:
 3236               	.L137:
 3237               	.LBB205:
 333:main.c        **** 				}
 3238               		.loc 3 333 0 discriminator 3
 3239 0312 F801      		movw r30,r16
 3240 0314 8191      		ld r24,Z+
 3241 0316 8F01      		movw r16,r30
 3242               	.LVL290:
 3243 0318 00D0      		rcall USART_Transmit
 3244               	.LVL291:
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3245               		.loc 3 332 0 discriminator 3
 3246 031a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3247 031c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3248 031e 8017      		cp r24,r16
 3249 0320 9107      		cpc r25,r17
 3250 0322 01F4      		brne .L137
 3251               	.LBE205:
 335:main.c        **** 				
 3252               		.loc 3 335 0
 3253 0324 9FEF      		ldi r25,-1
 3254 0326 C91A      		sub r12,r25
 3255 0328 D90A      		sbc r13,r25
 3256 032a E90A      		sbc r14,r25
 3257 032c F90A      		sbc r15,r25
 3258               	.LVL292:
 337:main.c        **** 				receivedChar = USART_Receive();
 3259               		.loc 3 337 0
 3260 032e 9398      		cbi 0x12,3
 338:main.c        **** 			}
 3261               		.loc 3 338 0
 3262 0330 00D0      		rcall USART_Receive
 3263               	.LVL293:
 3264 0332 8093 0000 		sts receivedChar,r24
 3265 0336 00C0      		rjmp .L136
 3266               	.LVL294:
 3267               	.L135:
 345:main.c        **** 			gba_eeprom_mode();
 3268               		.loc 3 345 0
 3269 0338 8037      		cpi r24,lo8(112)
 3270 033a 01F4      		brne .L139
 346:main.c        **** 			
 3271               		.loc 3 346 0
 3272 033c 00D0      		rcall gba_eeprom_mode
 3273               	.LVL295:
 3274 033e 00E0      		ldi r16,lo8(eepromBuffer)
 3275 0340 10E0      		ldi r17,hi8(eepromBuffer)
 3276               	.LVL296:
 3277               	.L140:
 3278               	.LBB206:
 350:main.c        **** 			}
 3279               		.loc 3 350 0 discriminator 3
 3280 0342 00D0      		rcall USART_Receive
 3281               	.LVL297:
 3282 0344 F801      		movw r30,r16
 3283 0346 8193      		st Z+,r24
 3284 0348 8F01      		movw r16,r30
 3285               	.LVL298:
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3286               		.loc 3 349 0 discriminator 3
 3287 034a 80E0      		ldi r24,lo8(eepromBuffer+8)
 3288 034c 90E0      		ldi r25,hi8(eepromBuffer+8)
 3289 034e 8E17      		cp r24,r30
 3290 0350 9F07      		cpc r25,r31
 3291 0352 01F4      		brne .L140
 3292               	.LBE206:
 352:main.c        **** 			
 3293               		.loc 3 352 0
 3294 0354 939A      		sbi 0x12,3
 354:main.c        **** 			address++;
 3295               		.loc 3 354 0
 3296 0356 6D2F      		mov r22,r29
 3297 0358 C601      		movw r24,r12
 3298 035a 00D0      		rcall gba_eeprom_write
 3299               	.LVL299:
 355:main.c        **** 			
 3300               		.loc 3 355 0
 3301 035c 9FEF      		ldi r25,-1
 3302 035e C91A      		sub r12,r25
 3303 0360 D90A      		sbc r13,r25
 3304 0362 E90A      		sbc r14,r25
 3305 0364 F90A      		sbc r15,r25
 3306               	.LVL300:
 3307               	.LBB207:
 3308               	.LBB208:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3309               		.loc 2 187 0
 3310 0366 EFE7      		ldi r30,lo8(15999)
 3311 0368 FEE3      		ldi r31,hi8(15999)
 3312 036a 3197      	1:	sbiw r30,1
 3313 036c 01F4      		brne 1b
 3314 036e 00C0      		rjmp .
 3315 0370 0000      		nop
 3316               	.LVL301:
 3317 0372 00C0      		rjmp .L271
 3318               	.LVL302:
 3319               	.L139:
 3320               	.LBE208:
 3321               	.LBE207:
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3322               		.loc 3 367 0
 3323 0374 8035      		cpi r24,lo8(80)
 3324 0376 01F4      		brne .L141
 368:main.c        **** 			
 3325               		.loc 3 368 0
 3326 0378 00D0      		rcall USART_Receive
 3327               	.LVL303:
 3328 037a 8093 0000 		sts flashWriteWePin,r24
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3329               		.loc 3 370 0
 3330 037e 8134      		cpi r24,lo8(65)
 3331 0380 01F0      		breq .+2
 3332 0382 00C0      		rjmp .L99
 371:main.c        **** 				audioPin_high;
 3333               		.loc 3 371 0
 3334 0384 319A      		sbi 0x6,1
 372:main.c        **** 			}
 3335               		.loc 3 372 0
 3336 0386 399A      		sbi 0x7,1
 3337 0388 00C0      		rjmp .L99
 3338               	.L141:
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3339               		.loc 3 377 0
 3340 038a 8E34      		cpi r24,lo8(78)
 3341 038c 01F4      		brne .L142
 378:main.c        **** 		}
 3342               		.loc 3 378 0
 3343 038e 81E0      		ldi r24,lo8(1)
 3344 0390 8093 0000 		sts flashBank1CommandWrites,r24
 3345 0394 00C0      		rjmp .L99
 3346               	.L142:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3347               		.loc 3 382 0
 3348 0396 8534      		cpi r24,lo8(69)
 3349 0398 01F4      		brne .L143
 3350 039a 00E0      		ldi r16,lo8(flashWriteCycle)
 3351 039c 10E0      		ldi r17,hi8(flashWriteCycle)
 3352               	.L144:
 3353               	.LBB209:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3354               		.loc 3 384 0 discriminator 3
 3355 039e 00D0      		rcall usart_read_chars
 3356               	.LVL304:
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3357               		.loc 3 385 0 discriminator 3
 3358 03a0 40E1      		ldi r20,lo8(16)
 3359 03a2 50E0      		ldi r21,0
 3360 03a4 60E0      		ldi r22,0
 3361 03a6 70E0      		ldi r23,0
 3362 03a8 80E0      		ldi r24,lo8(receivedBuffer)
 3363 03aa 90E0      		ldi r25,hi8(receivedBuffer)
 3364 03ac 00D0      		rcall strtol
 3365               	.LVL305:
 3366 03ae F801      		movw r30,r16
 3367 03b0 7183      		std Z+1,r23
 3368 03b2 6083      		st Z,r22
 386:main.c        **** 				
 3369               		.loc 3 386 0 discriminator 3
 3370 03b4 81E3      		ldi r24,lo8(49)
 3371 03b6 00D0      		rcall USART_Transmit
 3372               	.LVL306:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3373               		.loc 3 388 0 discriminator 3
 3374 03b8 00D0      		rcall usart_read_chars
 3375               	.LVL307:
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3376               		.loc 3 389 0 discriminator 3
 3377 03ba 40E1      		ldi r20,lo8(16)
 3378 03bc 50E0      		ldi r21,0
 3379 03be 60E0      		ldi r22,0
 3380 03c0 70E0      		ldi r23,0
 3381 03c2 80E0      		ldi r24,lo8(receivedBuffer)
 3382 03c4 90E0      		ldi r25,hi8(receivedBuffer)
 3383 03c6 00D0      		rcall strtol
 3384               	.LVL308:
 3385 03c8 F801      		movw r30,r16
 3386 03ca 7383      		std Z+3,r23
 3387 03cc 6283      		std Z+2,r22
 390:main.c        **** 			}
 3388               		.loc 3 390 0 discriminator 3
 3389 03ce 81E3      		ldi r24,lo8(49)
 3390 03d0 00D0      		rcall USART_Transmit
 3391               	.LVL309:
 3392 03d2 0C5F      		subi r16,-4
 3393 03d4 1F4F      		sbci r17,-1
 383:main.c        **** 				usart_read_chars(); // Address
 3394               		.loc 3 383 0 discriminator 3
 3395 03d6 F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3396 03d8 0030      		cpi r16,lo8(flashWriteCycle+12)
 3397 03da 1F07      		cpc r17,r31
 3398 03dc 01F4      		brne .L144
 3399 03de 00C0      		rjmp .L99
 3400               	.L143:
 3401               	.LBE209:
 395:main.c        **** 			usart_read_chars(); // Read address
 3402               		.loc 3 395 0
 3403 03e0 8634      		cpi r24,lo8(70)
 3404 03e2 01F4      		brne .L145
 3405               	.LBB210:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3406               		.loc 3 396 0
 3407 03e4 00D0      		rcall usart_read_chars
 3408               	.LVL310:
 397:main.c        **** 			
 3409               		.loc 3 397 0
 3410 03e6 40E1      		ldi r20,lo8(16)
 3411 03e8 50E0      		ldi r21,0
 3412 03ea 60E0      		ldi r22,0
 3413 03ec 70E0      		ldi r23,0
 3414 03ee 80E0      		ldi r24,lo8(receivedBuffer)
 3415 03f0 90E0      		ldi r25,hi8(receivedBuffer)
 3416 03f2 00D0      		rcall strtol
 3417               	.LVL311:
 3418 03f4 4B01      		movw r8,r22
 3419 03f6 5C01      		movw r10,r24
 3420               	.LVL312:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3421               		.loc 3 399 0
 3422 03f8 00D0      		rcall usart_read_chars
 3423               	.LVL313:
 400:main.c        **** 			
 3424               		.loc 3 400 0
 3425 03fa 40E1      		ldi r20,lo8(16)
 3426 03fc 50E0      		ldi r21,0
 3427 03fe 60E0      		ldi r22,0
 3428 0400 70E0      		ldi r23,0
 3429 0402 80E0      		ldi r24,lo8(receivedBuffer)
 3430 0404 90E0      		ldi r25,hi8(receivedBuffer)
 3431 0406 00D0      		rcall strtol
 3432               	.LVL314:
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3433               		.loc 3 402 0
 3434 0408 939A      		sbi 0x12,3
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3435               		.loc 3 403 0
 3436 040a C401      		movw r24,r8
 3437 040c 00D0      		rcall gb_flash_write_bus_cycle
 3438               	.LVL315:
 3439 040e 00C0      		rjmp .L287
 3440               	.LVL316:
 3441               	.L145:
 3442               	.LBE210:
 410:main.c        **** 			usart_read_bytes(64);
 3443               		.loc 3 410 0
 3444 0410 8435      		cpi r24,lo8(84)
 3445 0412 01F4      		brne .L146
 411:main.c        **** 			
 3446               		.loc 3 411 0
 3447 0414 80E4      		ldi r24,lo8(64)
 3448 0416 90E0      		ldi r25,0
 3449 0418 00D0      		rcall usart_read_bytes
 3450               	.LVL317:
 413:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3451               		.loc 3 413 0
 3452 041a 939A      		sbi 0x12,3
 414:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3453               		.loc 3 414 0
 3454 041c 8091 0000 		lds r24,flashBank1CommandWrites
 3455 0420 A0E0      		ldi r26,lo8(receivedBuffer)
 3456 0422 AA2E      		mov r10,r26
 3457 0424 A0E0      		ldi r26,hi8(receivedBuffer)
 3458 0426 BA2E      		mov r11,r26
 3459 0428 00E0      		ldi r16,0
 3460 042a 10E0      		ldi r17,0
 3461 042c 8111      		cpse r24,__zero_reg__
 3462 042e 00C0      		rjmp .L152
 3463               	.LVL318:
 3464               	.L149:
 3465               	.LBB211:
 416:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3466               		.loc 3 416 0
 3467 0430 F501      		movw r30,r10
 3468 0432 6191      		ld r22,Z+
 3469 0434 5F01      		movw r10,r30
 3470 0436 6F3F      		cpi r22,lo8(-1)
 3471 0438 01F0      		breq .L148
 417:main.c        **** 					}
 3472               		.loc 3 417 0
 3473 043a C801      		movw r24,r16
 3474 043c 8C0D      		add r24,r12
 3475 043e 9D1D      		adc r25,r13
 3476 0440 00D0      		rcall gb_flash_write_byte
 3477               	.LVL319:
 3478               	.L148:
 3479 0442 0F5F      		subi r16,-1
 3480 0444 1F4F      		sbci r17,-1
 3481               	.LVL320:
 415:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3482               		.loc 3 415 0 discriminator 2
 3483 0446 0034      		cpi r16,64
 3484 0448 1105      		cpc r17,__zero_reg__
 3485 044a 01F4      		brne .L149
 3486 044c 00C0      		rjmp .L288
 3487               	.LVL321:
 3488               	.L151:
 3489 044e 0F5F      		subi r16,-1
 3490 0450 1F4F      		sbci r17,-1
 3491               	.LVL322:
 3492               	.LBE211:
 3493               	.LBB212:
 423:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3494               		.loc 3 423 0 discriminator 2
 3495 0452 0034      		cpi r16,64
 3496 0454 1105      		cpc r17,__zero_reg__
 3497 0456 01F4      		brne .+2
 3498 0458 00C0      		rjmp .L288
 3499               	.LVL323:
 3500               	.L152:
 424:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3501               		.loc 3 424 0
 3502 045a F501      		movw r30,r10
 3503 045c 6191      		ld r22,Z+
 3504 045e 5F01      		movw r10,r30
 3505 0460 6F3F      		cpi r22,lo8(-1)
 3506 0462 01F0      		breq .L151
 425:main.c        **** 					}
 3507               		.loc 3 425 0
 3508 0464 C801      		movw r24,r16
 3509 0466 8C0D      		add r24,r12
 3510 0468 9D1D      		adc r25,r13
 3511 046a 00D0      		rcall gb_flash_write_byte_bank1_commands
 3512               	.LVL324:
 3513 046c 00C0      		rjmp .L151
 3514               	.LVL325:
 3515               	.L146:
 3516               	.LBE212:
 436:main.c        **** 			usart_read_bytes(32);
 3517               		.loc 3 436 0
 3518 046e 8935      		cpi r24,lo8(89)
 3519 0470 01F0      		breq .+2
 3520 0472 00C0      		rjmp .L153
 3521               	.LBB213:
 437:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3522               		.loc 3 437 0
 3523 0474 80E2      		ldi r24,lo8(32)
 3524 0476 90E0      		ldi r25,0
 3525 0478 00D0      		rcall usart_read_bytes
 3526               	.LVL326:
 438:main.c        **** 			
 3527               		.loc 3 438 0
 3528 047a 939A      		sbi 0x12,3
 441:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3529               		.loc 3 441 0
 3530 047c 6AEA      		ldi r22,lo8(-86)
 3531 047e 8AEA      		ldi r24,lo8(-86)
 3532 0480 9AE0      		ldi r25,lo8(10)
 3533 0482 00D0      		rcall gb_flash_write_bus_cycle
 3534               	.LVL327:
 442:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3535               		.loc 3 442 0
 3536 0484 65E5      		ldi r22,lo8(85)
 3537 0486 85E5      		ldi r24,lo8(85)
 3538 0488 95E0      		ldi r25,lo8(5)
 3539 048a 00D0      		rcall gb_flash_write_bus_cycle
 3540               	.LVL328:
 443:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3541               		.loc 3 443 0
 3542 048c 5601      		movw r10,r12
 3543 048e 65E2      		ldi r22,lo8(37)
 3544 0490 C601      		movw r24,r12
 3545 0492 00D0      		rcall gb_flash_write_bus_cycle
 3546               	.LVL329:
 444:main.c        **** 			_delay_us(1);
 3547               		.loc 3 444 0
 3548 0494 6FE1      		ldi r22,lo8(31)
 3549 0496 C601      		movw r24,r12
 3550 0498 00D0      		rcall gb_flash_write_bus_cycle
 3551               	.LVL330:
 3552               	.LBB214:
 3553               	.LBB215:
 3554               		.loc 2 276 0
 3555 049a 22E0      		ldi r18,lo8(2)
 3556 049c 2A95      	1:	dec r18
 3557 049e 01F4      		brne 1b
 3558 04a0 00C0      		rjmp .
 3559               	.LVL331:
 3560 04a2 00E0      		ldi r16,lo8(receivedBuffer)
 3561 04a4 10E0      		ldi r17,hi8(receivedBuffer)
 3562 04a6 812C      		mov r8,__zero_reg__
 3563 04a8 912C      		mov r9,__zero_reg__
 3564               	.LVL332:
 3565               	.L154:
 3566               	.LBE215:
 3567               	.LBE214:
 3568               	.LBB216:
 449:main.c        **** 				address++;
 3569               		.loc 3 449 0 discriminator 3
 3570 04aa F801      		movw r30,r16
 3571 04ac 6191      		ld r22,Z+
 3572 04ae 8F01      		movw r16,r30
 3573 04b0 C401      		movw r24,r8
 3574 04b2 8A0D      		add r24,r10
 3575 04b4 9B1D      		adc r25,r11
 3576 04b6 00D0      		rcall gb_flash_write_bus_cycle
 3577               	.LVL333:
 3578 04b8 FFEF      		ldi r31,-1
 3579 04ba 8F1A      		sub r8,r31
 3580 04bc 9F0A      		sbc r9,r31
 3581               	.LVL334:
 448:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3582               		.loc 3 448 0 discriminator 3
 3583 04be 20E2      		ldi r18,32
 3584 04c0 8216      		cp r8,r18
 3585 04c2 9104      		cpc r9,__zero_reg__
 3586 04c4 01F4      		brne .L154
 3587 04c6 80E2      		ldi r24,32
 3588 04c8 C80E      		add r12,r24
 3589 04ca D11C      		adc r13,__zero_reg__
 3590 04cc E11C      		adc r14,__zero_reg__
 3591 04ce F11C      		adc r15,__zero_reg__
 3592               	.LBE216:
 454:main.c        **** 			_delay_us(200);
 3593               		.loc 3 454 0
 3594 04d0 C601      		movw r24,r12
 3595 04d2 8097      		sbiw r24,32
 3596 04d4 69E2      		ldi r22,lo8(41)
 3597 04d6 00D0      		rcall gb_flash_write_bus_cycle
 3598               	.LVL335:
 3599               	.LBB217:
 3600               	.LBB218:
 3601               		.loc 2 276 0
 3602 04d8 EFE8      		ldi r30,lo8(399)
 3603 04da F1E0      		ldi r31,hi8(399)
 3604 04dc 3197      	1:	sbiw r30,1
 3605 04de 01F4      		brne 1b
 3606 04e0 00C0      		rjmp .
 3607 04e2 0000      		nop
 3608               	.LVL336:
 3609               	.LBE218:
 3610               	.LBE217:
 458:main.c        **** 			uint8_t verifyCount = 0;
 3611               		.loc 3 458 0
 3612 04e4 8601      		movw r16,r12
 3613 04e6 0150      		subi r16,1
 3614 04e8 1109      		sbc r17,__zero_reg__
 3615 04ea C801      		movw r24,r16
 3616 04ec 00D0      		rcall gb_flash_read_byte
 3617               	.LVL337:
 460:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3618               		.loc 3 460 0
 3619 04ee F8EC      		ldi r31,lo8(-56)
 3620 04f0 BF2E      		mov r11,r31
 3621               	.LVL338:
 3622               	.L155:
 3623 04f2 9091 0000 		lds r25,receivedBuffer+31
 3624 04f6 8917      		cp r24,r25
 3625 04f8 01F4      		brne .+2
 3626 04fa 00C0      		rjmp .L276
 461:main.c        **** 				_delay_us(5);
 3627               		.loc 3 461 0
 3628 04fc C801      		movw r24,r16
 3629               	.LVL339:
 3630 04fe 00D0      		rcall gb_flash_read_byte
 3631               	.LVL340:
 3632               	.LBB219:
 3633               	.LBB220:
 3634               		.loc 2 276 0
 3635 0500 FDE0      		ldi r31,lo8(13)
 3636 0502 FA95      	1:	dec r31
 3637 0504 01F4      		brne 1b
 3638 0506 0000      		nop
 3639               	.LVL341:
 3640 0508 BA94      		dec r11
 3641               	.LVL342:
 3642               	.LBE220:
 3643               	.LBE219:
 464:main.c        **** 					_delay_ms(500);
 3644               		.loc 3 464 0
 3645 050a B110      		cpse r11,__zero_reg__
 3646 050c 00C0      		rjmp .L155
 3647               	.LVL343:
 3648               	.LBB221:
 3649               	.LBB222:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3650               		.loc 2 187 0
 3651 050e 2FEF      		ldi r18,lo8(799999)
 3652 0510 84E3      		ldi r24,hi8(799999)
 3653 0512 9CE0      		ldi r25,hlo8(799999)
 3654 0514 2150      	1:	subi r18,1
 3655 0516 8040      		sbci r24,0
 3656 0518 9040      		sbci r25,0
 3657 051a 01F4      		brne 1b
 3658               	.LVL344:
 3659 051c 00C0      		rjmp .L289
 3660               	.LVL345:
 3661               	.L153:
 3662               	.LBE222:
 3663               	.LBE221:
 3664               	.LBE213:
 475:main.c        **** 			usart_read_bytes(64);
 3665               		.loc 3 475 0
 3666 051e 8A34      		cpi r24,lo8(74)
 3667 0520 01F4      		brne .L158
 476:main.c        **** 			
 3668               		.loc 3 476 0
 3669 0522 80E4      		ldi r24,lo8(64)
 3670 0524 90E0      		ldi r25,0
 3671 0526 00D0      		rcall usart_read_bytes
 3672               	.LVL346:
 478:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3673               		.loc 3 478 0
 3674 0528 939A      		sbi 0x12,3
 3675               	.LVL347:
 3676 052a E0E0      		ldi r30,lo8(receivedBuffer)
 3677 052c AE2E      		mov r10,r30
 3678 052e E0E0      		ldi r30,hi8(receivedBuffer)
 3679 0530 BE2E      		mov r11,r30
 3680 0532 00E0      		ldi r16,0
 3681 0534 10E0      		ldi r17,0
 3682               	.LVL348:
 3683               	.L160:
 3684               	.LBB223:
 480:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3685               		.loc 3 480 0
 3686 0536 F501      		movw r30,r10
 3687 0538 6191      		ld r22,Z+
 3688 053a 5F01      		movw r10,r30
 3689 053c 6F3F      		cpi r22,lo8(-1)
 3690 053e 01F0      		breq .L159
 481:main.c        **** 				}
 3691               		.loc 3 481 0
 3692 0540 C801      		movw r24,r16
 3693 0542 8C0D      		add r24,r12
 3694 0544 9D1D      		adc r25,r13
 3695 0546 00D0      		rcall gb_flash_write_byte_special
 3696               	.LVL349:
 3697               	.L159:
 3698 0548 0F5F      		subi r16,-1
 3699 054a 1F4F      		sbci r17,-1
 3700               	.LVL350:
 479:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 3701               		.loc 3 479 0 discriminator 2
 3702 054c 0034      		cpi r16,64
 3703 054e 1105      		cpc r17,__zero_reg__
 3704 0550 01F4      		brne .L160
 3705               	.LVL351:
 3706               	.L288:
 3707 0552 F0E4      		ldi r31,64
 3708 0554 CF0E      		add r12,r31
 3709 0556 D11C      		adc r13,__zero_reg__
 3710 0558 E11C      		adc r14,__zero_reg__
 3711 055a F11C      		adc r15,__zero_reg__
 3712 055c 00C0      		rjmp .L276
 3713               	.LVL352:
 3714               	.L158:
 3715               	.LBE223:
 491:main.c        **** 			usart_read_bytes(256);
 3716               		.loc 3 491 0
 3717 055e 8835      		cpi r24,lo8(88)
 3718 0560 01F0      		breq .+2
 3719 0562 00C0      		rjmp .L161
 3720               	.LBB224:
 492:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3721               		.loc 3 492 0
 3722 0564 80E0      		ldi r24,0
 3723 0566 91E0      		ldi r25,lo8(1)
 3724 0568 00D0      		rcall usart_read_bytes
 3725               	.LVL353:
 493:main.c        **** 			
 3726               		.loc 3 493 0
 3727 056a 939A      		sbi 0x12,3
 496:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3728               		.loc 3 496 0
 3729 056c 69EA      		ldi r22,lo8(-87)
 3730 056e 8AEA      		ldi r24,lo8(-86)
 3731 0570 9AE0      		ldi r25,lo8(10)
 3732 0572 00D0      		rcall gb_flash_write_bus_cycle
 3733               	.LVL354:
 497:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3734               		.loc 3 497 0
 3735 0574 66E5      		ldi r22,lo8(86)
 3736 0576 85E5      		ldi r24,lo8(85)
 3737 0578 95E0      		ldi r25,lo8(5)
 3738 057a 00D0      		rcall gb_flash_write_bus_cycle
 3739               	.LVL355:
 498:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3740               		.loc 3 498 0
 3741 057c 5601      		movw r10,r12
 3742 057e 66E2      		ldi r22,lo8(38)
 3743 0580 C601      		movw r24,r12
 3744 0582 00D0      		rcall gb_flash_write_bus_cycle
 3745               	.LVL356:
 499:main.c        **** 			_delay_us(50);
 3746               		.loc 3 499 0
 3747 0584 6FEF      		ldi r22,lo8(-1)
 3748 0586 C601      		movw r24,r12
 3749 0588 00D0      		rcall gb_flash_write_bus_cycle
 3750               	.LVL357:
 3751               	.LBB225:
 3752               	.LBB226:
 3753               		.loc 2 276 0
 3754 058a 25E8      		ldi r18,lo8(-123)
 3755 058c 2A95      	1:	dec r18
 3756 058e 01F4      		brne 1b
 3757 0590 0000      		nop
 3758               	.LVL358:
 3759 0592 00E0      		ldi r16,lo8(receivedBuffer)
 3760 0594 10E0      		ldi r17,hi8(receivedBuffer)
 3761               	.LBE226:
 3762               	.LBE225:
 3763               	.LBB227:
 503:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3764               		.loc 3 503 0
 3765 0596 812C      		mov r8,__zero_reg__
 3766 0598 912C      		mov r9,__zero_reg__
 3767               	.LVL359:
 3768               	.L162:
 504:main.c        **** 				address++;
 3769               		.loc 3 504 0 discriminator 3
 3770 059a F801      		movw r30,r16
 3771 059c 6191      		ld r22,Z+
 3772 059e 8F01      		movw r16,r30
 3773 05a0 C401      		movw r24,r8
 3774 05a2 8A0D      		add r24,r10
 3775 05a4 9B1D      		adc r25,r11
 3776 05a6 00D0      		rcall gb_flash_write_bus_cycle
 3777               	.LVL360:
 503:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3778               		.loc 3 503 0 discriminator 3
 3779 05a8 FFEF      		ldi r31,-1
 3780 05aa 8F1A      		sub r8,r31
 3781 05ac 9F0A      		sbc r9,r31
 3782               	.LVL361:
 3783 05ae 8114      		cp r8,__zero_reg__
 3784 05b0 21E0      		ldi r18,1
 3785 05b2 9206      		cpc r9,r18
 3786 05b4 01F4      		brne .L162
 3787 05b6 8FEF      		ldi r24,-1
 3788 05b8 D81A      		sub r13,r24
 3789 05ba E80A      		sbc r14,r24
 3790 05bc F80A      		sbc r15,r24
 3791               	.LBE227:
 509:main.c        **** 			
 3792               		.loc 3 509 0
 3793 05be C601      		movw r24,r12
 3794 05c0 9A95      		dec r25
 3795 05c2 6AE2      		ldi r22,lo8(42)
 3796 05c4 00D0      		rcall gb_flash_write_bus_cycle
 3797               	.LVL362:
 512:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3798               		.loc 3 512 0
 3799 05c6 8601      		movw r16,r12
 3800 05c8 0150      		subi r16,1
 3801 05ca 1109      		sbc r17,__zero_reg__
 3802 05cc C801      		movw r24,r16
 3803 05ce 00D0      		rcall gb_flash_read_byte
 3804               	.LVL363:
 3805               	.L163:
 513:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3806               		.loc 3 513 0
 3807 05d0 9091 0000 		lds r25,receivedBuffer+255
 3808 05d4 8917      		cp r24,r25
 3809 05d6 01F4      		brne .+2
 3810 05d8 00C0      		rjmp .L276
 514:main.c        **** 				_delay_us(5);
 3811               		.loc 3 514 0
 3812 05da C801      		movw r24,r16
 3813               	.LVL364:
 3814 05dc 00D0      		rcall gb_flash_read_byte
 3815               	.LVL365:
 3816               	.LBB228:
 3817               	.LBB229:
 3818               		.loc 2 276 0
 3819 05de 9DE0      		ldi r25,lo8(13)
 3820 05e0 9A95      	1:	dec r25
 3821 05e2 01F4      		brne 1b
 3822 05e4 0000      		nop
 3823 05e6 00C0      		rjmp .L163
 3824               	.LVL366:
 3825               	.L161:
 3826               	.LBE229:
 3827               	.LBE228:
 3828               	.LBE224:
 523:main.c        **** 			usart_read_bytes(128);
 3829               		.loc 3 523 0
 3830 05e8 8A35      		cpi r24,lo8(90)
 3831 05ea 01F0      		breq .+2
 3832 05ec 00C0      		rjmp .L165
 524:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3833               		.loc 3 524 0
 3834 05ee 80E8      		ldi r24,lo8(-128)
 3835 05f0 90E0      		ldi r25,0
 3836 05f2 00D0      		rcall usart_read_bytes
 3837               	.LVL367:
 525:main.c        **** 			
 3838               		.loc 3 525 0
 3839 05f4 939A      		sbi 0x12,3
 528:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3840               		.loc 3 528 0
 3841 05f6 69E0      		ldi r22,lo8(9)
 3842 05f8 80E2      		ldi r24,lo8(32)
 3843 05fa 91E0      		ldi r25,lo8(1)
 3844 05fc 00D0      		rcall gb_flash_write_bus_cycle
 3845               	.LVL368:
 529:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3846               		.loc 3 529 0
 3847 05fe 6AEA      		ldi r22,lo8(-86)
 3848 0600 81E2      		ldi r24,lo8(33)
 3849 0602 91E0      		ldi r25,lo8(1)
 3850 0604 00D0      		rcall gb_flash_write_bus_cycle
 3851               	.LVL369:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3852               		.loc 3 530 0
 3853 0606 65E5      		ldi r22,lo8(85)
 3854 0608 82E2      		ldi r24,lo8(34)
 3855 060a 91E0      		ldi r25,lo8(1)
 3856 060c 00D0      		rcall gb_flash_write_bus_cycle
 3857               	.LVL370:
 531:main.c        **** 			_delay_us(5);
 3858               		.loc 3 531 0
 3859 060e 65EA      		ldi r22,lo8(-91)
 3860 0610 8FE3      		ldi r24,lo8(63)
 3861 0612 91E0      		ldi r25,lo8(1)
 3862 0614 00D0      		rcall gb_flash_write_bus_cycle
 3863               	.LVL371:
 3864               	.LBB230:
 3865               	.LBB231:
 3866               		.loc 2 276 0
 3867 0616 EDE0      		ldi r30,lo8(13)
 3868 0618 EA95      	1:	dec r30
 3869 061a 01F4      		brne 1b
 3870 061c 0000      		nop
 3871               	.LVL372:
 3872               	.LBE231:
 3873               	.LBE230:
 535:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3874               		.loc 3 535 0
 3875 061e 61E1      		ldi r22,lo8(17)
 3876 0620 80E2      		ldi r24,lo8(32)
 3877 0622 91E0      		ldi r25,lo8(1)
 3878 0624 00D0      		rcall gb_flash_write_bus_cycle
 3879               	.LVL373:
 536:main.c        **** 			_delay_us(5);
 3880               		.loc 3 536 0
 3881 0626 65EA      		ldi r22,lo8(-91)
 3882 0628 8FE3      		ldi r24,lo8(63)
 3883 062a 91E0      		ldi r25,lo8(1)
 3884 062c 00D0      		rcall gb_flash_write_bus_cycle
 3885               	.LVL374:
 3886               	.LBB232:
 3887               	.LBB233:
 3888               		.loc 2 276 0
 3889 062e FDE0      		ldi r31,lo8(13)
 3890 0630 FA95      	1:	dec r31
 3891 0632 01F4      		brne 1b
 3892 0634 0000      		nop
 3893               	.LVL375:
 3894               	.LBE233:
 3895               	.LBE232:
 540:main.c        **** 			_delay_us(5);
 3896               		.loc 3 540 0
 3897 0636 61E0      		ldi r22,lo8(1)
 3898 0638 80E0      		ldi r24,0
 3899 063a 91E2      		ldi r25,lo8(33)
 3900 063c 00D0      		rcall gb_flash_write_bus_cycle
 3901               	.LVL376:
 3902               	.LBB234:
 3903               	.LBB235:
 3904               		.loc 2 276 0
 3905 063e 2DE0      		ldi r18,lo8(13)
 3906 0640 2A95      	1:	dec r18
 3907 0642 01F4      		brne 1b
 3908 0644 0000      		nop
 3909               	.LVL377:
 3910               	.LBE235:
 3911               	.LBE234:
 545:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3912               		.loc 3 545 0
 3913 0646 6FE0      		ldi r22,lo8(15)
 3914 0648 80E2      		ldi r24,lo8(32)
 3915 064a 91E0      		ldi r25,lo8(1)
 3916 064c 00D0      		rcall gb_flash_write_bus_cycle
 3917               	.LVL378:
 546:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3918               		.loc 3 546 0
 3919 064e 65E5      		ldi r22,lo8(85)
 3920 0650 85E2      		ldi r24,lo8(37)
 3921 0652 91E0      		ldi r25,lo8(1)
 3922 0654 00D0      		rcall gb_flash_write_bus_cycle
 3923               	.LVL379:
 547:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3924               		.loc 3 547 0
 3925 0656 65E5      		ldi r22,lo8(85)
 3926 0658 86E2      		ldi r24,lo8(38)
 3927 065a 91E0      		ldi r25,lo8(1)
 3928 065c 00D0      		rcall gb_flash_write_bus_cycle
 3929               	.LVL380:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3930               		.loc 3 548 0
 3931 065e 6AEA      		ldi r22,lo8(-86)
 3932 0660 87E2      		ldi r24,lo8(39)
 3933 0662 91E0      		ldi r25,lo8(1)
 3934 0664 00D0      		rcall gb_flash_write_bus_cycle
 3935               	.LVL381:
 549:main.c        **** 			_delay_us(5);
 3936               		.loc 3 549 0
 3937 0666 65EA      		ldi r22,lo8(-91)
 3938 0668 8FE3      		ldi r24,lo8(63)
 3939 066a 91E0      		ldi r25,lo8(1)
 3940 066c 00D0      		rcall gb_flash_write_bus_cycle
 3941               	.LVL382:
 3942               	.LBB236:
 3943               	.LBB237:
 3944               		.loc 2 276 0
 3945 066e 8DE0      		ldi r24,lo8(13)
 3946 0670 8A95      	1:	dec r24
 3947 0672 01F4      		brne 1b
 3948 0674 0000      		nop
 3949               	.LVL383:
 3950               	.LBE237:
 3951               	.LBE236:
 552:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3952               		.loc 3 552 0
 3953 0676 6FE0      		ldi r22,lo8(15)
 3954 0678 80E2      		ldi r24,lo8(32)
 3955 067a 91E0      		ldi r25,lo8(1)
 3956 067c 00D0      		rcall gb_flash_write_bus_cycle
 3957               	.LVL384:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3958               		.loc 3 553 0
 3959 067e 6AE2      		ldi r22,lo8(42)
 3960 0680 85E2      		ldi r24,lo8(37)
 3961 0682 91E0      		ldi r25,lo8(1)
 3962 0684 00D0      		rcall gb_flash_write_bus_cycle
 3963               	.LVL385:
 554:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3964               		.loc 3 554 0
 3965 0686 6AEA      		ldi r22,lo8(-86)
 3966 0688 86E2      		ldi r24,lo8(38)
 3967 068a 91E0      		ldi r25,lo8(1)
 3968 068c 00D0      		rcall gb_flash_write_bus_cycle
 3969               	.LVL386:
 555:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3970               		.loc 3 555 0
 3971 068e 65E5      		ldi r22,lo8(85)
 3972 0690 87E2      		ldi r24,lo8(39)
 3973 0692 91E0      		ldi r25,lo8(1)
 3974 0694 00D0      		rcall gb_flash_write_bus_cycle
 3975               	.LVL387:
 556:main.c        **** 			_delay_us(5);
 3976               		.loc 3 556 0
 3977 0696 65EA      		ldi r22,lo8(-91)
 3978 0698 8FE3      		ldi r24,lo8(63)
 3979 069a 91E0      		ldi r25,lo8(1)
 3980 069c 00D0      		rcall gb_flash_write_bus_cycle
 3981               	.LVL388:
 3982               	.LBB238:
 3983               	.LBB239:
 3984               		.loc 2 276 0
 3985 069e 9DE0      		ldi r25,lo8(13)
 3986 06a0 9A95      	1:	dec r25
 3987 06a2 01F4      		brne 1b
 3988 06a4 0000      		nop
 3989               	.LVL389:
 3990               	.LBE239:
 3991               	.LBE238:
 559:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3992               		.loc 3 559 0
 3993 06a6 6FE0      		ldi r22,lo8(15)
 3994 06a8 80E2      		ldi r24,lo8(32)
 3995 06aa 91E0      		ldi r25,lo8(1)
 3996 06ac 00D0      		rcall gb_flash_write_bus_cycle
 3997               	.LVL390:
 560:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3998               		.loc 3 560 0
 3999 06ae 65E5      		ldi r22,lo8(85)
 4000 06b0 85E2      		ldi r24,lo8(37)
 4001 06b2 91E0      		ldi r25,lo8(1)
 4002 06b4 00D0      		rcall gb_flash_write_bus_cycle
 4003               	.LVL391:
 561:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 4004               		.loc 3 561 0
 4005 06b6 65E5      		ldi r22,lo8(85)
 4006 06b8 86E2      		ldi r24,lo8(38)
 4007 06ba 91E0      		ldi r25,lo8(1)
 4008 06bc 00D0      		rcall gb_flash_write_bus_cycle
 4009               	.LVL392:
 562:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4010               		.loc 3 562 0
 4011 06be 60EA      		ldi r22,lo8(-96)
 4012 06c0 87E2      		ldi r24,lo8(39)
 4013 06c2 91E0      		ldi r25,lo8(1)
 4014 06c4 00D0      		rcall gb_flash_write_bus_cycle
 4015               	.LVL393:
 563:main.c        **** 			_delay_us(5);
 4016               		.loc 3 563 0
 4017 06c6 65EA      		ldi r22,lo8(-91)
 4018 06c8 8FE3      		ldi r24,lo8(63)
 4019 06ca 91E0      		ldi r25,lo8(1)
 4020 06cc 00D0      		rcall gb_flash_write_bus_cycle
 4021               	.LVL394:
 4022               	.LBB240:
 4023               	.LBB241:
 4024               		.loc 2 276 0
 4025 06ce EDE0      		ldi r30,lo8(13)
 4026 06d0 EA95      	1:	dec r30
 4027 06d2 01F4      		brne 1b
 4028 06d4 0000      		nop
 4029               	.LVL395:
 4030               	.LBE241:
 4031               	.LBE240:
 567:main.c        **** 			_delay_us(5);
 4032               		.loc 3 567 0
 4033 06d6 40E0      		ldi r20,0
 4034 06d8 6091 0000 		lds r22,lastBankAccessed
 4035 06dc 80E0      		ldi r24,0
 4036 06de 91E2      		ldi r25,lo8(33)
 4037 06e0 00D0      		rcall write_8bit_data
 4038               	.LVL396:
 4039               	.LBB242:
 4040               	.LBB243:
 4041               		.loc 2 276 0
 4042 06e2 FDE0      		ldi r31,lo8(13)
 4043 06e4 FA95      	1:	dec r31
 4044 06e6 01F4      		brne 1b
 4045 06e8 0000      		nop
 4046               	.LVL397:
 4047               	.LBE243:
 4048               	.LBE242:
 571:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4049               		.loc 3 571 0
 4050 06ea 60E1      		ldi r22,lo8(16)
 4051 06ec 80E2      		ldi r24,lo8(32)
 4052 06ee 91E0      		ldi r25,lo8(1)
 4053 06f0 00D0      		rcall gb_flash_write_bus_cycle
 4054               	.LVL398:
 572:main.c        **** 			_delay_us(5);
 4055               		.loc 3 572 0
 4056 06f2 65EA      		ldi r22,lo8(-91)
 4057 06f4 8FE3      		ldi r24,lo8(63)
 4058 06f6 91E0      		ldi r25,lo8(1)
 4059 06f8 00D0      		rcall gb_flash_write_bus_cycle
 4060               	.LVL399:
 4061               	.LBB244:
 4062               	.LBB245:
 4063               		.loc 2 276 0
 4064 06fa 2DE0      		ldi r18,lo8(13)
 4065 06fc 2A95      	1:	dec r18
 4066 06fe 01F4      		brne 1b
 4067 0700 0000      		nop
 4068               	.LVL400:
 4069               	.LBE245:
 4070               	.LBE244:
 576:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4071               		.loc 3 576 0
 4072 0702 68E0      		ldi r22,lo8(8)
 4073 0704 80E2      		ldi r24,lo8(32)
 4074 0706 91E0      		ldi r25,lo8(1)
 4075 0708 00D0      		rcall gb_flash_write_bus_cycle
 4076               	.LVL401:
 577:main.c        **** 			_delay_us(5);
 4077               		.loc 3 577 0
 4078 070a 65EA      		ldi r22,lo8(-91)
 4079 070c 8FE3      		ldi r24,lo8(63)
 4080 070e 91E0      		ldi r25,lo8(1)
 4081 0710 00D0      		rcall gb_flash_write_bus_cycle
 4082               	.LVL402:
 4083               	.LBB246:
 4084               	.LBB247:
 4085               		.loc 2 276 0
 4086 0712 8DE0      		ldi r24,lo8(13)
 4087 0714 8A95      	1:	dec r24
 4088 0716 01F4      		brne 1b
 4089 0718 0000      		nop
 4090               	.LVL403:
 4091 071a 00E0      		ldi r16,lo8(receivedBuffer)
 4092 071c 10E0      		ldi r17,hi8(receivedBuffer)
 4093               	.L166:
 4094               	.LBE247:
 4095               	.LBE246:
 4096               	.LBB248:
 582:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4097               		.loc 3 582 0 discriminator 1
 4098 071e 80E0      		ldi r24,lo8(receivedBuffer+128)
 4099 0720 90E0      		ldi r25,hi8(receivedBuffer+128)
 4100 0722 8017      		cp r24,r16
 4101 0724 9107      		cpc r25,r17
 4102 0726 01F0      		breq .L290
 583:main.c        **** 				_delay_us(5);
 4103               		.loc 3 583 0 discriminator 3
 4104 0728 F801      		movw r30,r16
 4105 072a 6191      		ld r22,Z+
 4106 072c 8F01      		movw r16,r30
 4107 072e C601      		movw r24,r12
 4108 0730 00D0      		rcall gb_flash_write_bus_cycle
 4109               	.LVL404:
 4110               	.LBB249:
 4111               	.LBB250:
 4112               		.loc 2 276 0 discriminator 3
 4113 0732 FDE0      		ldi r31,lo8(13)
 4114 0734 FA95      	1:	dec r31
 4115 0736 01F4      		brne 1b
 4116 0738 0000      		nop
 4117               	.LVL405:
 4118               	.LBE250:
 4119               	.LBE249:
 585:main.c        **** 			}
 4120               		.loc 3 585 0 discriminator 3
 4121 073a 2FEF      		ldi r18,-1
 4122 073c C21A      		sub r12,r18
 4123 073e D20A      		sbc r13,r18
 4124 0740 E20A      		sbc r14,r18
 4125 0742 F20A      		sbc r15,r18
 4126               	.LVL406:
 4127 0744 00C0      		rjmp .L166
 4128               	.L290:
 4129               	.LVL407:
 4130               	.LBE248:
 590:main.c        **** 			address++;
 4131               		.loc 3 590 0
 4132 0746 6FEF      		ldi r22,lo8(-1)
 4133 0748 D701      		movw r26,r14
 4134 074a C601      		movw r24,r12
 4135 074c 0197      		sbiw r24,1
 4136 074e A109      		sbc r26,__zero_reg__
 4137 0750 B109      		sbc r27,__zero_reg__
 4138               	.LVL408:
 4139 0752 00D0      		rcall gb_flash_write_bus_cycle
 4140               	.LVL409:
 4141               	.LBB251:
 4142               	.LBB252:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4143               		.loc 2 187 0
 4144 0754 EFE1      		ldi r30,lo8(19999)
 4145 0756 FEE4      		ldi r31,hi8(19999)
 4146 0758 3197      	1:	sbiw r30,1
 4147 075a 01F4      		brne 1b
 4148               	.LVL410:
 4149               	.L289:
 4150 075c 00C0      		rjmp .
 4151 075e 0000      		nop
 4152 0760 00C0      		rjmp .L276
 4153               	.LVL411:
 4154               	.L165:
 4155               	.LBE252:
 4156               	.LBE251:
 601:main.c        **** 			usart_read_chars(); // Read address
 4157               		.loc 3 601 0
 4158 0762 8E36      		cpi r24,lo8(110)
 4159 0764 01F4      		brne .L168
 4160               	.LBB253:
 602:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4161               		.loc 3 602 0
 4162 0766 00D0      		rcall usart_read_chars
 4163               	.LVL412:
 603:main.c        **** 			
 4164               		.loc 3 603 0
 4165 0768 40E1      		ldi r20,lo8(16)
 4166 076a 50E0      		ldi r21,0
 4167 076c 60E0      		ldi r22,0
 4168 076e 70E0      		ldi r23,0
 4169 0770 80E0      		ldi r24,lo8(receivedBuffer)
 4170 0772 90E0      		ldi r25,hi8(receivedBuffer)
 4171 0774 00D0      		rcall strtol
 4172               	.LVL413:
 4173 0776 4B01      		movw r8,r22
 4174 0778 5C01      		movw r10,r24
 4175               	.LVL414:
 605:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4176               		.loc 3 605 0
 4177 077a 00D0      		rcall USART_Receive
 4178               	.LVL415:
 4179 077c 8093 0000 		sts receivedChar,r24
 606:main.c        **** 				usart_read_chars(); // Read data
 4180               		.loc 3 606 0
 4181 0780 8E36      		cpi r24,lo8(110)
 4182 0782 01F0      		breq .+2
 4183 0784 00C0      		rjmp .L99
 4184               	.LBB254:
 607:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4185               		.loc 3 607 0
 4186 0786 00D0      		rcall usart_read_chars
 4187               	.LVL416:
 608:main.c        **** 				
 4188               		.loc 3 608 0
 4189 0788 40E1      		ldi r20,lo8(16)
 4190 078a 50E0      		ldi r21,0
 4191 078c 60E0      		ldi r22,0
 4192 078e 70E0      		ldi r23,0
 4193 0790 80E0      		ldi r24,lo8(receivedBuffer)
 4194 0792 90E0      		ldi r25,hi8(receivedBuffer)
 4195 0794 00D0      		rcall strtol
 4196               	.LVL417:
 610:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4197               		.loc 3 610 0
 4198 0796 939A      		sbi 0x12,3
 611:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4199               		.loc 3 611 0
 4200 0798 C4BB      		out 0x14,r28
 612:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4201               		.loc 3 612 0
 4202 079a CABB      		out 0x1a,r28
 613:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4203               		.loc 3 613 0
 4204 079c C7BB      		out 0x17,r28
 614:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4205               		.loc 3 614 0
 4206 079e AB01      		movw r20,r22
 4207 07a0 C501      		movw r24,r10
 4208 07a2 B401      		movw r22,r8
 4209               	.LVL418:
 4210 07a4 00D0      		rcall gba_flash_write_bus_cycle
 4211               	.LVL419:
 4212               	.L287:
 615:main.c        **** 				
 4213               		.loc 3 615 0
 4214 07a6 9398      		cbi 0x12,3
 617:main.c        **** 			}
 4215               		.loc 3 617 0
 4216 07a8 81E3      		ldi r24,lo8(49)
 4217 07aa 00C0      		rjmp .L267
 4218               	.LVL420:
 4219               	.L168:
 4220               	.LBE254:
 4221               	.LBE253:
 622:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4222               		.loc 3 622 0
 4223 07ac 8137      		cpi r24,lo8(113)
 4224 07ae 01F0      		breq .L169
 622:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4225               		.loc 3 622 0 is_stmt 0 discriminator 1
 4226 07b0 8437      		cpi r24,lo8(116)
 4227 07b2 01F4      		brne .L170
 4228               	.L169:
 4229               	.LBB255:
 623:main.c        **** 			
 4230               		.loc 3 623 0 is_stmt 1
 4231 07b4 939A      		sbi 0x12,3
 4232               	.LVL421:
 626:main.c        **** 				readLength = 256;
 4233               		.loc 3 626 0
 4234 07b6 8091 0000 		lds r24,receivedChar
 4235 07ba 8437      		cpi r24,lo8(116)
 4236 07bc 01F4      		brne .L221
 627:main.c        **** 			}
 4237               		.loc 3 627 0
 4238 07be 00E0      		ldi r16,0
 4239 07c0 11E0      		ldi r17,lo8(1)
 4240 07c2 00C0      		rjmp .L171
 4241               	.L221:
 625:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4242               		.loc 3 625 0
 4243 07c4 00E4      		ldi r16,lo8(64)
 4244 07c6 10E0      		ldi r17,0
 4245               	.L171:
 4246               	.LVL422:
 629:main.c        **** 			
 4247               		.loc 3 629 0
 4248 07c8 C801      		movw r24,r16
 4249 07ca 00D0      		rcall usart_read_bytes
 4250               	.LVL423:
 4251 07cc 70E0      		ldi r23,lo8(receivedBuffer)
 4252 07ce A72E      		mov r10,r23
 4253 07d0 70E0      		ldi r23,hi8(receivedBuffer)
 4254 07d2 B72E      		mov r11,r23
 4255 07d4 2601      		movw r4,r12
 4256 07d6 3701      		movw r6,r14
 4257               	.LVL424:
 4258               	.L173:
 4259               	.LBB256:
 4260               	.LBB257:
 632:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4261               		.loc 3 632 0
 4262 07d8 F501      		movw r30,r10
 4263 07da 4181      		ldd r20,Z+1
 4264 07dc 50E0      		ldi r21,0
 4265 07de 542F      		mov r21,r20
 4266 07e0 4427      		clr r20
 4267 07e2 8081      		ld r24,Z
 4268 07e4 482B      		or r20,r24
 4269               	.LVL425:
 633:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4270               		.loc 3 633 0
 4271 07e6 4F3F      		cpi r20,-1
 4272 07e8 FFEF      		ldi r31,-1
 4273 07ea 5F07      		cpc r21,r31
 4274 07ec 01F0      		breq .L172
 634:main.c        **** 				}
 4275               		.loc 3 634 0
 4276 07ee 21E0      		ldi r18,lo8(1)
 4277 07f0 C301      		movw r24,r6
 4278 07f2 B201      		movw r22,r4
 4279 07f4 00D0      		rcall gba_flash_write_byte
 4280               	.LVL426:
 4281               	.L172:
 636:main.c        **** 			}
 4282               		.loc 3 636 0 discriminator 2
 4283 07f6 2FEF      		ldi r18,-1
 4284 07f8 421A      		sub r4,r18
 4285 07fa 520A      		sbc r5,r18
 4286 07fc 620A      		sbc r6,r18
 4287 07fe 720A      		sbc r7,r18
 4288               	.LVL427:
 4289 0800 82E0      		ldi r24,2
 4290 0802 A80E      		add r10,r24
 4291 0804 B11C      		adc r11,__zero_reg__
 4292               	.LVL428:
 4293               	.LBE257:
 631:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4294               		.loc 3 631 0 discriminator 2
 4295 0806 C501      		movw r24,r10
 4296 0808 8050      		subi r24,lo8(receivedBuffer)
 4297 080a 9040      		sbci r25,hi8(receivedBuffer)
 4298 080c 8017      		cp r24,r16
 4299 080e 9107      		cpc r25,r17
 4300 0810 04F0      		brlt .L173
 4301 0812 9FEF      		ldi r25,-1
 4302 0814 C91A      		sub r12,r25
 4303 0816 D90A      		sbc r13,r25
 4304 0818 E90A      		sbc r14,r25
 4305 081a F90A      		sbc r15,r25
 4306 081c 0150      		subi r16,1
 4307 081e 1109      		sbc r17,__zero_reg__
 4308               	.LVL429:
 4309 0820 1695      		lsr r17
 4310 0822 0795      		ror r16
 4311               	.LVL430:
 4312 0824 C00E      		add r12,r16
 4313 0826 D11E      		adc r13,r17
 4314 0828 E11C      		adc r14,__zero_reg__
 4315 082a F11C      		adc r15,__zero_reg__
 4316 082c 00C0      		rjmp .L276
 4317               	.LVL431:
 4318               	.L170:
 4319               	.LBE256:
 4320               	.LBE255:
 644:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4321               		.loc 3 644 0
 4322 082e 8636      		cpi r24,lo8(102)
 4323 0830 01F4      		brne .L174
 4324               	.LBB258:
 645:main.c        **** 			
 4325               		.loc 3 645 0
 4326 0832 939A      		sbi 0x12,3
 4327               	.LVL432:
 648:main.c        **** 			
 4328               		.loc 3 648 0
 4329 0834 80E0      		ldi r24,0
 4330 0836 91E0      		ldi r25,lo8(1)
 4331 0838 00D0      		rcall usart_read_bytes
 4332               	.LVL433:
 4333 083a 00E0      		ldi r16,lo8(receivedBuffer)
 4334 083c 10E0      		ldi r17,hi8(receivedBuffer)
 4335 083e 4601      		movw r8,r12
 4336 0840 5701      		movw r10,r14
 4337               	.LVL434:
 4338               	.L176:
 4339               	.LBB259:
 4340               	.LBB260:
 651:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4341               		.loc 3 651 0
 4342 0842 F801      		movw r30,r16
 4343 0844 4181      		ldd r20,Z+1
 4344 0846 50E0      		ldi r21,0
 4345 0848 542F      		mov r21,r20
 4346 084a 4427      		clr r20
 4347 084c 8081      		ld r24,Z
 4348 084e 482B      		or r20,r24
 4349               	.LVL435:
 652:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4350               		.loc 3 652 0
 4351 0850 4F3F      		cpi r20,-1
 4352 0852 FFEF      		ldi r31,-1
 4353 0854 5F07      		cpc r21,r31
 4354 0856 01F0      		breq .L175
 653:main.c        **** 				}
 4355               		.loc 3 653 0
 4356 0858 20E0      		ldi r18,0
 4357 085a C501      		movw r24,r10
 4358 085c B401      		movw r22,r8
 4359 085e 00D0      		rcall gba_flash_write_byte
 4360               	.LVL436:
 4361               	.L175:
 655:main.c        **** 			}
 4362               		.loc 3 655 0 discriminator 2
 4363 0860 2FEF      		ldi r18,-1
 4364 0862 821A      		sub r8,r18
 4365 0864 920A      		sbc r9,r18
 4366 0866 A20A      		sbc r10,r18
 4367 0868 B20A      		sbc r11,r18
 4368               	.LVL437:
 4369 086a 0E5F      		subi r16,-2
 4370 086c 1F4F      		sbci r17,-1
 4371               	.LVL438:
 4372               	.LBE260:
 650:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4373               		.loc 3 650 0 discriminator 2
 4374 086e 80E0      		ldi r24,hi8(receivedBuffer+256)
 4375 0870 0030      		cpi r16,lo8(receivedBuffer+256)
 4376 0872 1807      		cpc r17,r24
 4377 0874 01F4      		brne .L176
 4378 0876 90E8      		ldi r25,-128
 4379 0878 C90E      		add r12,r25
 4380 087a D11C      		adc r13,__zero_reg__
 4381 087c E11C      		adc r14,__zero_reg__
 4382 087e F11C      		adc r15,__zero_reg__
 4383 0880 00C0      		rjmp .L276
 4384               	.LVL439:
 4385               	.L174:
 4386               	.LBE259:
 4387               	.LBE258:
 664:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4388               		.loc 3 664 0
 4389 0882 8C36      		cpi r24,lo8(108)
 4390 0884 01F0      		breq .+2
 4391 0886 00C0      		rjmp .L177
 4392               	.LBB261:
 665:main.c        **** 			usart_read_bytes(64);
 4393               		.loc 3 665 0
 4394 0888 939A      		sbi 0x12,3
 666:main.c        **** 			
 4395               		.loc 3 666 0
 4396 088a 80E4      		ldi r24,lo8(64)
 4397 088c 90E0      		ldi r25,0
 4398 088e 00D0      		rcall usart_read_bytes
 4399               	.LVL440:
 669:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4400               		.loc 3 669 0
 4401 0890 C4BB      		out 0x14,r28
 670:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4402               		.loc 3 670 0
 4403 0892 CABB      		out 0x1a,r28
 671:main.c        **** 			
 4404               		.loc 3 671 0
 4405 0894 C7BB      		out 0x17,r28
 674:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4406               		.loc 3 674 0
 4407 0896 40E6      		ldi r20,lo8(96)
 4408 0898 50E0      		ldi r21,0
 4409 089a C701      		movw r24,r14
 4410 089c B601      		movw r22,r12
 4411 089e 00D0      		rcall gba_flash_write_bus_cycle
 4412               	.LVL441:
 675:main.c        **** 			
 4413               		.loc 3 675 0
 4414 08a0 40ED      		ldi r20,lo8(-48)
 4415 08a2 50E0      		ldi r21,0
 4416 08a4 C701      		movw r24,r14
 4417 08a6 B601      		movw r22,r12
 4418 08a8 00D0      		rcall gba_flash_write_bus_cycle
 4419               	.LVL442:
 678:main.c        **** 			_delay_us(50);
 4420               		.loc 3 678 0
 4421 08aa 48EE      		ldi r20,lo8(-24)
 4422 08ac 50E0      		ldi r21,0
 4423 08ae C701      		movw r24,r14
 4424 08b0 B601      		movw r22,r12
 4425 08b2 00D0      		rcall gba_flash_write_bus_cycle
 4426               	.LVL443:
 4427               	.LBB262:
 4428               	.LBB263:
 4429               		.loc 2 276 0
 4430 08b4 E5E8      		ldi r30,lo8(-123)
 4431 08b6 EA95      	1:	dec r30
 4432 08b8 01F4      		brne 1b
 4433 08ba 0000      		nop
 4434               	.LVL444:
 4435               	.LBE263:
 4436               	.LBE262:
 682:main.c        **** 			while (dataVerify != 0x0080) {
 4437               		.loc 3 682 0
 4438 08bc C701      		movw r24,r14
 4439 08be B601      		movw r22,r12
 4440 08c0 00D0      		rcall gba_read_16bit_data
 4441               	.LVL445:
 4442               	.L178:
 683:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4443               		.loc 3 683 0
 4444 08c2 8038      		cpi r24,-128
 4445 08c4 9105      		cpc r25,__zero_reg__
 4446 08c6 01F0      		breq .L291
 684:main.c        **** 				_delay_us(50);
 4447               		.loc 3 684 0
 4448 08c8 C701      		movw r24,r14
 4449 08ca B601      		movw r22,r12
 4450 08cc 00D0      		rcall gba_read_16bit_data
 4451               	.LVL446:
 4452               	.LBB264:
 4453               	.LBB265:
 4454               		.loc 2 276 0
 4455 08ce F5E8      		ldi r31,lo8(-123)
 4456 08d0 FA95      	1:	dec r31
 4457 08d2 01F4      		brne 1b
 4458 08d4 0000      		nop
 4459 08d6 00C0      		rjmp .L178
 4460               	.LVL447:
 4461               	.L291:
 4462               	.LBE265:
 4463               	.LBE264:
 690:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4464               		.loc 3 690 0
 4465 08d8 C4BB      		out 0x14,r28
 691:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4466               		.loc 3 691 0
 4467 08da CABB      		out 0x1a,r28
 692:main.c        **** 			
 4468               		.loc 3 692 0
 4469 08dc C7BB      		out 0x17,r28
 695:main.c        **** 			
 4470               		.loc 3 695 0
 4471 08de 4FE1      		ldi r20,lo8(31)
 4472 08e0 50E0      		ldi r21,0
 4473 08e2 C701      		movw r24,r14
 4474 08e4 B601      		movw r22,r12
 4475 08e6 00D0      		rcall gba_flash_write_bus_cycle
 4476               	.LVL448:
 4477 08e8 00E0      		ldi r16,lo8(receivedBuffer)
 4478 08ea 10E0      		ldi r17,hi8(receivedBuffer)
 4479 08ec 4601      		movw r8,r12
 4480 08ee 5701      		movw r10,r14
 4481               	.LVL449:
 4482               	.L180:
 4483               	.LBB266:
 4484               	.LBB267:
 700:main.c        **** 				address++;
 4485               		.loc 3 700 0 discriminator 3
 4486 08f0 F801      		movw r30,r16
 4487 08f2 4181      		ldd r20,Z+1
 4488 08f4 50E0      		ldi r21,0
 4489 08f6 542F      		mov r21,r20
 4490 08f8 4427      		clr r20
 4491 08fa 8081      		ld r24,Z
 4492 08fc 482B      		or r20,r24
 4493 08fe C501      		movw r24,r10
 4494 0900 B401      		movw r22,r8
 4495 0902 00D0      		rcall gba_flash_write_bus_cycle
 4496               	.LVL450:
 701:main.c        **** 			}
 4497               		.loc 3 701 0 discriminator 3
 4498 0904 FFEF      		ldi r31,-1
 4499 0906 8F1A      		sub r8,r31
 4500 0908 9F0A      		sbc r9,r31
 4501 090a AF0A      		sbc r10,r31
 4502 090c BF0A      		sbc r11,r31
 4503               	.LVL451:
 4504 090e 0E5F      		subi r16,-2
 4505 0910 1F4F      		sbci r17,-1
 4506               	.LVL452:
 4507               	.LBE267:
 698:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4508               		.loc 3 698 0 discriminator 3
 4509 0912 20E0      		ldi r18,hi8(receivedBuffer+64)
 4510 0914 0030      		cpi r16,lo8(receivedBuffer+64)
 4511 0916 1207      		cpc r17,r18
 4512 0918 01F4      		brne .L180
 4513 091a 80E2      		ldi r24,32
 4514 091c C80E      		add r12,r24
 4515 091e D11C      		adc r13,__zero_reg__
 4516 0920 E11C      		adc r14,__zero_reg__
 4517 0922 F11C      		adc r15,__zero_reg__
 4518               	.LBE266:
 705:main.c        **** 			_delay_us(440);
 4519               		.loc 3 705 0
 4520 0924 40ED      		ldi r20,lo8(-48)
 4521 0926 50E0      		ldi r21,0
 4522 0928 C701      		movw r24,r14
 4523 092a B601      		movw r22,r12
 4524 092c 00D0      		rcall gba_flash_write_bus_cycle
 4525               	.LVL453:
 4526               	.LBB268:
 4527               	.LBB269:
 4528               		.loc 2 276 0
 4529 092e EFE6      		ldi r30,lo8(879)
 4530 0930 F3E0      		ldi r31,hi8(879)
 4531 0932 3197      	1:	sbiw r30,1
 4532 0934 01F4      		brne 1b
 4533 0936 00C0      		rjmp .
 4534 0938 0000      		nop
 4535               	.LVL454:
 4536               	.LBE269:
 4537               	.LBE268:
 709:main.c        **** 			while (dataVerify != 0x0080) {
 4538               		.loc 3 709 0
 4539 093a C701      		movw r24,r14
 4540 093c B601      		movw r22,r12
 4541 093e 00D0      		rcall gba_read_16bit_data
 4542               	.LVL455:
 4543               	.L181:
 710:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4544               		.loc 3 710 0
 4545 0940 8038      		cpi r24,-128
 4546 0942 9105      		cpc r25,__zero_reg__
 4547 0944 01F0      		breq .L292
 711:main.c        **** 				_delay_us(50);
 4548               		.loc 3 711 0
 4549 0946 C701      		movw r24,r14
 4550 0948 B601      		movw r22,r12
 4551 094a 00D0      		rcall gba_read_16bit_data
 4552               	.LVL456:
 4553               	.LBB270:
 4554               	.LBB271:
 4555               		.loc 2 276 0
 4556 094c F5E8      		ldi r31,lo8(-123)
 4557 094e FA95      	1:	dec r31
 4558 0950 01F4      		brne 1b
 4559 0952 0000      		nop
 4560 0954 00C0      		rjmp .L181
 4561               	.LVL457:
 4562               	.L292:
 4563               	.LBE271:
 4564               	.LBE270:
 717:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4565               		.loc 3 717 0
 4566 0956 C4BB      		out 0x14,r28
 718:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4567               		.loc 3 718 0
 4568 0958 CABB      		out 0x1a,r28
 719:main.c        **** 			
 4569               		.loc 3 719 0
 4570 095a C7BB      		out 0x17,r28
 722:main.c        **** 			
 4571               		.loc 3 722 0
 4572 095c 4FEF      		ldi r20,lo8(-1)
 4573 095e 50E0      		ldi r21,0
 4574 0960 C701      		movw r24,r14
 4575 0962 B601      		movw r22,r12
 4576 0964 00D0      		rcall gba_flash_write_bus_cycle
 4577               	.LVL458:
 4578 0966 00C0      		rjmp .L276
 4579               	.LVL459:
 4580               	.L177:
 4581               	.LBE261:
 729:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4582               		.loc 3 729 0
 4583 0968 8537      		cpi r24,lo8(117)
 4584 096a 01F4      		brne .L183
 730:main.c        **** 			usart_read_bytes(64);
 4585               		.loc 3 730 0
 4586 096c 939A      		sbi 0x12,3
 731:main.c        **** 			
 4587               		.loc 3 731 0
 4588 096e 80E4      		ldi r24,lo8(64)
 4589 0970 90E0      		ldi r25,0
 4590 0972 00D0      		rcall usart_read_bytes
 4591               	.LVL460:
 4592 0974 90E0      		ldi r25,lo8(receivedBuffer)
 4593 0976 A92E      		mov r10,r25
 4594 0978 90E0      		ldi r25,hi8(receivedBuffer)
 4595 097a B92E      		mov r11,r25
 4596 097c 2601      		movw r4,r12
 4597 097e 3701      		movw r6,r14
 4598               	.LVL461:
 4599               	.L186:
 4600               	.LBB272:
 4601               	.LBB193:
 4602               		.loc 3 736 0
 4603 0980 C4BB      		out 0x14,r28
 737:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4604               		.loc 3 737 0
 4605 0982 CABB      		out 0x1a,r28
 738:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4606               		.loc 3 738 0
 4607 0984 C7BB      		out 0x17,r28
 739:main.c        **** 				
 740:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4608               		.loc 3 740 0
 4609 0986 F501      		movw r30,r10
 4610 0988 0181      		ldd r16,Z+1
 4611 098a 10E0      		ldi r17,0
 4612 098c 102F      		mov r17,r16
 4613 098e 0027      		clr r16
 4614 0990 8081      		ld r24,Z
 4615 0992 082B      		or r16,r24
 4616               	.LVL462:
 741:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4617               		.loc 3 741 0
 4618 0994 40E4      		ldi r20,lo8(64)
 4619 0996 50E0      		ldi r21,0
 4620 0998 C301      		movw r24,r6
 4621 099a B201      		movw r22,r4
 4622 099c 00D0      		rcall gba_flash_write_bus_cycle
 4623               	.LVL463:
 742:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4624               		.loc 3 742 0
 4625 099e A801      		movw r20,r16
 4626 09a0 C301      		movw r24,r6
 4627 09a2 B201      		movw r22,r4
 4628 09a4 00D0      		rcall gba_flash_write_bus_cycle
 4629               	.LVL464:
 743:main.c        **** 				
 744:main.c        **** 				// Verify status ok
 745:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4630               		.loc 3 745 0
 4631 09a6 C301      		movw r24,r6
 4632 09a8 B201      		movw r22,r4
 4633 09aa 00D0      		rcall gba_read_16bit_data
 4634               	.LVL465:
 4635               	.L184:
 746:main.c        **** 				while ((status & 0x80) == 0) {
 4636               		.loc 3 746 0
 4637 09ac 87FD      		sbrc r24,7
 4638 09ae 00C0      		rjmp .L293
 747:main.c        **** 					status = gba_read_16bit_data(address);
 4639               		.loc 3 747 0
 4640 09b0 C301      		movw r24,r6
 4641 09b2 B201      		movw r22,r4
 4642 09b4 00D0      		rcall gba_read_16bit_data
 4643               	.LVL466:
 4644               	.LBB191:
 4645               	.LBB192:
 4646               		.loc 2 276 0
 4647 09b6 F5E0      		ldi r31,lo8(5)
 4648 09b8 FA95      	1:	dec r31
 4649 09ba 01F4      		brne 1b
 4650 09bc 0000      		nop
 4651 09be 00C0      		rjmp .L184
 4652               	.LVL467:
 4653               	.L293:
 4654               	.LBE192:
 4655               	.LBE191:
 748:main.c        **** 					_delay_us(2);
 749:main.c        **** 				}
 750:main.c        **** 				address++;
 4656               		.loc 3 750 0 discriminator 2
 4657 09c0 2FEF      		ldi r18,-1
 4658 09c2 421A      		sub r4,r18
 4659 09c4 520A      		sbc r5,r18
 4660 09c6 620A      		sbc r6,r18
 4661 09c8 720A      		sbc r7,r18
 4662               	.LVL468:
 4663 09ca 82E0      		ldi r24,2
 4664 09cc A80E      		add r10,r24
 4665 09ce B11C      		adc r11,__zero_reg__
 4666               	.LVL469:
 4667               	.LBE193:
 734:main.c        **** 				// Set address lines as outputs
 4668               		.loc 3 734 0 discriminator 2
 4669 09d0 90E0      		ldi r25,lo8(receivedBuffer+64)
 4670 09d2 A916      		cp r10,r25
 4671 09d4 90E0      		ldi r25,hi8(receivedBuffer+64)
 4672 09d6 B906      		cpc r11,r25
 4673 09d8 01F4      		brne .L186
 4674 09da E0E2      		ldi r30,32
 4675 09dc CE0E      		add r12,r30
 4676 09de D11C      		adc r13,__zero_reg__
 4677 09e0 E11C      		adc r14,__zero_reg__
 4678 09e2 F11C      		adc r15,__zero_reg__
 4679               	.LVL470:
 4680               	.L276:
 4681               	.LBE272:
 751:main.c        **** 			}
 752:main.c        **** 			
 753:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4682               		.loc 3 753 0
 4683 09e4 81E3      		ldi r24,lo8(49)
 4684 09e6 00C0      		rjmp .L270
 4685               	.LVL471:
 4686               	.L183:
 754:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 755:main.c        **** 		}
 756:main.c        **** 		
 757:main.c        **** 		
 758:main.c        **** 		// ---------- General commands ----------
 759:main.c        **** 		// Set any pin as input/output
 760:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 761:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 4687               		.loc 3 761 0
 4688 09e8 8934      		cpi r24,lo8(73)
 4689 09ea 01F0      		breq .L187
 4690               		.loc 3 761 0 is_stmt 0 discriminator 1
 4691 09ec 8F34      		cpi r24,lo8(79)
 4692 09ee 01F0      		breq .+2
 4693 09f0 00C0      		rjmp .L188
 4694               	.L187:
 4695               	.LBB273:
 762:main.c        **** 			char portChar = USART_Receive();
 4696               		.loc 3 762 0 is_stmt 1
 4697 09f2 00D0      		rcall USART_Receive
 4698               	.LVL472:
 4699 09f4 182F      		mov r17,r24
 4700               	.LVL473:
 763:main.c        **** 			usart_read_chars();
 4701               		.loc 3 763 0
 4702 09f6 00D0      		rcall usart_read_chars
 4703               	.LVL474:
 764:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4704               		.loc 3 764 0
 4705 09f8 40E1      		ldi r20,lo8(16)
 4706 09fa 50E0      		ldi r21,0
 4707 09fc 60E0      		ldi r22,0
 4708 09fe 70E0      		ldi r23,0
 4709 0a00 80E0      		ldi r24,lo8(receivedBuffer)
 4710 0a02 90E0      		ldi r25,hi8(receivedBuffer)
 4711 0a04 00D0      		rcall strtol
 4712               	.LVL475:
 765:main.c        **** 			
 766:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4713               		.loc 3 766 0
 4714 0a06 939A      		sbi 0x12,3
 767:main.c        **** 			if (receivedChar == SET_INPUT) {
 4715               		.loc 3 767 0
 4716 0a08 8091 0000 		lds r24,receivedChar
 4717 0a0c 8934      		cpi r24,lo8(73)
 4718 0a0e 01F4      		brne .L189
 768:main.c        **** 				if (portChar == 'A') {
 4719               		.loc 3 768 0
 4720 0a10 1134      		cpi r17,lo8(65)
 4721 0a12 01F4      		brne .L190
 769:main.c        **** 					DDRA &= ~(setValue);
 4722               		.loc 3 769 0
 4723 0a14 8AB3      		in r24,0x1a
 4724 0a16 6095      		com r22
 4725               	.LVL476:
 4726 0a18 6823      		and r22,r24
 4727               	.LVL477:
 4728 0a1a 00C0      		rjmp .L278
 4729               	.LVL478:
 4730               	.L190:
 770:main.c        **** 				}
 771:main.c        **** 				else if (portChar == 'B') {
 4731               		.loc 3 771 0
 4732 0a1c 1234      		cpi r17,lo8(66)
 4733 0a1e 01F4      		brne .L192
 772:main.c        **** 					DDRB &= ~(setValue);
 4734               		.loc 3 772 0
 4735 0a20 87B3      		in r24,0x17
 4736 0a22 6095      		com r22
 4737               	.LVL479:
 4738 0a24 6823      		and r22,r24
 4739               	.LVL480:
 4740 0a26 00C0      		rjmp .L279
 4741               	.LVL481:
 4742               	.L192:
 773:main.c        **** 				}
 774:main.c        **** 				else if (portChar == 'C') {
 4743               		.loc 3 774 0
 4744 0a28 1334      		cpi r17,lo8(67)
 4745 0a2a 01F4      		brne .L193
 775:main.c        **** 					DDRC &= ~(setValue);
 4746               		.loc 3 775 0
 4747 0a2c 84B3      		in r24,0x14
 4748 0a2e 6095      		com r22
 4749               	.LVL482:
 4750 0a30 6823      		and r22,r24
 4751               	.LVL483:
 4752 0a32 00C0      		rjmp .L284
 4753               	.LVL484:
 4754               	.L193:
 776:main.c        **** 				}
 777:main.c        **** 				else if (portChar == 'D') {
 4755               		.loc 3 777 0
 4756 0a34 1434      		cpi r17,lo8(68)
 4757 0a36 01F4      		brne .L194
 778:main.c        **** 					DDRD &= ~(setValue);
 4758               		.loc 3 778 0
 4759 0a38 81B3      		in r24,0x11
 4760 0a3a 6095      		com r22
 4761               	.LVL485:
 4762 0a3c 6823      		and r22,r24
 4763               	.LVL486:
 4764 0a3e 00C0      		rjmp .L285
 4765               	.LVL487:
 4766               	.L194:
 779:main.c        **** 				}
 780:main.c        **** 				else if (portChar == 'E') {
 4767               		.loc 3 780 0
 4768 0a40 1534      		cpi r17,lo8(69)
 4769 0a42 01F0      		breq .+2
 4770 0a44 00C0      		rjmp .L213
 781:main.c        **** 					DDRE &= ~(setValue);
 4771               		.loc 3 781 0
 4772 0a46 86B1      		in r24,0x6
 4773 0a48 6095      		com r22
 4774               	.LVL488:
 4775 0a4a 6823      		and r22,r24
 4776               	.LVL489:
 4777 0a4c 00C0      		rjmp .L286
 4778               	.LVL490:
 4779               	.L189:
 782:main.c        **** 				}
 783:main.c        **** 			}
 784:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4780               		.loc 3 784 0
 4781 0a4e 8F34      		cpi r24,lo8(79)
 4782 0a50 01F0      		breq .+2
 4783 0a52 00C0      		rjmp .L213
 785:main.c        **** 				if (portChar == 'A') {
 4784               		.loc 3 785 0
 4785 0a54 1134      		cpi r17,lo8(65)
 4786 0a56 01F4      		brne .L195
 786:main.c        **** 					DDRA |= (setValue);
 4787               		.loc 3 786 0
 4788 0a58 8AB3      		in r24,0x1a
 4789 0a5a 682B      		or r22,r24
 4790               	.LVL491:
 4791               	.L278:
 4792 0a5c 6ABB      		out 0x1a,r22
 4793 0a5e 00C0      		rjmp .L213
 4794               	.LVL492:
 4795               	.L195:
 787:main.c        **** 				}
 788:main.c        **** 				else if (portChar == 'B') {
 4796               		.loc 3 788 0
 4797 0a60 1234      		cpi r17,lo8(66)
 4798 0a62 01F4      		brne .L196
 789:main.c        **** 					DDRB |= (setValue);
 4799               		.loc 3 789 0
 4800 0a64 87B3      		in r24,0x17
 4801 0a66 682B      		or r22,r24
 4802               	.LVL493:
 4803               	.L279:
 4804 0a68 67BB      		out 0x17,r22
 4805 0a6a 00C0      		rjmp .L213
 4806               	.LVL494:
 4807               	.L196:
 790:main.c        **** 				}
 791:main.c        **** 				else if (portChar == 'C') {
 4808               		.loc 3 791 0
 4809 0a6c 1334      		cpi r17,lo8(67)
 4810 0a6e 01F4      		brne .L197
 792:main.c        **** 					DDRC |= (setValue);
 4811               		.loc 3 792 0
 4812 0a70 84B3      		in r24,0x14
 4813 0a72 682B      		or r22,r24
 4814               	.LVL495:
 4815               	.L284:
 4816 0a74 64BB      		out 0x14,r22
 4817 0a76 00C0      		rjmp .L213
 4818               	.LVL496:
 4819               	.L197:
 793:main.c        **** 				}
 794:main.c        **** 				else if (portChar == 'D') {
 4820               		.loc 3 794 0
 4821 0a78 1434      		cpi r17,lo8(68)
 4822 0a7a 01F4      		brne .L198
 795:main.c        **** 					DDRD |= (setValue);
 4823               		.loc 3 795 0
 4824 0a7c 81B3      		in r24,0x11
 4825 0a7e 682B      		or r22,r24
 4826               	.LVL497:
 4827               	.L285:
 4828 0a80 61BB      		out 0x11,r22
 4829 0a82 00C0      		rjmp .L213
 4830               	.LVL498:
 4831               	.L198:
 796:main.c        **** 				}
 797:main.c        **** 				else if (portChar == 'E') {
 4832               		.loc 3 797 0
 4833 0a84 1534      		cpi r17,lo8(69)
 4834 0a86 01F0      		breq .+2
 4835 0a88 00C0      		rjmp .L213
 798:main.c        **** 					DDRE |= (setValue);
 4836               		.loc 3 798 0
 4837 0a8a 86B1      		in r24,0x6
 4838 0a8c 682B      		or r22,r24
 4839               	.LVL499:
 4840               	.L286:
 4841 0a8e 66B9      		out 0x6,r22
 4842 0a90 00C0      		rjmp .L213
 4843               	.LVL500:
 4844               	.L188:
 4845               	.LBE273:
 799:main.c        **** 				}
 800:main.c        **** 			}
 801:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 802:main.c        **** 		}
 803:main.c        **** 		
 804:main.c        **** 		// Set pin output as low
 805:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4846               		.loc 3 805 0
 4847 0a92 8C34      		cpi r24,lo8(76)
 4848 0a94 01F4      		brne .L199
 4849               	.LBB274:
 806:main.c        **** 			char portChar = USART_Receive();			
 4850               		.loc 3 806 0
 4851 0a96 00D0      		rcall USART_Receive
 4852               	.LVL501:
 4853 0a98 182F      		mov r17,r24
 4854               	.LVL502:
 807:main.c        **** 			usart_read_chars();
 4855               		.loc 3 807 0
 4856 0a9a 00D0      		rcall usart_read_chars
 4857               	.LVL503:
 808:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4858               		.loc 3 808 0
 4859 0a9c 40E1      		ldi r20,lo8(16)
 4860 0a9e 50E0      		ldi r21,0
 4861 0aa0 60E0      		ldi r22,0
 4862 0aa2 70E0      		ldi r23,0
 4863 0aa4 80E0      		ldi r24,lo8(receivedBuffer)
 4864 0aa6 90E0      		ldi r25,hi8(receivedBuffer)
 4865 0aa8 00D0      		rcall strtol
 4866               	.LVL504:
 809:main.c        **** 			
 810:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4867               		.loc 3 810 0
 4868 0aaa 939A      		sbi 0x12,3
 811:main.c        **** 			if (portChar == 'A') {
 4869               		.loc 3 811 0
 4870 0aac 1134      		cpi r17,lo8(65)
 4871 0aae 01F4      		brne .L200
 812:main.c        **** 				PORTA &= ~(setValue);
 4872               		.loc 3 812 0
 4873 0ab0 8BB3      		in r24,0x1b
 4874 0ab2 6095      		com r22
 4875               	.LVL505:
 4876 0ab4 6823      		and r22,r24
 4877               	.LVL506:
 4878 0ab6 00C0      		rjmp .L283
 4879               	.LVL507:
 4880               	.L200:
 813:main.c        **** 			}
 814:main.c        **** 			else if (portChar == 'B') {
 4881               		.loc 3 814 0
 4882 0ab8 1234      		cpi r17,lo8(66)
 4883 0aba 01F4      		brne .L202
 815:main.c        **** 				PORTB &= ~(setValue);
 4884               		.loc 3 815 0
 4885 0abc 88B3      		in r24,0x18
 4886 0abe 6095      		com r22
 4887               	.LVL508:
 4888 0ac0 6823      		and r22,r24
 4889               	.LVL509:
 4890 0ac2 00C0      		rjmp .L282
 4891               	.LVL510:
 4892               	.L202:
 816:main.c        **** 			}
 817:main.c        **** 			else if (portChar == 'C') {
 4893               		.loc 3 817 0
 4894 0ac4 1334      		cpi r17,lo8(67)
 4895 0ac6 01F4      		brne .L203
 818:main.c        **** 				PORTC &= ~(setValue);
 4896               		.loc 3 818 0
 4897 0ac8 85B3      		in r24,0x15
 4898 0aca 6095      		com r22
 4899               	.LVL511:
 4900 0acc 6823      		and r22,r24
 4901               	.LVL512:
 4902 0ace 00C0      		rjmp .L281
 4903               	.LVL513:
 4904               	.L203:
 819:main.c        **** 			}
 820:main.c        **** 			else if (portChar == 'D') {
 4905               		.loc 3 820 0
 4906 0ad0 1434      		cpi r17,lo8(68)
 4907 0ad2 01F4      		brne .L204
 821:main.c        **** 				PORTD &= ~(setValue);
 4908               		.loc 3 821 0
 4909 0ad4 82B3      		in r24,0x12
 4910 0ad6 6095      		com r22
 4911               	.LVL514:
 4912 0ad8 6823      		and r22,r24
 4913               	.LVL515:
 4914 0ada 00C0      		rjmp .L280
 4915               	.LVL516:
 4916               	.L204:
 822:main.c        **** 			}
 823:main.c        **** 			else if (portChar == 'E') {
 4917               		.loc 3 823 0
 4918 0adc 1534      		cpi r17,lo8(69)
 4919 0ade 01F0      		breq .+2
 4920 0ae0 00C0      		rjmp .L213
 824:main.c        **** 				PORTE &= ~(setValue);
 4921               		.loc 3 824 0
 4922 0ae2 87B1      		in r24,0x7
 4923 0ae4 6095      		com r22
 4924               	.LVL517:
 4925 0ae6 6823      		and r22,r24
 4926               	.LVL518:
 4927 0ae8 00C0      		rjmp .L277
 4928               	.LVL519:
 4929               	.L199:
 4930               	.LBE274:
 825:main.c        **** 			}
 826:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 827:main.c        **** 		}
 828:main.c        **** 		
 829:main.c        **** 		// Set pin output as high
 830:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4931               		.loc 3 830 0
 4932 0aea 8834      		cpi r24,lo8(72)
 4933 0aec 01F4      		brne .L205
 4934               	.LBB275:
 831:main.c        **** 			char portChar = USART_Receive();			
 4935               		.loc 3 831 0
 4936 0aee 00D0      		rcall USART_Receive
 4937               	.LVL520:
 4938 0af0 182F      		mov r17,r24
 4939               	.LVL521:
 832:main.c        **** 			usart_read_chars();
 4940               		.loc 3 832 0
 4941 0af2 00D0      		rcall usart_read_chars
 4942               	.LVL522:
 833:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4943               		.loc 3 833 0
 4944 0af4 40E1      		ldi r20,lo8(16)
 4945 0af6 50E0      		ldi r21,0
 4946 0af8 60E0      		ldi r22,0
 4947 0afa 70E0      		ldi r23,0
 4948 0afc 80E0      		ldi r24,lo8(receivedBuffer)
 4949 0afe 90E0      		ldi r25,hi8(receivedBuffer)
 4950 0b00 00D0      		rcall strtol
 4951               	.LVL523:
 834:main.c        **** 			
 835:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4952               		.loc 3 835 0
 4953 0b02 939A      		sbi 0x12,3
 836:main.c        **** 			if (portChar == 'A') {
 4954               		.loc 3 836 0
 4955 0b04 1134      		cpi r17,lo8(65)
 4956 0b06 01F4      		brne .L206
 837:main.c        **** 				PORTA |= (setValue);
 4957               		.loc 3 837 0
 4958 0b08 8BB3      		in r24,0x1b
 4959 0b0a 682B      		or r22,r24
 4960               	.LVL524:
 4961               	.L283:
 4962 0b0c 6BBB      		out 0x1b,r22
 4963 0b0e 00C0      		rjmp .L213
 4964               	.LVL525:
 4965               	.L206:
 838:main.c        **** 			}
 839:main.c        **** 			else if (portChar == 'B') {
 4966               		.loc 3 839 0
 4967 0b10 1234      		cpi r17,lo8(66)
 4968 0b12 01F4      		brne .L208
 840:main.c        **** 				PORTB |= (setValue);
 4969               		.loc 3 840 0
 4970 0b14 88B3      		in r24,0x18
 4971 0b16 682B      		or r22,r24
 4972               	.LVL526:
 4973               	.L282:
 4974 0b18 68BB      		out 0x18,r22
 4975 0b1a 00C0      		rjmp .L213
 4976               	.LVL527:
 4977               	.L208:
 841:main.c        **** 			}
 842:main.c        **** 			else if (portChar == 'C') {
 4978               		.loc 3 842 0
 4979 0b1c 1334      		cpi r17,lo8(67)
 4980 0b1e 01F4      		brne .L209
 843:main.c        **** 				PORTC |= (setValue);
 4981               		.loc 3 843 0
 4982 0b20 85B3      		in r24,0x15
 4983 0b22 682B      		or r22,r24
 4984               	.LVL528:
 4985               	.L281:
 4986 0b24 65BB      		out 0x15,r22
 4987 0b26 00C0      		rjmp .L213
 4988               	.LVL529:
 4989               	.L209:
 844:main.c        **** 			}
 845:main.c        **** 			else if (portChar == 'D') {
 4990               		.loc 3 845 0
 4991 0b28 1434      		cpi r17,lo8(68)
 4992 0b2a 01F4      		brne .L210
 846:main.c        **** 				PORTD |= (setValue);
 4993               		.loc 3 846 0
 4994 0b2c 82B3      		in r24,0x12
 4995 0b2e 682B      		or r22,r24
 4996               	.LVL530:
 4997               	.L280:
 4998 0b30 62BB      		out 0x12,r22
 4999 0b32 00C0      		rjmp .L213
 5000               	.LVL531:
 5001               	.L210:
 847:main.c        **** 			}
 848:main.c        **** 			else if (portChar == 'E') {
 5002               		.loc 3 848 0
 5003 0b34 1534      		cpi r17,lo8(69)
 5004 0b36 01F4      		brne .L213
 849:main.c        **** 				PORTE |= (setValue);
 5005               		.loc 3 849 0
 5006 0b38 87B1      		in r24,0x7
 5007 0b3a 682B      		or r22,r24
 5008               	.LVL532:
 5009               	.L277:
 5010 0b3c 67B9      		out 0x7,r22
 5011 0b3e 00C0      		rjmp .L213
 5012               	.L205:
 5013               	.LBE275:
 850:main.c        **** 			}
 851:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 852:main.c        **** 		}
 853:main.c        **** 		
 854:main.c        **** 		// Read all pins of a PORT and return the value
 855:main.c        **** 		else if (receivedChar == READ_INPUT) {
 5014               		.loc 3 855 0
 5015 0b40 8434      		cpi r24,lo8(68)
 5016 0b42 01F4      		brne .L211
 5017               	.LBB276:
 856:main.c        **** 			char portChar = USART_Receive();			
 5018               		.loc 3 856 0
 5019 0b44 00D0      		rcall USART_Receive
 5020               	.LVL533:
 857:main.c        **** 			
 858:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5021               		.loc 3 858 0
 5022 0b46 939A      		sbi 0x12,3
 859:main.c        **** 			if (portChar == 'A') {
 5023               		.loc 3 859 0
 5024 0b48 8134      		cpi r24,lo8(65)
 5025 0b4a 01F4      		brne .L212
 860:main.c        **** 				USART_Transmit(PINA);
 5026               		.loc 3 860 0
 5027 0b4c 89B3      		in r24,0x19
 5028               	.LVL534:
 5029 0b4e 00C0      		rjmp .L270
 5030               	.LVL535:
 5031               	.L212:
 861:main.c        **** 			}
 862:main.c        **** 			else if (portChar == 'B') {
 5032               		.loc 3 862 0
 5033 0b50 8234      		cpi r24,lo8(66)
 5034 0b52 01F4      		brne .L214
 863:main.c        **** 				USART_Transmit(PINB);
 5035               		.loc 3 863 0
 5036 0b54 86B3      		in r24,0x16
 5037               	.LVL536:
 5038 0b56 00C0      		rjmp .L270
 5039               	.LVL537:
 5040               	.L214:
 864:main.c        **** 			}
 865:main.c        **** 			else if (portChar == 'C') {
 5041               		.loc 3 865 0
 5042 0b58 8334      		cpi r24,lo8(67)
 5043 0b5a 01F4      		brne .L215
 866:main.c        **** 				USART_Transmit(PINC);
 5044               		.loc 3 866 0
 5045 0b5c 83B3      		in r24,0x13
 5046               	.LVL538:
 5047 0b5e 00C0      		rjmp .L270
 5048               	.LVL539:
 5049               	.L215:
 867:main.c        **** 			}
 868:main.c        **** 			else if (portChar == 'D') {
 5050               		.loc 3 868 0
 5051 0b60 8434      		cpi r24,lo8(68)
 5052 0b62 01F4      		brne .L216
 869:main.c        **** 				USART_Transmit(PIND);
 5053               		.loc 3 869 0
 5054 0b64 80B3      		in r24,0x10
 5055               	.LVL540:
 5056 0b66 00C0      		rjmp .L270
 5057               	.LVL541:
 5058               	.L216:
 870:main.c        **** 			}
 871:main.c        **** 			else if (portChar == 'E') {
 5059               		.loc 3 871 0
 5060 0b68 8534      		cpi r24,lo8(69)
 5061 0b6a 01F4      		brne .L213
 872:main.c        **** 				USART_Transmit(PINE);
 5062               		.loc 3 872 0
 5063 0b6c 85B1      		in r24,0x5
 5064               	.LVL542:
 5065               	.L270:
 5066 0b6e 00D0      		rcall USART_Transmit
 5067               	.LVL543:
 5068               	.L213:
 873:main.c        **** 			}
 874:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 5069               		.loc 3 874 0
 5070 0b70 9398      		cbi 0x12,3
 5071               	.LBE276:
 5072 0b72 00C0      		rjmp .L99
 5073               	.LVL544:
 5074               	.L211:
 875:main.c        **** 		}
 876:main.c        **** 		
 877:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 878:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5075               		.loc 3 878 0
 5076 0b74 8D34      		cpi r24,lo8(77)
 5077 0b76 01F4      		brne .L217
 5078               	.LBB277:
 879:main.c        **** 			char commonChar = USART_Receive();
 5079               		.loc 3 879 0
 5080 0b78 00D0      		rcall USART_Receive
 5081               	.LVL545:
 880:main.c        **** 			if (commonChar == '1') {
 5082               		.loc 3 880 0
 5083 0b7a 8133      		cpi r24,lo8(49)
 5084 0b7c 01F4      		brne .L294
 881:main.c        **** 				resetCommonLines = 1;
 5085               		.loc 3 881 0
 5086 0b7e 2224      		clr r2
 5087 0b80 2394      		inc r2
 5088 0b82 00C0      		rjmp .L266
 5089               	.L294:
 882:main.c        **** 			}
 883:main.c        **** 			else if (commonChar == '0') {
 5090               		.loc 3 883 0
 5091 0b84 8033      		cpi r24,lo8(48)
 5092 0b86 01F0      		breq .+2
 5093 0b88 00C0      		rjmp .L99
 884:main.c        **** 				resetCommonLines = 0;
 5094               		.loc 3 884 0
 5095 0b8a 212C      		mov r2,__zero_reg__
 5096 0b8c 00C0      		rjmp .L100
 5097               	.LVL546:
 5098               	.L217:
 5099               	.LBE277:
 885:main.c        **** 			}
 886:main.c        **** 		}
 887:main.c        **** 		
 888:main.c        **** 		// Send back the PCB version number
 889:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5100               		.loc 3 889 0
 5101 0b8e 8836      		cpi r24,lo8(104)
 5102 0b90 01F4      		brne .L218
 890:main.c        **** 			USART_Transmit(PCB_VERSION);
 5103               		.loc 3 890 0
 5104 0b92 84E0      		ldi r24,lo8(4)
 5105 0b94 00C0      		rjmp .L267
 5106               	.L218:
 891:main.c        **** 		}
 892:main.c        **** 		
 893:main.c        **** 		// Send back the firmware version number
 894:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5107               		.loc 3 894 0
 5108 0b96 8635      		cpi r24,lo8(86)
 5109 0b98 01F4      		brne .L219
 895:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5110               		.loc 3 895 0
 5111 0b9a 81E1      		ldi r24,lo8(17)
 5112               	.LVL547:
 5113               	.L267:
 5114 0b9c 00D0      		rcall USART_Transmit
 5115               	.LVL548:
 5116 0b9e 00C0      		rjmp .L99
 5117               	.LVL549:
 5118               	.L219:
 896:main.c        **** 		}
 897:main.c        **** 		
 898:main.c        **** 		// Reset the AVR if it matches the number
 899:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5119               		.loc 3 899 0
 5120 0ba0 8A32      		cpi r24,lo8(42)
 5121 0ba2 01F0      		breq .+2
 5122 0ba4 00C0      		rjmp .L99
 5123               	.LBB278:
 900:main.c        **** 			usart_read_chars();
 5124               		.loc 3 900 0
 5125 0ba6 00D0      		rcall usart_read_chars
 5126               	.LVL550:
 901:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5127               		.loc 3 901 0
 5128 0ba8 40E1      		ldi r20,lo8(16)
 5129 0baa 50E0      		ldi r21,0
 5130 0bac 60E0      		ldi r22,0
 5131 0bae 70E0      		ldi r23,0
 5132 0bb0 80E0      		ldi r24,lo8(receivedBuffer)
 5133 0bb2 90E0      		ldi r25,hi8(receivedBuffer)
 5134 0bb4 00D0      		rcall strtol
 5135               	.LVL551:
 902:main.c        **** 			if (resetValue == RESET_VALUE) {
 5136               		.loc 3 902 0
 5137 0bb6 613E      		cpi r22,-31
 5138 0bb8 754E      		sbci r23,-27
 5139 0bba 8740      		sbci r24,7
 5140 0bbc 9105      		cpc r25,__zero_reg__
 5141 0bbe 01F0      		breq .+2
 5142 0bc0 00C0      		rjmp .L99
 903:main.c        **** 				// Clear watchdog flag
 904:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5143               		.loc 3 904 0
 5144 0bc2 84B7      		in r24,0x34
 5145 0bc4 877F      		andi r24,lo8(-9)
 5146 0bc6 84BF      		out 0x34,r24
 905:main.c        **** 				
 906:main.c        **** 				// Start timed sequence
 907:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5147               		.loc 3 907 0
 5148 0bc8 28E1      		ldi r18,lo8(24)
 5149 0bca 21BD      		out 0x21,r18
 908:main.c        **** 				
 909:main.c        **** 				// Reset in 250 ms
 910:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5150               		.loc 3 910 0
 5151 0bcc 8CE0      		ldi r24,lo8(12)
 5152 0bce 81BD      		out 0x21,r24
 5153               	.LVL552:
 5154               	.LBB279:
 5155               	.LBB280:
 5156               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5157               		.loc 4 105 0
 5158 0bd0 8FEF      		ldi r24,lo8(-1)
 5159 0bd2 9FEF      		ldi r25,lo8(-1)
 5160               	/* #APP */
 5161               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5162 0bd4 0197      		1: sbiw r24,1
 5163 0bd6 01F4      		brne 1b
 5164               	 ;  0 "" 2
 5165               	.LVL553:
 5166               	/* #NOAPP */
 5167 0bd8 00C0      		rjmp .L99
 5168               	.LBE280:
 5169               	.LBE279:
 5170               	.LBE278:
 5171               		.cfi_endproc
 5172               	.LFE48:
 5174               	.global	cartMode
 5175               		.data
 5178               	cartMode:
 5179 0000 02        		.byte	2
 5180               	.global	lastBankAccessed
 5181               		.section .bss
 5184               	lastBankAccessed:
 5185 0000 00        		.zero	1
 5186               	.global	flashBank1CommandWrites
 5189               	flashBank1CommandWrites:
 5190 0001 00        		.zero	1
 5191               		.comm	flashWriteCycle,12,1
 5192               		.comm	flashWriteWePin,1,1
 5193               		.comm	flashChipIdBuffer,2,1
 5194               		.comm	eepromBuffer,8,1
 5195               		.comm	receivedChar,1,1
 5196               		.comm	receivedBuffer,256,1
 5197               		.text
 5198               	.Letext0:
 5199               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5200               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1467   .text:0000040a gb_flash_read_byte_fast
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1499   .text:00000416 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1578   .text:00000448 gb_flash_write_bus_cycle_fast
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1648   .text:0000046e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1748   .text:000004d2 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:5189   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:5184   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:1873   .text:00000554 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2036   .text:000005e8 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2102   .text:00000618 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2226   .text:00000678 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2348   .text:000006d4 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2456   .text:0000072a setup
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:5178   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccK0G3Y5.s:2552   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
