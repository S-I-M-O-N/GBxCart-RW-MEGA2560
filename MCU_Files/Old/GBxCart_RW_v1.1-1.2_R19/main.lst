   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R19
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 20/08/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define READ_ROM_4000H 'Q'
 109:setup.c       **** #define WRITE_RAM 'W'
 110:setup.c       **** #define SET_BANK 'B'
 111:setup.c       **** #define GB_CART_MODE 'G'
 112:setup.c       **** 
 113:setup.c       **** // GBA commands
 114:setup.c       **** #define GBA_READ_ROM 'r'
 115:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 116:setup.c       **** #define GBA_READ_ROM_8000H 'Z'
 117:setup.c       **** #define GBA_READ_SRAM 'm'
 118:setup.c       **** #define GBA_WRITE_SRAM 'w'
 119:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 120:setup.c       **** #define GBA_CART_MODE 'g'
 121:setup.c       **** 
 122:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 123:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 124:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 125:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 126:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 127:setup.c       **** 
 128:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 129:setup.c       **** #define GBA_READ_EEPROM 'e'
 130:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 131:setup.c       **** 
 132:setup.c       **** // Flash Cart commands
 133:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 134:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 135:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 136:setup.c       **** 
 137:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 141:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 142:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 143:setup.c       **** 
 144:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 145:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 146:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 147:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 148:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 149:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 150:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
 151:setup.c       **** 
 152:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 153:setup.c       **** 
 154:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 155:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 156:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 157:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 158:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 159:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 160:setup.c       **** #define GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE 'v'
 161:setup.c       **** #define GBA_FLASH_WRITE_SHARP_64BYTE 'x'
 162:setup.c       **** #define D0D1_NOT_SWAPPED 0
 163:setup.c       **** #define D0D1_SWAPPED 1
 164:setup.c       **** 
 165:setup.c       **** // General commands
 166:setup.c       **** #define SEND_ACK '1'
 167:setup.c       **** #define CART_MODE 'C'
 168:setup.c       **** #define SET_INPUT 'I'
 169:setup.c       **** #define SET_OUTPUT 'O'
 170:setup.c       **** #define SET_OUTPUT_LOW 'L'
 171:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 172:setup.c       **** #define READ_INPUT 'D'
 173:setup.c       **** #define RESET_COMMON_LINES 'M'
 174:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 175:setup.c       **** #define READ_PCB_VERSION 'h'
 176:setup.c       **** 
 177:setup.c       **** #define RESET_AVR '*'
 178:setup.c       **** #define RESET_VALUE 0x7E5E1
 179:setup.c       **** 
 180:setup.c       **** 
 181:setup.c       **** char receivedBuffer[256];
 182:setup.c       **** char receivedChar;
 183:setup.c       **** uint8_t eepromBuffer[8];
 184:setup.c       **** uint8_t flashChipIdBuffer[2];
 185:setup.c       **** 
 186:setup.c       **** char flashWriteWePin;
 187:setup.c       **** uint16_t flashWriteCycle[3][2];
 188:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 189:setup.c       **** uint8_t lastBankAccessed = 0;
 190:setup.c       **** volatile uint8_t writingTimedout = 0;
 191:setup.c       **** 
 192:setup.c       **** 
 193:setup.c       **** // Receive USART data
 194:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 194 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 195:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 195 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 196:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 196 0
  26 0004 8CB1      		in r24,0xc
 197:setup.c       **** }
  27               		.loc 1 197 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 198:setup.c       **** 
 199:setup.c       **** // Transmit USART data
 200:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 200 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 201:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 201 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 202:setup.c       **** 	UDR = data;
  47               		.loc 1 202 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 203:setup.c       **** }
 204:setup.c       **** 
 205:setup.c       **** // Read 1-256 bytes from the USART 
 206:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 206 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB148:
 207:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 207 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 207 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 208:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 208 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE148:
 209:setup.c       **** 	}
 210:setup.c       **** }
 106               		.loc 1 210 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 211:setup.c       **** 
 212:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 213:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 213 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 214:setup.c       **** 	int x = 0;
 215:setup.c       **** 	while (1) {
 216:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 216 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 217:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 217 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 218:setup.c       **** 			break;
 219:setup.c       **** 		}
 220:setup.c       **** 		x++;
 221:setup.c       **** 	}
 222:setup.c       **** }
 148               		.loc 1 222 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 223:setup.c       **** 
 224:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 225:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 225 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 226:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 226 0
 167 0050 3A9A      		sbi 0x7,2
 227:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 227 0
 169 0052 949A      		sbi 0x12,4
 228:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 228 0
 171 0054 959A      		sbi 0x12,5
 229:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 229 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 230:setup.c       **** }
 231:setup.c       **** 
 232:setup.c       **** 
 233:setup.c       **** 
 234:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 235:setup.c       **** 
 236:setup.c       **** // Set Gameboy mode
 237:setup.c       **** void gb_mode(void) {
 182               		.loc 1 237 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 238:setup.c       **** 	// Set inputs
 239:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 239 0
 189 005a 15BA      		out 0x15,__zero_reg__
 240:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 240 0
 191 005c 14BA      		out 0x14,__zero_reg__
 241:setup.c       **** 	
 242:setup.c       **** 	// Set outputs
 243:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 243 0
 193 005e 18BA      		out 0x18,__zero_reg__
 244:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 244 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 245:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 245 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 246:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 246 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 247:setup.c       **** }
 248:setup.c       **** 
 249:setup.c       **** // Set the 16 bit address on A15-0
 250:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 250 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 251:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 251 0
 217 006a 9BBB      		out 0x1b,r25
 252:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 252 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 253:setup.c       **** }
 254:setup.c       **** 
 255:setup.c       **** // Set the address and read a byte from the 8 bit data line
 256:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 256 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 257:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 257 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 258:setup.c       **** 	
 259:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 259 0
 239 0072 9498      		cbi 0x12,4
 260:setup.c       **** 	rdPin_low;
 240               		.loc 1 260 0
 241 0074 9598      		cbi 0x12,5
 261:setup.c       **** 	
 262:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 262 0
 243               	/* #APP */
 244               	 ;  262 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 263:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 263 0
 248               	 ;  263 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 264:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 264 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 265:setup.c       **** 	
 266:setup.c       **** 	rdPin_high;
 255               		.loc 1 266 0
 256 007c 959A      		sbi 0x12,5
 267:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 267 0
 258 007e 949A      		sbi 0x12,4
 268:setup.c       **** 	
 269:setup.c       **** 	return data;
 270:setup.c       **** }
 259               		.loc 1 270 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 271:setup.c       **** 
 272:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 273:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 273 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 274:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 274 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 275:setup.c       **** 	
 276:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 276 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 277:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 277 0
 292 0090 D5BB      		out 0x15,r29
 278:setup.c       **** 	
 279:setup.c       **** 	// Pulse WR and mREQ if the type matches
 280:setup.c       **** 	wrPin_low;
 293               		.loc 1 280 0
 294 0092 9698      		cbi 0x12,6
 281:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 281 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 282:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 282 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 283:setup.c       **** 	}
 284:setup.c       **** 	
 285:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 285 0
 302               	/* #APP */
 303               	 ;  285 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 286:setup.c       **** 	
 287:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 287 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 288:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 288 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 289:setup.c       **** 	}
 290:setup.c       **** 	wrPin_high;
 313               		.loc 1 290 0
 314 00a2 969A      		sbi 0x12,6
 291:setup.c       **** 	
 292:setup.c       **** 	// Clear data outputs and set data pins as inputs
 293:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 293 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 294:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 294 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 295:setup.c       **** }
 320               		.loc 1 295 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 296:setup.c       **** 
 297:setup.c       **** 
 298:setup.c       **** 
 299:setup.c       **** // ****** Gameboy Advance functions ****** 
 300:setup.c       **** 
 301:setup.c       **** // Set GBA mode
 302:setup.c       **** void gba_mode(void) {
 333               		.loc 1 302 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 303:setup.c       **** 	// Set outputs for reading ROM addresses as default
 304:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 304 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 305:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 305 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 306:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 306 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 307:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 307 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 308:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 308 0
 349 00b8 8ABB      		out 0x1a,r24
 309:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 309 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 310:setup.c       **** }
 311:setup.c       **** 
 312:setup.c       **** // Set the 24 bit address on A23-0
 313:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 313 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 314:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 314 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 315:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 315 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 316:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 316 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 317:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 317 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 318:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 318 0
 385 00cc 2ABB      		out 0x1a,r18
 319:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 319 0
 387 00ce 27BB      		out 0x17,r18
 320:setup.c       **** 	
 321:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 321 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 322:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 322 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 323:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 323 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 324:setup.c       **** }
 402               		.loc 1 324 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 325:setup.c       **** 
 326:setup.c       **** 
 327:setup.c       **** 
 328:setup.c       **** // ---------- ROM/SRAM ----------
 329:setup.c       **** 
 330:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 331:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 331 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 332:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 332 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 333:setup.c       **** 	
 334:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 334 0
 424 00ec 9498      		cbi 0x12,4
 335:setup.c       **** 	
 336:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 336 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 337:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 337 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 338:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 338 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 339:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 339 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 340:setup.c       **** 	
 341:setup.c       **** 	rdPin_low;
 433               		.loc 1 341 0
 434 00f6 9598      		cbi 0x12,5
 342:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 342 0
 436               	/* #APP */
 437               	 ;  342 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 343:setup.c       **** 	
 344:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 344 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 345:setup.c       **** 	
 346:setup.c       **** 	rdPin_high;
 445               		.loc 1 346 0
 446 00fe 959A      		sbi 0x12,5
 347:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 347 0
 448 0100 949A      		sbi 0x12,4
 348:setup.c       **** 	
 349:setup.c       **** 	return data;
 449               		.loc 1 349 0
 450 0102 90E0      		ldi r25,0
 350:setup.c       **** }
 451               		.loc 1 350 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 351:setup.c       **** 
 352:setup.c       **** // Set the address and read a byte from the 8 bit data line
 353:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 353 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 354:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 354 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 355:setup.c       **** 	
 356:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 471               		.loc 1 356 0
 472 010a 3A98      		cbi 0x7,2
 357:setup.c       **** 	rdPin_low;
 473               		.loc 1 357 0
 474 010c 9598      		cbi 0x12,5
 358:setup.c       **** 	
 359:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 359 0
 476               	/* #APP */
 477               	 ;  359 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 360:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 360 0
 481               	 ;  360 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 361:setup.c       **** 	
 362:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 362 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 363:setup.c       **** 	
 364:setup.c       **** 	rdPin_high;
 488               		.loc 1 364 0
 489 0114 959A      		sbi 0x12,5
 365:setup.c       **** 	cs2Pin_high;
 490               		.loc 1 365 0
 491 0116 3A9A      		sbi 0x7,2
 366:setup.c       **** 	
 367:setup.c       **** 	return data;
 368:setup.c       **** }
 492               		.loc 1 368 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 369:setup.c       **** 
 370:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 371:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 371 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 372:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 372 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 373:setup.c       **** 	
 374:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 374 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 375:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 375 0
 520 0124 C5BB      		out 0x15,r28
 376:setup.c       **** 	
 377:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 521               		.loc 1 377 0
 522 0126 3A98      		cbi 0x7,2
 378:setup.c       **** 	wrPin_low; // Pulse WR
 523               		.loc 1 378 0
 524 0128 9698      		cbi 0x12,6
 379:setup.c       **** 	
 380:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 380 0
 526               	/* #APP */
 527               	 ;  380 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 381:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 381 0
 531               	 ;  381 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 382:setup.c       **** 	
 383:setup.c       **** 	wrPin_high;
 534               		.loc 1 383 0
 535               	/* #NOAPP */
 536 012e 969A      		sbi 0x12,6
 384:setup.c       **** 	cs2Pin_high;
 537               		.loc 1 384 0
 538 0130 3A9A      		sbi 0x7,2
 385:setup.c       **** 	
 386:setup.c       **** 	// Clear data outputs and set data pins as inputs
 387:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 387 0
 540 0132 15BA      		out 0x15,__zero_reg__
 388:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 388 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 389:setup.c       **** }
 544               		.loc 1 389 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 390:setup.c       **** 
 391:setup.c       **** 
 392:setup.c       **** 
 393:setup.c       **** // ---------- EEPROM ----------
 394:setup.c       **** 
 395:setup.c       **** // Set address/data all high (includes AD0/A23)
 396:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 396 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 397:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 397 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 398:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 398 0
 565 013e 8ABB      		out 0x1a,r24
 399:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 399 0
 567 0140 84BB      		out 0x14,r24
 400:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 400 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 401:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 401 0
 572 0146 8BBB      		out 0x1b,r24
 402:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 402 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 403:setup.c       **** }
 404:setup.c       **** 
 405:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 406:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 406 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 407:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 407 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 408:setup.c       **** 	
 409:setup.c       **** 	int8_t x = 0;
 410:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 410 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 411:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 411 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 412:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 412 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 413:setup.c       **** 		}
 414:setup.c       **** 		else {
 415:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 416:setup.c       **** 		}
 417:setup.c       **** 		x = 15;
 603               		.loc 1 417 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 418:setup.c       **** 	}
 419:setup.c       **** 	else {
 420:setup.c       **** 		if (command == EEPROM_READ) {
 421:setup.c       **** 			address |= (1<<7) | (1<<6);
 422:setup.c       **** 		}
 423:setup.c       **** 		else {
 424:setup.c       **** 			address |= (1<<7);
 425:setup.c       **** 		}
 426:setup.c       **** 		x = 7;
 427:setup.c       **** 	}
 428:setup.c       **** 	
 429:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 430:setup.c       **** 	while (x >= 0) {
 431:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 431 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 415:setup.c       **** 		}
 613               		.loc 1 415 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 420:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 420 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 421:setup.c       **** 		}
 621               		.loc 1 421 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 424:setup.c       **** 		}
 626               		.loc 1 424 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 426:setup.c       **** 	}
 630               		.loc 1 426 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 432:setup.c       **** 			ad0Pin_high;
 433:setup.c       **** 		}
 434:setup.c       **** 		else {
 435:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 435 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 436:setup.c       **** 		}
 437:setup.c       **** 		
 438:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 438 0
 639 0174 9698      		cbi 0x12,6
 439:setup.c       **** 		asm ("nop");
 640               		.loc 1 439 0
 641               	/* #APP */
 642               	 ;  439 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 440:setup.c       **** 		asm ("nop");
 645               		.loc 1 440 0
 646               	 ;  440 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 441:setup.c       **** 		wrPin_high; 
 649               		.loc 1 441 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 442:setup.c       **** 		asm ("nop");
 652               		.loc 1 442 0
 653               	/* #APP */
 654               	 ;  442 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 443:setup.c       **** 		asm ("nop");
 657               		.loc 1 443 0
 658               	 ;  443 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 430:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 430 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 431:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 431 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 432:setup.c       **** 		}
 682               		.loc 1 432 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 444:setup.c       **** 		
 445:setup.c       **** 		x--;
 446:setup.c       **** 	}
 447:setup.c       **** 	
 448:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 449:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 449 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 450:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 450 0
 690 01a4 C098      		cbi 0x18,0
 451:setup.c       **** 		asm ("nop");
 691               		.loc 1 451 0
 692               	/* #APP */
 693               	 ;  451 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 452:setup.c       **** 		wrPin_low;
 696               		.loc 1 452 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 453:setup.c       **** 		asm ("nop");
 699               		.loc 1 453 0
 700               	/* #APP */
 701               	 ;  453 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 454:setup.c       **** 		asm ("nop");
 704               		.loc 1 454 0
 705               	 ;  454 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 455:setup.c       **** 		
 456:setup.c       **** 		wrPin_high;
 708               		.loc 1 456 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 457:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 457 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 458:setup.c       **** 	}
 459:setup.c       **** }
 460:setup.c       **** 
 461:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 462:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 462 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 463:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 463 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 464:setup.c       **** 	
 465:setup.c       **** 	// Set AD0 pin as input
 466:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 466 0
 734 01b8 C098      		cbi 0x18,0
 467:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 467 0
 736 01ba B898      		cbi 0x17,0
 468:setup.c       **** 	
 469:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 469 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB149:
 470:setup.c       **** 	
 471:setup.c       **** 	// Ignore first 4 bits
 472:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 473:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 473 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 474:setup.c       **** 		asm ("nop");
 746               		.loc 1 474 0 discriminator 3
 747               	/* #APP */
 748               	 ;  474 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 475:setup.c       **** 		asm ("nop");
 751               		.loc 1 475 0 discriminator 3
 752               	 ;  475 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 476:setup.c       **** 		rdPin_high; 
 755               		.loc 1 476 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 477:setup.c       **** 		asm ("nop");
 758               		.loc 1 477 0 discriminator 3
 759               	/* #APP */
 760               	 ;  477 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 478:setup.c       **** 		asm ("nop");
 763               		.loc 1 478 0 discriminator 3
 764               	 ;  478 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 472:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 472 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE149:
 776               	.LBB150:
 777               	.LBB151:
 778               	.LBB152:
 479:setup.c       **** 	}
 480:setup.c       **** 	
 481:setup.c       **** 	// Read out 64 bits
 482:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 483:setup.c       **** 		uint8_t data = 0;
 484:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 485:setup.c       **** 			rdPin_low; // CLK
 486:setup.c       **** 			asm ("nop");
 487:setup.c       **** 			asm ("nop");
 488:setup.c       **** 			rdPin_high;
 489:setup.c       **** 			
 490:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 491:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 491 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE152:
 785               	.LBE151:
 786               	.LBE150:
 469:setup.c       **** 	
 787               		.loc 1 469 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB155:
 794               	.LBB154:
 795               	.LBB153:
 485:setup.c       **** 			asm ("nop");
 796               		.loc 1 485 0
 797 01de 9598      		cbi 0x12,5
 486:setup.c       **** 			asm ("nop");
 798               		.loc 1 486 0
 799               	/* #APP */
 800               	 ;  486 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 487:setup.c       **** 			rdPin_high;
 803               		.loc 1 487 0
 804               	 ;  487 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 488:setup.c       **** 			
 807               		.loc 1 488 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 490:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 490 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 491 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE153:
 492:setup.c       **** 			}
 493:setup.c       **** 		}
 494:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 494 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE154:
 482:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 482 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE155:
 495:setup.c       **** 	}
 496:setup.c       **** 	
 497:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 497 0
 841 0206 949A      		sbi 0x12,4
 498:setup.c       **** 	
 499:setup.c       **** 	// Set AD0 pin as output
 500:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 500 0
 843 0208 C09A      		sbi 0x18,0
 501:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 501 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 502:setup.c       **** }
 503:setup.c       **** 
 504:setup.c       **** // Write 8 bytes to the EEPROM address
 505:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 505 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 506:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 506 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 505:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 505 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB156:
 876               	.LBB157:
 507:setup.c       **** 	
 508:setup.c       **** 	// Write 64 bits
 509:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 510:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 511:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 511 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 512:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 512 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 513:setup.c       **** 			}
 514:setup.c       **** 			else {
 515:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 515 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 516:setup.c       **** 			}
 517:setup.c       **** 			
 518:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 518 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 519:setup.c       **** 			asm ("nop");
 899               		.loc 1 519 0 discriminator 2
 900               	/* #APP */
 901               	 ;  519 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 520:setup.c       **** 			asm ("nop");
 904               		.loc 1 520 0 discriminator 2
 905               	 ;  520 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 521:setup.c       **** 			wrPin_high; 
 908               		.loc 1 521 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 522:setup.c       **** 			asm ("nop");
 911               		.loc 1 522 0 discriminator 2
 912               	/* #APP */
 913               	 ;  522 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 523:setup.c       **** 			asm ("nop");
 916               		.loc 1 523 0 discriminator 2
 917               	 ;  523 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE157:
 509:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 509 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE156:
 524:setup.c       **** 		}
 525:setup.c       **** 	}
 526:setup.c       **** 	
 527:setup.c       **** 	// Last bit low
 528:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 528 0
 935 0250 C098      		cbi 0x18,0
 529:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 529 0
 937 0252 9698      		cbi 0x12,6
 530:setup.c       **** 	asm ("nop");
 938               		.loc 1 530 0
 939               	/* #APP */
 940               	 ;  530 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 531:setup.c       **** 	asm ("nop");
 943               		.loc 1 531 0
 944               	 ;  531 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 532:setup.c       **** 	wrPin_high; 
 947               		.loc 1 532 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 533:setup.c       **** 	asm ("nop");
 950               		.loc 1 533 0
 951               	/* #APP */
 952               	 ;  533 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 534:setup.c       **** 	asm ("nop");
 955               		.loc 1 534 0
 956               	 ;  534 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 535:setup.c       **** 	
 536:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 536 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 537:setup.c       **** }
 538:setup.c       **** 
 539:setup.c       **** 
 540:setup.c       **** 
 541:setup.c       **** // ---------- FLASH ----------
 542:setup.c       **** 
 543:setup.c       **** // Set the address and data for the write byte cycle to the flash
 544:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 544 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 545:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 545 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 546:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 546 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 547:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 547 0
 989 026c C5BB      		out 0x15,r28
 548:setup.c       **** 	
 549:setup.c       **** 	cs2Pin_low;
 990               		.loc 1 549 0
 991 026e 3A98      		cbi 0x7,2
 550:setup.c       **** 	wrPin_low;
 992               		.loc 1 550 0
 993 0270 9698      		cbi 0x12,6
 551:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 551 0
 995               	/* #APP */
 996               	 ;  551 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 552:setup.c       **** 	cs2Pin_high;
 999               		.loc 1 552 0
 1000               	/* #NOAPP */
 1001 0274 3A9A      		sbi 0x7,2
 553:setup.c       **** 	wrPin_high;
 1002               		.loc 1 553 0
 1003 0276 969A      		sbi 0x12,6
 1004               	/* epilogue start */
 554:setup.c       **** }
 1005               		.loc 1 554 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 555:setup.c       **** 
 556:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 557:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 557 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 558:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 558 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 559:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 559 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 560:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 560 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB158:
 1049               	.LBB159:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE159:
 1060               	.LBE158:
 561:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 562:setup.c       **** 	
 563:setup.c       **** 	// Set data as inputs
 564:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 564 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 565:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 565 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 566:setup.c       **** 	
 567:setup.c       **** 	// Read and transmit the 2 bytes
 568:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 568 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 569:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 569 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 570:setup.c       **** 	
 571:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 571 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 572:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 572 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 573:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 573 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB160:
 1098               	.LBB161:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE161:
 1109               	.LBE160:
 574:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 575:setup.c       **** }
 1110               		.loc 1 575 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 576:setup.c       **** 
 577:setup.c       **** // Switch banks on the Flash
 578:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 578 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 579:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 579 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 580:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 580 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 581:setup.c       **** 	
 582:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 582 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 583:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 583 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 584:setup.c       **** }
 1157               		.loc 1 584 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 583:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 583 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 585:setup.c       **** 
 586:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 587:setup.c       **** // Takes 25ms after last command to erase sector
 588:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 588 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 589:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 589 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 590:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 590 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 591:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 591 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 592:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 592 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 593:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 593 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 594:setup.c       **** 	
 595:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 595 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB162:
 1222               	.LBB163:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE163:
 1233               	.LBE162:
 596:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 597:setup.c       **** }
 1234               		.loc 1 597 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 598:setup.c       **** 
 599:setup.c       **** // Write a single byte to the Flash address
 600:setup.c       **** // Takes 20us to program Flash
 601:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 601 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 602:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 602 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 603:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 603 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 604:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 604 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 605:setup.c       **** 	
 606:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 606 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB164:
 1292               	.LBB165:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE165:
 1301               	.LBE164:
 607:setup.c       **** 	_delay_us(20); // Wait byte program time
 608:setup.c       **** }
 1302               		.loc 1 608 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 609:setup.c       **** 
 610:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 611:setup.c       **** // Takes 20ms for write cycle
 612:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 612 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 613:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 613 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 614:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 614 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 615:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 615 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB166:
 616:setup.c       **** 	
 617:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 618:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 619:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 619 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 619 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 618:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 618 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE166:
 1400               	.LBB167:
 1401               	.LBB168:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE168:
 1412               	.LBE167:
 620:setup.c       **** 	}
 621:setup.c       **** 	_delay_ms(20); // Wait sector program time
 622:setup.c       **** }
 1413               		.loc 1 622 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 623:setup.c       **** 
 624:setup.c       **** 
 625:setup.c       **** 
 626:setup.c       **** // ---------- GB FLASH CARTS ----------
 627:setup.c       **** 
 628:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 629:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 629 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 630:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 630 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 631:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 631 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 632:setup.c       **** 	
 633:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 633 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 634:setup.c       **** 	
 635:setup.c       **** 	rdPin_low;
 1443               		.loc 1 635 0
 1444 03fe 9598      		cbi 0x12,5
 636:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 636 0
 1446               	/* #APP */
 1447               	 ;  636 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 637:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 637 0
 1451               	 ;  637 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 638:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 638 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 639:setup.c       **** 	rdPin_high;
 1458               		.loc 1 639 0
 1459 0406 959A      		sbi 0x12,5
 640:setup.c       **** 	
 641:setup.c       **** 	return data;
 642:setup.c       **** }
 1460               		.loc 1 642 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_read_byte_fast
 1467               	gb_flash_read_byte_fast:
 1468               	.LFB37:
 643:setup.c       **** 
 644:setup.c       **** // No setting address or outputs, assuming already set
 645:setup.c       **** uint8_t gb_flash_read_byte_fast(void) {
 1469               		.loc 1 645 0
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 646:setup.c       **** 	rdPin_low;
 1475               		.loc 1 646 0
 1476 040a 9598      		cbi 0x12,5
 647:setup.c       **** 	asm volatile("nop"); // Delay a little
 1477               		.loc 1 647 0
 1478               	/* #APP */
 1479               	 ;  647 "setup.c" 1
 1480 040c 0000      		nop
 1481               	 ;  0 "" 2
 648:setup.c       **** 	asm volatile("nop");
 1482               		.loc 1 648 0
 1483               	 ;  648 "setup.c" 1
 1484 040e 0000      		nop
 1485               	 ;  0 "" 2
 649:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1486               		.loc 1 649 0
 1487               	/* #NOAPP */
 1488 0410 83B3      		in r24,0x13
 1489               	.LVL116:
 650:setup.c       **** 	rdPin_high;
 1490               		.loc 1 650 0
 1491 0412 959A      		sbi 0x12,5
 651:setup.c       **** 	
 652:setup.c       **** 	return data;
 653:setup.c       **** }
 1492               		.loc 1 653 0
 1493 0414 0895      		ret
 1494               		.cfi_endproc
 1495               	.LFE37:
 1497               	.global	gb_flash_write_bus_cycle
 1499               	gb_flash_write_bus_cycle:
 1500               	.LFB38:
 654:setup.c       **** 
 655:setup.c       **** // Set the address and data for the write byte cycle to the flash
 656:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1501               		.loc 1 656 0
 1502               		.cfi_startproc
 1503               	.LVL117:
 1504 0416 CF93      		push r28
 1505               	.LCFI25:
 1506               		.cfi_def_cfa_offset 3
 1507               		.cfi_offset 28, -2
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 1 */
 1511               	.L__stack_usage = 1
 1512 0418 C62F      		mov r28,r22
 657:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1513               		.loc 1 657 0
 1514 041a 2FEF      		ldi r18,lo8(-1)
 1515 041c 24BB      		out 0x14,r18
 658:setup.c       **** 	set_16bit_address(address);
 1516               		.loc 1 658 0
 1517 041e 00D0      		rcall set_16bit_address
 1518               	.LVL118:
 659:setup.c       **** 	PORT_DATA7_0 = data;
 1519               		.loc 1 659 0
 1520 0420 C5BB      		out 0x15,r28
 660:setup.c       **** 	
 661:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1521               		.loc 1 661 0
 1522 0422 8091 0000 		lds r24,flashWriteWePin
 1523 0426 8134      		cpi r24,lo8(65)
 1524 0428 01F4      		brne .L71
 662:setup.c       **** 		audioPin_low; // WE low
 1525               		.loc 1 662 0
 1526 042a 3998      		cbi 0x7,1
 663:setup.c       **** 		asm volatile("nop");
 1527               		.loc 1 663 0
 1528               	/* #APP */
 1529               	 ;  663 "setup.c" 1
 1530 042c 0000      		nop
 1531               	 ;  0 "" 2
 664:setup.c       **** 		asm volatile("nop");
 1532               		.loc 1 664 0
 1533               	 ;  664 "setup.c" 1
 1534 042e 0000      		nop
 1535               	 ;  0 "" 2
 665:setup.c       **** 		asm volatile("nop");
 1536               		.loc 1 665 0
 1537               	 ;  665 "setup.c" 1
 1538 0430 0000      		nop
 1539               	 ;  0 "" 2
 666:setup.c       **** 		audioPin_high; // WE high
 1540               		.loc 1 666 0
 1541               	/* #NOAPP */
 1542 0432 399A      		sbi 0x7,1
 1543 0434 00C0      		rjmp .L72
 1544               	.L71:
 667:setup.c       **** 	}
 668:setup.c       **** 	else { // WR pin
 669:setup.c       **** 		wrPin_low; // WE low
 1545               		.loc 1 669 0
 1546 0436 9698      		cbi 0x12,6
 670:setup.c       **** 		asm volatile("nop");
 1547               		.loc 1 670 0
 1548               	/* #APP */
 1549               	 ;  670 "setup.c" 1
 1550 0438 0000      		nop
 1551               	 ;  0 "" 2
 671:setup.c       **** 		asm volatile("nop");
 1552               		.loc 1 671 0
 1553               	 ;  671 "setup.c" 1
 1554 043a 0000      		nop
 1555               	 ;  0 "" 2
 672:setup.c       **** 		asm volatile("nop");
 1556               		.loc 1 672 0
 1557               	 ;  672 "setup.c" 1
 1558 043c 0000      		nop
 1559               	 ;  0 "" 2
 673:setup.c       **** 		wrPin_high; // WE high
 1560               		.loc 1 673 0
 1561               	/* #NOAPP */
 1562 043e 969A      		sbi 0x12,6
 1563               	.L72:
 674:setup.c       **** 	}
 675:setup.c       **** 	
 676:setup.c       **** 	// Clear data outputs and set data pins as inputs
 677:setup.c       **** 	PORT_DATA7_0 = 0;
 1564               		.loc 1 677 0
 1565 0440 15BA      		out 0x15,__zero_reg__
 678:setup.c       **** 	DDR_DATA7_0 = 0;
 1566               		.loc 1 678 0
 1567 0442 14BA      		out 0x14,__zero_reg__
 1568               	/* epilogue start */
 679:setup.c       **** }
 1569               		.loc 1 679 0
 1570 0444 CF91      		pop r28
 1571               	.LVL119:
 1572 0446 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE38:
 1576               	.global	gb_flash_write_bus_cycle_fast
 1578               	gb_flash_write_bus_cycle_fast:
 1579               	.LFB39:
 680:setup.c       **** 
 681:setup.c       **** void gb_flash_write_bus_cycle_fast(uint16_t address, uint8_t data) {
 1580               		.loc 1 681 0
 1581               		.cfi_startproc
 1582               	.LVL120:
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1585               	/* stack size = 0 */
 1586               	.L__stack_usage = 0
 682:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 1587               		.loc 1 682 0
 1588 0448 9BBB      		out 0x1b,r25
 683:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1589               		.loc 1 683 0
 1590 044a 88BB      		out 0x18,r24
 684:setup.c       **** 	PORT_DATA7_0 = data;
 1591               		.loc 1 684 0
 1592 044c 65BB      		out 0x15,r22
 685:setup.c       **** 	
 686:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1593               		.loc 1 686 0
 1594 044e 8091 0000 		lds r24,flashWriteWePin
 1595               	.LVL121:
 1596 0452 8134      		cpi r24,lo8(65)
 1597 0454 01F4      		brne .L74
 1598               	.LVL122:
 1599               	.LBB171:
 1600               	.LBB172:
 687:setup.c       **** 		audioPin_low; // WE low
 1601               		.loc 1 687 0
 1602 0456 3998      		cbi 0x7,1
 688:setup.c       **** 		asm volatile("nop");
 1603               		.loc 1 688 0
 1604               	/* #APP */
 1605               	 ;  688 "setup.c" 1
 1606 0458 0000      		nop
 1607               	 ;  0 "" 2
 689:setup.c       **** 		asm volatile("nop");
 1608               		.loc 1 689 0
 1609               	 ;  689 "setup.c" 1
 1610 045a 0000      		nop
 1611               	 ;  0 "" 2
 690:setup.c       **** 		asm volatile("nop");
 1612               		.loc 1 690 0
 1613               	 ;  690 "setup.c" 1
 1614 045c 0000      		nop
 1615               	 ;  0 "" 2
 691:setup.c       **** 		audioPin_high; // WE high
 1616               		.loc 1 691 0
 1617               	/* #NOAPP */
 1618 045e 399A      		sbi 0x7,1
 1619 0460 0895      		ret
 1620               	.LVL123:
 1621               	.L74:
 1622               	.LBE172:
 1623               	.LBE171:
 692:setup.c       **** 	}
 693:setup.c       **** 	else { // WR pin
 694:setup.c       **** 		wrPin_low; // WE low
 1624               		.loc 1 694 0
 1625 0462 9698      		cbi 0x12,6
 695:setup.c       **** 		asm volatile("nop");
 1626               		.loc 1 695 0
 1627               	/* #APP */
 1628               	 ;  695 "setup.c" 1
 1629 0464 0000      		nop
 1630               	 ;  0 "" 2
 696:setup.c       **** 		asm volatile("nop");
 1631               		.loc 1 696 0
 1632               	 ;  696 "setup.c" 1
 1633 0466 0000      		nop
 1634               	 ;  0 "" 2
 697:setup.c       **** 		asm volatile("nop");
 1635               		.loc 1 697 0
 1636               	 ;  697 "setup.c" 1
 1637 0468 0000      		nop
 1638               	 ;  0 "" 2
 698:setup.c       **** 		wrPin_high; // WE high
 1639               		.loc 1 698 0
 1640               	/* #NOAPP */
 1641 046a 969A      		sbi 0x12,6
 1642 046c 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE39:
 1646               	.global	gb_flash_write_byte
 1648               	gb_flash_write_byte:
 1649               	.LFB40:
 699:setup.c       **** 	}
 700:setup.c       **** }
 701:setup.c       **** 
 702:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 703:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1650               		.loc 1 703 0
 1651               		.cfi_startproc
 1652               	.LVL124:
 1653 046e 0F93      		push r16
 1654               	.LCFI26:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 0470 1F93      		push r17
 1658               	.LCFI27:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661 0472 CF93      		push r28
 1662               	.LCFI28:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 28, -4
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 3 */
 1668               	.L__stack_usage = 3
 1669 0474 8C01      		movw r16,r24
 1670 0476 C62F      		mov r28,r22
 704:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1671               		.loc 1 704 0
 1672 0478 8FEF      		ldi r24,lo8(-1)
 1673               	.LVL125:
 1674 047a 84BB      		out 0x14,r24
 705:setup.c       **** 	
 706:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1675               		.loc 1 706 0
 1676 047c 6091 0000 		lds r22,flashWriteCycle+2
 1677               	.LVL126:
 1678 0480 8091 0000 		lds r24,flashWriteCycle
 1679 0484 9091 0000 		lds r25,flashWriteCycle+1
 1680 0488 00D0      		rcall gb_flash_write_bus_cycle_fast
 1681               	.LVL127:
 707:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1682               		.loc 1 707 0
 1683 048a 6091 0000 		lds r22,flashWriteCycle+6
 1684 048e 8091 0000 		lds r24,flashWriteCycle+4
 1685 0492 9091 0000 		lds r25,flashWriteCycle+4+1
 1686 0496 00D0      		rcall gb_flash_write_bus_cycle_fast
 1687               	.LVL128:
 708:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1688               		.loc 1 708 0
 1689 0498 6091 0000 		lds r22,flashWriteCycle+10
 1690 049c 8091 0000 		lds r24,flashWriteCycle+8
 1691 04a0 9091 0000 		lds r25,flashWriteCycle+8+1
 1692 04a4 00D0      		rcall gb_flash_write_bus_cycle_fast
 1693               	.LVL129:
 709:setup.c       **** 	gb_flash_write_bus_cycle_fast(address, data);
 1694               		.loc 1 709 0
 1695 04a6 6C2F      		mov r22,r28
 1696 04a8 C801      		movw r24,r16
 1697 04aa 00D0      		rcall gb_flash_write_bus_cycle_fast
 1698               	.LVL130:
 1699               	.LBB173:
 1700               	.LBB174:
 1701               		.loc 2 276 0
 1702 04ac 8DE0      		ldi r24,lo8(13)
 1703 04ae 8A95      	1:	dec r24
 1704 04b0 01F4      		brne 1b
 1705 04b2 0000      		nop
 1706               	.LVL131:
 1707               	.LBE174:
 1708               	.LBE173:
 710:setup.c       **** 	_delay_us(5); // Wait byte program time
 711:setup.c       **** 	
 712:setup.c       **** 	// Set data pins inputs
 713:setup.c       **** 	PORT_DATA7_0 = 0;
 1709               		.loc 1 713 0
 1710 04b4 15BA      		out 0x15,__zero_reg__
 714:setup.c       **** 	DDR_DATA7_0 = 0;
 1711               		.loc 1 714 0
 1712 04b6 14BA      		out 0x14,__zero_reg__
 715:setup.c       **** 	
 716:setup.c       **** 	// Verify data
 717:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte_fast();
 1713               		.loc 1 717 0
 1714 04b8 00D0      		rcall gb_flash_read_byte_fast
 1715               	.LVL132:
 1716               	.L77:
 718:setup.c       **** 	while (data != dataVerify) {
 1717               		.loc 1 718 0
 1718 04ba 8C17      		cp r24,r28
 1719 04bc 01F0      		breq .L76
 719:setup.c       **** 		dataVerify = gb_flash_read_byte_fast();
 1720               		.loc 1 719 0
 1721 04be 00D0      		rcall gb_flash_read_byte_fast
 1722               	.LVL133:
 1723               	.LBB175:
 1724               	.LBB176:
 1725               		.loc 2 276 0
 1726 04c0 92E0      		ldi r25,lo8(2)
 1727 04c2 9A95      	1:	dec r25
 1728 04c4 01F4      		brne 1b
 1729 04c6 00C0      		rjmp .
 1730               	.LVL134:
 1731               	.LBE176:
 1732               	.LBE175:
 720:setup.c       **** 		_delay_us(1);
 721:setup.c       **** 		if (writingTimedout == 1) {
 1733               		.loc 1 721 0
 1734 04c8 9091 0000 		lds r25,writingTimedout
 1735 04cc 9130      		cpi r25,lo8(1)
 1736 04ce 01F4      		brne .L77
 1737               	.L76:
 1738               	/* epilogue start */
 722:setup.c       **** 			break;
 723:setup.c       **** 		}
 724:setup.c       **** 	}
 725:setup.c       **** }
 1739               		.loc 1 725 0
 1740 04d0 CF91      		pop r28
 1741               	.LVL135:
 1742 04d2 1F91      		pop r17
 1743 04d4 0F91      		pop r16
 1744               	.LVL136:
 1745 04d6 0895      		ret
 1746               		.cfi_endproc
 1747               	.LFE40:
 1749               	.global	gb_flash_write_byte_special
 1751               	gb_flash_write_byte_special:
 1752               	.LFB41:
 726:setup.c       **** 
 727:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 728:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1753               		.loc 1 728 0
 1754               		.cfi_startproc
 1755               	.LVL137:
 1756 04d8 1F93      		push r17
 1757               	.LCFI29:
 1758               		.cfi_def_cfa_offset 3
 1759               		.cfi_offset 17, -2
 1760 04da CF93      		push r28
 1761               	.LCFI30:
 1762               		.cfi_def_cfa_offset 4
 1763               		.cfi_offset 28, -3
 1764 04dc DF93      		push r29
 1765               	.LCFI31:
 1766               		.cfi_def_cfa_offset 5
 1767               		.cfi_offset 29, -4
 1768               	/* prologue: function */
 1769               	/* frame size = 0 */
 1770               	/* stack size = 3 */
 1771               	.L__stack_usage = 3
 1772 04de EC01      		movw r28,r24
 1773 04e0 162F      		mov r17,r22
 729:setup.c       **** 	// Set bank back
 730:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1774               		.loc 1 730 0
 1775 04e2 8091 0000 		lds r24,flashBank1CommandWrites
 1776               	.LVL138:
 1777 04e6 8130      		cpi r24,lo8(1)
 1778 04e8 01F4      		brne .L82
 731:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1779               		.loc 1 731 0
 1780 04ea 40E0      		ldi r20,0
 1781 04ec 6091 0000 		lds r22,lastBankAccessed
 1782               	.LVL139:
 1783 04f0 80E0      		ldi r24,0
 1784 04f2 91E2      		ldi r25,lo8(33)
 1785 04f4 00D0      		rcall write_8bit_data
 1786               	.LVL140:
 1787               	.LBB177:
 1788               	.LBB178:
 1789               		.loc 2 276 0
 1790 04f6 85E8      		ldi r24,lo8(-123)
 1791 04f8 8A95      	1:	dec r24
 1792 04fa 01F4      		brne 1b
 1793 04fc 0000      		nop
 1794               	.LVL141:
 1795               	.L82:
 1796               	.LBE178:
 1797               	.LBE177:
 732:setup.c       **** 		_delay_us(50);
 733:setup.c       **** 	}
 734:setup.c       **** 	
 735:setup.c       **** 	// Write
 736:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1798               		.loc 1 736 0
 1799 04fe 6091 0000 		lds r22,flashWriteCycle+2
 1800 0502 8091 0000 		lds r24,flashWriteCycle
 1801 0506 9091 0000 		lds r25,flashWriteCycle+1
 1802 050a 00D0      		rcall gb_flash_write_bus_cycle
 1803               	.LVL142:
 737:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1804               		.loc 1 737 0
 1805 050c 6091 0000 		lds r22,flashWriteCycle+6
 1806 0510 8091 0000 		lds r24,flashWriteCycle+4
 1807 0514 9091 0000 		lds r25,flashWriteCycle+4+1
 1808 0518 00D0      		rcall gb_flash_write_bus_cycle
 1809               	.LVL143:
 738:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1810               		.loc 1 738 0
 1811 051a 6091 0000 		lds r22,flashWriteCycle+10
 1812 051e 8091 0000 		lds r24,flashWriteCycle+8
 1813 0522 9091 0000 		lds r25,flashWriteCycle+8+1
 1814 0526 00D0      		rcall gb_flash_write_bus_cycle
 1815               	.LVL144:
 739:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1816               		.loc 1 739 0
 1817 0528 612F      		mov r22,r17
 1818 052a CE01      		movw r24,r28
 1819 052c 00D0      		rcall gb_flash_write_bus_cycle
 1820               	.LVL145:
 1821               	.LBB179:
 1822               	.LBB180:
 1823               		.loc 2 276 0
 1824 052e 83EF      		ldi r24,lo8(499)
 1825 0530 91E0      		ldi r25,hi8(499)
 1826 0532 0197      	1:	sbiw r24,1
 1827 0534 01F4      		brne 1b
 1828 0536 00C0      		rjmp .
 1829 0538 0000      		nop
 1830               	.LVL146:
 1831               	.LBE180:
 1832               	.LBE179:
 740:setup.c       **** 	_delay_us(250); // Wait byte program time
 741:setup.c       **** 	
 742:setup.c       **** 	// Set data pins inputs
 743:setup.c       **** 	PORT_DATA7_0 = 0;
 1833               		.loc 1 743 0
 1834 053a 15BA      		out 0x15,__zero_reg__
 744:setup.c       **** 	DDR_DATA7_0 = 0;
 1835               		.loc 1 744 0
 1836 053c 14BA      		out 0x14,__zero_reg__
 745:setup.c       **** 	
 746:setup.c       **** 	// Pulse reset
 747:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1837               		.loc 1 747 0
 1838 053e 3A98      		cbi 0x7,2
 1839               	.LVL147:
 1840               	.LBB181:
 1841               	.LBB182:
 1842               		.loc 2 276 0
 1843 0540 95E8      		ldi r25,lo8(-123)
 1844 0542 9A95      	1:	dec r25
 1845 0544 01F4      		brne 1b
 1846 0546 0000      		nop
 1847               	.LVL148:
 1848               	.LBE182:
 1849               	.LBE181:
 748:setup.c       **** 	_delay_us(50);
 749:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1850               		.loc 1 749 0
 1851 0548 3A9A      		sbi 0x7,2
 1852               	.LVL149:
 1853               	.LBB183:
 1854               	.LBB184:
 1855               		.loc 2 276 0
 1856 054a 85E8      		ldi r24,lo8(-123)
 1857 054c 8A95      	1:	dec r24
 1858 054e 01F4      		brne 1b
 1859 0550 0000      		nop
 1860               	.LVL150:
 1861               	/* epilogue start */
 1862               	.LBE184:
 1863               	.LBE183:
 750:setup.c       **** 	_delay_us(50);
 751:setup.c       **** }
 1864               		.loc 1 751 0
 1865 0552 DF91      		pop r29
 1866 0554 CF91      		pop r28
 1867               	.LVL151:
 1868 0556 1F91      		pop r17
 1869               	.LVL152:
 1870 0558 0895      		ret
 1871               		.cfi_endproc
 1872               	.LFE41:
 1874               	.global	gb_flash_write_byte_bank1_commands
 1876               	gb_flash_write_byte_bank1_commands:
 1877               	.LFB42:
 752:setup.c       **** 
 753:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 754:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 755:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1878               		.loc 1 755 0
 1879               		.cfi_startproc
 1880               	.LVL153:
 1881 055a FF92      		push r15
 1882               	.LCFI32:
 1883               		.cfi_def_cfa_offset 3
 1884               		.cfi_offset 15, -2
 1885 055c 0F93      		push r16
 1886               	.LCFI33:
 1887               		.cfi_def_cfa_offset 4
 1888               		.cfi_offset 16, -3
 1889 055e 1F93      		push r17
 1890               	.LCFI34:
 1891               		.cfi_def_cfa_offset 5
 1892               		.cfi_offset 17, -4
 1893 0560 CF93      		push r28
 1894               	.LCFI35:
 1895               		.cfi_def_cfa_offset 6
 1896               		.cfi_offset 28, -5
 1897 0562 DF93      		push r29
 1898               	.LCFI36:
 1899               		.cfi_def_cfa_offset 7
 1900               		.cfi_offset 29, -6
 1901               	/* prologue: function */
 1902               	/* frame size = 0 */
 1903               	/* stack size = 5 */
 1904               	.L__stack_usage = 5
 1905 0564 EC01      		movw r28,r24
 1906 0566 162F      		mov r17,r22
 756:setup.c       **** 	// Set bank 1
 757:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1907               		.loc 1 757 0
 1908 0568 FF24      		clr r15
 1909 056a FA94      		dec r15
 1910 056c F4BA      		out 0x14,r15
 1911               	.LVL154:
 1912               	.LBB185:
 1913               	.LBB186:
 251:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1914               		.loc 1 251 0
 1915 056e 01E2      		ldi r16,lo8(33)
 1916 0570 0BBB      		out 0x1b,r16
 252:setup.c       **** }
 1917               		.loc 1 252 0
 1918 0572 18BA      		out 0x18,__zero_reg__
 1919               	.LVL155:
 1920               	.LBE186:
 1921               	.LBE185:
 758:setup.c       **** 	set_16bit_address(0x2100);
 759:setup.c       **** 	PORT_DATA7_0 = 1;
 1922               		.loc 1 759 0
 1923 0574 81E0      		ldi r24,lo8(1)
 1924               	.LVL156:
 1925 0576 85BB      		out 0x15,r24
 760:setup.c       **** 	wrPin_low; // Pulse WR
 1926               		.loc 1 760 0
 1927 0578 9698      		cbi 0x12,6
 761:setup.c       **** 	asm volatile("nop");
 1928               		.loc 1 761 0
 1929               	/* #APP */
 1930               	 ;  761 "setup.c" 1
 1931 057a 0000      		nop
 1932               	 ;  0 "" 2
 762:setup.c       **** 	wrPin_high;
 1933               		.loc 1 762 0
 1934               	/* #NOAPP */
 1935 057c 969A      		sbi 0x12,6
 763:setup.c       **** 	
 764:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1936               		.loc 1 764 0
 1937 057e 6091 0000 		lds r22,flashWriteCycle+2
 1938               	.LVL157:
 1939 0582 8091 0000 		lds r24,flashWriteCycle
 1940 0586 9091 0000 		lds r25,flashWriteCycle+1
 1941 058a 00D0      		rcall gb_flash_write_bus_cycle
 1942               	.LVL158:
 765:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1943               		.loc 1 765 0
 1944 058c 6091 0000 		lds r22,flashWriteCycle+6
 1945 0590 8091 0000 		lds r24,flashWriteCycle+4
 1946 0594 9091 0000 		lds r25,flashWriteCycle+4+1
 1947 0598 00D0      		rcall gb_flash_write_bus_cycle
 1948               	.LVL159:
 766:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1949               		.loc 1 766 0
 1950 059a 6091 0000 		lds r22,flashWriteCycle+10
 1951 059e 8091 0000 		lds r24,flashWriteCycle+8
 1952 05a2 9091 0000 		lds r25,flashWriteCycle+8+1
 1953 05a6 00D0      		rcall gb_flash_write_bus_cycle
 1954               	.LVL160:
 767:setup.c       **** 	
 768:setup.c       **** 	
 769:setup.c       **** 	// Set bank back
 770:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1955               		.loc 1 770 0
 1956 05a8 F4BA      		out 0x14,r15
 1957               	.LVL161:
 1958               	.LBB187:
 1959               	.LBB188:
 251:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1960               		.loc 1 251 0
 1961 05aa 0BBB      		out 0x1b,r16
 252:setup.c       **** }
 1962               		.loc 1 252 0
 1963 05ac 18BA      		out 0x18,__zero_reg__
 1964               	.LVL162:
 1965               	.LBE188:
 1966               	.LBE187:
 771:setup.c       **** 	set_16bit_address(0x2100);
 772:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1967               		.loc 1 772 0
 1968 05ae 8091 0000 		lds r24,lastBankAccessed
 1969 05b2 85BB      		out 0x15,r24
 773:setup.c       **** 	wrPin_low; // Pulse WR
 1970               		.loc 1 773 0
 1971 05b4 9698      		cbi 0x12,6
 774:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 774 0
 1973               	/* #APP */
 1974               	 ;  774 "setup.c" 1
 1975 05b6 0000      		nop
 1976               	 ;  0 "" 2
 775:setup.c       **** 	wrPin_high;
 1977               		.loc 1 775 0
 1978               	/* #NOAPP */
 1979 05b8 969A      		sbi 0x12,6
 776:setup.c       **** 	
 777:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1980               		.loc 1 777 0
 1981 05ba 612F      		mov r22,r17
 1982 05bc CE01      		movw r24,r28
 1983 05be 00D0      		rcall gb_flash_write_bus_cycle
 1984               	.LVL163:
 1985               	.LBB189:
 1986               	.LBB190:
 1987               		.loc 2 276 0
 1988 05c0 8AE1      		ldi r24,lo8(26)
 1989 05c2 8A95      	1:	dec r24
 1990 05c4 01F4      		brne 1b
 1991 05c6 00C0      		rjmp .
 1992               	.LVL164:
 1993               	.LBE190:
 1994               	.LBE189:
 778:setup.c       **** 	_delay_us(10); // Wait byte program time
 779:setup.c       **** 	
 780:setup.c       **** 	// Set data pins inputs
 781:setup.c       **** 	PORT_DATA7_0 = 0;
 1995               		.loc 1 781 0
 1996 05c8 15BA      		out 0x15,__zero_reg__
 782:setup.c       **** 	DDR_DATA7_0 = 0;
 1997               		.loc 1 782 0
 1998 05ca 14BA      		out 0x14,__zero_reg__
 783:setup.c       **** 	
 784:setup.c       **** 	// Verify data
 785:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1999               		.loc 1 785 0
 2000 05cc CE01      		movw r24,r28
 2001 05ce 00D0      		rcall gb_flash_read_byte
 2002               	.LVL165:
 2003               	.L84:
 786:setup.c       **** 	while (data != dataVerify) {
 2004               		.loc 1 786 0
 2005 05d0 8117      		cp r24,r17
 2006 05d2 01F0      		breq .L83
 787:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2007               		.loc 1 787 0
 2008 05d4 CE01      		movw r24,r28
 2009               	.LVL166:
 2010 05d6 00D0      		rcall gb_flash_read_byte
 2011               	.LVL167:
 2012               	.LBB191:
 2013               	.LBB192:
 2014               		.loc 2 276 0
 2015 05d8 9DE0      		ldi r25,lo8(13)
 2016 05da 9A95      	1:	dec r25
 2017 05dc 01F4      		brne 1b
 2018 05de 0000      		nop
 2019               	.LVL168:
 2020               	.LBE192:
 2021               	.LBE191:
 788:setup.c       **** 		_delay_us(5);
 789:setup.c       **** 		if (writingTimedout == 1) {
 2022               		.loc 1 789 0
 2023 05e0 9091 0000 		lds r25,writingTimedout
 2024 05e4 9130      		cpi r25,lo8(1)
 2025 05e6 01F4      		brne .L84
 2026               	.L83:
 2027               	/* epilogue start */
 790:setup.c       **** 			break;
 791:setup.c       **** 		}
 792:setup.c       **** 	}
 793:setup.c       **** }
 2028               		.loc 1 793 0
 2029 05e8 DF91      		pop r29
 2030 05ea CF91      		pop r28
 2031               	.LVL169:
 2032 05ec 1F91      		pop r17
 2033               	.LVL170:
 2034 05ee 0F91      		pop r16
 2035 05f0 FF90      		pop r15
 2036 05f2 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE42:
 2040               	.global	gba_flash_write_bus_cycle
 2042               	gba_flash_write_bus_cycle:
 2043               	.LFB43:
 794:setup.c       **** 
 795:setup.c       **** 
 796:setup.c       **** 
 797:setup.c       **** // ---------- GBA FLASH CARTS ----------
 798:setup.c       **** 
 799:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 800:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2044               		.loc 1 800 0
 2045               		.cfi_startproc
 2046               	.LVL171:
 2047 05f4 0F93      		push r16
 2048               	.LCFI37:
 2049               		.cfi_def_cfa_offset 3
 2050               		.cfi_offset 16, -2
 2051 05f6 1F93      		push r17
 2052               	.LCFI38:
 2053               		.cfi_def_cfa_offset 4
 2054               		.cfi_offset 17, -3
 2055               	/* prologue: function */
 2056               	/* frame size = 0 */
 2057               	/* stack size = 2 */
 2058               	.L__stack_usage = 2
 801:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 2059               		.loc 1 801 0
 2060 05f8 8C01      		movw r16,r24
 2061 05fa 2227      		clr r18
 2062 05fc 3327      		clr r19
 2063 05fe 05BB      		out 0x15,r16
 802:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 2064               		.loc 1 802 0
 2065 0600 072F      		mov r16,r23
 2066 0602 182F      		mov r17,r24
 2067 0604 292F      		mov r18,r25
 2068 0606 3327      		clr r19
 2069 0608 0BBB      		out 0x1b,r16
 803:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 2070               		.loc 1 803 0
 2071 060a 68BB      		out 0x18,r22
 804:setup.c       **** 	
 805:setup.c       **** 	cs_mreqPin_low;
 2072               		.loc 1 805 0
 2073 060c 9498      		cbi 0x12,4
 806:setup.c       **** 	
 807:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2074               		.loc 1 807 0
 2075 060e 5BBB      		out 0x1b,r21
 808:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2076               		.loc 1 808 0
 2077 0610 48BB      		out 0x18,r20
 809:setup.c       **** 	
 810:setup.c       **** 	wrPin_low;
 2078               		.loc 1 810 0
 2079 0612 9698      		cbi 0x12,6
 811:setup.c       **** 	asm volatile("nop");
 2080               		.loc 1 811 0
 2081               	/* #APP */
 2082               	 ;  811 "setup.c" 1
 2083 0614 0000      		nop
 2084               	 ;  0 "" 2
 812:setup.c       **** 	asm volatile("nop");
 2085               		.loc 1 812 0
 2086               	 ;  812 "setup.c" 1
 2087 0616 0000      		nop
 2088               	 ;  0 "" 2
 813:setup.c       **** 	asm volatile("nop");
 2089               		.loc 1 813 0
 2090               	 ;  813 "setup.c" 1
 2091 0618 0000      		nop
 2092               	 ;  0 "" 2
 814:setup.c       **** 	wrPin_high;
 2093               		.loc 1 814 0
 2094               	/* #NOAPP */
 2095 061a 969A      		sbi 0x12,6
 815:setup.c       **** 	cs_mreqPin_high;
 2096               		.loc 1 815 0
 2097 061c 949A      		sbi 0x12,4
 2098               	/* epilogue start */
 816:setup.c       **** }
 2099               		.loc 1 816 0
 2100 061e 1F91      		pop r17
 2101 0620 0F91      		pop r16
 2102 0622 0895      		ret
 2103               		.cfi_endproc
 2104               	.LFE43:
 2106               	.global	gba_flash_write_cycle_start_swapped
 2108               	gba_flash_write_cycle_start_swapped:
 2109               	.LFB44:
 817:setup.c       **** 
 818:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 819:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2110               		.loc 1 819 0
 2111               		.cfi_startproc
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 0 */
 2115               	.L__stack_usage = 0
 820:setup.c       **** 	// Set outputs
 821:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2116               		.loc 1 821 0
 2117 0624 8FEF      		ldi r24,lo8(-1)
 2118 0626 84BB      		out 0x14,r24
 822:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2119               		.loc 1 822 0
 2120 0628 8ABB      		out 0x1a,r24
 823:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2121               		.loc 1 823 0
 2122 062a 87BB      		out 0x17,r24
 824:setup.c       **** 	
 825:setup.c       **** 	// 0x555, 0xA9
 826:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2123               		.loc 1 826 0
 2124 062c 15BA      		out 0x15,__zero_reg__
 827:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2125               		.loc 1 827 0
 2126 062e 95E0      		ldi r25,lo8(5)
 2127 0630 9BBB      		out 0x1b,r25
 828:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2128               		.loc 1 828 0
 2129 0632 85E5      		ldi r24,lo8(85)
 2130 0634 88BB      		out 0x18,r24
 829:setup.c       **** 	cs_mreqPin_low;
 2131               		.loc 1 829 0
 2132 0636 9498      		cbi 0x12,4
 830:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2133               		.loc 1 830 0
 2134 0638 1BBA      		out 0x1b,__zero_reg__
 831:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2135               		.loc 1 831 0
 2136 063a 29EA      		ldi r18,lo8(-87)
 2137 063c 28BB      		out 0x18,r18
 832:setup.c       **** 	wrPin_low;
 2138               		.loc 1 832 0
 2139 063e 9698      		cbi 0x12,6
 833:setup.c       **** 	asm volatile("nop");
 2140               		.loc 1 833 0
 2141               	/* #APP */
 2142               	 ;  833 "setup.c" 1
 2143 0640 0000      		nop
 2144               	 ;  0 "" 2
 834:setup.c       **** 	asm volatile("nop");
 2145               		.loc 1 834 0
 2146               	 ;  834 "setup.c" 1
 2147 0642 0000      		nop
 2148               	 ;  0 "" 2
 835:setup.c       **** 	asm volatile("nop");
 2149               		.loc 1 835 0
 2150               	 ;  835 "setup.c" 1
 2151 0644 0000      		nop
 2152               	 ;  0 "" 2
 836:setup.c       **** 	wrPin_high;
 2153               		.loc 1 836 0
 2154               	/* #NOAPP */
 2155 0646 969A      		sbi 0x12,6
 837:setup.c       **** 	cs_mreqPin_high;
 2156               		.loc 1 837 0
 2157 0648 949A      		sbi 0x12,4
 838:setup.c       **** 	
 839:setup.c       **** 	// 0x2AA, 0x56
 840:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2158               		.loc 1 840 0
 2159 064a 15BA      		out 0x15,__zero_reg__
 841:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2160               		.loc 1 841 0
 2161 064c 22E0      		ldi r18,lo8(2)
 2162 064e 2BBB      		out 0x1b,r18
 842:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2163               		.loc 1 842 0
 2164 0650 2AEA      		ldi r18,lo8(-86)
 2165 0652 28BB      		out 0x18,r18
 843:setup.c       **** 	cs_mreqPin_low;
 2166               		.loc 1 843 0
 2167 0654 9498      		cbi 0x12,4
 844:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2168               		.loc 1 844 0
 2169 0656 1BBA      		out 0x1b,__zero_reg__
 845:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2170               		.loc 1 845 0
 2171 0658 26E5      		ldi r18,lo8(86)
 2172 065a 28BB      		out 0x18,r18
 846:setup.c       **** 	wrPin_low;
 2173               		.loc 1 846 0
 2174 065c 9698      		cbi 0x12,6
 847:setup.c       **** 	asm volatile("nop");
 2175               		.loc 1 847 0
 2176               	/* #APP */
 2177               	 ;  847 "setup.c" 1
 2178 065e 0000      		nop
 2179               	 ;  0 "" 2
 848:setup.c       **** 	asm volatile("nop");
 2180               		.loc 1 848 0
 2181               	 ;  848 "setup.c" 1
 2182 0660 0000      		nop
 2183               	 ;  0 "" 2
 849:setup.c       **** 	asm volatile("nop");
 2184               		.loc 1 849 0
 2185               	 ;  849 "setup.c" 1
 2186 0662 0000      		nop
 2187               	 ;  0 "" 2
 850:setup.c       **** 	wrPin_high;
 2188               		.loc 1 850 0
 2189               	/* #NOAPP */
 2190 0664 969A      		sbi 0x12,6
 851:setup.c       **** 	cs_mreqPin_high;
 2191               		.loc 1 851 0
 2192 0666 949A      		sbi 0x12,4
 852:setup.c       **** 	
 853:setup.c       **** 	// 0x555, 0xA0;
 854:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2193               		.loc 1 854 0
 2194 0668 15BA      		out 0x15,__zero_reg__
 855:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2195               		.loc 1 855 0
 2196 066a 9BBB      		out 0x1b,r25
 856:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2197               		.loc 1 856 0
 2198 066c 88BB      		out 0x18,r24
 857:setup.c       **** 	cs_mreqPin_low;
 2199               		.loc 1 857 0
 2200 066e 9498      		cbi 0x12,4
 858:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2201               		.loc 1 858 0
 2202 0670 1BBA      		out 0x1b,__zero_reg__
 859:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2203               		.loc 1 859 0
 2204 0672 80EA      		ldi r24,lo8(-96)
 2205 0674 88BB      		out 0x18,r24
 860:setup.c       **** 	wrPin_low;
 2206               		.loc 1 860 0
 2207 0676 9698      		cbi 0x12,6
 861:setup.c       **** 	asm volatile("nop");
 2208               		.loc 1 861 0
 2209               	/* #APP */
 2210               	 ;  861 "setup.c" 1
 2211 0678 0000      		nop
 2212               	 ;  0 "" 2
 862:setup.c       **** 	asm volatile("nop");
 2213               		.loc 1 862 0
 2214               	 ;  862 "setup.c" 1
 2215 067a 0000      		nop
 2216               	 ;  0 "" 2
 863:setup.c       **** 	asm volatile("nop");
 2217               		.loc 1 863 0
 2218               	 ;  863 "setup.c" 1
 2219 067c 0000      		nop
 2220               	 ;  0 "" 2
 864:setup.c       **** 	wrPin_high;
 2221               		.loc 1 864 0
 2222               	/* #NOAPP */
 2223 067e 969A      		sbi 0x12,6
 865:setup.c       **** 	cs_mreqPin_high;
 2224               		.loc 1 865 0
 2225 0680 949A      		sbi 0x12,4
 2226 0682 0895      		ret
 2227               		.cfi_endproc
 2228               	.LFE44:
 2230               	.global	gba_flash_write_cycle_start
 2232               	gba_flash_write_cycle_start:
 2233               	.LFB45:
 866:setup.c       **** }
 867:setup.c       **** 
 868:setup.c       **** 
 869:setup.c       **** // Send the first 3 write cycles to the flash
 870:setup.c       **** void gba_flash_write_cycle_start(void) {
 2234               		.loc 1 870 0
 2235               		.cfi_startproc
 2236               	/* prologue: function */
 2237               	/* frame size = 0 */
 2238               	/* stack size = 0 */
 2239               	.L__stack_usage = 0
 871:setup.c       **** 	// Set outputs
 872:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2240               		.loc 1 872 0
 2241 0684 8FEF      		ldi r24,lo8(-1)
 2242 0686 84BB      		out 0x14,r24
 873:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2243               		.loc 1 873 0
 2244 0688 8ABB      		out 0x1a,r24
 874:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2245               		.loc 1 874 0
 2246 068a 87BB      		out 0x17,r24
 875:setup.c       **** 	
 876:setup.c       **** 	// 0x555, 0xAA
 877:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2247               		.loc 1 877 0
 2248 068c 15BA      		out 0x15,__zero_reg__
 878:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2249               		.loc 1 878 0
 2250 068e 95E0      		ldi r25,lo8(5)
 2251 0690 9BBB      		out 0x1b,r25
 879:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2252               		.loc 1 879 0
 2253 0692 85E5      		ldi r24,lo8(85)
 2254 0694 88BB      		out 0x18,r24
 880:setup.c       **** 	cs_mreqPin_low;
 2255               		.loc 1 880 0
 2256 0696 9498      		cbi 0x12,4
 881:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2257               		.loc 1 881 0
 2258 0698 1BBA      		out 0x1b,__zero_reg__
 882:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2259               		.loc 1 882 0
 2260 069a 2AEA      		ldi r18,lo8(-86)
 2261 069c 28BB      		out 0x18,r18
 883:setup.c       **** 	wrPin_low;
 2262               		.loc 1 883 0
 2263 069e 9698      		cbi 0x12,6
 884:setup.c       **** 	asm volatile("nop");
 2264               		.loc 1 884 0
 2265               	/* #APP */
 2266               	 ;  884 "setup.c" 1
 2267 06a0 0000      		nop
 2268               	 ;  0 "" 2
 885:setup.c       **** 	asm volatile("nop");
 2269               		.loc 1 885 0
 2270               	 ;  885 "setup.c" 1
 2271 06a2 0000      		nop
 2272               	 ;  0 "" 2
 886:setup.c       **** 	asm volatile("nop");
 2273               		.loc 1 886 0
 2274               	 ;  886 "setup.c" 1
 2275 06a4 0000      		nop
 2276               	 ;  0 "" 2
 887:setup.c       **** 	wrPin_high;
 2277               		.loc 1 887 0
 2278               	/* #NOAPP */
 2279 06a6 969A      		sbi 0x12,6
 888:setup.c       **** 	cs_mreqPin_high;
 2280               		.loc 1 888 0
 2281 06a8 949A      		sbi 0x12,4
 889:setup.c       **** 	
 890:setup.c       **** 	// 0x2AA, 0x55
 891:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2282               		.loc 1 891 0
 2283 06aa 15BA      		out 0x15,__zero_reg__
 892:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2284               		.loc 1 892 0
 2285 06ac 32E0      		ldi r19,lo8(2)
 2286 06ae 3BBB      		out 0x1b,r19
 893:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2287               		.loc 1 893 0
 2288 06b0 28BB      		out 0x18,r18
 894:setup.c       **** 	cs_mreqPin_low;
 2289               		.loc 1 894 0
 2290 06b2 9498      		cbi 0x12,4
 895:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2291               		.loc 1 895 0
 2292 06b4 1BBA      		out 0x1b,__zero_reg__
 896:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2293               		.loc 1 896 0
 2294 06b6 88BB      		out 0x18,r24
 897:setup.c       **** 	wrPin_low;
 2295               		.loc 1 897 0
 2296 06b8 9698      		cbi 0x12,6
 898:setup.c       **** 	asm volatile("nop");
 2297               		.loc 1 898 0
 2298               	/* #APP */
 2299               	 ;  898 "setup.c" 1
 2300 06ba 0000      		nop
 2301               	 ;  0 "" 2
 899:setup.c       **** 	asm volatile("nop");
 2302               		.loc 1 899 0
 2303               	 ;  899 "setup.c" 1
 2304 06bc 0000      		nop
 2305               	 ;  0 "" 2
 900:setup.c       **** 	asm volatile("nop");
 2306               		.loc 1 900 0
 2307               	 ;  900 "setup.c" 1
 2308 06be 0000      		nop
 2309               	 ;  0 "" 2
 901:setup.c       **** 	wrPin_high;
 2310               		.loc 1 901 0
 2311               	/* #NOAPP */
 2312 06c0 969A      		sbi 0x12,6
 902:setup.c       **** 	cs_mreqPin_high;
 2313               		.loc 1 902 0
 2314 06c2 949A      		sbi 0x12,4
 903:setup.c       **** 	
 904:setup.c       **** 	// 0x555, 0xA0;
 905:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2315               		.loc 1 905 0
 2316 06c4 15BA      		out 0x15,__zero_reg__
 906:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2317               		.loc 1 906 0
 2318 06c6 9BBB      		out 0x1b,r25
 907:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2319               		.loc 1 907 0
 2320 06c8 88BB      		out 0x18,r24
 908:setup.c       **** 	cs_mreqPin_low;
 2321               		.loc 1 908 0
 2322 06ca 9498      		cbi 0x12,4
 909:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2323               		.loc 1 909 0
 2324 06cc 1BBA      		out 0x1b,__zero_reg__
 910:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2325               		.loc 1 910 0
 2326 06ce 80EA      		ldi r24,lo8(-96)
 2327 06d0 88BB      		out 0x18,r24
 911:setup.c       **** 	wrPin_low;
 2328               		.loc 1 911 0
 2329 06d2 9698      		cbi 0x12,6
 912:setup.c       **** 	asm volatile("nop");
 2330               		.loc 1 912 0
 2331               	/* #APP */
 2332               	 ;  912 "setup.c" 1
 2333 06d4 0000      		nop
 2334               	 ;  0 "" 2
 913:setup.c       **** 	asm volatile("nop");
 2335               		.loc 1 913 0
 2336               	 ;  913 "setup.c" 1
 2337 06d6 0000      		nop
 2338               	 ;  0 "" 2
 914:setup.c       **** 	asm volatile("nop");
 2339               		.loc 1 914 0
 2340               	 ;  914 "setup.c" 1
 2341 06d8 0000      		nop
 2342               	 ;  0 "" 2
 915:setup.c       **** 	wrPin_high;
 2343               		.loc 1 915 0
 2344               	/* #NOAPP */
 2345 06da 969A      		sbi 0x12,6
 916:setup.c       **** 	cs_mreqPin_high;
 2346               		.loc 1 916 0
 2347 06dc 949A      		sbi 0x12,4
 2348 06de 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE45:
 2352               	.global	gba_flash_write_byte
 2354               	gba_flash_write_byte:
 2355               	.LFB46:
 917:setup.c       **** }	
 918:setup.c       **** 
 919:setup.c       **** 
 920:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 921:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 922:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2356               		.loc 1 922 0
 2357               		.cfi_startproc
 2358               	.LVL172:
 2359 06e0 CF92      		push r12
 2360               	.LCFI39:
 2361               		.cfi_def_cfa_offset 3
 2362               		.cfi_offset 12, -2
 2363 06e2 DF92      		push r13
 2364               	.LCFI40:
 2365               		.cfi_def_cfa_offset 4
 2366               		.cfi_offset 13, -3
 2367 06e4 EF92      		push r14
 2368               	.LCFI41:
 2369               		.cfi_def_cfa_offset 5
 2370               		.cfi_offset 14, -4
 2371 06e6 FF92      		push r15
 2372               	.LCFI42:
 2373               		.cfi_def_cfa_offset 6
 2374               		.cfi_offset 15, -5
 2375 06e8 CF93      		push r28
 2376               	.LCFI43:
 2377               		.cfi_def_cfa_offset 7
 2378               		.cfi_offset 28, -6
 2379 06ea DF93      		push r29
 2380               	.LCFI44:
 2381               		.cfi_def_cfa_offset 8
 2382               		.cfi_offset 29, -7
 2383               	/* prologue: function */
 2384               	/* frame size = 0 */
 2385               	/* stack size = 6 */
 2386               	.L__stack_usage = 6
 2387 06ec 6B01      		movw r12,r22
 2388 06ee 7C01      		movw r14,r24
 2389 06f0 EA01      		movw r28,r20
 923:setup.c       **** 	if (isD0D1Swapped == 0) {
 2390               		.loc 1 923 0
 2391 06f2 2111      		cpse r18,__zero_reg__
 2392 06f4 00C0      		rjmp .L92
 924:setup.c       **** 		gba_flash_write_cycle_start();
 2393               		.loc 1 924 0
 2394 06f6 00D0      		rcall gba_flash_write_cycle_start
 2395               	.LVL173:
 2396 06f8 00C0      		rjmp .L93
 2397               	.LVL174:
 2398               	.L92:
 925:setup.c       **** 	}
 926:setup.c       **** 	else {
 927:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2399               		.loc 1 927 0
 2400 06fa 00D0      		rcall gba_flash_write_cycle_start_swapped
 2401               	.LVL175:
 2402               	.L93:
 928:setup.c       **** 	}
 929:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2403               		.loc 1 929 0
 2404 06fc AE01      		movw r20,r28
 2405 06fe C701      		movw r24,r14
 2406 0700 B601      		movw r22,r12
 2407 0702 00D0      		rcall gba_flash_write_bus_cycle
 2408               	.LVL176:
 2409               	.LBB193:
 2410               	.LBB194:
 2411               		.loc 2 276 0
 2412 0704 25E0      		ldi r18,lo8(5)
 2413 0706 2A95      	1:	dec r18
 2414 0708 01F4      		brne 1b
 2415 070a 0000      		nop
 2416               	.LVL177:
 2417               	.LBE194:
 2418               	.LBE193:
 930:setup.c       **** 	_delay_us(2); // Wait byte program time
 931:setup.c       **** 	
 932:setup.c       **** 	// Verify data
 933:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2419               		.loc 1 933 0
 2420 070c C701      		movw r24,r14
 2421 070e B601      		movw r22,r12
 2422 0710 00D0      		rcall gba_read_16bit_data
 2423               	.LVL178:
 2424               	.L94:
 934:setup.c       **** 	while (data != dataVerify) {
 2425               		.loc 1 934 0
 2426 0712 8C17      		cp r24,r28
 2427 0714 9D07      		cpc r25,r29
 2428 0716 01F0      		breq .L91
 935:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2429               		.loc 1 935 0
 2430 0718 C701      		movw r24,r14
 2431 071a B601      		movw r22,r12
 2432 071c 00D0      		rcall gba_read_16bit_data
 2433               	.LVL179:
 2434               	.LBB195:
 2435               	.LBB196:
 2436               		.loc 2 276 0
 2437 071e 25E0      		ldi r18,lo8(5)
 2438 0720 2A95      	1:	dec r18
 2439 0722 01F4      		brne 1b
 2440 0724 0000      		nop
 2441               	.LVL180:
 2442               	.LBE196:
 2443               	.LBE195:
 936:setup.c       **** 		_delay_us(2);
 937:setup.c       **** 		if (writingTimedout == 1) {
 2444               		.loc 1 937 0
 2445 0726 2091 0000 		lds r18,writingTimedout
 2446 072a 2130      		cpi r18,lo8(1)
 2447 072c 01F4      		brne .L94
 2448               	.L91:
 2449               	/* epilogue start */
 938:setup.c       **** 			break;
 939:setup.c       **** 		}
 940:setup.c       **** 	}
 941:setup.c       **** }
 2450               		.loc 1 941 0
 2451 072e DF91      		pop r29
 2452 0730 CF91      		pop r28
 2453               	.LVL181:
 2454 0732 FF90      		pop r15
 2455 0734 EF90      		pop r14
 2456 0736 DF90      		pop r13
 2457 0738 CF90      		pop r12
 2458               	.LVL182:
 2459 073a 0895      		ret
 2460               		.cfi_endproc
 2461               	.LFE46:
 2463               	.global	start_timeout_timer
 2465               	start_timeout_timer:
 2466               	.LFB47:
 942:setup.c       **** 
 943:setup.c       **** // Timeout for ~500ms when flashing carts
 944:setup.c       **** void start_timeout_timer(void) {
 2467               		.loc 1 944 0
 2468               		.cfi_startproc
 2469               	/* prologue: function */
 2470               	/* frame size = 0 */
 2471               	/* stack size = 0 */
 2472               	.L__stack_usage = 0
 945:setup.c       **** 	writingTimedout = 0;
 2473               		.loc 1 945 0
 2474 073c 1092 0000 		sts writingTimedout,__zero_reg__
 946:setup.c       **** 	TCNT1 = 0;
 2475               		.loc 1 946 0
 2476 0740 1DBC      		out 0x2c+1,__zero_reg__
 2477 0742 1CBC      		out 0x2c,__zero_reg__
 947:setup.c       **** 	TCCR1B |= (1<<CS11) | (1<<CS10);
 2478               		.loc 1 947 0
 2479 0744 8EB5      		in r24,0x2e
 2480 0746 8360      		ori r24,lo8(3)
 2481 0748 8EBD      		out 0x2e,r24
 2482 074a 0895      		ret
 2483               		.cfi_endproc
 2484               	.LFE47:
 2486               	.global	stop_timeout_timer
 2488               	stop_timeout_timer:
 2489               	.LFB48:
 948:setup.c       **** }
 949:setup.c       **** 
 950:setup.c       **** // Stop the flash timeout timer
 951:setup.c       **** void stop_timeout_timer(void) {
 2490               		.loc 1 951 0
 2491               		.cfi_startproc
 2492               	/* prologue: function */
 2493               	/* frame size = 0 */
 2494               	/* stack size = 0 */
 2495               	.L__stack_usage = 0
 952:setup.c       **** 	writingTimedout = 0;
 2496               		.loc 1 952 0
 2497 074c 1092 0000 		sts writingTimedout,__zero_reg__
 953:setup.c       **** 	TCNT1 = 0;
 2498               		.loc 1 953 0
 2499 0750 1DBC      		out 0x2c+1,__zero_reg__
 2500 0752 1CBC      		out 0x2c,__zero_reg__
 954:setup.c       **** 	TCCR1B = 0;
 2501               		.loc 1 954 0
 2502 0754 1EBC      		out 0x2e,__zero_reg__
 955:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2503               		.loc 1 955 0
 2504 0756 9398      		cbi 0x12,3
 2505 0758 0895      		ret
 2506               		.cfi_endproc
 2507               	.LFE48:
 2509               	.global	check_if_timed_out
 2511               	check_if_timed_out:
 2512               	.LFB49:
 956:setup.c       **** }
 957:setup.c       **** 
 958:setup.c       **** void check_if_timed_out(void) {
 2513               		.loc 1 958 0
 2514               		.cfi_startproc
 2515               	/* prologue: function */
 2516               	/* frame size = 0 */
 2517               	/* stack size = 0 */
 2518               	.L__stack_usage = 0
 959:setup.c       **** 	if (writingTimedout == 0) {
 2519               		.loc 1 959 0
 2520 075a 8091 0000 		lds r24,writingTimedout
 2521 075e 8111      		cpse r24,__zero_reg__
 2522 0760 00C0      		rjmp .L100
 2523               	.LBB199:
 2524               	.LBB200:
 960:setup.c       **** 		stop_timeout_timer();		
 2525               		.loc 1 960 0
 2526 0762 00D0      		rcall stop_timeout_timer
 2527               	.LVL183:
 961:setup.c       **** 		USART_Transmit(SEND_ACK); // Send back acknowledgement
 2528               		.loc 1 961 0
 2529 0764 81E3      		ldi r24,lo8(49)
 2530 0766 00D0      		rcall USART_Transmit
 2531               	.LVL184:
 962:setup.c       **** 		PORTD &= ~(1<<ACTIVITY_LED);
 2532               		.loc 1 962 0
 2533 0768 9398      		cbi 0x12,3
 2534               	.L100:
 2535 076a 0895      		ret
 2536               	.LBE200:
 2537               	.LBE199:
 2538               		.cfi_endproc
 2539               	.LFE49:
 2541               	.global	setup
 2543               	setup:
 2544               	.LFB50:
 963:setup.c       **** 	}
 964:setup.c       **** }
 965:setup.c       **** 
 966:setup.c       **** 
 967:setup.c       **** // Setup
 968:setup.c       **** void setup(void) {
 2545               		.loc 1 968 0
 2546               		.cfi_startproc
 2547               	/* prologue: function */
 2548               	/* frame size = 0 */
 2549               	/* stack size = 0 */
 2550               	.L__stack_usage = 0
 969:setup.c       **** 	// Turn off watchdog
 970:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2551               		.loc 1 970 0
 2552 076c 84B7      		in r24,0x34
 2553 076e 877F      		andi r24,lo8(-9)
 2554 0770 84BF      		out 0x34,r24
 971:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2555               		.loc 1 971 0
 2556 0772 88E1      		ldi r24,lo8(24)
 2557 0774 81BD      		out 0x21,r24
 972:setup.c       **** 	WDTCR = 0;
 2558               		.loc 1 972 0
 2559 0776 11BC      		out 0x21,__zero_reg__
 973:setup.c       **** 	
 974:setup.c       **** 	// Reset common lines
 975:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2560               		.loc 1 975 0
 2561 0778 00D0      		rcall rd_wr_csmreq_cs2_reset
 2562               	.LVL185:
 976:setup.c       **** 	
 977:setup.c       **** 	// Set outputs
 978:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2563               		.loc 1 978 0
 2564 077a 81B3      		in r24,0x11
 2565 077c 886F      		ori r24,lo8(-8)
 2566 077e 81BB      		out 0x11,r24
 979:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2567               		.loc 1 979 0
 2568 0780 86B1      		in r24,0x6
 2569 0782 8560      		ori r24,lo8(5)
 2570 0784 86B9      		out 0x6,r24
 980:setup.c       **** 	
 981:setup.c       **** 	// Set all pins as inputs
 982:setup.c       **** 	PORT_DATA7_0 = 0;
 2571               		.loc 1 982 0
 2572 0786 15BA      		out 0x15,__zero_reg__
 983:setup.c       **** 	DDR_DATA7_0 = 0;
 2573               		.loc 1 983 0
 2574 0788 14BA      		out 0x14,__zero_reg__
 984:setup.c       **** 	PORT_ADDR7_0 = 0;
 2575               		.loc 1 984 0
 2576 078a 18BA      		out 0x18,__zero_reg__
 985:setup.c       **** 	DDR_ADDR7_0 = 0;
 2577               		.loc 1 985 0
 2578 078c 17BA      		out 0x17,__zero_reg__
 986:setup.c       **** 	PORT_ADDR15_8 = 0;
 2579               		.loc 1 986 0
 2580 078e 1BBA      		out 0x1b,__zero_reg__
 987:setup.c       **** 	DDR_ADDR15_8 = 0;
 2581               		.loc 1 987 0
 2582 0790 1ABA      		out 0x1a,__zero_reg__
 988:setup.c       **** 	
 989:setup.c       **** 	// Light up 3.3V or 5V
 990:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2583               		.loc 1 990 0
 2584 0792 829B      		sbis 0x10,2
 2585 0794 00C0      		rjmp .L103
 991:setup.c       **** 		PORTD |= (1<<LED_5V);
 2586               		.loc 1 991 0
 2587 0796 979A      		sbi 0x12,7
 992:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2588               		.loc 1 992 0
 2589 0798 3898      		cbi 0x7,0
 993:setup.c       **** 		
 994:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 995:setup.c       **** 		cs2Pin_low;
 2590               		.loc 1 995 0
 2591 079a 3A98      		cbi 0x7,2
 2592               	.LVL186:
 2593               	.LBB201:
 2594               	.LBB202:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2595               		.loc 2 187 0
 2596 079c 2FE7      		ldi r18,lo8(79999)
 2597 079e 88E3      		ldi r24,hi8(79999)
 2598 07a0 91E0      		ldi r25,hlo8(79999)
 2599 07a2 2150      	1:	subi r18,1
 2600 07a4 8040      		sbci r24,0
 2601 07a6 9040      		sbci r25,0
 2602 07a8 01F4      		brne 1b
 2603 07aa 00C0      		rjmp .
 2604 07ac 0000      		nop
 2605               	.LVL187:
 2606               	.LBE202:
 2607               	.LBE201:
 996:setup.c       **** 		_delay_ms(50);
 997:setup.c       **** 		cs2Pin_high;
 2608               		.loc 1 997 0
 2609 07ae 3A9A      		sbi 0x7,2
 2610 07b0 00C0      		rjmp .L104
 2611               	.L103:
 998:setup.c       **** 	}
 999:setup.c       **** 	else {
1000:setup.c       **** 		PORTE |= (1<<LED_3V);
 2612               		.loc 1 1000 0
 2613 07b2 389A      		sbi 0x7,0
1001:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2614               		.loc 1 1001 0
 2615 07b4 9798      		cbi 0x12,7
 2616               	.L104:
1002:setup.c       **** 	}
1003:setup.c       **** 	
1004:setup.c       **** 	// Light LED
1005:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2617               		.loc 1 1005 0
 2618 07b6 939A      		sbi 0x12,3
 2619               	.LVL188:
 2620               	.LBB203:
 2621               	.LBB204:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2622               		.loc 2 187 0
 2623 07b8 2FEF      		ldi r18,lo8(799999)
 2624 07ba 84E3      		ldi r24,hi8(799999)
 2625 07bc 9CE0      		ldi r25,hlo8(799999)
 2626 07be 2150      	1:	subi r18,1
 2627 07c0 8040      		sbci r24,0
 2628 07c2 9040      		sbci r25,0
 2629 07c4 01F4      		brne 1b
 2630 07c6 00C0      		rjmp .
 2631 07c8 0000      		nop
 2632               	.LVL189:
 2633               	.LBE204:
 2634               	.LBE203:
1006:setup.c       **** 	_delay_ms(500);
1007:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2635               		.loc 1 1007 0
 2636 07ca 9398      		cbi 0x12,3
1008:setup.c       **** 	
1009:setup.c       **** 	// Setup USART
1010:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2637               		.loc 1 1010 0
 2638 07cc 19B8      		out 0x9,__zero_reg__
1011:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2639               		.loc 1 1011 0
 2640 07ce 599A      		sbi 0xb,1
1012:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2641               		.loc 1 1012 0
 2642 07d0 539A      		sbi 0xa,3
1013:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2643               		.loc 1 1013 0
 2644 07d2 549A      		sbi 0xa,4
1014:setup.c       **** 	
1015:setup.c       **** 	// Timer1 setup
1016:setup.c       **** 	TIMSK |= (1<<TOIE1);
 2645               		.loc 1 1016 0
 2646 07d4 89B7      		in r24,0x39
 2647 07d6 8068      		ori r24,lo8(-128)
 2648 07d8 89BF      		out 0x39,r24
1017:setup.c       **** 	TCNT1 = 0;
 2649               		.loc 1 1017 0
 2650 07da 1DBC      		out 0x2c+1,__zero_reg__
 2651 07dc 1CBC      		out 0x2c,__zero_reg__
1018:setup.c       **** 	
1019:setup.c       **** 	// Turn on interrupts
1020:setup.c       **** 	sei();
 2652               		.loc 1 1020 0
 2653               	/* #APP */
 2654               	 ;  1020 "setup.c" 1
 2655 07de 7894      		sei
 2656               	 ;  0 "" 2
 2657               	/* #NOAPP */
 2658 07e0 0895      		ret
 2659               		.cfi_endproc
 2660               	.LFE50:
 2662               		.section	.text.startup,"ax",@progbits
 2663               	.global	main
 2665               	main:
 2666               	.LFB51:
 2667               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R19
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 20/08/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.x_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.x_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  */
  28:main.c        **** 
  29:main.c        **** // ATmega8515L Pin Map
  30:main.c        **** //
  31:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  32:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  33:main.c        **** // 
  34:main.c        **** // Gameboy / Gameboy Colour
  35:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  36:main.c        **** // 
  37:main.c        **** // Gameboy Advance
  38:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  39:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  40:main.c        **** 
  41:main.c        **** #define F_CPU 8000000 // 8 MHz
  42:main.c        **** #define PCB_VERSION 2
  43:main.c        **** #define FIRMWARE_VERSION 19
  44:main.c        **** 
  45:main.c        **** #include <avr/io.h>
  46:main.c        **** #include <avr/wdt.h>
  47:main.c        **** #include <avr/eeprom.h>
  48:main.c        **** #include <avr/interrupt.h>
  49:main.c        **** #include <avr/sleep.h>
  50:main.c        **** #include <util/delay.h>
  51:main.c        **** #include <stdlib.h>
  52:main.c        **** #include <string.h>
  53:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  54:main.c        **** 
  55:main.c        **** 
  56:main.c        **** int main(void) {
 2668               		.loc 3 56 0
 2669               		.cfi_startproc
 2670 0000 CF93      		push r28
 2671               	.LCFI45:
 2672               		.cfi_def_cfa_offset 3
 2673               		.cfi_offset 28, -2
 2674 0002 DF93      		push r29
 2675               	.LCFI46:
 2676               		.cfi_def_cfa_offset 4
 2677               		.cfi_offset 29, -3
 2678 0004 CDB7      		in r28,__SP_L__
 2679 0006 DEB7      		in r29,__SP_H__
 2680               	.LCFI47:
 2681               		.cfi_def_cfa_register 28
 2682 0008 2897      		sbiw r28,8
 2683               	.LCFI48:
 2684               		.cfi_def_cfa_offset 12
 2685 000a 0FB6      		in __tmp_reg__,__SREG__
 2686 000c F894      		cli
 2687 000e DEBF      		out __SP_H__,r29
 2688 0010 0FBE      		out __SREG__,__tmp_reg__
 2689 0012 CDBF      		out __SP_L__,r28
 2690               	/* prologue: function */
 2691               	/* frame size = 8 */
 2692               	/* stack size = 10 */
 2693               	.L__stack_usage = 10
  57:main.c        **** 	setup();
 2694               		.loc 3 57 0
 2695 0014 00D0      		rcall setup
 2696               	.LVL190:
  58:main.c        **** 	
  59:main.c        **** 	uint32_t address = 0;
  60:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  61:main.c        **** 	uint8_t cartMode = GB_MODE;
  62:main.c        **** 	uint8_t resetCommonLines = 1;
 2697               		.loc 3 62 0
 2698 0016 21E0      		ldi r18,lo8(1)
 2699 0018 2F83      		std Y+7,r18
  60:main.c        **** 	uint8_t cartMode = GB_MODE;
 2700               		.loc 3 60 0
 2701 001a 81E0      		ldi r24,lo8(1)
 2702 001c 8887      		std Y+8,r24
  59:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2703               		.loc 3 59 0
 2704 001e C12C      		mov r12,__zero_reg__
 2705 0020 D12C      		mov r13,__zero_reg__
 2706 0022 7601      		movw r14,r12
 2707               	.LVL191:
 2708               	.L106:
  63:main.c        **** 	
  64:main.c        **** 	while(1) {
  65:main.c        **** 		if (resetCommonLines == 1) {
 2709               		.loc 3 65 0
 2710 0024 AF81      		ldd r26,Y+7
 2711 0026 A130      		cpi r26,lo8(1)
 2712 0028 01F4      		brne .L107
 2713               	.LVL192:
 2714               	.L310:
  66:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2715               		.loc 3 66 0
 2716 002a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2717               	.LVL193:
 2718               	.L107:
  67:main.c        **** 		}
  68:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2719               		.loc 3 68 0
 2720 002c 00D0      		rcall USART_Receive
 2721               	.LVL194:
 2722 002e 8093 0000 		sts receivedChar,r24
  69:main.c        **** 		
  70:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  71:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2723               		.loc 3 71 0
 2724 0032 829B      		sbis 0x10,2
 2725 0034 00C0      		rjmp .L108
 2726               	.LVL195:
  72:main.c        **** 			cartMode = GB_MODE;
  73:main.c        **** 			PORTD |= (1<<LED_5V);
 2727               		.loc 3 73 0
 2728 0036 979A      		sbi 0x12,7
  74:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2729               		.loc 3 74 0
 2730 0038 3898      		cbi 0x7,0
  72:main.c        **** 			cartMode = GB_MODE;
 2731               		.loc 3 72 0
 2732 003a 81E0      		ldi r24,lo8(1)
 2733 003c 00C0      		rjmp .L109
 2734               	.LVL196:
 2735               	.L108:
  75:main.c        **** 		}
  76:main.c        **** 		else {
  77:main.c        **** 			cartMode = GBA_MODE;
  78:main.c        **** 			PORTE |= (1<<LED_3V);
 2736               		.loc 3 78 0
 2737 003e 389A      		sbi 0x7,0
  79:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2738               		.loc 3 79 0
 2739 0040 9798      		cbi 0x12,7
  77:main.c        **** 			PORTE |= (1<<LED_3V);
 2740               		.loc 3 77 0
 2741 0042 82E0      		ldi r24,lo8(2)
 2742               	.LVL197:
 2743               	.L109:
  80:main.c        **** 		}
  81:main.c        **** 		
  82:main.c        **** 		// Return the cart mode in use
  83:main.c        **** 		if (receivedChar == CART_MODE) {
 2744               		.loc 3 83 0
 2745 0044 9091 0000 		lds r25,receivedChar
 2746 0048 9334      		cpi r25,lo8(67)
 2747 004a 01F4      		brne .L110
  84:main.c        **** 			USART_Transmit(cartMode);
 2748               		.loc 3 84 0
 2749 004c 00D0      		rcall USART_Transmit
 2750               	.LVL198:
 2751 004e 00C0      		rjmp .L313
 2752               	.LVL199:
 2753               	.L110:
  85:main.c        **** 			stop_timeout_timer();
  86:main.c        **** 		}
  87:main.c        **** 		
  88:main.c        **** 		// Change to GB mode or GBA mode if requested
  89:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2754               		.loc 3 89 0
 2755 0050 9734      		cpi r25,lo8(71)
 2756 0052 01F4      		brne .L112
  90:main.c        **** 			gb_mode();
 2757               		.loc 3 90 0
 2758 0054 00D0      		rcall gb_mode
 2759               	.LVL200:
  91:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
 2760               		.loc 3 91 0
 2761 0056 1092 0000 		sts flashBank1CommandWrites,__zero_reg__
 2762               	.L313:
  92:main.c        **** 			stop_timeout_timer();
 2763               		.loc 3 92 0
 2764 005a 00D0      		rcall stop_timeout_timer
 2765               	.LVL201:
 2766 005c 00C0      		rjmp .L106
 2767               	.LVL202:
 2768               	.L112:
  93:main.c        **** 		}
  94:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2769               		.loc 3 94 0
 2770 005e 9736      		cpi r25,lo8(103)
 2771 0060 01F4      		brne .L113
  95:main.c        **** 			gba_mode();
 2772               		.loc 3 95 0
 2773 0062 00D0      		rcall gba_mode
 2774               	.LVL203:
 2775 0064 00C0      		rjmp .L313
 2776               	.LVL204:
 2777               	.L113:
  96:main.c        **** 			stop_timeout_timer();
  97:main.c        **** 		}
  98:main.c        **** 		
  99:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 100:main.c        **** 		
 101:main.c        **** 		// Set address
 102:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2778               		.loc 3 102 0
 2779 0066 9134      		cpi r25,lo8(65)
 2780 0068 01F4      		brne .L114
 103:main.c        **** 			usart_read_chars(); // Read start address
 2781               		.loc 3 103 0
 2782 006a 00D0      		rcall usart_read_chars
 2783               	.LVL205:
 104:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2784               		.loc 3 104 0
 2785 006c 40E1      		ldi r20,lo8(16)
 2786 006e 50E0      		ldi r21,0
 2787 0070 60E0      		ldi r22,0
 2788 0072 70E0      		ldi r23,0
 2789 0074 80E0      		ldi r24,lo8(receivedBuffer)
 2790 0076 90E0      		ldi r25,hi8(receivedBuffer)
 2791 0078 00D0      		rcall strtol
 2792               	.LVL206:
 2793 007a 6B01      		movw r12,r22
 2794 007c 7C01      		movw r14,r24
 2795               	.LVL207:
 2796 007e 00C0      		rjmp .L106
 2797               	.LVL208:
 2798               	.L114:
 105:main.c        **** 		}
 106:main.c        **** 		
 107:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 108:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2799               		.loc 3 108 0
 2800 0080 9235      		cpi r25,lo8(82)
 2801 0082 01F4      		brne .L115
 109:main.c        **** 			gb_mode();
 2802               		.loc 3 109 0
 2803 0084 00D0      		rcall gb_mode
 2804               	.LVL209:
 110:main.c        **** 			receivedChar = '1';
 2805               		.loc 3 110 0
 2806 0086 B1E3      		ldi r27,lo8(49)
 2807 0088 B093 0000 		sts receivedChar,r27
 2808               	.LVL210:
 2809               	.L116:
 111:main.c        **** 			while (receivedChar == '1') {
 2810               		.loc 3 111 0
 2811 008c 8091 0000 		lds r24,receivedChar
 2812 0090 8133      		cpi r24,lo8(49)
 2813 0092 01F4      		brne .L106
 112:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2814               		.loc 3 112 0
 2815 0094 939A      		sbi 0x12,3
 2816               	.LVL211:
 2817 0096 00E0      		ldi r16,0
 2818 0098 10E0      		ldi r17,0
 2819               	.LVL212:
 2820               	.L117:
 2821               	.LBB205:
 113:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 114:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2822               		.loc 3 114 0 discriminator 3
 2823 009a C801      		movw r24,r16
 2824 009c 8C0D      		add r24,r12
 2825 009e 9D1D      		adc r25,r13
 2826 00a0 00D0      		rcall read_8bit_data
 2827               	.LVL213:
 2828 00a2 00D0      		rcall USART_Transmit
 2829               	.LVL214:
 2830 00a4 0F5F      		subi r16,-1
 2831 00a6 1F4F      		sbci r17,-1
 2832               	.LVL215:
 113:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2833               		.loc 3 113 0 discriminator 3
 2834 00a8 0034      		cpi r16,64
 2835 00aa 1105      		cpc r17,__zero_reg__
 2836 00ac 01F4      		brne .L117
 2837 00ae E0E4      		ldi r30,64
 2838 00b0 CE0E      		add r12,r30
 2839 00b2 D11C      		adc r13,__zero_reg__
 2840 00b4 E11C      		adc r14,__zero_reg__
 2841 00b6 F11C      		adc r15,__zero_reg__
 2842               	.LBE205:
 115:main.c        **** 					address++;
 116:main.c        **** 				}
 117:main.c        **** 				
 118:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2843               		.loc 3 118 0
 2844 00b8 9398      		cbi 0x12,3
 119:main.c        **** 				receivedChar = USART_Receive();
 2845               		.loc 3 119 0
 2846 00ba 00D0      		rcall USART_Receive
 2847               	.LVL216:
 2848 00bc 8093 0000 		sts receivedChar,r24
 2849 00c0 00C0      		rjmp .L116
 2850               	.LVL217:
 2851               	.L115:
 120:main.c        **** 			}
 121:main.c        **** 		}
 122:main.c        **** 		
 123:main.c        **** 		// Read and send 0x4000 bytes of data
 124:main.c        **** 		else if (receivedChar == READ_ROM_4000H) {
 2852               		.loc 3 124 0
 2853 00c2 9135      		cpi r25,lo8(81)
 2854 00c4 01F4      		brne .L119
 125:main.c        **** 			gb_mode();
 2855               		.loc 3 125 0
 2856 00c6 00D0      		rcall gb_mode
 2857               	.LVL218:
 126:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2858               		.loc 3 126 0
 2859 00c8 939A      		sbi 0x12,3
 2860               	.LVL219:
 2861               	.LBB206:
 127:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2862               		.loc 3 127 0
 2863 00ca 00E0      		ldi r16,0
 2864 00cc 10E0      		ldi r17,0
 2865               	.LVL220:
 2866               	.L120:
 128:main.c        **** 				USART_Transmit(read_8bit_data(address));
 2867               		.loc 3 128 0 discriminator 3
 2868 00ce C801      		movw r24,r16
 2869 00d0 8C0D      		add r24,r12
 2870 00d2 9D1D      		adc r25,r13
 2871 00d4 00D0      		rcall read_8bit_data
 2872               	.LVL221:
 2873 00d6 00D0      		rcall USART_Transmit
 2874               	.LVL222:
 127:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2875               		.loc 3 127 0 discriminator 3
 2876 00d8 0F5F      		subi r16,-1
 2877 00da 1F4F      		sbci r17,-1
 2878               	.LVL223:
 2879 00dc 0115      		cp r16,__zero_reg__
 2880 00de F0E4      		ldi r31,64
 2881 00e0 1F07      		cpc r17,r31
 2882 00e2 01F4      		brne .L120
 2883 00e4 20E4      		ldi r18,64
 2884 00e6 D20E      		add r13,r18
 2885 00e8 E11C      		adc r14,__zero_reg__
 2886 00ea F11C      		adc r15,__zero_reg__
 2887 00ec 00C0      		rjmp .L243
 2888               	.LVL224:
 2889               	.L119:
 2890               	.LBE206:
 129:main.c        **** 				address++;
 130:main.c        **** 			}
 131:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 132:main.c        **** 		}
 133:main.c        **** 		
 134:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 135:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2891               		.loc 3 135 0
 2892 00ee 9735      		cpi r25,lo8(87)
 2893 00f0 01F4      		brne .L121
 136:main.c        **** 			gb_mode();
 2894               		.loc 3 136 0
 2895 00f2 00D0      		rcall gb_mode
 2896               	.LVL225:
 137:main.c        **** 			
 138:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 139:main.c        **** 			usart_read_bytes(64);
 2897               		.loc 3 139 0
 2898 00f4 80E4      		ldi r24,lo8(64)
 2899 00f6 90E0      		ldi r25,0
 2900 00f8 00D0      		rcall usart_read_bytes
 2901               	.LVL226:
 140:main.c        **** 			
 141:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2902               		.loc 3 141 0
 2903 00fa 939A      		sbi 0x12,3
 2904               	.LVL227:
 2905 00fc 20E0      		ldi r18,lo8(receivedBuffer)
 2906 00fe A22E      		mov r10,r18
 2907 0100 20E0      		ldi r18,hi8(receivedBuffer)
 2908 0102 B22E      		mov r11,r18
 2909 0104 00E0      		ldi r16,0
 2910 0106 10E0      		ldi r17,0
 2911               	.LVL228:
 2912               	.L122:
 2913               	.LBB207:
 142:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 143:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2914               		.loc 3 143 0 discriminator 3
 2915 0108 D501      		movw r26,r10
 2916 010a 6D91      		ld r22,X+
 2917 010c 5D01      		movw r10,r26
 2918 010e C801      		movw r24,r16
 2919 0110 8C0D      		add r24,r12
 2920 0112 9D1D      		adc r25,r13
 2921 0114 41E0      		ldi r20,lo8(1)
 2922 0116 00D0      		rcall write_8bit_data
 2923               	.LVL229:
 2924 0118 0F5F      		subi r16,-1
 2925 011a 1F4F      		sbci r17,-1
 2926               	.LVL230:
 142:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2927               		.loc 3 142 0 discriminator 3
 2928 011c 0034      		cpi r16,64
 2929 011e 1105      		cpc r17,__zero_reg__
 2930 0120 01F4      		brne .L122
 2931 0122 B0E4      		ldi r27,64
 2932 0124 CB0E      		add r12,r27
 2933 0126 D11C      		adc r13,__zero_reg__
 2934 0128 E11C      		adc r14,__zero_reg__
 2935 012a F11C      		adc r15,__zero_reg__
 2936 012c 00C0      		rjmp .L332
 2937               	.LVL231:
 2938               	.L121:
 2939               	.LBE207:
 144:main.c        **** 				address++;
 145:main.c        **** 			}
 146:main.c        **** 			
 147:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 148:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 149:main.c        **** 		}
 150:main.c        **** 		
 151:main.c        **** 		// Set bank address and write a byte
 152:main.c        **** 		else if (receivedChar == SET_BANK) {
 2940               		.loc 3 152 0
 2941 012e 9234      		cpi r25,lo8(66)
 2942 0130 01F4      		brne .L123
 2943               	.LBB208:
 153:main.c        **** 			gb_mode();
 2944               		.loc 3 153 0
 2945 0132 00D0      		rcall gb_mode
 2946               	.LVL232:
 154:main.c        **** 			
 155:main.c        **** 			usart_read_chars(); // Read start address
 2947               		.loc 3 155 0
 2948 0134 00D0      		rcall usart_read_chars
 2949               	.LVL233:
 156:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2950               		.loc 3 156 0
 2951 0136 40E1      		ldi r20,lo8(16)
 2952 0138 50E0      		ldi r21,0
 2953 013a 60E0      		ldi r22,0
 2954 013c 70E0      		ldi r23,0
 2955 013e 80E0      		ldi r24,lo8(receivedBuffer)
 2956 0140 90E0      		ldi r25,hi8(receivedBuffer)
 2957 0142 00D0      		rcall strtol
 2958               	.LVL234:
 2959 0144 4B01      		movw r8,r22
 2960 0146 5C01      		movw r10,r24
 2961               	.LVL235:
 157:main.c        **** 			
 158:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2962               		.loc 3 158 0
 2963 0148 00D0      		rcall USART_Receive
 2964               	.LVL236:
 2965 014a 8093 0000 		sts receivedChar,r24
 159:main.c        **** 			if (receivedChar == 'B') {
 2966               		.loc 3 159 0
 2967 014e 8234      		cpi r24,lo8(66)
 2968 0150 01F0      		breq .+2
 2969 0152 00C0      		rjmp .L106
 2970               	.LBB209:
 160:main.c        **** 				usart_read_chars(); // Read data
 2971               		.loc 3 160 0
 2972 0154 00D0      		rcall usart_read_chars
 2973               	.LVL237:
 161:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2974               		.loc 3 161 0
 2975 0156 80E0      		ldi r24,lo8(receivedBuffer)
 2976 0158 90E0      		ldi r25,hi8(receivedBuffer)
 2977 015a 00D0      		rcall atoi
 2978               	.LVL238:
 162:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2979               		.loc 3 162 0
 2980 015c 8093 0000 		sts lastBankAccessed,r24
 163:main.c        **** 				
 164:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2981               		.loc 3 164 0
 2982 0160 40E0      		ldi r20,0
 2983 0162 682F      		mov r22,r24
 2984 0164 C401      		movw r24,r8
 2985               	.LVL239:
 2986 0166 00D0      		rcall write_8bit_data
 2987               	.LVL240:
 2988 0168 00C0      		rjmp .L106
 2989               	.LVL241:
 2990               	.L123:
 2991               	.LBE209:
 2992               	.LBE208:
 165:main.c        **** 			}
 166:main.c        **** 		}
 167:main.c        **** 		
 168:main.c        **** 		
 169:main.c        **** 		// ****** Gameboy Advance ******
 170:main.c        **** 		
 171:main.c        **** 		// ---------- ROM ----------
 172:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 173:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2993               		.loc 3 173 0
 2994 016a 9237      		cpi r25,lo8(114)
 2995 016c 01F0      		breq .L124
 2996               		.loc 3 173 0 is_stmt 0 discriminator 1
 2997 016e 9A36      		cpi r25,lo8(106)
 2998 0170 01F4      		brne .L125
 2999               	.L124:
 3000               	.LBB210:
 174:main.c        **** 			gba_mode();
 3001               		.loc 3 174 0 is_stmt 1
 3002 0172 00D0      		rcall gba_mode
 3003               	.LVL242:
 175:main.c        **** 			
 176:main.c        **** 			uint8_t readEnd = 32;
 177:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 3004               		.loc 3 177 0
 3005 0174 8091 0000 		lds r24,receivedChar
 3006 0178 8A36      		cpi r24,lo8(106)
 3007 017a 01F4      		brne .L250
 178:main.c        **** 				readEnd = 128;
 3008               		.loc 3 178 0
 3009 017c 10E8      		ldi r17,lo8(-128)
 3010 017e 00C0      		rjmp .L126
 3011               	.L250:
 176:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 3012               		.loc 3 176 0
 3013 0180 10E2      		ldi r17,lo8(32)
 3014               	.L126:
 3015               	.LVL243:
 179:main.c        **** 			}
 180:main.c        **** 			
 181:main.c        **** 			receivedChar = '1';
 3016               		.loc 3 181 0
 3017 0182 E1E3      		ldi r30,lo8(49)
 3018 0184 E093 0000 		sts receivedChar,r30
 3019 0188 8824      		clr r8
 3020 018a 8A94      		dec r8
 3021 018c 810E      		add r8,r17
 3022 018e 912C      		mov r9,__zero_reg__
 3023 0190 A12C      		mov r10,__zero_reg__
 3024 0192 B12C      		mov r11,__zero_reg__
 3025 0194 FFEF      		ldi r31,-1
 3026 0196 8F1A      		sub r8,r31
 3027 0198 9F0A      		sbc r9,r31
 3028 019a AF0A      		sbc r10,r31
 3029 019c BF0A      		sbc r11,r31
 3030               	.LVL244:
 3031               	.L127:
 182:main.c        **** 			while (receivedChar == '1') {
 3032               		.loc 3 182 0
 3033 019e 8091 0000 		lds r24,receivedChar
 3034 01a2 8133      		cpi r24,lo8(49)
 3035 01a4 01F0      		breq .+2
 3036 01a6 00C0      		rjmp .L106
 183:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3037               		.loc 3 183 0
 3038 01a8 939A      		sbi 0x12,3
 3039               	.LVL245:
 3040 01aa 2601      		movw r4,r12
 3041 01ac 3701      		movw r6,r14
 3042               	.LVL246:
 3043               	.L128:
 3044               	.LBB211:
 3045               	.LBB212:
 184:main.c        **** 				
 185:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 186:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 3046               		.loc 3 186 0 discriminator 3
 3047 01ae C301      		movw r24,r6
 3048 01b0 B201      		movw r22,r4
 3049 01b2 00D0      		rcall gba_read_16bit_data
 3050               	.LVL247:
 3051 01b4 092F      		mov r16,r25
 3052               	.LVL248:
 187:main.c        **** 					
 188:main.c        **** 					// Low byte & High byte
 189:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 3053               		.loc 3 189 0 discriminator 3
 3054 01b6 00D0      		rcall USART_Transmit
 3055               	.LVL249:
 190:main.c        **** 					USART_Transmit(dataRead >> 8);
 3056               		.loc 3 190 0 discriminator 3
 3057 01b8 802F      		mov r24,r16
 3058 01ba 00D0      		rcall USART_Transmit
 3059               	.LVL250:
 191:main.c        **** 					
 192:main.c        **** 					address++;
 3060               		.loc 3 192 0 discriminator 3
 3061 01bc 2FEF      		ldi r18,-1
 3062 01be 421A      		sub r4,r18
 3063 01c0 520A      		sbc r5,r18
 3064 01c2 620A      		sbc r6,r18
 3065 01c4 720A      		sbc r7,r18
 3066               	.LVL251:
 3067               	.LBE212:
 185:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 3068               		.loc 3 185 0 discriminator 3
 3069 01c6 842D      		mov r24,r4
 3070 01c8 8C19      		sub r24,r12
 3071 01ca 8117      		cp r24,r17
 3072 01cc 00F0      		brlo .L128
 3073 01ce C80C      		add r12,r8
 3074 01d0 D91C      		adc r13,r9
 3075 01d2 EA1C      		adc r14,r10
 3076 01d4 FB1C      		adc r15,r11
 3077               	.LVL252:
 3078               	.LBE211:
 193:main.c        **** 				}
 194:main.c        **** 				
 195:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3079               		.loc 3 195 0
 3080 01d6 9398      		cbi 0x12,3
 196:main.c        **** 				receivedChar = USART_Receive();
 3081               		.loc 3 196 0
 3082 01d8 00D0      		rcall USART_Receive
 3083               	.LVL253:
 3084 01da 8093 0000 		sts receivedChar,r24
 3085 01de 00C0      		rjmp .L127
 3086               	.LVL254:
 3087               	.L125:
 3088               	.LBE210:
 197:main.c        **** 			}
 198:main.c        **** 		}
 199:main.c        **** 		
 200:main.c        **** 		// Read and send 0x10000 bytes of data
 201:main.c        **** 		else if (receivedChar == GBA_READ_ROM_8000H) {
 3089               		.loc 3 201 0
 3090 01e0 9A35      		cpi r25,lo8(90)
 3091 01e2 01F4      		brne .L130
 202:main.c        **** 			gba_mode();
 3092               		.loc 3 202 0
 3093 01e4 00D0      		rcall gba_mode
 3094               	.LVL255:
 203:main.c        **** 			
 204:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3095               		.loc 3 204 0
 3096 01e6 939A      		sbi 0x12,3
 205:main.c        **** 			gba_set_24bit_address(address);
 3097               		.loc 3 205 0
 3098 01e8 C701      		movw r24,r14
 3099 01ea B601      		movw r22,r12
 3100 01ec 00D0      		rcall gba_set_24bit_address
 3101               	.LVL256:
 206:main.c        **** 			cs_mreqPin_low;
 3102               		.loc 3 206 0
 3103 01ee 9498      		cbi 0x12,4
 207:main.c        **** 			
 208:main.c        **** 			GBA_PORT_ROM_ADDR15_8 = 0;
 3104               		.loc 3 208 0
 3105 01f0 1BBA      		out 0x1b,__zero_reg__
 209:main.c        **** 			GBA_PORT_ROM_ADDR7_0 = 0;
 3106               		.loc 3 209 0
 3107 01f2 18BA      		out 0x18,__zero_reg__
 210:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0;
 3108               		.loc 3 210 0
 3109 01f4 1ABA      		out 0x1a,__zero_reg__
 211:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0;
 3110               		.loc 3 211 0
 3111 01f6 17BA      		out 0x17,__zero_reg__
 3112               	.LVL257:
 3113               	.LBB213:
 212:main.c        **** 			
 213:main.c        **** 			for (uint16_t x = 0; x < 0x8000; x++) {
 3114               		.loc 3 213 0
 3115 01f8 00E0      		ldi r16,0
 3116 01fa 10E0      		ldi r17,0
 3117               	.LVL258:
 3118               	.L131:
 3119               		.loc 3 213 0 is_stmt 0 discriminator 1
 3120 01fc 17FD      		sbrc r17,7
 3121 01fe 00C0      		rjmp .L333
 214:main.c        **** 				rdPin_low;
 3122               		.loc 3 214 0 is_stmt 1 discriminator 3
 3123 0200 9598      		cbi 0x12,5
 215:main.c        **** 				asm volatile("nop");
 3124               		.loc 3 215 0 discriminator 3
 3125               	/* #APP */
 3126               	 ;  215 "main.c" 1
 3127 0202 0000      		nop
 3128               	 ;  0 "" 2
 216:main.c        **** 				
 217:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA7_0);
 3129               		.loc 3 217 0 discriminator 3
 3130               	/* #NOAPP */
 3131 0204 86B3      		in r24,0x16
 3132 0206 00D0      		rcall USART_Transmit
 3133               	.LVL259:
 218:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA15_8);
 3134               		.loc 3 218 0 discriminator 3
 3135 0208 89B3      		in r24,0x19
 3136 020a 00D0      		rcall USART_Transmit
 3137               	.LVL260:
 219:main.c        **** 				rdPin_high;
 3138               		.loc 3 219 0 discriminator 3
 3139 020c 959A      		sbi 0x12,5
 213:main.c        **** 				rdPin_low;
 3140               		.loc 3 213 0 discriminator 3
 3141 020e 0F5F      		subi r16,-1
 3142 0210 1F4F      		sbci r17,-1
 3143               	.LVL261:
 3144 0212 00C0      		rjmp .L131
 3145               	.L333:
 3146               	.LBE213:
 220:main.c        **** 			}
 221:main.c        **** 			address += 0x8000;
 3147               		.loc 3 221 0
 3148 0214 80E8      		ldi r24,-128
 3149 0216 D80E      		add r13,r24
 3150 0218 E11C      		adc r14,__zero_reg__
 3151 021a F11C      		adc r15,__zero_reg__
 3152               	.LVL262:
 3153 021c 00C0      		rjmp .L243
 3154               	.LVL263:
 3155               	.L130:
 222:main.c        **** 			
 223:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// ---------- SRAM ----------
 227:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 228:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 3156               		.loc 3 228 0
 3157 021e 9D36      		cpi r25,lo8(109)
 3158 0220 01F4      		brne .L133
 229:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 3159               		.loc 3 229 0
 3160 0222 00D0      		rcall gb_mode
 3161               	.LVL264:
 230:main.c        **** 			
 231:main.c        **** 			receivedChar = '1';
 3162               		.loc 3 231 0
 3163 0224 91E3      		ldi r25,lo8(49)
 3164 0226 9093 0000 		sts receivedChar,r25
 3165               	.LVL265:
 3166               	.L134:
 232:main.c        **** 			while (receivedChar == '1') {
 3167               		.loc 3 232 0
 3168 022a 8091 0000 		lds r24,receivedChar
 3169 022e 8133      		cpi r24,lo8(49)
 3170 0230 01F4      		brne .L317
 233:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3171               		.loc 3 233 0
 3172 0232 939A      		sbi 0x12,3
 3173               	.LVL266:
 3174 0234 00E0      		ldi r16,0
 3175 0236 10E0      		ldi r17,0
 3176               	.LVL267:
 3177               	.L135:
 3178               	.LBB214:
 234:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 235:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 3179               		.loc 3 235 0 discriminator 3
 3180 0238 C801      		movw r24,r16
 3181 023a 8C0D      		add r24,r12
 3182 023c 9D1D      		adc r25,r13
 3183 023e 00D0      		rcall gba_read_ram_8bit_data
 3184               	.LVL268:
 3185 0240 00D0      		rcall USART_Transmit
 3186               	.LVL269:
 3187 0242 0F5F      		subi r16,-1
 3188 0244 1F4F      		sbci r17,-1
 3189               	.LVL270:
 234:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3190               		.loc 3 234 0 discriminator 3
 3191 0246 0034      		cpi r16,64
 3192 0248 1105      		cpc r17,__zero_reg__
 3193 024a 01F4      		brne .L135
 3194 024c A0E4      		ldi r26,64
 3195 024e CA0E      		add r12,r26
 3196 0250 D11C      		adc r13,__zero_reg__
 3197 0252 E11C      		adc r14,__zero_reg__
 3198 0254 F11C      		adc r15,__zero_reg__
 3199               	.LBE214:
 236:main.c        **** 					address++;
 237:main.c        **** 				}
 238:main.c        **** 				
 239:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3200               		.loc 3 239 0
 3201 0256 9398      		cbi 0x12,3
 240:main.c        **** 				receivedChar = USART_Receive();
 3202               		.loc 3 240 0
 3203 0258 00D0      		rcall USART_Receive
 3204               	.LVL271:
 3205 025a 8093 0000 		sts receivedChar,r24
 3206 025e 00C0      		rjmp .L134
 3207               	.LVL272:
 3208               	.L133:
 241:main.c        **** 			}
 242:main.c        **** 			
 243:main.c        **** 			gba_mode(); // Set back
 244:main.c        **** 		}
 245:main.c        **** 		
 246:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 247:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 3209               		.loc 3 247 0
 3210 0260 9737      		cpi r25,lo8(119)
 3211 0262 01F4      		brne .L137
 248:main.c        **** 			gb_mode();
 3212               		.loc 3 248 0
 3213 0264 00D0      		rcall gb_mode
 3214               	.LVL273:
 249:main.c        **** 			
 250:main.c        **** 			usart_read_bytes(64);
 3215               		.loc 3 250 0
 3216 0266 80E4      		ldi r24,lo8(64)
 3217 0268 90E0      		ldi r25,0
 3218 026a 00D0      		rcall usart_read_bytes
 3219               	.LVL274:
 251:main.c        **** 			
 252:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3220               		.loc 3 252 0
 3221 026c 939A      		sbi 0x12,3
 3222               	.LVL275:
 3223 026e 90E0      		ldi r25,lo8(receivedBuffer)
 3224 0270 A92E      		mov r10,r25
 3225 0272 90E0      		ldi r25,hi8(receivedBuffer)
 3226 0274 B92E      		mov r11,r25
 3227 0276 00E0      		ldi r16,0
 3228 0278 10E0      		ldi r17,0
 3229               	.LVL276:
 3230               	.L138:
 3231               	.LBB215:
 253:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 254:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 3232               		.loc 3 254 0 discriminator 3
 3233 027a F501      		movw r30,r10
 3234 027c 6191      		ld r22,Z+
 3235 027e 5F01      		movw r10,r30
 3236 0280 C801      		movw r24,r16
 3237 0282 8C0D      		add r24,r12
 3238 0284 9D1D      		adc r25,r13
 3239 0286 00D0      		rcall gba_write_ram_8bit_data
 3240               	.LVL277:
 3241 0288 0F5F      		subi r16,-1
 3242 028a 1F4F      		sbci r17,-1
 3243               	.LVL278:
 253:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3244               		.loc 3 253 0 discriminator 3
 3245 028c 0034      		cpi r16,64
 3246 028e 1105      		cpc r17,__zero_reg__
 3247 0290 01F4      		brne .L138
 3248 0292 F0E4      		ldi r31,64
 3249 0294 CF0E      		add r12,r31
 3250 0296 D11C      		adc r13,__zero_reg__
 3251 0298 E11C      		adc r14,__zero_reg__
 3252 029a F11C      		adc r15,__zero_reg__
 3253               	.LVL279:
 3254               	.L318:
 3255               	.LBE215:
 255:main.c        **** 				address++;
 256:main.c        **** 			}
 257:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3256               		.loc 3 257 0
 3257 029c 81E3      		ldi r24,lo8(49)
 3258 029e 00D0      		rcall USART_Transmit
 3259               	.LVL280:
 258:main.c        **** 			
 259:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3260               		.loc 3 259 0
 3261 02a0 9398      		cbi 0x12,3
 3262               	.L317:
 260:main.c        **** 			gba_mode(); // Set back
 3263               		.loc 3 260 0
 3264 02a2 00D0      		rcall gba_mode
 3265               	.LVL281:
 3266 02a4 00C0      		rjmp .L106
 3267               	.LVL282:
 3268               	.L137:
 261:main.c        **** 		}
 262:main.c        **** 		
 263:main.c        **** 		// Write 1 byte to SRAM address
 264:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 3269               		.loc 3 264 0
 3270 02a6 9F36      		cpi r25,lo8(111)
 3271 02a8 01F4      		brne .L139
 3272               	.LBB216:
 265:main.c        **** 			gb_mode();
 3273               		.loc 3 265 0
 3274 02aa 00D0      		rcall gb_mode
 3275               	.LVL283:
 266:main.c        **** 			
 267:main.c        **** 			uint8_t data = USART_Receive();
 3276               		.loc 3 267 0
 3277 02ac 00D0      		rcall USART_Receive
 3278               	.LVL284:
 268:main.c        **** 			gba_write_ram_8bit_data(address, data);
 3279               		.loc 3 268 0
 3280 02ae 682F      		mov r22,r24
 3281 02b0 C601      		movw r24,r12
 3282               	.LVL285:
 3283 02b2 00D0      		rcall gba_write_ram_8bit_data
 3284               	.LVL286:
 3285 02b4 00C0      		rjmp .L320
 3286               	.LVL287:
 3287               	.L139:
 3288               	.LBE216:
 269:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		
 275:main.c        **** 		// ---------- FLASH ----------
 276:main.c        **** 		// Read the Flash Manufacturer and Device ID
 277:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 3289               		.loc 3 277 0
 3290 02b6 9936      		cpi r25,lo8(105)
 3291 02b8 01F4      		brne .L140
 278:main.c        **** 			gb_mode();
 3292               		.loc 3 278 0
 3293 02ba 00D0      		rcall gb_mode
 3294               	.LVL288:
 279:main.c        **** 			
 280:main.c        **** 			flash_read_chip_id();
 3295               		.loc 3 280 0
 3296 02bc 00D0      		rcall flash_read_chip_id
 3297               	.LVL289:
 281:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 3298               		.loc 3 281 0
 3299 02be 8091 0000 		lds r24,flashChipIdBuffer
 3300 02c2 00D0      		rcall USART_Transmit
 3301               	.LVL290:
 282:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 3302               		.loc 3 282 0
 3303 02c4 8091 0000 		lds r24,flashChipIdBuffer+1
 3304               	.L319:
 3305 02c8 00D0      		rcall USART_Transmit
 3306               	.LVL291:
 3307 02ca 00C0      		rjmp .L317
 3308               	.LVL292:
 3309               	.L140:
 283:main.c        **** 			
 284:main.c        **** 			gba_mode(); // Set back
 285:main.c        **** 		}
 286:main.c        **** 		
 287:main.c        **** 		// Change bank
 288:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 3310               		.loc 3 288 0
 3311 02cc 9B36      		cpi r25,lo8(107)
 3312 02ce 01F4      		brne .L141
 3313               	.LBB217:
 289:main.c        **** 			usart_read_chars(); // Read data
 3314               		.loc 3 289 0
 3315 02d0 00D0      		rcall usart_read_chars
 3316               	.LVL293:
 290:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3317               		.loc 3 290 0
 3318 02d2 80E0      		ldi r24,lo8(receivedBuffer)
 3319 02d4 90E0      		ldi r25,hi8(receivedBuffer)
 3320 02d6 00D0      		rcall atoi
 3321               	.LVL294:
 3322 02d8 182F      		mov r17,r24
 3323               	.LVL295:
 291:main.c        **** 			
 292:main.c        **** 			gb_mode();
 3324               		.loc 3 292 0
 3325 02da 00D0      		rcall gb_mode
 3326               	.LVL296:
 293:main.c        **** 			flash_switch_bank(bank);
 3327               		.loc 3 293 0
 3328 02dc 812F      		mov r24,r17
 3329 02de 00D0      		rcall flash_switch_bank
 3330               	.LVL297:
 3331 02e0 00C0      		rjmp .L317
 3332               	.LVL298:
 3333               	.L141:
 3334               	.LBE217:
 294:main.c        **** 			
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 3335               		.loc 3 299 0
 3336 02e2 9337      		cpi r25,lo8(115)
 3337 02e4 01F4      		brne .L142
 3338               	.LBB218:
 300:main.c        **** 			gb_mode();
 3339               		.loc 3 300 0
 3340 02e6 00D0      		rcall gb_mode
 3341               	.LVL299:
 301:main.c        **** 			
 302:main.c        **** 			usart_read_chars(); // Read sector
 3342               		.loc 3 302 0
 3343 02e8 00D0      		rcall usart_read_chars
 3344               	.LVL300:
 303:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3345               		.loc 3 303 0
 3346 02ea 40E1      		ldi r20,lo8(16)
 3347 02ec 50E0      		ldi r21,0
 3348 02ee 60E0      		ldi r22,0
 3349 02f0 70E0      		ldi r23,0
 3350 02f2 80E0      		ldi r24,lo8(receivedBuffer)
 3351 02f4 90E0      		ldi r25,hi8(receivedBuffer)
 3352 02f6 00D0      		rcall strtol
 3353               	.LVL301:
 3354 02f8 862F      		mov r24,r22
 3355               	.LVL302:
 304:main.c        **** 			
 305:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 3356               		.loc 3 305 0
 3357 02fa 00D0      		rcall flash_erase_4k_sector
 3358               	.LVL303:
 3359               	.L320:
 306:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3360               		.loc 3 306 0
 3361 02fc 81E3      		ldi r24,lo8(49)
 3362 02fe 00C0      		rjmp .L319
 3363               	.LVL304:
 3364               	.L142:
 3365               	.LBE218:
 307:main.c        **** 			
 308:main.c        **** 			gba_mode(); // Set back
 309:main.c        **** 		}
 310:main.c        **** 		
 311:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 312:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 3366               		.loc 3 312 0
 3367 0300 9236      		cpi r25,lo8(98)
 3368 0302 01F4      		brne .L143
 313:main.c        **** 			gb_mode();
 3369               		.loc 3 313 0
 3370 0304 00D0      		rcall gb_mode
 3371               	.LVL305:
 314:main.c        **** 			
 315:main.c        **** 			usart_read_bytes(64);
 3372               		.loc 3 315 0
 3373 0306 80E4      		ldi r24,lo8(64)
 3374 0308 90E0      		ldi r25,0
 3375 030a 00D0      		rcall usart_read_bytes
 3376               	.LVL306:
 316:main.c        **** 			
 317:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3377               		.loc 3 317 0
 3378 030c 939A      		sbi 0x12,3
 3379               	.LVL307:
 3380 030e 80E0      		ldi r24,lo8(receivedBuffer)
 3381 0310 A82E      		mov r10,r24
 3382 0312 80E0      		ldi r24,hi8(receivedBuffer)
 3383 0314 B82E      		mov r11,r24
 3384 0316 00E0      		ldi r16,0
 3385 0318 10E0      		ldi r17,0
 3386               	.LVL308:
 3387               	.L144:
 3388               	.LBB219:
 318:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 319:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3389               		.loc 3 319 0 discriminator 3
 3390 031a D501      		movw r26,r10
 3391 031c 6D91      		ld r22,X+
 3392 031e 5D01      		movw r10,r26
 3393 0320 C801      		movw r24,r16
 3394 0322 8C0D      		add r24,r12
 3395 0324 9D1D      		adc r25,r13
 3396 0326 00D0      		rcall flash_write_byte
 3397               	.LVL309:
 3398 0328 0F5F      		subi r16,-1
 3399 032a 1F4F      		sbci r17,-1
 3400               	.LVL310:
 318:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3401               		.loc 3 318 0 discriminator 3
 3402 032c 0034      		cpi r16,64
 3403 032e 1105      		cpc r17,__zero_reg__
 3404 0330 01F4      		brne .L144
 3405 0332 B0E4      		ldi r27,64
 3406 0334 CB0E      		add r12,r27
 3407 0336 D11C      		adc r13,__zero_reg__
 3408 0338 E11C      		adc r14,__zero_reg__
 3409 033a F11C      		adc r15,__zero_reg__
 3410 033c 00C0      		rjmp .L318
 3411               	.LVL311:
 3412               	.L143:
 3413               	.LBE219:
 320:main.c        **** 				address++;
 321:main.c        **** 			}
 322:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 323:main.c        **** 			
 324:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 325:main.c        **** 			gba_mode(); // Set back
 326:main.c        **** 		}
 327:main.c        **** 		
 328:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 329:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 3414               		.loc 3 329 0
 3415 033e 9136      		cpi r25,lo8(97)
 3416 0340 01F4      		brne .L145
 330:main.c        **** 			gb_mode();
 3417               		.loc 3 330 0
 3418 0342 00D0      		rcall gb_mode
 3419               	.LVL312:
 331:main.c        **** 			
 332:main.c        **** 			usart_read_bytes(128);
 3420               		.loc 3 332 0
 3421 0344 80E8      		ldi r24,lo8(-128)
 3422 0346 90E0      		ldi r25,0
 3423 0348 00D0      		rcall usart_read_bytes
 3424               	.LVL313:
 333:main.c        **** 			
 334:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3425               		.loc 3 334 0
 3426 034a 939A      		sbi 0x12,3
 335:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3427               		.loc 3 335 0
 3428 034c C601      		movw r24,r12
 3429 034e 00D0      		rcall flash_write_sector
 3430               	.LVL314:
 336:main.c        **** 			address++;
 3431               		.loc 3 336 0
 3432 0350 EFEF      		ldi r30,-1
 3433 0352 CE1A      		sub r12,r30
 3434 0354 DE0A      		sbc r13,r30
 3435 0356 EE0A      		sbc r14,r30
 3436 0358 FE0A      		sbc r15,r30
 3437               	.LVL315:
 3438 035a 00C0      		rjmp .L318
 3439               	.LVL316:
 3440               	.L145:
 337:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 338:main.c        **** 			
 339:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		
 344:main.c        **** 		// ---------- EEPROM ----------
 345:main.c        **** 		// Set EEPROM size
 346:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 3441               		.loc 3 346 0
 3442 035c 9335      		cpi r25,lo8(83)
 3443 035e 01F4      		brne .L146
 347:main.c        **** 			usart_read_chars(); // Read size
 3444               		.loc 3 347 0
 3445 0360 00D0      		rcall usart_read_chars
 3446               	.LVL317:
 348:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3447               		.loc 3 348 0
 3448 0362 40E1      		ldi r20,lo8(16)
 3449 0364 50E0      		ldi r21,0
 3450 0366 60E0      		ldi r22,0
 3451 0368 70E0      		ldi r23,0
 3452 036a 80E0      		ldi r24,lo8(receivedBuffer)
 3453 036c 90E0      		ldi r25,hi8(receivedBuffer)
 3454 036e 00D0      		rcall strtol
 3455               	.LVL318:
 3456 0370 6887      		std Y+8,r22
 3457               	.LVL319:
 3458 0372 00C0      		rjmp .L106
 3459               	.LVL320:
 3460               	.L146:
 349:main.c        **** 		}
 350:main.c        **** 		
 351:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 352:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 3461               		.loc 3 352 0
 3462 0374 9536      		cpi r25,lo8(101)
 3463 0376 01F4      		brne .L147
 353:main.c        **** 			gba_eeprom_mode();
 3464               		.loc 3 353 0
 3465 0378 00D0      		rcall gba_eeprom_mode
 3466               	.LVL321:
 354:main.c        **** 			
 355:main.c        **** 			receivedChar = '1';
 3467               		.loc 3 355 0
 3468 037a F1E3      		ldi r31,lo8(49)
 3469 037c F093 0000 		sts receivedChar,r31
 3470               	.L148:
 356:main.c        **** 			while (receivedChar == '1') {
 3471               		.loc 3 356 0
 3472 0380 8091 0000 		lds r24,receivedChar
 3473 0384 8133      		cpi r24,lo8(49)
 3474 0386 01F0      		breq .+2
 3475 0388 00C0      		rjmp .L317
 357:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3476               		.loc 3 357 0
 3477 038a 939A      		sbi 0x12,3
 358:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3478               		.loc 3 358 0
 3479 038c 6885      		ldd r22,Y+8
 3480 038e C601      		movw r24,r12
 3481 0390 00D0      		rcall gba_eeprom_read
 3482               	.LVL322:
 3483 0392 00E0      		ldi r16,lo8(eepromBuffer)
 3484 0394 10E0      		ldi r17,hi8(eepromBuffer)
 3485               	.LVL323:
 3486               	.L149:
 3487               	.LBB220:
 359:main.c        **** 				
 360:main.c        **** 				// Send back the 8 bytes of data
 361:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 362:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3488               		.loc 3 362 0 discriminator 3
 3489 0396 D801      		movw r26,r16
 3490 0398 8D91      		ld r24,X+
 3491 039a 8D01      		movw r16,r26
 3492               	.LVL324:
 3493 039c 00D0      		rcall USART_Transmit
 3494               	.LVL325:
 361:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3495               		.loc 3 361 0 discriminator 3
 3496 039e E0E0      		ldi r30,lo8(eepromBuffer+8)
 3497 03a0 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3498 03a2 E017      		cp r30,r16
 3499 03a4 F107      		cpc r31,r17
 3500 03a6 01F4      		brne .L149
 3501               	.LBE220:
 363:main.c        **** 				}
 364:main.c        **** 				address++; // Increment to next 8 bytes
 3502               		.loc 3 364 0
 3503 03a8 FFEF      		ldi r31,-1
 3504 03aa CF1A      		sub r12,r31
 3505 03ac DF0A      		sbc r13,r31
 3506 03ae EF0A      		sbc r14,r31
 3507 03b0 FF0A      		sbc r15,r31
 3508               	.LVL326:
 365:main.c        **** 				
 366:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3509               		.loc 3 366 0
 3510 03b2 9398      		cbi 0x12,3
 367:main.c        **** 				receivedChar = USART_Receive();
 3511               		.loc 3 367 0
 3512 03b4 00D0      		rcall USART_Receive
 3513               	.LVL327:
 3514 03b6 8093 0000 		sts receivedChar,r24
 3515 03ba 00C0      		rjmp .L148
 3516               	.LVL328:
 3517               	.L147:
 368:main.c        **** 			}
 369:main.c        **** 			
 370:main.c        **** 			gba_mode(); // Set back
 371:main.c        **** 		}
 372:main.c        **** 		
 373:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 374:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3518               		.loc 3 374 0
 3519 03bc 9037      		cpi r25,lo8(112)
 3520 03be 01F4      		brne .L151
 375:main.c        **** 			gba_eeprom_mode();
 3521               		.loc 3 375 0
 3522 03c0 00D0      		rcall gba_eeprom_mode
 3523               	.LVL329:
 3524 03c2 00E0      		ldi r16,lo8(eepromBuffer)
 3525 03c4 10E0      		ldi r17,hi8(eepromBuffer)
 3526               	.LVL330:
 3527               	.L152:
 3528               	.LBB221:
 376:main.c        **** 			
 377:main.c        **** 			// Read 8 bytes from USART and place in buffer
 378:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 379:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3529               		.loc 3 379 0 discriminator 3
 3530 03c6 00D0      		rcall USART_Receive
 3531               	.LVL331:
 3532 03c8 D801      		movw r26,r16
 3533 03ca 8D93      		st X+,r24
 3534 03cc 8D01      		movw r16,r26
 3535               	.LVL332:
 378:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3536               		.loc 3 378 0 discriminator 3
 3537 03ce E0E0      		ldi r30,lo8(eepromBuffer+8)
 3538 03d0 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3539 03d2 EA17      		cp r30,r26
 3540 03d4 FB07      		cpc r31,r27
 3541 03d6 01F4      		brne .L152
 3542               	.LBE221:
 380:main.c        **** 			}
 381:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3543               		.loc 3 381 0
 3544 03d8 939A      		sbi 0x12,3
 382:main.c        **** 			
 383:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3545               		.loc 3 383 0
 3546 03da 6885      		ldd r22,Y+8
 3547 03dc C601      		movw r24,r12
 3548 03de 00D0      		rcall gba_eeprom_write
 3549               	.LVL333:
 384:main.c        **** 			address++;
 3550               		.loc 3 384 0
 3551 03e0 FFEF      		ldi r31,-1
 3552 03e2 CF1A      		sub r12,r31
 3553 03e4 DF0A      		sbc r13,r31
 3554 03e6 EF0A      		sbc r14,r31
 3555 03e8 FF0A      		sbc r15,r31
 3556               	.LVL334:
 3557               	.LBB222:
 3558               	.LBB223:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3559               		.loc 2 187 0
 3560 03ea 8FE7      		ldi r24,lo8(15999)
 3561 03ec 9EE3      		ldi r25,hi8(15999)
 3562 03ee 0197      	1:	sbiw r24,1
 3563 03f0 01F4      		brne 1b
 3564 03f2 00C0      		rjmp .
 3565 03f4 0000      		nop
 3566               	.LVL335:
 3567 03f6 00C0      		rjmp .L318
 3568               	.LVL336:
 3569               	.L151:
 3570               	.LBE223:
 3571               	.LBE222:
 385:main.c        **** 			
 386:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 387:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 388:main.c        **** 			
 389:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 390:main.c        **** 			gba_mode(); // Set back
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		
 394:main.c        **** 		// ---------- GB FLASH CARTS ----------
 395:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 396:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3572               		.loc 3 396 0
 3573 03f8 9035      		cpi r25,lo8(80)
 3574 03fa 01F4      		brne .L153
 397:main.c        **** 			flashWriteWePin = USART_Receive();
 3575               		.loc 3 397 0
 3576 03fc 00D0      		rcall USART_Receive
 3577               	.LVL337:
 3578 03fe 8093 0000 		sts flashWriteWePin,r24
 398:main.c        **** 			
 399:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3579               		.loc 3 399 0
 3580 0402 8134      		cpi r24,lo8(65)
 3581 0404 01F0      		breq .+2
 3582 0406 00C0      		rjmp .L106
 400:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3583               		.loc 3 400 0
 3584 0408 319A      		sbi 0x6,1
 401:main.c        **** 				audioPin_high;
 3585               		.loc 3 401 0
 3586 040a 399A      		sbi 0x7,1
 3587 040c 00C0      		rjmp .L106
 3588               	.LVL338:
 3589               	.L153:
 402:main.c        **** 			}
 403:main.c        **** 		}
 404:main.c        **** 		
 405:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 406:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3590               		.loc 3 406 0
 3591 040e 9E34      		cpi r25,lo8(78)
 3592 0410 01F4      		brne .L154
 407:main.c        **** 			flashBank1CommandWrites = 1;
 3593               		.loc 3 407 0
 3594 0412 91E0      		ldi r25,lo8(1)
 3595 0414 9093 0000 		sts flashBank1CommandWrites,r25
 3596 0418 00C0      		rjmp .L106
 3597               	.L154:
 408:main.c        **** 		}
 409:main.c        **** 		
 410:main.c        **** 		// Load the program method to use
 411:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3598               		.loc 3 411 0
 3599 041a 9534      		cpi r25,lo8(69)
 3600 041c 01F4      		brne .L155
 3601 041e 00E0      		ldi r16,lo8(flashWriteCycle)
 3602 0420 10E0      		ldi r17,hi8(flashWriteCycle)
 3603               	.LVL339:
 3604               	.L156:
 3605               	.LBB224:
 412:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 413:main.c        **** 				usart_read_chars(); // Address
 3606               		.loc 3 413 0 discriminator 3
 3607 0422 00D0      		rcall usart_read_chars
 3608               	.LVL340:
 414:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3609               		.loc 3 414 0 discriminator 3
 3610 0424 40E1      		ldi r20,lo8(16)
 3611 0426 50E0      		ldi r21,0
 3612 0428 60E0      		ldi r22,0
 3613 042a 70E0      		ldi r23,0
 3614 042c 80E0      		ldi r24,lo8(receivedBuffer)
 3615 042e 90E0      		ldi r25,hi8(receivedBuffer)
 3616 0430 00D0      		rcall strtol
 3617               	.LVL341:
 3618 0432 D801      		movw r26,r16
 3619 0434 6D93      		st X+,r22
 3620 0436 7C93      		st X,r23
 415:main.c        **** 				USART_Transmit(SEND_ACK);
 3621               		.loc 3 415 0 discriminator 3
 3622 0438 81E3      		ldi r24,lo8(49)
 3623 043a 00D0      		rcall USART_Transmit
 3624               	.LVL342:
 416:main.c        **** 				
 417:main.c        **** 				usart_read_chars(); // Data
 3625               		.loc 3 417 0 discriminator 3
 3626 043c 00D0      		rcall usart_read_chars
 3627               	.LVL343:
 418:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3628               		.loc 3 418 0 discriminator 3
 3629 043e 40E1      		ldi r20,lo8(16)
 3630 0440 50E0      		ldi r21,0
 3631 0442 60E0      		ldi r22,0
 3632 0444 70E0      		ldi r23,0
 3633 0446 80E0      		ldi r24,lo8(receivedBuffer)
 3634 0448 90E0      		ldi r25,hi8(receivedBuffer)
 3635 044a 00D0      		rcall strtol
 3636               	.LVL344:
 3637 044c F801      		movw r30,r16
 3638 044e 7383      		std Z+3,r23
 3639 0450 6283      		std Z+2,r22
 419:main.c        **** 				USART_Transmit(SEND_ACK);
 3640               		.loc 3 419 0 discriminator 3
 3641 0452 81E3      		ldi r24,lo8(49)
 3642 0454 00D0      		rcall USART_Transmit
 3643               	.LVL345:
 3644 0456 0C5F      		subi r16,-4
 3645 0458 1F4F      		sbci r17,-1
 412:main.c        **** 				usart_read_chars(); // Address
 3646               		.loc 3 412 0 discriminator 3
 3647 045a F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3648 045c 0030      		cpi r16,lo8(flashWriteCycle+12)
 3649 045e 1F07      		cpc r17,r31
 3650 0460 01F4      		brne .L156
 3651 0462 00C0      		rjmp .L106
 3652               	.LVL346:
 3653               	.L155:
 3654               	.LBE224:
 420:main.c        **** 			}
 421:main.c        **** 		}
 422:main.c        **** 		
 423:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 424:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3655               		.loc 3 424 0
 3656 0464 9634      		cpi r25,lo8(70)
 3657 0466 01F4      		brne .L157
 3658               	.LBB225:
 425:main.c        **** 			usart_read_chars(); // Read address
 3659               		.loc 3 425 0
 3660 0468 00D0      		rcall usart_read_chars
 3661               	.LVL347:
 426:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3662               		.loc 3 426 0
 3663 046a 40E1      		ldi r20,lo8(16)
 3664 046c 50E0      		ldi r21,0
 3665 046e 60E0      		ldi r22,0
 3666 0470 70E0      		ldi r23,0
 3667 0472 80E0      		ldi r24,lo8(receivedBuffer)
 3668 0474 90E0      		ldi r25,hi8(receivedBuffer)
 3669 0476 00D0      		rcall strtol
 3670               	.LVL348:
 3671 0478 4B01      		movw r8,r22
 3672 047a 5C01      		movw r10,r24
 3673               	.LVL349:
 427:main.c        **** 			
 428:main.c        **** 			usart_read_chars(); // Read data byte
 3674               		.loc 3 428 0
 3675 047c 00D0      		rcall usart_read_chars
 3676               	.LVL350:
 429:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3677               		.loc 3 429 0
 3678 047e 40E1      		ldi r20,lo8(16)
 3679 0480 50E0      		ldi r21,0
 3680 0482 60E0      		ldi r22,0
 3681 0484 70E0      		ldi r23,0
 3682 0486 80E0      		ldi r24,lo8(receivedBuffer)
 3683 0488 90E0      		ldi r25,hi8(receivedBuffer)
 3684 048a 00D0      		rcall strtol
 3685               	.LVL351:
 430:main.c        **** 			
 431:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3686               		.loc 3 431 0
 3687 048c 939A      		sbi 0x12,3
 432:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3688               		.loc 3 432 0
 3689 048e C401      		movw r24,r8
 3690 0490 00D0      		rcall gb_flash_write_bus_cycle
 3691               	.LVL352:
 3692 0492 00C0      		rjmp .L332
 3693               	.LVL353:
 3694               	.L157:
 3695               	.LBE225:
 433:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 434:main.c        **** 			
 435:main.c        **** 			USART_Transmit(SEND_ACK);
 436:main.c        **** 		}
 437:main.c        **** 		
 438:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 439:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3696               		.loc 3 439 0
 3697 0494 9435      		cpi r25,lo8(84)
 3698 0496 01F4      		brne .L158
 440:main.c        **** 			usart_read_bytes(64);
 3699               		.loc 3 440 0
 3700 0498 80E4      		ldi r24,lo8(64)
 3701 049a 90E0      		ldi r25,0
 3702               	.LVL354:
 3703 049c 00D0      		rcall usart_read_bytes
 3704               	.LVL355:
 441:main.c        **** 			start_timeout_timer();
 3705               		.loc 3 441 0
 3706 049e 00D0      		rcall start_timeout_timer
 3707               	.LVL356:
 442:main.c        **** 			
 443:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3708               		.loc 3 443 0
 3709 04a0 939A      		sbi 0x12,3
 444:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3710               		.loc 3 444 0
 3711 04a2 8091 0000 		lds r24,flashBank1CommandWrites
 3712 04a6 00E0      		ldi r16,lo8(receivedBuffer)
 3713 04a8 A02E      		mov r10,r16
 3714 04aa 00E0      		ldi r16,hi8(receivedBuffer)
 3715 04ac B02E      		mov r11,r16
 3716 04ae 00E0      		ldi r16,0
 3717 04b0 10E0      		ldi r17,0
 3718 04b2 8111      		cpse r24,__zero_reg__
 3719 04b4 00C0      		rjmp .L164
 3720               	.LVL357:
 3721               	.L161:
 3722               	.LBB226:
 445:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 446:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3723               		.loc 3 446 0
 3724 04b6 D501      		movw r26,r10
 3725 04b8 6D91      		ld r22,X+
 3726 04ba 5D01      		movw r10,r26
 3727 04bc 6F3F      		cpi r22,lo8(-1)
 3728 04be 01F0      		breq .L160
 447:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3729               		.loc 3 447 0
 3730 04c0 C801      		movw r24,r16
 3731 04c2 8C0D      		add r24,r12
 3732 04c4 9D1D      		adc r25,r13
 3733 04c6 00D0      		rcall gb_flash_write_byte
 3734               	.LVL358:
 3735               	.L160:
 3736 04c8 0F5F      		subi r16,-1
 3737 04ca 1F4F      		sbci r17,-1
 3738               	.LVL359:
 445:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3739               		.loc 3 445 0 discriminator 2
 3740 04cc 0034      		cpi r16,64
 3741 04ce 1105      		cpc r17,__zero_reg__
 3742 04d0 01F4      		brne .L161
 3743 04d2 00C0      		rjmp .L321
 3744               	.LVL360:
 3745               	.L164:
 3746               	.LBE226:
 3747               	.LBB227:
 448:main.c        **** 					}
 449:main.c        **** 					address++;
 450:main.c        **** 				}
 451:main.c        **** 			}
 452:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 453:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 454:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3748               		.loc 3 454 0
 3749 04d4 F501      		movw r30,r10
 3750 04d6 6191      		ld r22,Z+
 3751 04d8 5F01      		movw r10,r30
 3752 04da 6F3F      		cpi r22,lo8(-1)
 3753 04dc 01F0      		breq .L163
 455:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3754               		.loc 3 455 0
 3755 04de C801      		movw r24,r16
 3756 04e0 8C0D      		add r24,r12
 3757 04e2 9D1D      		adc r25,r13
 3758 04e4 00D0      		rcall gb_flash_write_byte_bank1_commands
 3759               	.LVL361:
 3760               	.L163:
 3761 04e6 0F5F      		subi r16,-1
 3762 04e8 1F4F      		sbci r17,-1
 3763               	.LVL362:
 453:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3764               		.loc 3 453 0 discriminator 2
 3765 04ea 0034      		cpi r16,64
 3766 04ec 1105      		cpc r17,__zero_reg__
 3767 04ee 01F4      		brne .L164
 3768 04f0 F0E4      		ldi r31,64
 3769 04f2 CF0E      		add r12,r31
 3770 04f4 D11C      		adc r13,__zero_reg__
 3771 04f6 E11C      		adc r14,__zero_reg__
 3772 04f8 F11C      		adc r15,__zero_reg__
 3773               	.LVL363:
 3774 04fa 00C0      		rjmp .L314
 3775               	.LVL364:
 3776               	.L158:
 3777               	.LBE227:
 456:main.c        **** 					}
 457:main.c        **** 					address++;
 458:main.c        **** 				}
 459:main.c        **** 			}
 460:main.c        **** 			
 461:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 462:main.c        **** 		}
 463:main.c        **** 		
 464:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 465:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 3778               		.loc 3 465 0
 3779 04fc 9935      		cpi r25,lo8(89)
 3780 04fe 01F0      		breq .+2
 3781 0500 00C0      		rjmp .L165
 3782               	.LBB228:
 466:main.c        **** 			usart_read_bytes(32);
 3783               		.loc 3 466 0
 3784 0502 80E2      		ldi r24,lo8(32)
 3785 0504 90E0      		ldi r25,0
 3786               	.LVL365:
 3787 0506 00D0      		rcall usart_read_bytes
 3788               	.LVL366:
 467:main.c        **** 			start_timeout_timer();
 3789               		.loc 3 467 0
 3790 0508 00D0      		rcall start_timeout_timer
 3791               	.LVL367:
 468:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3792               		.loc 3 468 0
 3793 050a 939A      		sbi 0x12,3
 469:main.c        **** 			
 470:main.c        **** 			// Setup buffered write
 471:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 3794               		.loc 3 471 0
 3795 050c 6AEA      		ldi r22,lo8(-86)
 3796 050e 8AEA      		ldi r24,lo8(-86)
 3797 0510 9AE0      		ldi r25,lo8(10)
 3798 0512 00D0      		rcall gb_flash_write_bus_cycle
 3799               	.LVL368:
 472:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3800               		.loc 3 472 0
 3801 0514 65E5      		ldi r22,lo8(85)
 3802 0516 85E5      		ldi r24,lo8(85)
 3803 0518 95E0      		ldi r25,lo8(5)
 3804 051a 00D0      		rcall gb_flash_write_bus_cycle
 3805               	.LVL369:
 473:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3806               		.loc 3 473 0
 3807 051c 5601      		movw r10,r12
 3808 051e 65E2      		ldi r22,lo8(37)
 3809 0520 C601      		movw r24,r12
 3810 0522 00D0      		rcall gb_flash_write_bus_cycle
 3811               	.LVL370:
 474:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3812               		.loc 3 474 0
 3813 0524 6FE1      		ldi r22,lo8(31)
 3814 0526 C601      		movw r24,r12
 3815 0528 00D0      		rcall gb_flash_write_bus_cycle
 3816               	.LVL371:
 3817               	.LBB229:
 3818               	.LBB230:
 3819               		.loc 2 276 0
 3820 052a 22E0      		ldi r18,lo8(2)
 3821 052c 2A95      	1:	dec r18
 3822 052e 01F4      		brne 1b
 3823 0530 00C0      		rjmp .
 3824               	.LVL372:
 3825 0532 00E0      		ldi r16,lo8(receivedBuffer)
 3826 0534 10E0      		ldi r17,hi8(receivedBuffer)
 3827 0536 812C      		mov r8,__zero_reg__
 3828 0538 912C      		mov r9,__zero_reg__
 3829               	.LVL373:
 3830               	.L166:
 3831               	.LBE230:
 3832               	.LBE229:
 3833               	.LBB231:
 475:main.c        **** 			_delay_us(1);
 476:main.c        **** 			
 477:main.c        **** 			// Write data
 478:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 479:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3834               		.loc 3 479 0 discriminator 3
 3835 053a D801      		movw r26,r16
 3836 053c 6D91      		ld r22,X+
 3837 053e 8D01      		movw r16,r26
 3838 0540 C401      		movw r24,r8
 3839 0542 8A0D      		add r24,r10
 3840 0544 9B1D      		adc r25,r11
 3841 0546 00D0      		rcall gb_flash_write_bus_cycle
 3842               	.LVL374:
 3843 0548 BFEF      		ldi r27,-1
 3844 054a 8B1A      		sub r8,r27
 3845 054c 9B0A      		sbc r9,r27
 3846               	.LVL375:
 478:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3847               		.loc 3 478 0 discriminator 3
 3848 054e E0E2      		ldi r30,32
 3849 0550 8E16      		cp r8,r30
 3850 0552 9104      		cpc r9,__zero_reg__
 3851 0554 01F4      		brne .L166
 3852 0556 F0E2      		ldi r31,32
 3853 0558 CF0E      		add r12,r31
 3854 055a D11C      		adc r13,__zero_reg__
 3855 055c E11C      		adc r14,__zero_reg__
 3856 055e F11C      		adc r15,__zero_reg__
 3857               	.LBE231:
 480:main.c        **** 				address++;
 481:main.c        **** 			}
 482:main.c        **** 			
 483:main.c        **** 			// Write buffer to flash
 484:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 3858               		.loc 3 484 0
 3859 0560 C601      		movw r24,r12
 3860 0562 8097      		sbiw r24,32
 3861 0564 69E2      		ldi r22,lo8(41)
 3862 0566 00D0      		rcall gb_flash_write_bus_cycle
 3863               	.LVL376:
 3864               	.LBB232:
 3865               	.LBB233:
 3866               		.loc 2 276 0
 3867 0568 8FE8      		ldi r24,lo8(399)
 3868 056a 91E0      		ldi r25,hi8(399)
 3869 056c 0197      	1:	sbiw r24,1
 3870 056e 01F4      		brne 1b
 3871 0570 00C0      		rjmp .
 3872 0572 0000      		nop
 3873               	.LVL377:
 3874               	.LBE233:
 3875               	.LBE232:
 485:main.c        **** 			_delay_us(200);
 486:main.c        **** 			
 487:main.c        **** 			// Verify last byte written
 488:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3876               		.loc 3 488 0
 3877 0574 8601      		movw r16,r12
 3878 0576 0150      		subi r16,1
 3879 0578 1109      		sbc r17,__zero_reg__
 3880 057a C801      		movw r24,r16
 3881 057c 00D0      		rcall gb_flash_read_byte
 3882               	.LVL378:
 3883               	.L167:
 489:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3884               		.loc 3 489 0
 3885 057e 9091 0000 		lds r25,receivedBuffer+31
 3886 0582 8917      		cp r24,r25
 3887 0584 01F4      		brne .+2
 3888 0586 00C0      		rjmp .L314
 490:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3889               		.loc 3 490 0
 3890 0588 C801      		movw r24,r16
 3891               	.LVL379:
 3892 058a 00D0      		rcall gb_flash_read_byte
 3893               	.LVL380:
 3894               	.LBB234:
 3895               	.LBB235:
 3896               		.loc 2 276 0
 3897 058c 9DE0      		ldi r25,lo8(13)
 3898 058e 9A95      	1:	dec r25
 3899 0590 01F4      		brne 1b
 3900 0592 0000      		nop
 3901               	.LVL381:
 3902               	.LBE235:
 3903               	.LBE234:
 491:main.c        **** 				_delay_us(5);
 492:main.c        **** 				if (writingTimedout == 1) {
 3904               		.loc 3 492 0
 3905 0594 9091 0000 		lds r25,writingTimedout
 3906 0598 9130      		cpi r25,lo8(1)
 3907 059a 01F4      		brne .L167
 3908 059c 00C0      		rjmp .L314
 3909               	.LVL382:
 3910               	.L165:
 3911               	.LBE228:
 493:main.c        **** 					break;
 494:main.c        **** 				}
 495:main.c        **** 			}
 496:main.c        **** 			
 497:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 498:main.c        **** 		}
 499:main.c        **** 		
 500:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 501:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 3912               		.loc 3 501 0
 3913 059e 9A34      		cpi r25,lo8(74)
 3914 05a0 01F4      		brne .L170
 502:main.c        **** 			usart_read_bytes(64);
 3915               		.loc 3 502 0
 3916 05a2 80E4      		ldi r24,lo8(64)
 3917 05a4 90E0      		ldi r25,0
 3918               	.LVL383:
 3919 05a6 00D0      		rcall usart_read_bytes
 3920               	.LVL384:
 503:main.c        **** 			start_timeout_timer();
 3921               		.loc 3 503 0
 3922 05a8 00D0      		rcall start_timeout_timer
 3923               	.LVL385:
 504:main.c        **** 			
 505:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3924               		.loc 3 505 0
 3925 05aa 939A      		sbi 0x12,3
 3926               	.LVL386:
 3927 05ac 10E0      		ldi r17,lo8(receivedBuffer)
 3928 05ae A12E      		mov r10,r17
 3929 05b0 10E0      		ldi r17,hi8(receivedBuffer)
 3930 05b2 B12E      		mov r11,r17
 3931 05b4 00E0      		ldi r16,0
 3932 05b6 10E0      		ldi r17,0
 3933               	.LVL387:
 3934               	.L172:
 3935               	.LBB236:
 506:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 507:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 3936               		.loc 3 507 0
 3937 05b8 D501      		movw r26,r10
 3938 05ba 6D91      		ld r22,X+
 3939 05bc 5D01      		movw r10,r26
 3940 05be 6F3F      		cpi r22,lo8(-1)
 3941 05c0 01F0      		breq .L171
 508:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3942               		.loc 3 508 0
 3943 05c2 C801      		movw r24,r16
 3944 05c4 8C0D      		add r24,r12
 3945 05c6 9D1D      		adc r25,r13
 3946 05c8 00D0      		rcall gb_flash_write_byte_special
 3947               	.LVL388:
 3948               	.L171:
 3949 05ca 0F5F      		subi r16,-1
 3950 05cc 1F4F      		sbci r17,-1
 3951               	.LVL389:
 506:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3952               		.loc 3 506 0 discriminator 2
 3953 05ce 0034      		cpi r16,64
 3954 05d0 1105      		cpc r17,__zero_reg__
 3955 05d2 01F4      		brne .L172
 3956               	.LVL390:
 3957               	.L321:
 3958 05d4 B0E4      		ldi r27,64
 3959 05d6 CB0E      		add r12,r27
 3960 05d8 D11C      		adc r13,__zero_reg__
 3961 05da E11C      		adc r14,__zero_reg__
 3962 05dc F11C      		adc r15,__zero_reg__
 3963 05de 00C0      		rjmp .L314
 3964               	.LVL391:
 3965               	.L170:
 3966               	.LBE236:
 509:main.c        **** 				}
 510:main.c        **** 				address++;
 511:main.c        **** 			}
 512:main.c        **** 			
 513:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 514:main.c        **** 		}
 515:main.c        **** 		
 516:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 517:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3967               		.loc 3 517 0
 3968 05e0 9835      		cpi r25,lo8(88)
 3969 05e2 01F0      		breq .+2
 3970 05e4 00C0      		rjmp .L173
 3971               	.LBB237:
 518:main.c        **** 			usart_read_bytes(256);
 3972               		.loc 3 518 0
 3973 05e6 80E0      		ldi r24,0
 3974 05e8 91E0      		ldi r25,lo8(1)
 3975               	.LVL392:
 3976 05ea 00D0      		rcall usart_read_bytes
 3977               	.LVL393:
 519:main.c        **** 			start_timeout_timer();
 3978               		.loc 3 519 0
 3979 05ec 00D0      		rcall start_timeout_timer
 3980               	.LVL394:
 520:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3981               		.loc 3 520 0
 3982 05ee 939A      		sbi 0x12,3
 521:main.c        **** 			
 522:main.c        **** 			// Setup buffered write
 523:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3983               		.loc 3 523 0
 3984 05f0 69EA      		ldi r22,lo8(-87)
 3985 05f2 8AEA      		ldi r24,lo8(-86)
 3986 05f4 9AE0      		ldi r25,lo8(10)
 3987 05f6 00D0      		rcall gb_flash_write_bus_cycle
 3988               	.LVL395:
 524:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3989               		.loc 3 524 0
 3990 05f8 66E5      		ldi r22,lo8(86)
 3991 05fa 85E5      		ldi r24,lo8(85)
 3992 05fc 95E0      		ldi r25,lo8(5)
 3993 05fe 00D0      		rcall gb_flash_write_bus_cycle
 3994               	.LVL396:
 525:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3995               		.loc 3 525 0
 3996 0600 5601      		movw r10,r12
 3997 0602 66E2      		ldi r22,lo8(38)
 3998 0604 C601      		movw r24,r12
 3999 0606 00D0      		rcall gb_flash_write_bus_cycle
 4000               	.LVL397:
 526:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 4001               		.loc 3 526 0
 4002 0608 6FEF      		ldi r22,lo8(-1)
 4003 060a C601      		movw r24,r12
 4004 060c 00D0      		rcall gb_flash_write_bus_cycle
 4005               	.LVL398:
 4006               	.LBB238:
 4007               	.LBB239:
 4008               		.loc 2 276 0
 4009 060e E5E8      		ldi r30,lo8(-123)
 4010 0610 EA95      	1:	dec r30
 4011 0612 01F4      		brne 1b
 4012 0614 0000      		nop
 4013               	.LVL399:
 4014 0616 00E0      		ldi r16,lo8(receivedBuffer)
 4015 0618 10E0      		ldi r17,hi8(receivedBuffer)
 4016               	.LBE239:
 4017               	.LBE238:
 4018               	.LBB240:
 527:main.c        **** 			_delay_us(50);
 528:main.c        **** 			
 529:main.c        **** 			// Write data
 530:main.c        **** 			for (int x = 0; x < 256; x++) {
 4019               		.loc 3 530 0
 4020 061a 812C      		mov r8,__zero_reg__
 4021 061c 912C      		mov r9,__zero_reg__
 4022               	.LVL400:
 4023               	.L174:
 531:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4024               		.loc 3 531 0 discriminator 3
 4025 061e D801      		movw r26,r16
 4026 0620 6D91      		ld r22,X+
 4027 0622 8D01      		movw r16,r26
 4028 0624 C401      		movw r24,r8
 4029 0626 8A0D      		add r24,r10
 4030 0628 9B1D      		adc r25,r11
 4031 062a 00D0      		rcall gb_flash_write_bus_cycle
 4032               	.LVL401:
 530:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4033               		.loc 3 530 0 discriminator 3
 4034 062c BFEF      		ldi r27,-1
 4035 062e 8B1A      		sub r8,r27
 4036 0630 9B0A      		sbc r9,r27
 4037               	.LVL402:
 4038 0632 8114      		cp r8,__zero_reg__
 4039 0634 E1E0      		ldi r30,1
 4040 0636 9E06      		cpc r9,r30
 4041 0638 01F4      		brne .L174
 4042 063a FFEF      		ldi r31,-1
 4043 063c DF1A      		sub r13,r31
 4044 063e EF0A      		sbc r14,r31
 4045 0640 FF0A      		sbc r15,r31
 4046               	.LBE240:
 532:main.c        **** 				address++;
 533:main.c        **** 			}
 534:main.c        **** 			
 535:main.c        **** 			// Write buffer to flash
 536:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 4047               		.loc 3 536 0
 4048 0642 C601      		movw r24,r12
 4049 0644 9A95      		dec r25
 4050 0646 6AE2      		ldi r22,lo8(42)
 4051 0648 00D0      		rcall gb_flash_write_bus_cycle
 4052               	.LVL403:
 537:main.c        **** 			
 538:main.c        **** 			// Verify last byte written
 539:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 4053               		.loc 3 539 0
 4054 064a 8601      		movw r16,r12
 4055 064c 0150      		subi r16,1
 4056 064e 1109      		sbc r17,__zero_reg__
 4057 0650 C801      		movw r24,r16
 4058 0652 00D0      		rcall gb_flash_read_byte
 4059               	.LVL404:
 4060               	.L175:
 540:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 4061               		.loc 3 540 0
 4062 0654 9091 0000 		lds r25,receivedBuffer+255
 4063 0658 8917      		cp r24,r25
 4064 065a 01F4      		brne .+2
 4065 065c 00C0      		rjmp .L314
 541:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 4066               		.loc 3 541 0
 4067 065e C801      		movw r24,r16
 4068               	.LVL405:
 4069 0660 00D0      		rcall gb_flash_read_byte
 4070               	.LVL406:
 4071               	.LBB241:
 4072               	.LBB242:
 4073               		.loc 2 276 0
 4074 0662 2DE0      		ldi r18,lo8(13)
 4075 0664 2A95      	1:	dec r18
 4076 0666 01F4      		brne 1b
 4077 0668 0000      		nop
 4078               	.LVL407:
 4079               	.LBE242:
 4080               	.LBE241:
 542:main.c        **** 				_delay_us(5);
 543:main.c        **** 				if (writingTimedout == 1) {
 4081               		.loc 3 543 0
 4082 066a 9091 0000 		lds r25,writingTimedout
 4083 066e 9130      		cpi r25,lo8(1)
 4084 0670 01F4      		brne .L175
 4085 0672 00C0      		rjmp .L314
 4086               	.LVL408:
 4087               	.L173:
 4088               	.LBE237:
 544:main.c        **** 					break;
 545:main.c        **** 				}
 546:main.c        **** 			}
 547:main.c        **** 			
 548:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 549:main.c        **** 		}
 550:main.c        **** 		
 551:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 552:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 553:main.c        **** 			usart_read_bytes(128);
 554:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 555:main.c        **** 			
 556:main.c        **** 			// Enable flash chip access
 557:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 558:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 559:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 560:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 561:main.c        **** 			_delay_us(5);
 562:main.c        **** 			
 563:main.c        **** 			// Re-Enable writes to MBC registers
 564:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 565:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 566:main.c        **** 			_delay_us(5);
 567:main.c        **** 			
 568:main.c        **** 			// Bank 1 for commands
 569:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 570:main.c        **** 			_delay_us(5);
 571:main.c        **** 			
 572:main.c        **** 			
 573:main.c        **** 			// Write setup
 574:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 575:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 576:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 577:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 578:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 579:main.c        **** 			_delay_us(5);
 580:main.c        **** 			
 581:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 582:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 583:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 584:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 585:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 586:main.c        **** 			_delay_us(5);
 587:main.c        **** 			
 588:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 589:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 590:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 591:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 592:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 593:main.c        **** 			_delay_us(5);
 594:main.c        **** 			
 595:main.c        **** 			// Set bank back
 596:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 597:main.c        **** 			_delay_us(5);
 598:main.c        **** 			
 599:main.c        **** 			// Disable writes to MBC registers
 600:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 601:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 602:main.c        **** 			_delay_us(5);
 603:main.c        **** 			
 604:main.c        **** 			// Undo Wakeup
 605:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 606:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 607:main.c        **** 			_delay_us(5);
 608:main.c        **** 			
 609:main.c        **** 			
 610:main.c        **** 			// Write data
 611:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 612:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 613:main.c        **** 				_delay_us(5);
 614:main.c        **** 				address++;
 615:main.c        **** 			}
 616:main.c        **** 			
 617:main.c        **** 			// Write buffer to flash
 618:main.c        **** 			address--;
 619:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 620:main.c        **** 			address++;
 621:main.c        **** 			_delay_ms(10);
 622:main.c        **** 			
 623:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 624:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 625:main.c        **** 		}
 626:main.c        **** 		
 627:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 628:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 629:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 4089               		.loc 3 629 0
 4090 0674 9937      		cpi r25,lo8(121)
 4091 0676 01F4      		brne .L178
 630:main.c        **** 			usart_read_bytes(32);
 4092               		.loc 3 630 0
 4093 0678 80E2      		ldi r24,lo8(32)
 4094 067a 90E0      		ldi r25,0
 4095               	.LVL409:
 4096 067c 00D0      		rcall usart_read_bytes
 4097               	.LVL410:
 631:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4098               		.loc 3 631 0
 4099 067e 939A      		sbi 0x12,3
 632:main.c        **** 			
 633:main.c        **** 			// Setup buffered write
 634:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 4100               		.loc 3 634 0
 4101 0680 5601      		movw r10,r12
 4102 0682 68EE      		ldi r22,lo8(-24)
 4103 0684 C601      		movw r24,r12
 4104 0686 00D0      		rcall gb_flash_write_bus_cycle
 4105               	.LVL411:
 4106               	.L179:
 635:main.c        **** 			
 636:main.c        **** 			// Wait until ready
 637:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 638:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 4107               		.loc 3 638 0 discriminator 1
 4108 0688 C501      		movw r24,r10
 4109 068a 00D0      		rcall gb_flash_read_byte
 4110               	.LVL412:
 4111 068c 8038      		cpi r24,lo8(-128)
 4112 068e 01F4      		brne .L179
 639:main.c        **** 			
 640:main.c        **** 			// Set buffer size
 641:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 4113               		.loc 3 641 0
 4114 0690 6FE1      		ldi r22,lo8(31)
 4115 0692 C501      		movw r24,r10
 4116 0694 00D0      		rcall gb_flash_write_bus_cycle
 4117               	.LVL413:
 4118 0696 00E0      		ldi r16,lo8(receivedBuffer)
 4119 0698 10E0      		ldi r17,hi8(receivedBuffer)
 4120 069a 812C      		mov r8,__zero_reg__
 4121 069c 912C      		mov r9,__zero_reg__
 4122               	.LVL414:
 4123               	.L180:
 4124               	.LBB243:
 642:main.c        **** 			
 643:main.c        **** 			// Write data to buffer
 644:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 645:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4125               		.loc 3 645 0 discriminator 3
 4126 069e D801      		movw r26,r16
 4127 06a0 6D91      		ld r22,X+
 4128 06a2 8D01      		movw r16,r26
 4129 06a4 C501      		movw r24,r10
 4130 06a6 880D      		add r24,r8
 4131 06a8 991D      		adc r25,r9
 4132 06aa 00D0      		rcall gb_flash_write_bus_cycle
 4133               	.LVL415:
 4134 06ac BFEF      		ldi r27,-1
 4135 06ae 8B1A      		sub r8,r27
 4136 06b0 9B0A      		sbc r9,r27
 4137               	.LVL416:
 644:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4138               		.loc 3 644 0 discriminator 3
 4139 06b2 E0E2      		ldi r30,32
 4140 06b4 8E16      		cp r8,r30
 4141 06b6 9104      		cpc r9,__zero_reg__
 4142 06b8 01F4      		brne .L180
 4143 06ba F0E2      		ldi r31,32
 4144 06bc CF0E      		add r12,r31
 4145 06be D11C      		adc r13,__zero_reg__
 4146 06c0 E11C      		adc r14,__zero_reg__
 4147 06c2 F11C      		adc r15,__zero_reg__
 4148               	.LBE243:
 646:main.c        **** 				address++;
 647:main.c        **** 			}
 648:main.c        **** 			
 649:main.c        **** 			// Write buffer to flash
 650:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 4149               		.loc 3 650 0
 4150 06c4 8601      		movw r16,r12
 4151 06c6 0052      		subi r16,32
 4152 06c8 1109      		sbc r17,__zero_reg__
 4153 06ca 60ED      		ldi r22,lo8(-48)
 4154 06cc C801      		movw r24,r16
 4155 06ce 00D0      		rcall gb_flash_write_bus_cycle
 4156               	.LVL417:
 4157               	.LBB244:
 4158               	.LBB245:
 4159               		.loc 2 276 0
 4160 06d0 87E8      		ldi r24,lo8(391)
 4161 06d2 91E0      		ldi r25,hi8(391)
 4162 06d4 0197      	1:	sbiw r24,1
 4163 06d6 01F4      		brne 1b
 4164 06d8 00C0      		rjmp .
 4165 06da 0000      		nop
 4166               	.L181:
 4167               	.LBE245:
 4168               	.LBE244:
 651:main.c        **** 			_delay_us(196);
 652:main.c        **** 			
 653:main.c        **** 			// Wait until ready
 654:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 655:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 4169               		.loc 3 655 0 discriminator 1
 4170 06dc C801      		movw r24,r16
 4171 06de 00D0      		rcall gb_flash_read_byte
 4172               	.LVL418:
 4173 06e0 8038      		cpi r24,lo8(-128)
 4174 06e2 01F4      		brne .L181
 656:main.c        **** 			
 657:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4175               		.loc 3 657 0
 4176 06e4 81E3      		ldi r24,lo8(49)
 4177 06e6 00C0      		rjmp .L316
 4178               	.LVL419:
 4179               	.L178:
 658:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 659:main.c        **** 		}
 660:main.c        **** 		
 661:main.c        **** 		
 662:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 663:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 664:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4180               		.loc 3 664 0
 4181 06e8 9E36      		cpi r25,lo8(110)
 4182 06ea 01F4      		brne .L182
 4183               	.LBB246:
 665:main.c        **** 			usart_read_chars(); // Read address
 4184               		.loc 3 665 0
 4185 06ec 00D0      		rcall usart_read_chars
 4186               	.LVL420:
 666:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4187               		.loc 3 666 0
 4188 06ee 40E1      		ldi r20,lo8(16)
 4189 06f0 50E0      		ldi r21,0
 4190 06f2 60E0      		ldi r22,0
 4191 06f4 70E0      		ldi r23,0
 4192 06f6 80E0      		ldi r24,lo8(receivedBuffer)
 4193 06f8 90E0      		ldi r25,hi8(receivedBuffer)
 4194 06fa 00D0      		rcall strtol
 4195               	.LVL421:
 4196 06fc 4B01      		movw r8,r22
 4197 06fe 5C01      		movw r10,r24
 4198               	.LVL422:
 667:main.c        **** 			
 668:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 4199               		.loc 3 668 0
 4200 0700 00D0      		rcall USART_Receive
 4201               	.LVL423:
 4202 0702 8093 0000 		sts receivedChar,r24
 669:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4203               		.loc 3 669 0
 4204 0706 8E36      		cpi r24,lo8(110)
 4205 0708 01F0      		breq .+2
 4206 070a 00C0      		rjmp .L106
 4207               	.LBB247:
 670:main.c        **** 				usart_read_chars(); // Read data
 4208               		.loc 3 670 0
 4209 070c 00D0      		rcall usart_read_chars
 4210               	.LVL424:
 671:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4211               		.loc 3 671 0
 4212 070e 40E1      		ldi r20,lo8(16)
 4213 0710 50E0      		ldi r21,0
 4214 0712 60E0      		ldi r22,0
 4215 0714 70E0      		ldi r23,0
 4216 0716 80E0      		ldi r24,lo8(receivedBuffer)
 4217 0718 90E0      		ldi r25,hi8(receivedBuffer)
 4218 071a 00D0      		rcall strtol
 4219               	.LVL425:
 672:main.c        **** 				
 673:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 4220               		.loc 3 673 0
 4221 071c 939A      		sbi 0x12,3
 674:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4222               		.loc 3 674 0
 4223 071e AFEF      		ldi r26,lo8(-1)
 4224 0720 A4BB      		out 0x14,r26
 675:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4225               		.loc 3 675 0
 4226 0722 AABB      		out 0x1a,r26
 676:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4227               		.loc 3 676 0
 4228 0724 A7BB      		out 0x17,r26
 677:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4229               		.loc 3 677 0
 4230 0726 AB01      		movw r20,r22
 4231 0728 C501      		movw r24,r10
 4232 072a B401      		movw r22,r8
 4233               	.LVL426:
 4234 072c 00D0      		rcall gba_flash_write_bus_cycle
 4235               	.LVL427:
 4236               	.L332:
 678:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4237               		.loc 3 678 0
 4238 072e 9398      		cbi 0x12,3
 679:main.c        **** 				
 680:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 4239               		.loc 3 680 0
 4240 0730 81E3      		ldi r24,lo8(49)
 4241 0732 00C0      		rjmp .L312
 4242               	.LVL428:
 4243               	.L182:
 4244               	.LBE247:
 4245               	.LBE246:
 681:main.c        **** 			}
 682:main.c        **** 		}
 683:main.c        **** 		
 684:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 685:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 4246               		.loc 3 685 0
 4247 0734 9137      		cpi r25,lo8(113)
 4248 0736 01F0      		breq .L183
 4249               		.loc 3 685 0 is_stmt 0 discriminator 1
 4250 0738 9437      		cpi r25,lo8(116)
 4251 073a 01F4      		brne .L184
 4252               	.L183:
 4253               	.LBB248:
 686:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4254               		.loc 3 686 0 is_stmt 1
 4255 073c 939A      		sbi 0x12,3
 4256               	.LVL429:
 687:main.c        **** 			
 688:main.c        **** 			int readLength = 64;
 689:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4257               		.loc 3 689 0
 4258 073e 8091 0000 		lds r24,receivedChar
 4259               	.LVL430:
 4260 0742 8437      		cpi r24,lo8(116)
 4261 0744 01F4      		brne .L251
 690:main.c        **** 				readLength = 256;
 4262               		.loc 3 690 0
 4263 0746 00E0      		ldi r16,0
 4264 0748 11E0      		ldi r17,lo8(1)
 4265 074a 00C0      		rjmp .L185
 4266               	.L251:
 688:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4267               		.loc 3 688 0
 4268 074c 00E4      		ldi r16,lo8(64)
 4269 074e 10E0      		ldi r17,0
 4270               	.L185:
 4271               	.LVL431:
 691:main.c        **** 			}
 692:main.c        **** 			usart_read_bytes(readLength);
 4272               		.loc 3 692 0
 4273 0750 C801      		movw r24,r16
 4274 0752 00D0      		rcall usart_read_bytes
 4275               	.LVL432:
 693:main.c        **** 			start_timeout_timer();
 4276               		.loc 3 693 0
 4277 0754 00D0      		rcall start_timeout_timer
 4278               	.LVL433:
 4279 0756 B0E0      		ldi r27,lo8(receivedBuffer)
 4280 0758 AB2E      		mov r10,r27
 4281 075a B0E0      		ldi r27,hi8(receivedBuffer)
 4282 075c BB2E      		mov r11,r27
 4283 075e 2601      		movw r4,r12
 4284 0760 3701      		movw r6,r14
 4285               	.LVL434:
 4286               	.L187:
 4287               	.LBB249:
 4288               	.LBB250:
 694:main.c        **** 			
 695:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 696:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4289               		.loc 3 696 0
 4290 0762 F501      		movw r30,r10
 4291 0764 4181      		ldd r20,Z+1
 4292 0766 50E0      		ldi r21,0
 4293 0768 542F      		mov r21,r20
 4294 076a 4427      		clr r20
 4295 076c 8081      		ld r24,Z
 4296 076e 482B      		or r20,r24
 4297               	.LVL435:
 697:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4298               		.loc 3 697 0
 4299 0770 4F3F      		cpi r20,-1
 4300 0772 FFEF      		ldi r31,-1
 4301 0774 5F07      		cpc r21,r31
 4302 0776 01F0      		breq .L186
 698:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4303               		.loc 3 698 0
 4304 0778 21E0      		ldi r18,lo8(1)
 4305 077a C301      		movw r24,r6
 4306 077c B201      		movw r22,r4
 4307 077e 00D0      		rcall gba_flash_write_byte
 4308               	.LVL436:
 4309               	.L186:
 699:main.c        **** 				}
 700:main.c        **** 				address++;
 4310               		.loc 3 700 0 discriminator 2
 4311 0780 2FEF      		ldi r18,-1
 4312 0782 421A      		sub r4,r18
 4313 0784 520A      		sbc r5,r18
 4314 0786 620A      		sbc r6,r18
 4315 0788 720A      		sbc r7,r18
 4316               	.LVL437:
 4317 078a 82E0      		ldi r24,2
 4318 078c A80E      		add r10,r24
 4319 078e B11C      		adc r11,__zero_reg__
 4320               	.LVL438:
 4321               	.LBE250:
 695:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4322               		.loc 3 695 0 discriminator 2
 4323 0790 C501      		movw r24,r10
 4324 0792 8050      		subi r24,lo8(receivedBuffer)
 4325 0794 9040      		sbci r25,hi8(receivedBuffer)
 4326 0796 8017      		cp r24,r16
 4327 0798 9107      		cpc r25,r17
 4328 079a 04F0      		brlt .L187
 4329 079c 9FEF      		ldi r25,-1
 4330 079e C91A      		sub r12,r25
 4331 07a0 D90A      		sbc r13,r25
 4332 07a2 E90A      		sbc r14,r25
 4333 07a4 F90A      		sbc r15,r25
 4334 07a6 0150      		subi r16,1
 4335 07a8 1109      		sbc r17,__zero_reg__
 4336               	.LVL439:
 4337 07aa 1695      		lsr r17
 4338 07ac 0795      		ror r16
 4339               	.LVL440:
 4340 07ae C00E      		add r12,r16
 4341 07b0 D11E      		adc r13,r17
 4342 07b2 E11C      		adc r14,__zero_reg__
 4343 07b4 F11C      		adc r15,__zero_reg__
 4344 07b6 00C0      		rjmp .L314
 4345               	.LVL441:
 4346               	.L184:
 4347               	.LBE249:
 4348               	.LBE248:
 701:main.c        **** 			}
 702:main.c        **** 			
 703:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 704:main.c        **** 		}
 705:main.c        **** 		
 706:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 707:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 4349               		.loc 3 707 0
 4350 07b8 9636      		cpi r25,lo8(102)
 4351 07ba 01F4      		brne .L188
 4352               	.LBB251:
 708:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4353               		.loc 3 708 0
 4354 07bc 939A      		sbi 0x12,3
 4355               	.LVL442:
 709:main.c        **** 			
 710:main.c        **** 			int readLength = 256;
 711:main.c        **** 			usart_read_bytes(readLength);
 4356               		.loc 3 711 0
 4357 07be 80E0      		ldi r24,0
 4358 07c0 91E0      		ldi r25,lo8(1)
 4359               	.LVL443:
 4360 07c2 00D0      		rcall usart_read_bytes
 4361               	.LVL444:
 712:main.c        **** 			start_timeout_timer();
 4362               		.loc 3 712 0
 4363 07c4 00D0      		rcall start_timeout_timer
 4364               	.LVL445:
 4365 07c6 00E0      		ldi r16,lo8(receivedBuffer)
 4366 07c8 10E0      		ldi r17,hi8(receivedBuffer)
 4367 07ca 4601      		movw r8,r12
 4368 07cc 5701      		movw r10,r14
 4369               	.LVL446:
 4370               	.L190:
 4371               	.LBB252:
 4372               	.LBB253:
 713:main.c        **** 			
 714:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 715:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4373               		.loc 3 715 0
 4374 07ce D801      		movw r26,r16
 4375 07d0 1196      		adiw r26,1
 4376 07d2 4C91      		ld r20,X
 4377 07d4 1197      		sbiw r26,1
 4378 07d6 50E0      		ldi r21,0
 4379 07d8 542F      		mov r21,r20
 4380 07da 4427      		clr r20
 4381 07dc 8C91      		ld r24,X
 4382 07de 482B      		or r20,r24
 4383               	.LVL447:
 716:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4384               		.loc 3 716 0
 4385 07e0 4F3F      		cpi r20,-1
 4386 07e2 BFEF      		ldi r27,-1
 4387 07e4 5B07      		cpc r21,r27
 4388 07e6 01F0      		breq .L189
 717:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4389               		.loc 3 717 0
 4390 07e8 20E0      		ldi r18,0
 4391 07ea C501      		movw r24,r10
 4392 07ec B401      		movw r22,r8
 4393 07ee 00D0      		rcall gba_flash_write_byte
 4394               	.LVL448:
 4395               	.L189:
 718:main.c        **** 				}
 719:main.c        **** 				address++;
 4396               		.loc 3 719 0 discriminator 2
 4397 07f0 EFEF      		ldi r30,-1
 4398 07f2 8E1A      		sub r8,r30
 4399 07f4 9E0A      		sbc r9,r30
 4400 07f6 AE0A      		sbc r10,r30
 4401 07f8 BE0A      		sbc r11,r30
 4402               	.LVL449:
 4403 07fa 0E5F      		subi r16,-2
 4404 07fc 1F4F      		sbci r17,-1
 4405               	.LVL450:
 4406               	.LBE253:
 714:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4407               		.loc 3 714 0 discriminator 2
 4408 07fe F0E0      		ldi r31,hi8(receivedBuffer+256)
 4409 0800 0030      		cpi r16,lo8(receivedBuffer+256)
 4410 0802 1F07      		cpc r17,r31
 4411 0804 01F4      		brne .L190
 4412 0806 20E8      		ldi r18,-128
 4413 0808 C20E      		add r12,r18
 4414 080a D11C      		adc r13,__zero_reg__
 4415 080c E11C      		adc r14,__zero_reg__
 4416 080e F11C      		adc r15,__zero_reg__
 4417 0810 00C0      		rjmp .L314
 4418               	.LVL451:
 4419               	.L188:
 4420               	.LBE252:
 4421               	.LBE251:
 720:main.c        **** 			}
 721:main.c        **** 			
 722:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 723:main.c        **** 		}
 724:main.c        **** 		
 725:main.c        **** 		// Intel flash command based chips
 726:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 727:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 4422               		.loc 3 727 0
 4423 0812 9C36      		cpi r25,lo8(108)
 4424 0814 01F0      		breq .+2
 4425 0816 00C0      		rjmp .L191
 4426               	.LBB254:
 728:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4427               		.loc 3 728 0
 4428 0818 939A      		sbi 0x12,3
 729:main.c        **** 			usart_read_bytes(64);
 4429               		.loc 3 729 0
 4430 081a 80E4      		ldi r24,lo8(64)
 4431 081c 90E0      		ldi r25,0
 4432               	.LVL452:
 4433 081e 00D0      		rcall usart_read_bytes
 4434               	.LVL453:
 730:main.c        **** 			start_timeout_timer();
 4435               		.loc 3 730 0
 4436 0820 00D0      		rcall start_timeout_timer
 4437               	.LVL454:
 731:main.c        **** 			
 732:main.c        **** 			// Set address lines as outputs
 733:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4438               		.loc 3 733 0
 4439 0822 8FEF      		ldi r24,lo8(-1)
 4440 0824 84BB      		out 0x14,r24
 734:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4441               		.loc 3 734 0
 4442 0826 8ABB      		out 0x1a,r24
 735:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4443               		.loc 3 735 0
 4444 0828 87BB      		out 0x17,r24
 736:main.c        **** 			
 737:main.c        **** 			// Unlock
 738:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 4445               		.loc 3 738 0
 4446 082a 40E6      		ldi r20,lo8(96)
 4447 082c 50E0      		ldi r21,0
 4448 082e C701      		movw r24,r14
 4449 0830 B601      		movw r22,r12
 4450 0832 00D0      		rcall gba_flash_write_bus_cycle
 4451               	.LVL455:
 739:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4452               		.loc 3 739 0
 4453 0834 40ED      		ldi r20,lo8(-48)
 4454 0836 50E0      		ldi r21,0
 4455 0838 C701      		movw r24,r14
 4456 083a B601      		movw r22,r12
 4457 083c 00D0      		rcall gba_flash_write_bus_cycle
 4458               	.LVL456:
 740:main.c        **** 			
 741:main.c        **** 			// Buffered write command
 742:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 4459               		.loc 3 742 0
 4460 083e 48EE      		ldi r20,lo8(-24)
 4461 0840 50E0      		ldi r21,0
 4462 0842 C701      		movw r24,r14
 4463 0844 B601      		movw r22,r12
 4464 0846 00D0      		rcall gba_flash_write_bus_cycle
 4465               	.LVL457:
 4466               	.LBB255:
 4467               	.LBB256:
 4468               		.loc 2 276 0
 4469 0848 95E8      		ldi r25,lo8(-123)
 4470 084a 9A95      	1:	dec r25
 4471 084c 01F4      		brne 1b
 4472 084e 0000      		nop
 4473               	.LVL458:
 4474               	.LBE256:
 4475               	.LBE255:
 743:main.c        **** 			_delay_us(50);
 744:main.c        **** 			
 745:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 746:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 4476               		.loc 3 746 0
 4477 0850 C701      		movw r24,r14
 4478 0852 B601      		movw r22,r12
 4479 0854 00D0      		rcall gba_read_16bit_data
 4480               	.LVL459:
 4481               	.L192:
 747:main.c        **** 			while (dataVerify != 0x0080) {
 4482               		.loc 3 747 0
 4483 0856 8038      		cpi r24,-128
 4484 0858 9105      		cpc r25,__zero_reg__
 4485 085a 01F0      		breq .L195
 748:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4486               		.loc 3 748 0
 4487 085c C701      		movw r24,r14
 4488 085e B601      		movw r22,r12
 4489 0860 00D0      		rcall gba_read_16bit_data
 4490               	.LVL460:
 4491               	.LBB257:
 4492               	.LBB258:
 4493               		.loc 2 276 0
 4494 0862 A5E8      		ldi r26,lo8(-123)
 4495 0864 AA95      	1:	dec r26
 4496 0866 01F4      		brne 1b
 4497 0868 0000      		nop
 4498               	.LVL461:
 4499               	.LBE258:
 4500               	.LBE257:
 749:main.c        **** 				_delay_us(50);
 750:main.c        **** 				if (writingTimedout == 1) {
 4501               		.loc 3 750 0
 4502 086a 2091 0000 		lds r18,writingTimedout
 4503 086e 2130      		cpi r18,lo8(1)
 4504 0870 01F4      		brne .L192
 4505               	.L195:
 751:main.c        **** 					break;
 752:main.c        **** 				}
 753:main.c        **** 			}
 754:main.c        **** 			
 755:main.c        **** 			
 756:main.c        **** 			// Set address lines as outputs
 757:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4506               		.loc 3 757 0
 4507 0872 BFEF      		ldi r27,lo8(-1)
 4508 0874 B4BB      		out 0x14,r27
 758:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4509               		.loc 3 758 0
 4510 0876 BABB      		out 0x1a,r27
 759:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4511               		.loc 3 759 0
 4512 0878 B7BB      		out 0x17,r27
 760:main.c        **** 			
 761:main.c        **** 			// Set length
 762:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 4513               		.loc 3 762 0
 4514 087a 4FE1      		ldi r20,lo8(31)
 4515 087c 50E0      		ldi r21,0
 4516 087e C701      		movw r24,r14
 4517 0880 B601      		movw r22,r12
 4518 0882 00D0      		rcall gba_flash_write_bus_cycle
 4519               	.LVL462:
 4520 0884 00E0      		ldi r16,lo8(receivedBuffer)
 4521 0886 10E0      		ldi r17,hi8(receivedBuffer)
 4522 0888 4601      		movw r8,r12
 4523 088a 5701      		movw r10,r14
 4524               	.LVL463:
 4525               	.L193:
 4526               	.LBB259:
 4527               	.LBB260:
 763:main.c        **** 			
 764:main.c        **** 			// Write data
 765:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 766:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 767:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4528               		.loc 3 767 0 discriminator 3
 4529 088c F801      		movw r30,r16
 4530 088e 4181      		ldd r20,Z+1
 4531 0890 50E0      		ldi r21,0
 4532 0892 542F      		mov r21,r20
 4533 0894 4427      		clr r20
 4534 0896 8081      		ld r24,Z
 4535 0898 482B      		or r20,r24
 4536 089a C501      		movw r24,r10
 4537 089c B401      		movw r22,r8
 4538 089e 00D0      		rcall gba_flash_write_bus_cycle
 4539               	.LVL464:
 768:main.c        **** 				address++;
 4540               		.loc 3 768 0 discriminator 3
 4541 08a0 FFEF      		ldi r31,-1
 4542 08a2 8F1A      		sub r8,r31
 4543 08a4 9F0A      		sbc r9,r31
 4544 08a6 AF0A      		sbc r10,r31
 4545 08a8 BF0A      		sbc r11,r31
 4546               	.LVL465:
 4547 08aa 0E5F      		subi r16,-2
 4548 08ac 1F4F      		sbci r17,-1
 4549               	.LVL466:
 4550               	.LBE260:
 765:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4551               		.loc 3 765 0 discriminator 3
 4552 08ae 80E0      		ldi r24,lo8(receivedBuffer+64)
 4553 08b0 90E0      		ldi r25,hi8(receivedBuffer+64)
 4554 08b2 8017      		cp r24,r16
 4555 08b4 9107      		cpc r25,r17
 4556 08b6 01F4      		brne .L193
 4557 08b8 90E2      		ldi r25,32
 4558 08ba C90E      		add r12,r25
 4559 08bc D11C      		adc r13,__zero_reg__
 4560 08be E11C      		adc r14,__zero_reg__
 4561 08c0 F11C      		adc r15,__zero_reg__
 4562               	.LBE259:
 769:main.c        **** 			}
 770:main.c        **** 			
 771:main.c        **** 			// Write buffer to flash
 772:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4563               		.loc 3 772 0
 4564 08c2 40ED      		ldi r20,lo8(-48)
 4565 08c4 50E0      		ldi r21,0
 4566 08c6 C701      		movw r24,r14
 4567 08c8 B601      		movw r22,r12
 4568 08ca 00D0      		rcall gba_flash_write_bus_cycle
 4569               	.LVL467:
 4570               	.LBB261:
 4571               	.LBB262:
 4572               		.loc 2 276 0
 4573 08cc AFE6      		ldi r26,lo8(879)
 4574 08ce B3E0      		ldi r27,hi8(879)
 4575 08d0 1197      	1:	sbiw r26,1
 4576 08d2 01F4      		brne 1b
 4577 08d4 00C0      		rjmp .
 4578 08d6 0000      		nop
 4579               	.LVL468:
 4580               	.LBE262:
 4581               	.LBE261:
 773:main.c        **** 			_delay_us(440);
 774:main.c        **** 			
 775:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 776:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 4582               		.loc 3 776 0
 4583 08d8 C701      		movw r24,r14
 4584 08da B601      		movw r22,r12
 4585 08dc 00D0      		rcall gba_read_16bit_data
 4586               	.LVL469:
 4587               	.L196:
 777:main.c        **** 			while (dataVerify != 0x0080) {
 4588               		.loc 3 777 0
 4589 08de 8038      		cpi r24,-128
 4590 08e0 9105      		cpc r25,__zero_reg__
 4591 08e2 01F0      		breq .L198
 778:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4592               		.loc 3 778 0
 4593 08e4 C701      		movw r24,r14
 4594 08e6 B601      		movw r22,r12
 4595 08e8 00D0      		rcall gba_read_16bit_data
 4596               	.LVL470:
 4597               	.LBB263:
 4598               	.LBB264:
 4599               		.loc 2 276 0
 4600 08ea B5E8      		ldi r27,lo8(-123)
 4601 08ec BA95      	1:	dec r27
 4602 08ee 01F4      		brne 1b
 4603 08f0 0000      		nop
 4604               	.LVL471:
 4605               	.LBE264:
 4606               	.LBE263:
 779:main.c        **** 				_delay_us(50);
 780:main.c        **** 				if (writingTimedout == 1) {
 4607               		.loc 3 780 0
 4608 08f2 2091 0000 		lds r18,writingTimedout
 4609 08f6 2130      		cpi r18,lo8(1)
 4610 08f8 01F4      		brne .L196
 4611               	.L198:
 781:main.c        **** 					break;
 782:main.c        **** 				}
 783:main.c        **** 			}
 784:main.c        **** 			
 785:main.c        **** 			
 786:main.c        **** 			// Set address lines as outputs
 787:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4612               		.loc 3 787 0
 4613 08fa EFEF      		ldi r30,lo8(-1)
 4614 08fc E4BB      		out 0x14,r30
 788:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4615               		.loc 3 788 0
 4616 08fe EABB      		out 0x1a,r30
 789:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4617               		.loc 3 789 0
 4618 0900 E7BB      		out 0x17,r30
 790:main.c        **** 			
 791:main.c        **** 			// Back to reading mode
 792:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 4619               		.loc 3 792 0
 4620 0902 4FEF      		ldi r20,lo8(-1)
 4621 0904 50E0      		ldi r21,0
 4622 0906 C701      		movw r24,r14
 4623 0908 B601      		movw r22,r12
 4624 090a 00D0      		rcall gba_flash_write_bus_cycle
 4625               	.LVL472:
 4626 090c 00C0      		rjmp .L314
 4627               	.LVL473:
 4628               	.L191:
 4629               	.LBE254:
 793:main.c        **** 			
 794:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 795:main.c        **** 		}
 796:main.c        **** 		
 797:main.c        **** 		// Intel word programming
 798:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 4630               		.loc 3 798 0
 4631 090e 9537      		cpi r25,lo8(117)
 4632 0910 01F0      		breq .+2
 4633 0912 00C0      		rjmp .L199
 799:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4634               		.loc 3 799 0
 4635 0914 939A      		sbi 0x12,3
 800:main.c        **** 			usart_read_bytes(64);
 4636               		.loc 3 800 0
 4637 0916 80E4      		ldi r24,lo8(64)
 4638 0918 90E0      		ldi r25,0
 4639               	.LVL474:
 4640 091a 00D0      		rcall usart_read_bytes
 4641               	.LVL475:
 801:main.c        **** 			start_timeout_timer();
 4642               		.loc 3 801 0
 4643 091c 00D0      		rcall start_timeout_timer
 4644               	.LVL476:
 4645 091e 40E0      		ldi r20,lo8(receivedBuffer)
 4646 0920 A42E      		mov r10,r20
 4647 0922 40E0      		ldi r20,hi8(receivedBuffer)
 4648 0924 B42E      		mov r11,r20
 4649 0926 2601      		movw r4,r12
 4650 0928 3701      		movw r6,r14
 4651               	.LVL477:
 4652               	.L201:
 4653               	.LBB265:
 4654               	.LBB266:
 802:main.c        **** 			
 803:main.c        **** 			// Write data
 804:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 805:main.c        **** 				// Set address lines as outputs
 806:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4655               		.loc 3 806 0
 4656 092a FFEF      		ldi r31,lo8(-1)
 4657 092c F4BB      		out 0x14,r31
 807:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4658               		.loc 3 807 0
 4659 092e FABB      		out 0x1a,r31
 808:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4660               		.loc 3 808 0
 4661 0930 F7BB      		out 0x17,r31
 809:main.c        **** 				
 810:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4662               		.loc 3 810 0
 4663 0932 D501      		movw r26,r10
 4664 0934 1196      		adiw r26,1
 4665 0936 0C91      		ld r16,X
 4666 0938 1197      		sbiw r26,1
 4667 093a 10E0      		ldi r17,0
 4668 093c 102F      		mov r17,r16
 4669 093e 0027      		clr r16
 4670 0940 8C91      		ld r24,X
 4671 0942 082B      		or r16,r24
 4672               	.LVL478:
 811:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4673               		.loc 3 811 0
 4674 0944 40E4      		ldi r20,lo8(64)
 4675 0946 50E0      		ldi r21,0
 4676 0948 C301      		movw r24,r6
 4677 094a B201      		movw r22,r4
 4678 094c 00D0      		rcall gba_flash_write_bus_cycle
 4679               	.LVL479:
 812:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4680               		.loc 3 812 0
 4681 094e A801      		movw r20,r16
 4682 0950 C301      		movw r24,r6
 4683 0952 B201      		movw r22,r4
 4684 0954 00D0      		rcall gba_flash_write_bus_cycle
 4685               	.LVL480:
 813:main.c        **** 				
 814:main.c        **** 				// Verify status ok
 815:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4686               		.loc 3 815 0
 4687 0956 C301      		movw r24,r6
 4688 0958 B201      		movw r22,r4
 4689 095a 00D0      		rcall gba_read_16bit_data
 4690               	.LVL481:
 4691               	.L200:
 816:main.c        **** 				while ((status & 0x80) == 0) {
 4692               		.loc 3 816 0
 4693 095c 87FD      		sbrc r24,7
 4694 095e 00C0      		rjmp .L204
 817:main.c        **** 					status = gba_read_16bit_data(address);
 4695               		.loc 3 817 0
 4696 0960 C301      		movw r24,r6
 4697 0962 B201      		movw r22,r4
 4698 0964 00D0      		rcall gba_read_16bit_data
 4699               	.LVL482:
 4700               	.LBB267:
 4701               	.LBB268:
 4702               		.loc 2 276 0
 4703 0966 B5E0      		ldi r27,lo8(5)
 4704 0968 BA95      	1:	dec r27
 4705 096a 01F4      		brne 1b
 4706 096c 0000      		nop
 4707               	.LVL483:
 4708               	.LBE268:
 4709               	.LBE267:
 818:main.c        **** 					_delay_us(2);
 819:main.c        **** 					if (writingTimedout == 1) {
 4710               		.loc 3 819 0
 4711 096e 9091 0000 		lds r25,writingTimedout
 4712 0972 9130      		cpi r25,lo8(1)
 4713 0974 01F4      		brne .L200
 4714               	.L204:
 820:main.c        **** 						break;
 821:main.c        **** 					}
 822:main.c        **** 				}
 823:main.c        **** 				address++;
 4715               		.loc 3 823 0
 4716 0976 EFEF      		ldi r30,-1
 4717 0978 4E1A      		sub r4,r30
 4718 097a 5E0A      		sbc r5,r30
 4719 097c 6E0A      		sbc r6,r30
 4720 097e 7E0A      		sbc r7,r30
 4721               	.LVL484:
 4722 0980 F2E0      		ldi r31,2
 4723 0982 AF0E      		add r10,r31
 4724 0984 B11C      		adc r11,__zero_reg__
 4725               	.LVL485:
 4726               	.LBE266:
 804:main.c        **** 				// Set address lines as outputs
 4727               		.loc 3 804 0
 4728 0986 80E0      		ldi r24,lo8(receivedBuffer+64)
 4729 0988 90E0      		ldi r25,hi8(receivedBuffer+64)
 4730 098a 8A15      		cp r24,r10
 4731 098c 9B05      		cpc r25,r11
 4732 098e 01F4      		brne .L201
 4733 0990 00C0      		rjmp .L315
 4734               	.LVL486:
 4735               	.L199:
 4736               	.LBE265:
 824:main.c        **** 			}
 825:main.c        **** 			
 826:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 827:main.c        **** 		}
 828:main.c        **** 		
 829:main.c        **** 		// Intel flash command based chips, two chips interleaved (Flash2Advance 256M cart)
 830:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 831:main.c        **** 		// Thanks to lesserkuma for adding support
 832:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE) {
 4737               		.loc 3 832 0
 4738 0992 9637      		cpi r25,lo8(118)
 4739 0994 01F0      		breq .+2
 4740 0996 00C0      		rjmp .L205
 833:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4741               		.loc 3 833 0
 4742 0998 939A      		sbi 0x12,3
 834:main.c        **** 			usart_read_bytes(256);
 4743               		.loc 3 834 0
 4744 099a 80E0      		ldi r24,0
 4745 099c 91E0      		ldi r25,lo8(1)
 4746               	.LVL487:
 4747 099e 00D0      		rcall usart_read_bytes
 4748               	.LVL488:
 835:main.c        **** 			start_timeout_timer();
 4749               		.loc 3 835 0
 4750 09a0 00D0      		rcall start_timeout_timer
 4751               	.LVL489:
 4752 09a2 00E0      		ldi r16,lo8(receivedBuffer)
 4753 09a4 10E0      		ldi r17,hi8(receivedBuffer)
 4754 09a6 4601      		movw r8,r12
 4755 09a8 5701      		movw r10,r14
 4756               	.LVL490:
 4757               	.L211:
 4758               	.LBB269:
 4759               	.LBB270:
 836:main.c        **** 			
 837:main.c        **** 			// Loop four times, transferring 256 bytes over USB at once is faster than doing four transfers
 838:main.c        **** 			for (int c = 0; c < 4; c++) {
 839:main.c        **** 				// Set address lines as outputs
 840:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4760               		.loc 3 840 0
 4761 09aa AFEF      		ldi r26,lo8(-1)
 4762 09ac A4BB      		out 0x14,r26
 841:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4763               		.loc 3 841 0
 4764 09ae AABB      		out 0x1a,r26
 842:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4765               		.loc 3 842 0
 4766 09b0 A7BB      		out 0x17,r26
 843:main.c        **** 				
 844:main.c        **** 				// Setup buffered write
 845:main.c        **** 				gba_flash_write_bus_cycle(address, 0xE8);
 4767               		.loc 3 845 0
 4768 09b2 48EE      		ldi r20,lo8(-24)
 4769 09b4 50E0      		ldi r21,0
 4770 09b6 C501      		movw r24,r10
 4771 09b8 B401      		movw r22,r8
 4772 09ba 00D0      		rcall gba_flash_write_bus_cycle
 4773               	.LVL491:
 4774 09bc D501      		movw r26,r10
 4775 09be C401      		movw r24,r8
 4776 09c0 0196      		adiw r24,1
 4777 09c2 A11D      		adc r26,__zero_reg__
 4778 09c4 B11D      		adc r27,__zero_reg__
 4779 09c6 8983      		std Y+1,r24
 4780 09c8 9A83      		std Y+2,r25
 4781 09ca AB83      		std Y+3,r26
 4782 09cc BC83      		std Y+4,r27
 846:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 4783               		.loc 3 846 0
 4784 09ce 48EE      		ldi r20,lo8(-24)
 4785 09d0 50E0      		ldi r21,0
 4786 09d2 BC01      		movw r22,r24
 4787 09d4 CD01      		movw r24,r26
 4788 09d6 00D0      		rcall gba_flash_write_bus_cycle
 4789               	.LVL492:
 4790               	.L206:
 847:main.c        **** 				
 848:main.c        **** 				// Wait until both chips are ready
 849:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4791               		.loc 3 849 0 discriminator 1
 4792 09d8 C501      		movw r24,r10
 4793 09da B401      		movw r22,r8
 4794 09dc 00D0      		rcall gba_read_16bit_data
 4795               	.LVL493:
 4796 09de 8038      		cpi r24,-128
 4797 09e0 9105      		cpc r25,__zero_reg__
 4798 09e2 01F4      		brne .L206
 4799               	.L207:
 850:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4800               		.loc 3 850 0 discriminator 1
 4801 09e4 6981      		ldd r22,Y+1
 4802 09e6 7A81      		ldd r23,Y+2
 4803 09e8 8B81      		ldd r24,Y+3
 4804 09ea 9C81      		ldd r25,Y+4
 4805 09ec 00D0      		rcall gba_read_16bit_data
 4806               	.LVL494:
 4807 09ee 8038      		cpi r24,-128
 4808 09f0 9105      		cpc r25,__zero_reg__
 4809 09f2 01F4      		brne .L207
 851:main.c        **** 				
 852:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 853:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 854:main.c        **** 				
 855:main.c        **** 				// Set address lines as outputs
 856:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4810               		.loc 3 856 0
 4811 09f4 9FEF      		ldi r25,lo8(-1)
 4812 09f6 94BB      		out 0x14,r25
 857:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4813               		.loc 3 857 0
 4814 09f8 9ABB      		out 0x1a,r25
 858:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4815               		.loc 3 858 0
 4816 09fa 97BB      		out 0x17,r25
 859:main.c        **** 				
 860:main.c        **** 				// Set length (number of words+1 to write)
 861:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // 16 words
 4817               		.loc 3 861 0
 4818 09fc 4FE0      		ldi r20,lo8(15)
 4819 09fe 50E0      		ldi r21,0
 4820 0a00 C501      		movw r24,r10
 4821 0a02 B401      		movw r22,r8
 4822 0a04 00D0      		rcall gba_flash_write_bus_cycle
 4823               	.LVL495:
 862:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
 4824               		.loc 3 862 0
 4825 0a06 4FE0      		ldi r20,lo8(15)
 4826 0a08 50E0      		ldi r21,0
 4827 0a0a 6981      		ldd r22,Y+1
 4828 0a0c 7A81      		ldd r23,Y+2
 4829 0a0e 8B81      		ldd r24,Y+3
 4830 0a10 9C81      		ldd r25,Y+4
 4831 0a12 00D0      		rcall gba_flash_write_bus_cycle
 4832               	.LVL496:
 4833 0a14 1E83      		std Y+6,r17
 4834 0a16 0D83      		std Y+5,r16
 4835 0a18 2401      		movw r4,r8
 4836 0a1a 3501      		movw r6,r10
 4837               	.LBB271:
 863:main.c        **** 				
 864:main.c        **** 				// Write data (32 words total)
 865:main.c        **** 				uint16_t combinedBytes;
 866:main.c        **** 				for (int x = 0; x < 64; x += 2) {
 4838               		.loc 3 866 0
 4839 0a1c 212C      		mov r2,__zero_reg__
 4840 0a1e 312C      		mov r3,__zero_reg__
 4841               	.LVL497:
 4842               	.L208:
 867:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 868:main.c        **** 					gba_flash_write_bus_cycle(address, combinedBytes);
 4843               		.loc 3 868 0 discriminator 3
 4844 0a20 AD81      		ldd r26,Y+5
 4845 0a22 BE81      		ldd r27,Y+6
 4846 0a24 1196      		adiw r26,1
 4847 0a26 4C91      		ld r20,X
 4848 0a28 1197      		sbiw r26,1
 4849 0a2a 50E0      		ldi r21,0
 4850 0a2c 542F      		mov r21,r20
 4851 0a2e 4427      		clr r20
 4852 0a30 8C91      		ld r24,X
 4853 0a32 482B      		or r20,r24
 4854 0a34 C301      		movw r24,r6
 4855 0a36 B201      		movw r22,r4
 4856 0a38 00D0      		rcall gba_flash_write_bus_cycle
 4857               	.LVL498:
 869:main.c        **** 					address++;
 4858               		.loc 3 869 0 discriminator 3
 4859 0a3a BFEF      		ldi r27,-1
 4860 0a3c 4B1A      		sub r4,r27
 4861 0a3e 5B0A      		sbc r5,r27
 4862 0a40 6B0A      		sbc r6,r27
 4863 0a42 7B0A      		sbc r7,r27
 4864               	.LVL499:
 866:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 4865               		.loc 3 866 0 discriminator 3
 4866 0a44 E2E0      		ldi r30,2
 4867 0a46 2E0E      		add r2,r30
 4868 0a48 311C      		adc r3,__zero_reg__
 4869               	.LVL500:
 4870 0a4a 8D81      		ldd r24,Y+5
 4871 0a4c 9E81      		ldd r25,Y+6
 4872 0a4e 0296      		adiw r24,2
 4873 0a50 9E83      		std Y+6,r25
 4874 0a52 8D83      		std Y+5,r24
 4875 0a54 90E4      		ldi r25,64
 4876 0a56 2916      		cp r2,r25
 4877 0a58 3104      		cpc r3,__zero_reg__
 4878 0a5a 01F4      		brne .L208
 4879 0a5c 2401      		movw r4,r8
 4880 0a5e 3501      		movw r6,r10
 4881               	.LVL501:
 4882 0a60 A0E2      		ldi r26,32
 4883 0a62 4A0E      		add r4,r26
 4884 0a64 511C      		adc r5,__zero_reg__
 4885 0a66 611C      		adc r6,__zero_reg__
 4886 0a68 711C      		adc r7,__zero_reg__
 4887               	.LBE271:
 870:main.c        **** 				}
 871:main.c        **** 				
 872:main.c        **** 				// Write buffer to flash
 873:main.c        **** 				gba_flash_write_bus_cycle(address-32, 0xD0);
 4888               		.loc 3 873 0
 4889 0a6a 40ED      		ldi r20,lo8(-48)
 4890 0a6c 50E0      		ldi r21,0
 4891 0a6e C501      		movw r24,r10
 4892 0a70 B401      		movw r22,r8
 4893 0a72 00D0      		rcall gba_flash_write_bus_cycle
 4894               	.LVL502:
 874:main.c        **** 				gba_flash_write_bus_cycle(address-32+1, 0xD0);
 4895               		.loc 3 874 0
 4896 0a74 40ED      		ldi r20,lo8(-48)
 4897 0a76 50E0      		ldi r21,0
 4898 0a78 6981      		ldd r22,Y+1
 4899 0a7a 7A81      		ldd r23,Y+2
 4900 0a7c 8B81      		ldd r24,Y+3
 4901 0a7e 9C81      		ldd r25,Y+4
 4902 0a80 00D0      		rcall gba_flash_write_bus_cycle
 4903               	.LVL503:
 4904               	.L209:
 875:main.c        **** 				
 876:main.c        **** 				// Wait until ready
 877:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4905               		.loc 3 877 0 discriminator 1
 4906 0a82 C301      		movw r24,r6
 4907 0a84 B201      		movw r22,r4
 4908 0a86 00D0      		rcall gba_read_16bit_data
 4909               	.LVL504:
 4910 0a88 8038      		cpi r24,-128
 4911 0a8a 9105      		cpc r25,__zero_reg__
 4912 0a8c 01F4      		brne .L209
 878:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4913               		.loc 3 878 0
 4914 0a8e B1E2      		ldi r27,33
 4915 0a90 8B0E      		add r8,r27
 4916 0a92 911C      		adc r9,__zero_reg__
 4917 0a94 A11C      		adc r10,__zero_reg__
 4918 0a96 B11C      		adc r11,__zero_reg__
 4919               	.L210:
 4920               		.loc 3 878 0 is_stmt 0 discriminator 1
 4921 0a98 C501      		movw r24,r10
 4922 0a9a B401      		movw r22,r8
 4923 0a9c 00D0      		rcall gba_read_16bit_data
 4924               	.LVL505:
 4925 0a9e 8038      		cpi r24,-128
 4926 0aa0 9105      		cpc r25,__zero_reg__
 4927 0aa2 01F4      		brne .L210
 4928               	.LVL506:
 4929 0aa4 005C      		subi r16,-64
 4930 0aa6 1F4F      		sbci r17,-1
 4931               	.LBE270:
 838:main.c        **** 				// Set address lines as outputs
 4932               		.loc 3 838 0 is_stmt 1 discriminator 2
 4933 0aa8 E0E0      		ldi r30,lo8(receivedBuffer+256)
 4934 0aaa F0E0      		ldi r31,hi8(receivedBuffer+256)
 4935 0aac E017      		cp r30,r16
 4936 0aae F107      		cpc r31,r17
 4937 0ab0 01F0      		breq .L334
 4938               	.LBB273:
 4939               	.LBB272:
 869:main.c        **** 				}
 4940               		.loc 3 869 0
 4941 0ab2 5301      		movw r10,r6
 4942 0ab4 4201      		movw r8,r4
 4943 0ab6 00C0      		rjmp .L211
 4944               	.L334:
 4945 0ab8 F0E8      		ldi r31,-128
 4946 0aba CF0E      		add r12,r31
 4947 0abc D11C      		adc r13,__zero_reg__
 4948 0abe E11C      		adc r14,__zero_reg__
 4949 0ac0 F11C      		adc r15,__zero_reg__
 4950 0ac2 00C0      		rjmp .L314
 4951               	.LVL507:
 4952               	.L205:
 4953               	.LBE272:
 4954               	.LBE273:
 4955               	.LBE269:
 879:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 880:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 881:main.c        **** 			}
 882:main.c        **** 			
 883:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 884:main.c        **** 		}
 885:main.c        **** 
 886:main.c        **** 		// Sharp LH28F320BJE programming (Thanks to lesserkuma for adding support)
 887:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_SHARP_64BYTE) {
 4956               		.loc 3 887 0
 4957 0ac4 9837      		cpi r25,lo8(120)
 4958 0ac6 01F0      		breq .+2
 4959 0ac8 00C0      		rjmp .L212
 4960               	.LVL508:
 4961               	.LBB274:
 888:main.c        **** 			uint16_t status = 0;
 889:main.c        **** 			
 890:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4962               		.loc 3 890 0
 4963 0aca 939A      		sbi 0x12,3
 891:main.c        **** 			usart_read_bytes(64);
 4964               		.loc 3 891 0
 4965 0acc 80E4      		ldi r24,lo8(64)
 4966 0ace 90E0      		ldi r25,0
 4967               	.LVL509:
 4968 0ad0 00D0      		rcall usart_read_bytes
 4969               	.LVL510:
 892:main.c        **** 			start_timeout_timer();
 4970               		.loc 3 892 0
 4971 0ad2 00D0      		rcall start_timeout_timer
 4972               	.LVL511:
 4973 0ad4 90E0      		ldi r25,lo8(receivedBuffer)
 4974 0ad6 A92E      		mov r10,r25
 4975 0ad8 90E0      		ldi r25,hi8(receivedBuffer)
 4976 0ada B92E      		mov r11,r25
 4977 0adc 2601      		movw r4,r12
 4978 0ade 3701      		movw r6,r14
 888:main.c        **** 			uint16_t status = 0;
 4979               		.loc 3 888 0
 4980 0ae0 912C      		mov r9,__zero_reg__
 4981               	.LVL512:
 4982               	.L216:
 4983               	.LBB275:
 4984               	.LBB276:
 893:main.c        **** 			
 894:main.c        **** 			// Write data
 895:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 896:main.c        **** 				// Wait until ready
 897:main.c        **** 				while ((status & 0x80) != 0x80) {
 4985               		.loc 3 897 0
 4986 0ae2 97FC      		sbrc r9,7
 4987 0ae4 00C0      		rjmp .L335
 898:main.c        **** 					// Set address lines as outputs
 899:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4988               		.loc 3 899 0
 4989 0ae6 2FEF      		ldi r18,lo8(-1)
 4990 0ae8 24BB      		out 0x14,r18
 900:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4991               		.loc 3 900 0
 4992 0aea 2ABB      		out 0x1a,r18
 901:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4993               		.loc 3 901 0
 4994 0aec 27BB      		out 0x17,r18
 902:main.c        **** 					
 903:main.c        **** 					gba_flash_write_bus_cycle(address, 0x70); // Query status register
 4995               		.loc 3 903 0
 4996 0aee 40E7      		ldi r20,lo8(112)
 4997 0af0 50E0      		ldi r21,0
 4998 0af2 C301      		movw r24,r6
 4999 0af4 B201      		movw r22,r4
 5000 0af6 00D0      		rcall gba_flash_write_bus_cycle
 5001               	.LVL513:
 904:main.c        **** 					status = gba_read_16bit_data(address);
 5002               		.loc 3 904 0
 5003 0af8 C301      		movw r24,r6
 5004 0afa B201      		movw r22,r4
 5005 0afc 00D0      		rcall gba_read_16bit_data
 5006               	.LVL514:
 5007 0afe 982E      		mov r9,r24
 5008 0b00 00C0      		rjmp .L216
 5009               	.L335:
 905:main.c        **** 				}
 906:main.c        **** 				
 907:main.c        **** 				// Set address lines as outputs
 908:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 5010               		.loc 3 908 0 discriminator 2
 5011 0b02 8FEF      		ldi r24,lo8(-1)
 5012 0b04 84BB      		out 0x14,r24
 909:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5013               		.loc 3 909 0 discriminator 2
 5014 0b06 8ABB      		out 0x1a,r24
 910:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5015               		.loc 3 910 0 discriminator 2
 5016 0b08 87BB      		out 0x17,r24
 911:main.c        **** 				
 912:main.c        **** 				// Write one word to flash
 913:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5017               		.loc 3 913 0 discriminator 2
 5018 0b0a D501      		movw r26,r10
 5019 0b0c 1196      		adiw r26,1
 5020 0b0e 0C91      		ld r16,X
 5021 0b10 1197      		sbiw r26,1
 5022 0b12 10E0      		ldi r17,0
 5023 0b14 102F      		mov r17,r16
 5024 0b16 0027      		clr r16
 5025 0b18 8C91      		ld r24,X
 5026 0b1a 082B      		or r16,r24
 5027               	.LVL515:
 914:main.c        **** 				gba_flash_write_bus_cycle(address, 0x10);
 5028               		.loc 3 914 0 discriminator 2
 5029 0b1c 40E1      		ldi r20,lo8(16)
 5030 0b1e 50E0      		ldi r21,0
 5031 0b20 C301      		movw r24,r6
 5032 0b22 B201      		movw r22,r4
 5033 0b24 00D0      		rcall gba_flash_write_bus_cycle
 5034               	.LVL516:
 915:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5035               		.loc 3 915 0 discriminator 2
 5036 0b26 A801      		movw r20,r16
 5037 0b28 C301      		movw r24,r6
 5038 0b2a B201      		movw r22,r4
 5039 0b2c 00D0      		rcall gba_flash_write_bus_cycle
 5040               	.LVL517:
 5041               	.LBB277:
 5042               	.LBB278:
 5043               		.loc 2 276 0 discriminator 2
 5044 0b2e BAE6      		ldi r27,lo8(106)
 5045 0b30 BA95      	1:	dec r27
 5046 0b32 01F4      		brne 1b
 5047 0b34 00C0      		rjmp .
 5048               	.LVL518:
 5049               	.LBE278:
 5050               	.LBE277:
 916:main.c        **** 				_delay_us(40);
 917:main.c        **** 				
 918:main.c        **** 				address++;
 5051               		.loc 3 918 0 discriminator 2
 5052 0b36 EFEF      		ldi r30,-1
 5053 0b38 4E1A      		sub r4,r30
 5054 0b3a 5E0A      		sbc r5,r30
 5055 0b3c 6E0A      		sbc r6,r30
 5056 0b3e 7E0A      		sbc r7,r30
 5057               	.LVL519:
 5058 0b40 F2E0      		ldi r31,2
 5059 0b42 AF0E      		add r10,r31
 5060 0b44 B11C      		adc r11,__zero_reg__
 5061               	.LVL520:
 5062               	.LBE276:
 895:main.c        **** 				// Wait until ready
 5063               		.loc 3 895 0 discriminator 2
 5064 0b46 80E0      		ldi r24,lo8(receivedBuffer+64)
 5065 0b48 90E0      		ldi r25,hi8(receivedBuffer+64)
 5066 0b4a 8A15      		cp r24,r10
 5067 0b4c 9B05      		cpc r25,r11
 5068 0b4e 01F4      		brne .L216
 5069               	.LVL521:
 5070               	.L315:
 5071 0b50 90E2      		ldi r25,32
 5072 0b52 C90E      		add r12,r25
 5073 0b54 D11C      		adc r13,__zero_reg__
 5074 0b56 E11C      		adc r14,__zero_reg__
 5075 0b58 F11C      		adc r15,__zero_reg__
 5076               	.LVL522:
 5077               	.L314:
 5078               	.LBE275:
 919:main.c        **** 			}
 920:main.c        **** 			
 921:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 5079               		.loc 3 921 0
 5080 0b5a 00D0      		rcall check_if_timed_out
 5081               	.LVL523:
 5082               	.LBE274:
 5083 0b5c 00C0      		rjmp .L106
 5084               	.LVL524:
 5085               	.L212:
 922:main.c        **** 		}
 923:main.c        **** 		
 924:main.c        **** 		// ---------- General commands ----------
 925:main.c        **** 		// Set any pin as input/output
 926:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 927:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 5086               		.loc 3 927 0
 5087 0b5e 9934      		cpi r25,lo8(73)
 5088 0b60 01F0      		breq .L217
 5089               		.loc 3 927 0 is_stmt 0 discriminator 1
 5090 0b62 9F34      		cpi r25,lo8(79)
 5091 0b64 01F0      		breq .+2
 5092 0b66 00C0      		rjmp .L218
 5093               	.L217:
 5094               	.LBB279:
 928:main.c        **** 			char portChar = USART_Receive();
 5095               		.loc 3 928 0 is_stmt 1
 5096 0b68 00D0      		rcall USART_Receive
 5097               	.LVL525:
 5098 0b6a 182F      		mov r17,r24
 5099               	.LVL526:
 929:main.c        **** 			usart_read_chars();
 5100               		.loc 3 929 0
 5101 0b6c 00D0      		rcall usart_read_chars
 5102               	.LVL527:
 930:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5103               		.loc 3 930 0
 5104 0b6e 40E1      		ldi r20,lo8(16)
 5105 0b70 50E0      		ldi r21,0
 5106 0b72 60E0      		ldi r22,0
 5107 0b74 70E0      		ldi r23,0
 5108 0b76 80E0      		ldi r24,lo8(receivedBuffer)
 5109 0b78 90E0      		ldi r25,hi8(receivedBuffer)
 5110 0b7a 00D0      		rcall strtol
 5111               	.LVL528:
 931:main.c        **** 			
 932:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5112               		.loc 3 932 0
 5113 0b7c 939A      		sbi 0x12,3
 933:main.c        **** 			if (receivedChar == SET_INPUT) {
 5114               		.loc 3 933 0
 5115 0b7e 8091 0000 		lds r24,receivedChar
 5116 0b82 8934      		cpi r24,lo8(73)
 5117 0b84 01F4      		brne .L219
 934:main.c        **** 				if (portChar == 'A') {
 5118               		.loc 3 934 0
 5119 0b86 1134      		cpi r17,lo8(65)
 5120 0b88 01F4      		brne .L220
 935:main.c        **** 					DDRA &= ~(setValue);
 5121               		.loc 3 935 0
 5122 0b8a 8AB3      		in r24,0x1a
 5123 0b8c 6095      		com r22
 5124               	.LVL529:
 5125 0b8e 6823      		and r22,r24
 5126               	.LVL530:
 5127 0b90 00C0      		rjmp .L323
 5128               	.LVL531:
 5129               	.L220:
 936:main.c        **** 				}
 937:main.c        **** 				else if (portChar == 'B') {
 5130               		.loc 3 937 0
 5131 0b92 1234      		cpi r17,lo8(66)
 5132 0b94 01F4      		brne .L222
 938:main.c        **** 					DDRB &= ~(setValue);
 5133               		.loc 3 938 0
 5134 0b96 87B3      		in r24,0x17
 5135 0b98 6095      		com r22
 5136               	.LVL532:
 5137 0b9a 6823      		and r22,r24
 5138               	.LVL533:
 5139 0b9c 00C0      		rjmp .L324
 5140               	.LVL534:
 5141               	.L222:
 939:main.c        **** 				}
 940:main.c        **** 				else if (portChar == 'C') {
 5142               		.loc 3 940 0
 5143 0b9e 1334      		cpi r17,lo8(67)
 5144 0ba0 01F4      		brne .L223
 941:main.c        **** 					DDRC &= ~(setValue);
 5145               		.loc 3 941 0
 5146 0ba2 84B3      		in r24,0x14
 5147 0ba4 6095      		com r22
 5148               	.LVL535:
 5149 0ba6 6823      		and r22,r24
 5150               	.LVL536:
 5151 0ba8 00C0      		rjmp .L329
 5152               	.LVL537:
 5153               	.L223:
 942:main.c        **** 				}
 943:main.c        **** 				else if (portChar == 'D') {
 5154               		.loc 3 943 0
 5155 0baa 1434      		cpi r17,lo8(68)
 5156 0bac 01F4      		brne .L224
 944:main.c        **** 					DDRD &= ~(setValue);
 5157               		.loc 3 944 0
 5158 0bae 81B3      		in r24,0x11
 5159 0bb0 6095      		com r22
 5160               	.LVL538:
 5161 0bb2 6823      		and r22,r24
 5162               	.LVL539:
 5163 0bb4 00C0      		rjmp .L330
 5164               	.LVL540:
 5165               	.L224:
 945:main.c        **** 				}
 946:main.c        **** 				else if (portChar == 'E') {
 5166               		.loc 3 946 0
 5167 0bb6 1534      		cpi r17,lo8(69)
 5168 0bb8 01F0      		breq .+2
 5169 0bba 00C0      		rjmp .L243
 947:main.c        **** 					DDRE &= ~(setValue);
 5170               		.loc 3 947 0
 5171 0bbc 86B1      		in r24,0x6
 5172 0bbe 6095      		com r22
 5173               	.LVL541:
 5174 0bc0 6823      		and r22,r24
 5175               	.LVL542:
 5176 0bc2 00C0      		rjmp .L331
 5177               	.LVL543:
 5178               	.L219:
 948:main.c        **** 				}
 949:main.c        **** 			}
 950:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 5179               		.loc 3 950 0
 5180 0bc4 8F34      		cpi r24,lo8(79)
 5181 0bc6 01F0      		breq .+2
 5182 0bc8 00C0      		rjmp .L243
 951:main.c        **** 				if (portChar == 'A') {
 5183               		.loc 3 951 0
 5184 0bca 1134      		cpi r17,lo8(65)
 5185 0bcc 01F4      		brne .L225
 952:main.c        **** 					DDRA |= (setValue);
 5186               		.loc 3 952 0
 5187 0bce 8AB3      		in r24,0x1a
 5188 0bd0 682B      		or r22,r24
 5189               	.LVL544:
 5190               	.L323:
 5191 0bd2 6ABB      		out 0x1a,r22
 5192 0bd4 00C0      		rjmp .L243
 5193               	.LVL545:
 5194               	.L225:
 953:main.c        **** 				}
 954:main.c        **** 				else if (portChar == 'B') {
 5195               		.loc 3 954 0
 5196 0bd6 1234      		cpi r17,lo8(66)
 5197 0bd8 01F4      		brne .L226
 955:main.c        **** 					DDRB |= (setValue);
 5198               		.loc 3 955 0
 5199 0bda 87B3      		in r24,0x17
 5200 0bdc 682B      		or r22,r24
 5201               	.LVL546:
 5202               	.L324:
 5203 0bde 67BB      		out 0x17,r22
 5204 0be0 00C0      		rjmp .L243
 5205               	.LVL547:
 5206               	.L226:
 956:main.c        **** 				}
 957:main.c        **** 				else if (portChar == 'C') {
 5207               		.loc 3 957 0
 5208 0be2 1334      		cpi r17,lo8(67)
 5209 0be4 01F4      		brne .L227
 958:main.c        **** 					DDRC |= (setValue);
 5210               		.loc 3 958 0
 5211 0be6 84B3      		in r24,0x14
 5212 0be8 682B      		or r22,r24
 5213               	.LVL548:
 5214               	.L329:
 5215 0bea 64BB      		out 0x14,r22
 5216 0bec 00C0      		rjmp .L243
 5217               	.LVL549:
 5218               	.L227:
 959:main.c        **** 				}
 960:main.c        **** 				else if (portChar == 'D') {
 5219               		.loc 3 960 0
 5220 0bee 1434      		cpi r17,lo8(68)
 5221 0bf0 01F4      		brne .L228
 961:main.c        **** 					DDRD |= (setValue);
 5222               		.loc 3 961 0
 5223 0bf2 81B3      		in r24,0x11
 5224 0bf4 682B      		or r22,r24
 5225               	.LVL550:
 5226               	.L330:
 5227 0bf6 61BB      		out 0x11,r22
 5228 0bf8 00C0      		rjmp .L243
 5229               	.LVL551:
 5230               	.L228:
 962:main.c        **** 				}
 963:main.c        **** 				else if (portChar == 'E') {
 5231               		.loc 3 963 0
 5232 0bfa 1534      		cpi r17,lo8(69)
 5233 0bfc 01F0      		breq .+2
 5234 0bfe 00C0      		rjmp .L243
 964:main.c        **** 					DDRE |= (setValue);
 5235               		.loc 3 964 0
 5236 0c00 86B1      		in r24,0x6
 5237 0c02 682B      		or r22,r24
 5238               	.LVL552:
 5239               	.L331:
 5240 0c04 66B9      		out 0x6,r22
 5241 0c06 00C0      		rjmp .L243
 5242               	.LVL553:
 5243               	.L218:
 5244               	.LBE279:
 965:main.c        **** 				}
 966:main.c        **** 			}
 967:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 968:main.c        **** 		}
 969:main.c        **** 		
 970:main.c        **** 		// Set pin output as low
 971:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 5245               		.loc 3 971 0
 5246 0c08 9C34      		cpi r25,lo8(76)
 5247 0c0a 01F4      		brne .L229
 5248               	.LBB280:
 972:main.c        **** 			char portChar = USART_Receive();			
 5249               		.loc 3 972 0
 5250 0c0c 00D0      		rcall USART_Receive
 5251               	.LVL554:
 5252 0c0e 182F      		mov r17,r24
 5253               	.LVL555:
 973:main.c        **** 			usart_read_chars();
 5254               		.loc 3 973 0
 5255 0c10 00D0      		rcall usart_read_chars
 5256               	.LVL556:
 974:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5257               		.loc 3 974 0
 5258 0c12 40E1      		ldi r20,lo8(16)
 5259 0c14 50E0      		ldi r21,0
 5260 0c16 60E0      		ldi r22,0
 5261 0c18 70E0      		ldi r23,0
 5262 0c1a 80E0      		ldi r24,lo8(receivedBuffer)
 5263 0c1c 90E0      		ldi r25,hi8(receivedBuffer)
 5264 0c1e 00D0      		rcall strtol
 5265               	.LVL557:
 975:main.c        **** 			
 976:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5266               		.loc 3 976 0
 5267 0c20 939A      		sbi 0x12,3
 977:main.c        **** 			if (portChar == 'A') {
 5268               		.loc 3 977 0
 5269 0c22 1134      		cpi r17,lo8(65)
 5270 0c24 01F4      		brne .L230
 978:main.c        **** 				PORTA &= ~(setValue);
 5271               		.loc 3 978 0
 5272 0c26 8BB3      		in r24,0x1b
 5273 0c28 6095      		com r22
 5274               	.LVL558:
 5275 0c2a 6823      		and r22,r24
 5276               	.LVL559:
 5277 0c2c 00C0      		rjmp .L328
 5278               	.LVL560:
 5279               	.L230:
 979:main.c        **** 			}
 980:main.c        **** 			else if (portChar == 'B') {
 5280               		.loc 3 980 0
 5281 0c2e 1234      		cpi r17,lo8(66)
 5282 0c30 01F4      		brne .L232
 981:main.c        **** 				PORTB &= ~(setValue);
 5283               		.loc 3 981 0
 5284 0c32 88B3      		in r24,0x18
 5285 0c34 6095      		com r22
 5286               	.LVL561:
 5287 0c36 6823      		and r22,r24
 5288               	.LVL562:
 5289 0c38 00C0      		rjmp .L327
 5290               	.LVL563:
 5291               	.L232:
 982:main.c        **** 			}
 983:main.c        **** 			else if (portChar == 'C') {
 5292               		.loc 3 983 0
 5293 0c3a 1334      		cpi r17,lo8(67)
 5294 0c3c 01F4      		brne .L233
 984:main.c        **** 				PORTC &= ~(setValue);
 5295               		.loc 3 984 0
 5296 0c3e 85B3      		in r24,0x15
 5297 0c40 6095      		com r22
 5298               	.LVL564:
 5299 0c42 6823      		and r22,r24
 5300               	.LVL565:
 5301 0c44 00C0      		rjmp .L326
 5302               	.LVL566:
 5303               	.L233:
 985:main.c        **** 			}
 986:main.c        **** 			else if (portChar == 'D') {
 5304               		.loc 3 986 0
 5305 0c46 1434      		cpi r17,lo8(68)
 5306 0c48 01F4      		brne .L234
 987:main.c        **** 				PORTD &= ~(setValue);
 5307               		.loc 3 987 0
 5308 0c4a 82B3      		in r24,0x12
 5309 0c4c 6095      		com r22
 5310               	.LVL567:
 5311 0c4e 6823      		and r22,r24
 5312               	.LVL568:
 5313 0c50 00C0      		rjmp .L325
 5314               	.LVL569:
 5315               	.L234:
 988:main.c        **** 			}
 989:main.c        **** 			else if (portChar == 'E') {
 5316               		.loc 3 989 0
 5317 0c52 1534      		cpi r17,lo8(69)
 5318 0c54 01F0      		breq .+2
 5319 0c56 00C0      		rjmp .L243
 990:main.c        **** 				PORTE &= ~(setValue);
 5320               		.loc 3 990 0
 5321 0c58 87B1      		in r24,0x7
 5322 0c5a 6095      		com r22
 5323               	.LVL570:
 5324 0c5c 6823      		and r22,r24
 5325               	.LVL571:
 5326 0c5e 00C0      		rjmp .L322
 5327               	.LVL572:
 5328               	.L229:
 5329               	.LBE280:
 991:main.c        **** 			}
 992:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 993:main.c        **** 		}
 994:main.c        **** 		
 995:main.c        **** 		// Set pin output as high
 996:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 5330               		.loc 3 996 0
 5331 0c60 9834      		cpi r25,lo8(72)
 5332 0c62 01F4      		brne .L235
 5333               	.LBB281:
 997:main.c        **** 			char portChar = USART_Receive();			
 5334               		.loc 3 997 0
 5335 0c64 00D0      		rcall USART_Receive
 5336               	.LVL573:
 5337 0c66 182F      		mov r17,r24
 5338               	.LVL574:
 998:main.c        **** 			usart_read_chars();
 5339               		.loc 3 998 0
 5340 0c68 00D0      		rcall usart_read_chars
 5341               	.LVL575:
 999:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5342               		.loc 3 999 0
 5343 0c6a 40E1      		ldi r20,lo8(16)
 5344 0c6c 50E0      		ldi r21,0
 5345 0c6e 60E0      		ldi r22,0
 5346 0c70 70E0      		ldi r23,0
 5347 0c72 80E0      		ldi r24,lo8(receivedBuffer)
 5348 0c74 90E0      		ldi r25,hi8(receivedBuffer)
 5349 0c76 00D0      		rcall strtol
 5350               	.LVL576:
1000:main.c        **** 			
1001:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5351               		.loc 3 1001 0
 5352 0c78 939A      		sbi 0x12,3
1002:main.c        **** 			if (portChar == 'A') {
 5353               		.loc 3 1002 0
 5354 0c7a 1134      		cpi r17,lo8(65)
 5355 0c7c 01F4      		brne .L236
1003:main.c        **** 				PORTA |= (setValue);
 5356               		.loc 3 1003 0
 5357 0c7e 8BB3      		in r24,0x1b
 5358 0c80 682B      		or r22,r24
 5359               	.LVL577:
 5360               	.L328:
 5361 0c82 6BBB      		out 0x1b,r22
 5362 0c84 00C0      		rjmp .L243
 5363               	.LVL578:
 5364               	.L236:
1004:main.c        **** 			}
1005:main.c        **** 			else if (portChar == 'B') {
 5365               		.loc 3 1005 0
 5366 0c86 1234      		cpi r17,lo8(66)
 5367 0c88 01F4      		brne .L238
1006:main.c        **** 				PORTB |= (setValue);
 5368               		.loc 3 1006 0
 5369 0c8a 88B3      		in r24,0x18
 5370 0c8c 682B      		or r22,r24
 5371               	.LVL579:
 5372               	.L327:
 5373 0c8e 68BB      		out 0x18,r22
 5374 0c90 00C0      		rjmp .L243
 5375               	.LVL580:
 5376               	.L238:
1007:main.c        **** 			}
1008:main.c        **** 			else if (portChar == 'C') {
 5377               		.loc 3 1008 0
 5378 0c92 1334      		cpi r17,lo8(67)
 5379 0c94 01F4      		brne .L239
1009:main.c        **** 				PORTC |= (setValue);
 5380               		.loc 3 1009 0
 5381 0c96 85B3      		in r24,0x15
 5382 0c98 682B      		or r22,r24
 5383               	.LVL581:
 5384               	.L326:
 5385 0c9a 65BB      		out 0x15,r22
 5386 0c9c 00C0      		rjmp .L243
 5387               	.LVL582:
 5388               	.L239:
1010:main.c        **** 			}
1011:main.c        **** 			else if (portChar == 'D') {
 5389               		.loc 3 1011 0
 5390 0c9e 1434      		cpi r17,lo8(68)
 5391 0ca0 01F4      		brne .L240
1012:main.c        **** 				PORTD |= (setValue);
 5392               		.loc 3 1012 0
 5393 0ca2 82B3      		in r24,0x12
 5394 0ca4 682B      		or r22,r24
 5395               	.LVL583:
 5396               	.L325:
 5397 0ca6 62BB      		out 0x12,r22
 5398 0ca8 00C0      		rjmp .L243
 5399               	.LVL584:
 5400               	.L240:
1013:main.c        **** 			}
1014:main.c        **** 			else if (portChar == 'E') {
 5401               		.loc 3 1014 0
 5402 0caa 1534      		cpi r17,lo8(69)
 5403 0cac 01F4      		brne .L243
1015:main.c        **** 				PORTE |= (setValue);
 5404               		.loc 3 1015 0
 5405 0cae 87B1      		in r24,0x7
 5406 0cb0 682B      		or r22,r24
 5407               	.LVL585:
 5408               	.L322:
 5409 0cb2 67B9      		out 0x7,r22
 5410 0cb4 00C0      		rjmp .L243
 5411               	.LVL586:
 5412               	.L235:
 5413               	.LBE281:
1016:main.c        **** 			}
1017:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1018:main.c        **** 		}
1019:main.c        **** 		
1020:main.c        **** 		// Read all pins of a PORT and return the value
1021:main.c        **** 		else if (receivedChar == READ_INPUT) {
 5414               		.loc 3 1021 0
 5415 0cb6 9434      		cpi r25,lo8(68)
 5416 0cb8 01F4      		brne .L241
 5417               	.LBB282:
1022:main.c        **** 			char portChar = USART_Receive();			
 5418               		.loc 3 1022 0
 5419 0cba 00D0      		rcall USART_Receive
 5420               	.LVL587:
1023:main.c        **** 			
1024:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5421               		.loc 3 1024 0
 5422 0cbc 939A      		sbi 0x12,3
1025:main.c        **** 			if (portChar == 'A') {
 5423               		.loc 3 1025 0
 5424 0cbe 8134      		cpi r24,lo8(65)
 5425 0cc0 01F4      		brne .L242
1026:main.c        **** 				USART_Transmit(PINA);
 5426               		.loc 3 1026 0
 5427 0cc2 89B3      		in r24,0x19
 5428               	.LVL588:
 5429 0cc4 00C0      		rjmp .L316
 5430               	.LVL589:
 5431               	.L242:
1027:main.c        **** 			}
1028:main.c        **** 			else if (portChar == 'B') {
 5432               		.loc 3 1028 0
 5433 0cc6 8234      		cpi r24,lo8(66)
 5434 0cc8 01F4      		brne .L244
1029:main.c        **** 				USART_Transmit(PINB);
 5435               		.loc 3 1029 0
 5436 0cca 86B3      		in r24,0x16
 5437               	.LVL590:
 5438 0ccc 00C0      		rjmp .L316
 5439               	.LVL591:
 5440               	.L244:
1030:main.c        **** 			}
1031:main.c        **** 			else if (portChar == 'C') {
 5441               		.loc 3 1031 0
 5442 0cce 8334      		cpi r24,lo8(67)
 5443 0cd0 01F4      		brne .L245
1032:main.c        **** 				USART_Transmit(PINC);
 5444               		.loc 3 1032 0
 5445 0cd2 83B3      		in r24,0x13
 5446               	.LVL592:
 5447 0cd4 00C0      		rjmp .L316
 5448               	.LVL593:
 5449               	.L245:
1033:main.c        **** 			}
1034:main.c        **** 			else if (portChar == 'D') {
 5450               		.loc 3 1034 0
 5451 0cd6 8434      		cpi r24,lo8(68)
 5452 0cd8 01F4      		brne .L246
1035:main.c        **** 				USART_Transmit(PIND);
 5453               		.loc 3 1035 0
 5454 0cda 80B3      		in r24,0x10
 5455               	.LVL594:
 5456 0cdc 00C0      		rjmp .L316
 5457               	.LVL595:
 5458               	.L246:
1036:main.c        **** 			}
1037:main.c        **** 			else if (portChar == 'E') {
 5459               		.loc 3 1037 0
 5460 0cde 8534      		cpi r24,lo8(69)
 5461 0ce0 01F4      		brne .L243
1038:main.c        **** 				USART_Transmit(PINE);
 5462               		.loc 3 1038 0
 5463 0ce2 85B1      		in r24,0x5
 5464               	.LVL596:
 5465               	.L316:
 5466 0ce4 00D0      		rcall USART_Transmit
 5467               	.LVL597:
 5468               	.L243:
1039:main.c        **** 			}
1040:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 5469               		.loc 3 1040 0
 5470 0ce6 9398      		cbi 0x12,3
 5471               	.LBE282:
 5472 0ce8 00C0      		rjmp .L106
 5473               	.LVL598:
 5474               	.L241:
1041:main.c        **** 		}
1042:main.c        **** 		
1043:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
1044:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5475               		.loc 3 1044 0
 5476 0cea 9D34      		cpi r25,lo8(77)
 5477 0cec 01F4      		brne .L247
 5478               	.LBB283:
1045:main.c        **** 			char commonChar = USART_Receive();
 5479               		.loc 3 1045 0
 5480 0cee 00D0      		rcall USART_Receive
 5481               	.LVL599:
1046:main.c        **** 			if (commonChar == '1') {
 5482               		.loc 3 1046 0
 5483 0cf0 8133      		cpi r24,lo8(49)
 5484 0cf2 01F4      		brne .L336
1047:main.c        **** 				resetCommonLines = 1;
 5485               		.loc 3 1047 0
 5486 0cf4 91E0      		ldi r25,lo8(1)
 5487 0cf6 9F83      		std Y+7,r25
 5488 0cf8 00C0      		rjmp .L310
 5489               	.L336:
1048:main.c        **** 			}
1049:main.c        **** 			else if (commonChar == '0') {
 5490               		.loc 3 1049 0
 5491 0cfa 8033      		cpi r24,lo8(48)
 5492 0cfc 01F0      		breq .+2
 5493 0cfe 00C0      		rjmp .L106
1050:main.c        **** 				resetCommonLines = 0;
 5494               		.loc 3 1050 0
 5495 0d00 1F82      		std Y+7,__zero_reg__
 5496 0d02 00C0      		rjmp .L107
 5497               	.LVL600:
 5498               	.L247:
 5499               	.LBE283:
1051:main.c        **** 			}
1052:main.c        **** 		}
1053:main.c        **** 		
1054:main.c        **** 		// Send back the PCB version number
1055:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5500               		.loc 3 1055 0
 5501 0d04 9836      		cpi r25,lo8(104)
 5502 0d06 01F4      		brne .L248
1056:main.c        **** 			USART_Transmit(PCB_VERSION);
 5503               		.loc 3 1056 0
 5504 0d08 82E0      		ldi r24,lo8(2)
 5505               	.LVL601:
 5506 0d0a 00C0      		rjmp .L312
 5507               	.LVL602:
 5508               	.L248:
1057:main.c        **** 		}
1058:main.c        **** 		
1059:main.c        **** 		// Send back the firmware version number
1060:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5509               		.loc 3 1060 0
 5510 0d0c 9635      		cpi r25,lo8(86)
 5511 0d0e 01F4      		brne .L249
1061:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5512               		.loc 3 1061 0
 5513 0d10 83E1      		ldi r24,lo8(19)
 5514               	.LVL603:
 5515               	.L312:
 5516 0d12 00D0      		rcall USART_Transmit
 5517               	.LVL604:
 5518 0d14 00C0      		rjmp .L106
 5519               	.LVL605:
 5520               	.L249:
1062:main.c        **** 		}
1063:main.c        **** 		
1064:main.c        **** 		// Reset the AVR if it matches the number
1065:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5521               		.loc 3 1065 0
 5522 0d16 9A32      		cpi r25,lo8(42)
 5523 0d18 01F0      		breq .+2
 5524 0d1a 00C0      		rjmp .L106
 5525               	.LBB284:
1066:main.c        **** 			usart_read_chars();
 5526               		.loc 3 1066 0
 5527 0d1c 00D0      		rcall usart_read_chars
 5528               	.LVL606:
1067:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5529               		.loc 3 1067 0
 5530 0d1e 40E1      		ldi r20,lo8(16)
 5531 0d20 50E0      		ldi r21,0
 5532 0d22 60E0      		ldi r22,0
 5533 0d24 70E0      		ldi r23,0
 5534 0d26 80E0      		ldi r24,lo8(receivedBuffer)
 5535 0d28 90E0      		ldi r25,hi8(receivedBuffer)
 5536 0d2a 00D0      		rcall strtol
 5537               	.LVL607:
1068:main.c        **** 			if (resetValue == RESET_VALUE) {
 5538               		.loc 3 1068 0
 5539 0d2c 613E      		cpi r22,-31
 5540 0d2e 754E      		sbci r23,-27
 5541 0d30 8740      		sbci r24,7
 5542 0d32 9105      		cpc r25,__zero_reg__
 5543 0d34 01F0      		breq .+2
 5544 0d36 00C0      		rjmp .L106
1069:main.c        **** 				// Clear watchdog flag
1070:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5545               		.loc 3 1070 0
 5546 0d38 84B7      		in r24,0x34
 5547 0d3a 877F      		andi r24,lo8(-9)
 5548 0d3c 84BF      		out 0x34,r24
1071:main.c        **** 				
1072:main.c        **** 				// Start timed sequence
1073:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5549               		.loc 3 1073 0
 5550 0d3e 88E1      		ldi r24,lo8(24)
 5551 0d40 81BD      		out 0x21,r24
1074:main.c        **** 				
1075:main.c        **** 				// Reset in 250 ms
1076:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5552               		.loc 3 1076 0
 5553 0d42 8CE0      		ldi r24,lo8(12)
 5554 0d44 81BD      		out 0x21,r24
 5555               	.LVL608:
 5556               	.LBB285:
 5557               	.LBB286:
 5558               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5559               		.loc 4 105 0
 5560 0d46 8FEF      		ldi r24,lo8(-1)
 5561 0d48 9FEF      		ldi r25,lo8(-1)
 5562               	/* #APP */
 5563               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5564 0d4a 0197      		1: sbiw r24,1
 5565 0d4c 01F4      		brne 1b
 5566               	 ;  0 "" 2
 5567               	.LVL609:
 5568               	/* #NOAPP */
 5569 0d4e 00C0      		rjmp .L106
 5570               	.LBE286:
 5571               	.LBE285:
 5572               	.LBE284:
 5573               		.cfi_endproc
 5574               	.LFE51:
 5576               		.text
 5577               	.global	__vector_6
 5579               	__vector_6:
 5580               	.LFB52:
1077:main.c        **** 				
1078:main.c        **** 				// Wait for reset
1079:main.c        **** 				_delay_loop_2(65535);
1080:main.c        **** 			}
1081:main.c        **** 		}
1082:main.c        **** 	}
1083:main.c        **** }
1084:main.c        **** 
1085:main.c        **** // Timeout after ~500ms which also blinks the LED
1086:main.c        **** ISR(TIMER1_OVF_vect) {
 5581               		.loc 3 1086 0
 5582               		.cfi_startproc
 5583 07e2 1F92      		push r1
 5584               	.LCFI49:
 5585               		.cfi_def_cfa_offset 3
 5586               		.cfi_offset 1, -2
 5587 07e4 0F92      		push r0
 5588               	.LCFI50:
 5589               		.cfi_def_cfa_offset 4
 5590               		.cfi_offset 0, -3
 5591 07e6 0FB6      		in r0,__SREG__
 5592 07e8 0F92      		push r0
 5593 07ea 1124      		clr __zero_reg__
 5594 07ec 8F93      		push r24
 5595               	.LCFI51:
 5596               		.cfi_def_cfa_offset 5
 5597               		.cfi_offset 24, -4
 5598 07ee 9F93      		push r25
 5599               	.LCFI52:
 5600               		.cfi_def_cfa_offset 6
 5601               		.cfi_offset 25, -5
 5602               	/* prologue: Signal */
 5603               	/* frame size = 0 */
 5604               	/* stack size = 5 */
 5605               	.L__stack_usage = 5
1087:main.c        **** 	PORTD ^= (1<<ACTIVITY_LED);
 5606               		.loc 3 1087 0
 5607 07f0 92B3      		in r25,0x12
 5608 07f2 88E0      		ldi r24,lo8(8)
 5609 07f4 8927      		eor r24,r25
 5610 07f6 82BB      		out 0x12,r24
1088:main.c        **** 	writingTimedout = 1;
 5611               		.loc 3 1088 0
 5612 07f8 81E0      		ldi r24,lo8(1)
 5613 07fa 8093 0000 		sts writingTimedout,r24
 5614               	/* epilogue start */
1089:main.c        **** }...
 5615               		.loc 3 1089 0
 5616 07fe 9F91      		pop r25
 5617 0800 8F91      		pop r24
 5618 0802 0F90      		pop r0
 5619 0804 0FBE      		out __SREG__,r0
 5620 0806 0F90      		pop r0
 5621 0808 1F90      		pop r1
 5622 080a 1895      		reti
 5623               		.cfi_endproc
 5624               	.LFE52:
 5626               	.global	writingTimedout
 5627               		.section .bss
 5630               	writingTimedout:
 5631 0000 00        		.zero	1
 5632               	.global	lastBankAccessed
 5635               	lastBankAccessed:
 5636 0001 00        		.zero	1
 5637               	.global	flashBank1CommandWrites
 5640               	flashBank1CommandWrites:
 5641 0002 00        		.zero	1
 5642               		.comm	flashWriteCycle,12,1
 5643               		.comm	flashWriteWePin,1,1
 5644               		.comm	flashChipIdBuffer,2,1
 5645               		.comm	eepromBuffer,8,1
 5646               		.comm	receivedChar,1,1
 5647               		.comm	receivedBuffer,256,1
 5648               		.text
 5649               	.Letext0:
 5650               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5651               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1467   .text:0000040a gb_flash_read_byte_fast
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1499   .text:00000416 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1578   .text:00000448 gb_flash_write_bus_cycle_fast
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1648   .text:0000046e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:5630   .bss:00000000 writingTimedout
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1751   .text:000004d8 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:5640   .bss:00000002 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:5635   .bss:00000001 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:1876   .text:0000055a gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2042   .text:000005f4 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2108   .text:00000624 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2232   .text:00000684 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2354   .text:000006e0 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2465   .text:0000073c start_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2488   .text:0000074c stop_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2511   .text:0000075a check_if_timed_out
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2543   .text:0000076c setup
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:2665   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccDmtYWU.s:5579   .text:000007e2 __vector_6

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
