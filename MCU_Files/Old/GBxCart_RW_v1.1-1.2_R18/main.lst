   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R18
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 3/07/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 146:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 147:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 148:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
 149:setup.c       **** 
 150:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 151:setup.c       **** 
 152:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 153:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 154:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 155:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 156:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 157:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 158:setup.c       **** #define GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE 'v'
 159:setup.c       **** #define GBA_FLASH_WRITE_SHARP_64BYTE 'x'
 160:setup.c       **** #define D0D1_NOT_SWAPPED 0
 161:setup.c       **** #define D0D1_SWAPPED 1
 162:setup.c       **** 
 163:setup.c       **** // General commands
 164:setup.c       **** #define SEND_ACK '1'
 165:setup.c       **** #define CART_MODE 'C'
 166:setup.c       **** #define SET_INPUT 'I'
 167:setup.c       **** #define SET_OUTPUT 'O'
 168:setup.c       **** #define SET_OUTPUT_LOW 'L'
 169:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 170:setup.c       **** #define READ_INPUT 'D'
 171:setup.c       **** #define RESET_COMMON_LINES 'M'
 172:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 173:setup.c       **** #define READ_PCB_VERSION 'h'
 174:setup.c       **** 
 175:setup.c       **** #define RESET_AVR '*'
 176:setup.c       **** #define RESET_VALUE 0x7E5E1
 177:setup.c       **** 
 178:setup.c       **** 
 179:setup.c       **** char receivedBuffer[256];
 180:setup.c       **** char receivedChar;
 181:setup.c       **** uint8_t eepromBuffer[8];
 182:setup.c       **** uint8_t flashChipIdBuffer[2];
 183:setup.c       **** 
 184:setup.c       **** char flashWriteWePin;
 185:setup.c       **** uint16_t flashWriteCycle[3][2];
 186:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 187:setup.c       **** uint8_t lastBankAccessed = 0;
 188:setup.c       **** 
 189:setup.c       **** 
 190:setup.c       **** // Receive USART data
 191:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 191 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 192:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 192 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 193:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 193 0
  26 0004 8CB1      		in r24,0xc
 194:setup.c       **** }
  27               		.loc 1 194 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 195:setup.c       **** 
 196:setup.c       **** // Transmit USART data
 197:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 197 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 198:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 198 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 199:setup.c       **** 	UDR = data;
  47               		.loc 1 199 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 200:setup.c       **** }
 201:setup.c       **** 
 202:setup.c       **** // Read 1-256 bytes from the USART 
 203:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 203 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB148:
 204:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 204 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 204 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 205:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 205 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE148:
 206:setup.c       **** 	}
 207:setup.c       **** }
 106               		.loc 1 207 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 208:setup.c       **** 
 209:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 210:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 210 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 211:setup.c       **** 	int x = 0;
 212:setup.c       **** 	while (1) {
 213:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 213 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 214:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 214 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 215:setup.c       **** 			break;
 216:setup.c       **** 		}
 217:setup.c       **** 		x++;
 218:setup.c       **** 	}
 219:setup.c       **** }
 148               		.loc 1 219 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 220:setup.c       **** 
 221:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 222:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 222 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 223:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 223 0
 167 0050 3A9A      		sbi 0x7,2
 224:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 224 0
 169 0052 949A      		sbi 0x12,4
 225:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 225 0
 171 0054 959A      		sbi 0x12,5
 226:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 226 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 227:setup.c       **** }
 228:setup.c       **** 
 229:setup.c       **** 
 230:setup.c       **** 
 231:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 232:setup.c       **** 
 233:setup.c       **** // Set Gameboy mode
 234:setup.c       **** void gb_mode(void) {
 182               		.loc 1 234 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 235:setup.c       **** 	// Set inputs
 236:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 236 0
 189 005a 15BA      		out 0x15,__zero_reg__
 237:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 237 0
 191 005c 14BA      		out 0x14,__zero_reg__
 238:setup.c       **** 	
 239:setup.c       **** 	// Set outputs
 240:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 240 0
 193 005e 18BA      		out 0x18,__zero_reg__
 241:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 241 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 242:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 242 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 243:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 243 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 244:setup.c       **** }
 245:setup.c       **** 
 246:setup.c       **** // Set the 16 bit address on A15-0
 247:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 247 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 248:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 248 0
 217 006a 9BBB      		out 0x1b,r25
 249:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 249 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 250:setup.c       **** }
 251:setup.c       **** 
 252:setup.c       **** // Set the address and read a byte from the 8 bit data line
 253:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 253 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 254:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 254 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 255:setup.c       **** 	
 256:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 256 0
 239 0072 9498      		cbi 0x12,4
 257:setup.c       **** 	rdPin_low;
 240               		.loc 1 257 0
 241 0074 9598      		cbi 0x12,5
 258:setup.c       **** 	
 259:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 259 0
 243               	/* #APP */
 244               	 ;  259 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 260:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 260 0
 248               	 ;  260 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 261:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 261 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 262:setup.c       **** 	
 263:setup.c       **** 	rdPin_high;
 255               		.loc 1 263 0
 256 007c 959A      		sbi 0x12,5
 264:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 264 0
 258 007e 949A      		sbi 0x12,4
 265:setup.c       **** 	
 266:setup.c       **** 	return data;
 267:setup.c       **** }
 259               		.loc 1 267 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 268:setup.c       **** 
 269:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 270:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 270 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 271:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 271 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 272:setup.c       **** 	
 273:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 273 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 274:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 274 0
 292 0090 D5BB      		out 0x15,r29
 275:setup.c       **** 	
 276:setup.c       **** 	// Pulse WR and mREQ if the type matches
 277:setup.c       **** 	wrPin_low;
 293               		.loc 1 277 0
 294 0092 9698      		cbi 0x12,6
 278:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 278 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 279:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 279 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 280:setup.c       **** 	}
 281:setup.c       **** 	
 282:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 282 0
 302               	/* #APP */
 303               	 ;  282 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 283:setup.c       **** 	
 284:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 284 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 285:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 285 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 286:setup.c       **** 	}
 287:setup.c       **** 	wrPin_high;
 313               		.loc 1 287 0
 314 00a2 969A      		sbi 0x12,6
 288:setup.c       **** 	
 289:setup.c       **** 	// Clear data outputs and set data pins as inputs
 290:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 290 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 291:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 291 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 292:setup.c       **** }
 320               		.loc 1 292 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 293:setup.c       **** 
 294:setup.c       **** 
 295:setup.c       **** 
 296:setup.c       **** // ****** Gameboy Advance functions ****** 
 297:setup.c       **** 
 298:setup.c       **** // Set GBA mode
 299:setup.c       **** void gba_mode(void) {
 333               		.loc 1 299 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 300:setup.c       **** 	// Set outputs for reading ROM addresses as default
 301:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 301 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 302:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 302 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 303:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 303 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 304:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 304 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 305:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 305 0
 349 00b8 8ABB      		out 0x1a,r24
 306:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 306 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 307:setup.c       **** }
 308:setup.c       **** 
 309:setup.c       **** // Set the 24 bit address on A23-0
 310:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 310 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 311:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 311 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 312:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 312 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 313:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 313 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 314:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 314 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 315:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 315 0
 385 00cc 2ABB      		out 0x1a,r18
 316:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 316 0
 387 00ce 27BB      		out 0x17,r18
 317:setup.c       **** 	
 318:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 318 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 319:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 319 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 320:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 320 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 321:setup.c       **** }
 402               		.loc 1 321 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 322:setup.c       **** 
 323:setup.c       **** 
 324:setup.c       **** 
 325:setup.c       **** // ---------- ROM/SRAM ----------
 326:setup.c       **** 
 327:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 328:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 328 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 329:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 329 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 330:setup.c       **** 	
 331:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 331 0
 424 00ec 9498      		cbi 0x12,4
 332:setup.c       **** 	
 333:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 333 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 334:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 334 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 335:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 335 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 336:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 336 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 337:setup.c       **** 	
 338:setup.c       **** 	rdPin_low;
 433               		.loc 1 338 0
 434 00f6 9598      		cbi 0x12,5
 339:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 339 0
 436               	/* #APP */
 437               	 ;  339 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 340:setup.c       **** 	
 341:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 341 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 342:setup.c       **** 	
 343:setup.c       **** 	rdPin_high;
 445               		.loc 1 343 0
 446 00fe 959A      		sbi 0x12,5
 344:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 344 0
 448 0100 949A      		sbi 0x12,4
 345:setup.c       **** 	
 346:setup.c       **** 	return data;
 449               		.loc 1 346 0
 450 0102 90E0      		ldi r25,0
 347:setup.c       **** }
 451               		.loc 1 347 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 348:setup.c       **** 
 349:setup.c       **** // Set the address and read a byte from the 8 bit data line
 350:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 350 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 351:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 351 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 352:setup.c       **** 	
 353:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 471               		.loc 1 353 0
 472 010a 3A98      		cbi 0x7,2
 354:setup.c       **** 	rdPin_low;
 473               		.loc 1 354 0
 474 010c 9598      		cbi 0x12,5
 355:setup.c       **** 	
 356:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 356 0
 476               	/* #APP */
 477               	 ;  356 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 357:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 357 0
 481               	 ;  357 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 358:setup.c       **** 	
 359:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 359 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 360:setup.c       **** 	
 361:setup.c       **** 	rdPin_high;
 488               		.loc 1 361 0
 489 0114 959A      		sbi 0x12,5
 362:setup.c       **** 	cs2Pin_high;
 490               		.loc 1 362 0
 491 0116 3A9A      		sbi 0x7,2
 363:setup.c       **** 	
 364:setup.c       **** 	return data;
 365:setup.c       **** }
 492               		.loc 1 365 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 366:setup.c       **** 
 367:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 368:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 368 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 369:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 369 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 370:setup.c       **** 	
 371:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 371 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 372:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 372 0
 520 0124 C5BB      		out 0x15,r28
 373:setup.c       **** 	
 374:setup.c       **** 	// Pulse WR
 375:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 521               		.loc 1 375 0
 522 0126 3A98      		cbi 0x7,2
 376:setup.c       **** 	wrPin_low;
 523               		.loc 1 376 0
 524 0128 9698      		cbi 0x12,6
 377:setup.c       **** 	
 378:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 378 0
 526               	/* #APP */
 527               	 ;  378 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 379:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 379 0
 531               	 ;  379 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 380:setup.c       **** 	
 381:setup.c       **** 	wrPin_high;
 534               		.loc 1 381 0
 535               	/* #NOAPP */
 536 012e 969A      		sbi 0x12,6
 382:setup.c       **** 	cs2Pin_high;
 537               		.loc 1 382 0
 538 0130 3A9A      		sbi 0x7,2
 383:setup.c       **** 	
 384:setup.c       **** 	// Clear data outputs and set data pins as inputs
 385:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 385 0
 540 0132 15BA      		out 0x15,__zero_reg__
 386:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 386 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 387:setup.c       **** }
 544               		.loc 1 387 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 388:setup.c       **** 
 389:setup.c       **** 
 390:setup.c       **** 
 391:setup.c       **** // ---------- EEPROM ----------
 392:setup.c       **** 
 393:setup.c       **** // Set address/data all high (includes AD0/A23)
 394:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 394 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 395:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 395 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 396:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 396 0
 565 013e 8ABB      		out 0x1a,r24
 397:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 397 0
 567 0140 84BB      		out 0x14,r24
 398:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 398 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 399:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 399 0
 572 0146 8BBB      		out 0x1b,r24
 400:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 400 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 401:setup.c       **** }
 402:setup.c       **** 
 403:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 404:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 404 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 405:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 405 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 406:setup.c       **** 	
 407:setup.c       **** 	int8_t x = 0;
 408:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 408 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 409:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 409 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 410:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 410 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 411:setup.c       **** 		}
 412:setup.c       **** 		else {
 413:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 414:setup.c       **** 		}
 415:setup.c       **** 		x = 15;
 603               		.loc 1 415 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 416:setup.c       **** 	}
 417:setup.c       **** 	else {
 418:setup.c       **** 		if (command == EEPROM_READ) {
 419:setup.c       **** 			address |= (1<<7) | (1<<6);
 420:setup.c       **** 		}
 421:setup.c       **** 		else {
 422:setup.c       **** 			address |= (1<<7);
 423:setup.c       **** 		}
 424:setup.c       **** 		x = 7;
 425:setup.c       **** 	}
 426:setup.c       **** 	
 427:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 428:setup.c       **** 	while (x >= 0) {
 429:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 429 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 413:setup.c       **** 		}
 613               		.loc 1 413 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 418:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 418 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 419:setup.c       **** 		}
 621               		.loc 1 419 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 422:setup.c       **** 		}
 626               		.loc 1 422 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 424:setup.c       **** 	}
 630               		.loc 1 424 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 430:setup.c       **** 			ad0Pin_high;
 431:setup.c       **** 		}
 432:setup.c       **** 		else {
 433:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 433 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 434:setup.c       **** 		}
 435:setup.c       **** 		
 436:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 436 0
 639 0174 9698      		cbi 0x12,6
 437:setup.c       **** 		asm ("nop");
 640               		.loc 1 437 0
 641               	/* #APP */
 642               	 ;  437 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 438:setup.c       **** 		asm ("nop");
 645               		.loc 1 438 0
 646               	 ;  438 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 439:setup.c       **** 		wrPin_high; 
 649               		.loc 1 439 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 440:setup.c       **** 		asm ("nop");
 652               		.loc 1 440 0
 653               	/* #APP */
 654               	 ;  440 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 441:setup.c       **** 		asm ("nop");
 657               		.loc 1 441 0
 658               	 ;  441 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 428:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 428 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 429:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 429 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 430:setup.c       **** 		}
 682               		.loc 1 430 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 442:setup.c       **** 		
 443:setup.c       **** 		x--;
 444:setup.c       **** 	}
 445:setup.c       **** 	
 446:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 447:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 447 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 448:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 448 0
 690 01a4 C098      		cbi 0x18,0
 449:setup.c       **** 		asm ("nop");
 691               		.loc 1 449 0
 692               	/* #APP */
 693               	 ;  449 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 450:setup.c       **** 		wrPin_low;
 696               		.loc 1 450 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 451:setup.c       **** 		asm ("nop");
 699               		.loc 1 451 0
 700               	/* #APP */
 701               	 ;  451 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 452:setup.c       **** 		asm ("nop");
 704               		.loc 1 452 0
 705               	 ;  452 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 453:setup.c       **** 		
 454:setup.c       **** 		wrPin_high;
 708               		.loc 1 454 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 455:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 455 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 456:setup.c       **** 	}
 457:setup.c       **** }
 458:setup.c       **** 
 459:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 460:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 460 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 461:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 461 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 462:setup.c       **** 	
 463:setup.c       **** 	// Set AD0 pin as input
 464:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 464 0
 734 01b8 C098      		cbi 0x18,0
 465:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 465 0
 736 01ba B898      		cbi 0x17,0
 466:setup.c       **** 	
 467:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 467 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB149:
 468:setup.c       **** 	
 469:setup.c       **** 	// Ignore first 4 bits
 470:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 471:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 471 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 472:setup.c       **** 		asm ("nop");
 746               		.loc 1 472 0 discriminator 3
 747               	/* #APP */
 748               	 ;  472 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 473:setup.c       **** 		asm ("nop");
 751               		.loc 1 473 0 discriminator 3
 752               	 ;  473 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 474:setup.c       **** 		rdPin_high; 
 755               		.loc 1 474 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 475:setup.c       **** 		asm ("nop");
 758               		.loc 1 475 0 discriminator 3
 759               	/* #APP */
 760               	 ;  475 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 476:setup.c       **** 		asm ("nop");
 763               		.loc 1 476 0 discriminator 3
 764               	 ;  476 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 470:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 470 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE149:
 776               	.LBB150:
 777               	.LBB151:
 778               	.LBB152:
 477:setup.c       **** 	}
 478:setup.c       **** 	
 479:setup.c       **** 	// Read out 64 bits
 480:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 481:setup.c       **** 		uint8_t data = 0;
 482:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 483:setup.c       **** 			rdPin_low; // CLK
 484:setup.c       **** 			asm ("nop");
 485:setup.c       **** 			asm ("nop");
 486:setup.c       **** 			rdPin_high;
 487:setup.c       **** 			
 488:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 489:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 489 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE152:
 785               	.LBE151:
 786               	.LBE150:
 467:setup.c       **** 	
 787               		.loc 1 467 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB155:
 794               	.LBB154:
 795               	.LBB153:
 483:setup.c       **** 			asm ("nop");
 796               		.loc 1 483 0
 797 01de 9598      		cbi 0x12,5
 484:setup.c       **** 			asm ("nop");
 798               		.loc 1 484 0
 799               	/* #APP */
 800               	 ;  484 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 485:setup.c       **** 			rdPin_high;
 803               		.loc 1 485 0
 804               	 ;  485 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 486:setup.c       **** 			
 807               		.loc 1 486 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 488:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 488 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 489 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE153:
 490:setup.c       **** 			}
 491:setup.c       **** 		}
 492:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 492 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE154:
 480:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 480 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE155:
 493:setup.c       **** 	}
 494:setup.c       **** 	
 495:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 495 0
 841 0206 949A      		sbi 0x12,4
 496:setup.c       **** 	
 497:setup.c       **** 	// Set AD0 pin as output
 498:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 498 0
 843 0208 C09A      		sbi 0x18,0
 499:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 499 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 500:setup.c       **** }
 501:setup.c       **** 
 502:setup.c       **** // Write 8 bytes to the EEPROM address
 503:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 503 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 504:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 504 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 503:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 503 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB156:
 876               	.LBB157:
 505:setup.c       **** 	
 506:setup.c       **** 	// Write 64 bits
 507:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 508:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 509:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 509 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 510:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 510 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 511:setup.c       **** 			}
 512:setup.c       **** 			else {
 513:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 513 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 514:setup.c       **** 			}
 515:setup.c       **** 			
 516:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 516 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 517:setup.c       **** 			asm ("nop");
 899               		.loc 1 517 0 discriminator 2
 900               	/* #APP */
 901               	 ;  517 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 518:setup.c       **** 			asm ("nop");
 904               		.loc 1 518 0 discriminator 2
 905               	 ;  518 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 519:setup.c       **** 			wrPin_high; 
 908               		.loc 1 519 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 520:setup.c       **** 			asm ("nop");
 911               		.loc 1 520 0 discriminator 2
 912               	/* #APP */
 913               	 ;  520 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 521:setup.c       **** 			asm ("nop");
 916               		.loc 1 521 0 discriminator 2
 917               	 ;  521 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE157:
 507:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 507 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE156:
 522:setup.c       **** 		}
 523:setup.c       **** 	}
 524:setup.c       **** 	
 525:setup.c       **** 	// Last bit low
 526:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 526 0
 935 0250 C098      		cbi 0x18,0
 527:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 527 0
 937 0252 9698      		cbi 0x12,6
 528:setup.c       **** 	asm ("nop");
 938               		.loc 1 528 0
 939               	/* #APP */
 940               	 ;  528 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 529:setup.c       **** 	asm ("nop");
 943               		.loc 1 529 0
 944               	 ;  529 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 530:setup.c       **** 	wrPin_high; 
 947               		.loc 1 530 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 531:setup.c       **** 	asm ("nop");
 950               		.loc 1 531 0
 951               	/* #APP */
 952               	 ;  531 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 532:setup.c       **** 	asm ("nop");
 955               		.loc 1 532 0
 956               	 ;  532 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 533:setup.c       **** 	
 534:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 534 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 535:setup.c       **** }
 536:setup.c       **** 
 537:setup.c       **** 
 538:setup.c       **** 
 539:setup.c       **** // ---------- FLASH ----------
 540:setup.c       **** 
 541:setup.c       **** // Set the address and data for the write byte cycle to the flash
 542:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 542 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 543:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 543 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 544:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 544 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 545:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 545 0
 989 026c C5BB      		out 0x15,r28
 546:setup.c       **** 	
 547:setup.c       **** 	cs2Pin_low;
 990               		.loc 1 547 0
 991 026e 3A98      		cbi 0x7,2
 548:setup.c       **** 	wrPin_low;
 992               		.loc 1 548 0
 993 0270 9698      		cbi 0x12,6
 549:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 549 0
 995               	/* #APP */
 996               	 ;  549 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 550:setup.c       **** 	cs2Pin_high;
 999               		.loc 1 550 0
 1000               	/* #NOAPP */
 1001 0274 3A9A      		sbi 0x7,2
 551:setup.c       **** 	wrPin_high;
 1002               		.loc 1 551 0
 1003 0276 969A      		sbi 0x12,6
 1004               	/* epilogue start */
 552:setup.c       **** }
 1005               		.loc 1 552 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 553:setup.c       **** 
 554:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 555:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 555 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 556:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 556 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 557:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 557 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 558:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 558 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB158:
 1049               	.LBB159:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE159:
 1060               	.LBE158:
 559:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 560:setup.c       **** 	
 561:setup.c       **** 	// Set data as inputs
 562:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 562 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 563:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 563 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 564:setup.c       **** 	
 565:setup.c       **** 	// Read and transmit the 2 bytes
 566:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 566 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 567:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 567 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 568:setup.c       **** 	
 569:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 569 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 570:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 570 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 571:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 571 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB160:
 1098               	.LBB161:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE161:
 1109               	.LBE160:
 572:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 573:setup.c       **** }
 1110               		.loc 1 573 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 574:setup.c       **** 
 575:setup.c       **** // Switch banks on the Flash
 576:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 576 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 577:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 577 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 578:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 578 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 579:setup.c       **** 	
 580:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 580 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 581:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 581 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 582:setup.c       **** }
 1157               		.loc 1 582 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 581:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 581 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 583:setup.c       **** 
 584:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 585:setup.c       **** // Takes 25ms after last command to erase sector
 586:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 586 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 587:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 587 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 588:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 588 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 589:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 589 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 590:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 590 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 591:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 591 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 592:setup.c       **** 	
 593:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 593 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB162:
 1222               	.LBB163:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE163:
 1233               	.LBE162:
 594:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 595:setup.c       **** }
 1234               		.loc 1 595 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 596:setup.c       **** 
 597:setup.c       **** // Write a single byte to the Flash address
 598:setup.c       **** // Takes 20us to program Flash
 599:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 599 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 600:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 600 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 601:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 601 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 602:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 602 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 603:setup.c       **** 	
 604:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 604 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB164:
 1292               	.LBB165:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE165:
 1301               	.LBE164:
 605:setup.c       **** 	_delay_us(20); // Wait byte program time
 606:setup.c       **** }
 1302               		.loc 1 606 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 607:setup.c       **** 
 608:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 609:setup.c       **** // Takes 20ms for write cycle
 610:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 610 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 611:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 611 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 612:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 612 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 613:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 613 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB166:
 614:setup.c       **** 	
 615:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 616:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 617:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 617 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 617 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 616:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 616 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE166:
 1400               	.LBB167:
 1401               	.LBB168:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE168:
 1412               	.LBE167:
 618:setup.c       **** 	}
 619:setup.c       **** 	_delay_ms(20); // Wait sector program time
 620:setup.c       **** }
 1413               		.loc 1 620 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 621:setup.c       **** 
 622:setup.c       **** 
 623:setup.c       **** 
 624:setup.c       **** // ---------- GB FLASH CARTS ----------
 625:setup.c       **** 
 626:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 627:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 627 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 628:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 628 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 629:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 629 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 630:setup.c       **** 	
 631:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 631 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 632:setup.c       **** 	
 633:setup.c       **** 	rdPin_low;
 1443               		.loc 1 633 0
 1444 03fe 9598      		cbi 0x12,5
 634:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 634 0
 1446               	/* #APP */
 1447               	 ;  634 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 635:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 635 0
 1451               	 ;  635 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 636:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 636 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 637:setup.c       **** 	rdPin_high;
 1458               		.loc 1 637 0
 1459 0406 959A      		sbi 0x12,5
 638:setup.c       **** 	
 639:setup.c       **** 	return data;
 640:setup.c       **** }
 1460               		.loc 1 640 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 641:setup.c       **** 
 642:setup.c       **** // Set the address and data for the write byte cycle to the flash
 643:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 643 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 644:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 644 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 645:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 645 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 646:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 646 0
 1488 0414 C5BB      		out 0x15,r28
 647:setup.c       **** 	
 648:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 648 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 649:setup.c       **** 		audioPin_low; // WE low
 1493               		.loc 1 649 0
 1494 041e 3998      		cbi 0x7,1
 650:setup.c       **** 		asm volatile("nop");
 1495               		.loc 1 650 0
 1496               	/* #APP */
 1497               	 ;  650 "setup.c" 1
 1498 0420 0000      		nop
 1499               	 ;  0 "" 2
 651:setup.c       **** 		asm volatile("nop");
 1500               		.loc 1 651 0
 1501               	 ;  651 "setup.c" 1
 1502 0422 0000      		nop
 1503               	 ;  0 "" 2
 652:setup.c       **** 		asm volatile("nop");
 1504               		.loc 1 652 0
 1505               	 ;  652 "setup.c" 1
 1506 0424 0000      		nop
 1507               	 ;  0 "" 2
 653:setup.c       **** 		audioPin_high; // WE high
 1508               		.loc 1 653 0
 1509               	/* #NOAPP */
 1510 0426 399A      		sbi 0x7,1
 1511 0428 00C0      		rjmp .L71
 1512               	.L70:
 654:setup.c       **** 	}
 655:setup.c       **** 	else { // WR pin
 656:setup.c       **** 		wrPin_low; // WE low
 1513               		.loc 1 656 0
 1514 042a 9698      		cbi 0x12,6
 657:setup.c       **** 		asm volatile("nop");
 1515               		.loc 1 657 0
 1516               	/* #APP */
 1517               	 ;  657 "setup.c" 1
 1518 042c 0000      		nop
 1519               	 ;  0 "" 2
 658:setup.c       **** 		asm volatile("nop");
 1520               		.loc 1 658 0
 1521               	 ;  658 "setup.c" 1
 1522 042e 0000      		nop
 1523               	 ;  0 "" 2
 659:setup.c       **** 		asm volatile("nop");
 1524               		.loc 1 659 0
 1525               	 ;  659 "setup.c" 1
 1526 0430 0000      		nop
 1527               	 ;  0 "" 2
 660:setup.c       **** 		wrPin_high; // WE high
 1528               		.loc 1 660 0
 1529               	/* #NOAPP */
 1530 0432 969A      		sbi 0x12,6
 1531               	.L71:
 661:setup.c       **** 	}
 662:setup.c       **** 	
 663:setup.c       **** 	// Clear data outputs and set data pins as inputs
 664:setup.c       **** 	PORT_DATA7_0 = 0;
 1532               		.loc 1 664 0
 1533 0434 15BA      		out 0x15,__zero_reg__
 665:setup.c       **** 	DDR_DATA7_0 = 0;
 1534               		.loc 1 665 0
 1535 0436 14BA      		out 0x14,__zero_reg__
 1536               	/* epilogue start */
 666:setup.c       **** }
 1537               		.loc 1 666 0
 1538 0438 CF91      		pop r28
 1539               	.LVL118:
 1540 043a 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE37:
 1544               	.global	gb_flash_write_byte
 1546               	gb_flash_write_byte:
 1547               	.LFB38:
 667:setup.c       **** 
 668:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 669:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1548               		.loc 1 669 0
 1549               		.cfi_startproc
 1550               	.LVL119:
 1551 043c 1F93      		push r17
 1552               	.LCFI26:
 1553               		.cfi_def_cfa_offset 3
 1554               		.cfi_offset 17, -2
 1555 043e CF93      		push r28
 1556               	.LCFI27:
 1557               		.cfi_def_cfa_offset 4
 1558               		.cfi_offset 28, -3
 1559 0440 DF93      		push r29
 1560               	.LCFI28:
 1561               		.cfi_def_cfa_offset 5
 1562               		.cfi_offset 29, -4
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 3 */
 1566               	.L__stack_usage = 3
 1567 0442 EC01      		movw r28,r24
 1568 0444 162F      		mov r17,r22
 670:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1569               		.loc 1 670 0
 1570 0446 6091 0000 		lds r22,flashWriteCycle+2
 1571               	.LVL120:
 1572 044a 8091 0000 		lds r24,flashWriteCycle
 1573 044e 9091 0000 		lds r25,flashWriteCycle+1
 1574               	.LVL121:
 1575 0452 00D0      		rcall gb_flash_write_bus_cycle
 1576               	.LVL122:
 671:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1577               		.loc 1 671 0
 1578 0454 6091 0000 		lds r22,flashWriteCycle+6
 1579 0458 8091 0000 		lds r24,flashWriteCycle+4
 1580 045c 9091 0000 		lds r25,flashWriteCycle+4+1
 1581 0460 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 672:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1583               		.loc 1 672 0
 1584 0462 6091 0000 		lds r22,flashWriteCycle+10
 1585 0466 8091 0000 		lds r24,flashWriteCycle+8
 1586 046a 9091 0000 		lds r25,flashWriteCycle+8+1
 1587 046e 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 673:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1589               		.loc 1 673 0
 1590 0470 612F      		mov r22,r17
 1591 0472 CE01      		movw r24,r28
 1592 0474 00D0      		rcall gb_flash_write_bus_cycle
 1593               	.LVL125:
 1594               	.LBB169:
 1595               	.LBB170:
 1596               		.loc 2 276 0
 1597 0476 8AE1      		ldi r24,lo8(26)
 1598 0478 8A95      	1:	dec r24
 1599 047a 01F4      		brne 1b
 1600 047c 00C0      		rjmp .
 1601               	.LVL126:
 1602               	.LBE170:
 1603               	.LBE169:
 674:setup.c       **** 	_delay_us(10); // Wait byte program time
 675:setup.c       **** 	
 676:setup.c       **** 	// Set data pins inputs
 677:setup.c       **** 	PORT_DATA7_0 = 0;
 1604               		.loc 1 677 0
 1605 047e 15BA      		out 0x15,__zero_reg__
 678:setup.c       **** 	DDR_DATA7_0 = 0;
 1606               		.loc 1 678 0
 1607 0480 14BA      		out 0x14,__zero_reg__
 679:setup.c       **** 	
 680:setup.c       **** 	// Verify data
 681:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1608               		.loc 1 681 0
 1609 0482 CE01      		movw r24,r28
 1610 0484 00D0      		rcall gb_flash_read_byte
 1611               	.LVL127:
 1612               	.L73:
 682:setup.c       **** 	while (data != dataVerify) {
 1613               		.loc 1 682 0
 1614 0486 8117      		cp r24,r17
 1615 0488 01F0      		breq .L75
 683:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1616               		.loc 1 683 0
 1617 048a CE01      		movw r24,r28
 1618               	.LVL128:
 1619 048c 00D0      		rcall gb_flash_read_byte
 1620               	.LVL129:
 1621               	.LBB171:
 1622               	.LBB172:
 1623               		.loc 2 276 0
 1624 048e 9DE0      		ldi r25,lo8(13)
 1625 0490 9A95      	1:	dec r25
 1626 0492 01F4      		brne 1b
 1627 0494 0000      		nop
 1628 0496 00C0      		rjmp .L73
 1629               	.LVL130:
 1630               	.L75:
 1631               	/* epilogue start */
 1632               	.LBE172:
 1633               	.LBE171:
 684:setup.c       **** 		_delay_us(5);
 685:setup.c       **** 	}
 686:setup.c       **** }
 1634               		.loc 1 686 0
 1635 0498 DF91      		pop r29
 1636 049a CF91      		pop r28
 1637               	.LVL131:
 1638 049c 1F91      		pop r17
 1639               	.LVL132:
 1640 049e 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE38:
 1644               	.global	gb_flash_write_byte_special
 1646               	gb_flash_write_byte_special:
 1647               	.LFB39:
 687:setup.c       **** 
 688:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 689:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1648               		.loc 1 689 0
 1649               		.cfi_startproc
 1650               	.LVL133:
 1651 04a0 1F93      		push r17
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 17, -2
 1655 04a2 CF93      		push r28
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 28, -3
 1659 04a4 DF93      		push r29
 1660               	.LCFI31:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 29, -4
 1663               	/* prologue: function */
 1664               	/* frame size = 0 */
 1665               	/* stack size = 3 */
 1666               	.L__stack_usage = 3
 1667 04a6 EC01      		movw r28,r24
 1668 04a8 162F      		mov r17,r22
 690:setup.c       **** 	// Set bank back
 691:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1669               		.loc 1 691 0
 1670 04aa 8091 0000 		lds r24,flashBank1CommandWrites
 1671               	.LVL134:
 1672 04ae 8130      		cpi r24,lo8(1)
 1673 04b0 01F4      		brne .L77
 692:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1674               		.loc 1 692 0
 1675 04b2 40E0      		ldi r20,0
 1676 04b4 6091 0000 		lds r22,lastBankAccessed
 1677               	.LVL135:
 1678 04b8 80E0      		ldi r24,0
 1679 04ba 91E2      		ldi r25,lo8(33)
 1680 04bc 00D0      		rcall write_8bit_data
 1681               	.LVL136:
 1682               	.LBB173:
 1683               	.LBB174:
 1684               		.loc 2 276 0
 1685 04be 85E8      		ldi r24,lo8(-123)
 1686 04c0 8A95      	1:	dec r24
 1687 04c2 01F4      		brne 1b
 1688 04c4 0000      		nop
 1689               	.LVL137:
 1690               	.L77:
 1691               	.LBE174:
 1692               	.LBE173:
 693:setup.c       **** 		_delay_us(50);
 694:setup.c       **** 	}
 695:setup.c       **** 	
 696:setup.c       **** 	// Write
 697:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1693               		.loc 1 697 0
 1694 04c6 6091 0000 		lds r22,flashWriteCycle+2
 1695 04ca 8091 0000 		lds r24,flashWriteCycle
 1696 04ce 9091 0000 		lds r25,flashWriteCycle+1
 1697 04d2 00D0      		rcall gb_flash_write_bus_cycle
 1698               	.LVL138:
 698:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1699               		.loc 1 698 0
 1700 04d4 6091 0000 		lds r22,flashWriteCycle+6
 1701 04d8 8091 0000 		lds r24,flashWriteCycle+4
 1702 04dc 9091 0000 		lds r25,flashWriteCycle+4+1
 1703 04e0 00D0      		rcall gb_flash_write_bus_cycle
 1704               	.LVL139:
 699:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1705               		.loc 1 699 0
 1706 04e2 6091 0000 		lds r22,flashWriteCycle+10
 1707 04e6 8091 0000 		lds r24,flashWriteCycle+8
 1708 04ea 9091 0000 		lds r25,flashWriteCycle+8+1
 1709 04ee 00D0      		rcall gb_flash_write_bus_cycle
 1710               	.LVL140:
 700:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1711               		.loc 1 700 0
 1712 04f0 612F      		mov r22,r17
 1713 04f2 CE01      		movw r24,r28
 1714 04f4 00D0      		rcall gb_flash_write_bus_cycle
 1715               	.LVL141:
 1716               	.LBB175:
 1717               	.LBB176:
 1718               		.loc 2 276 0
 1719 04f6 83EF      		ldi r24,lo8(499)
 1720 04f8 91E0      		ldi r25,hi8(499)
 1721 04fa 0197      	1:	sbiw r24,1
 1722 04fc 01F4      		brne 1b
 1723 04fe 00C0      		rjmp .
 1724 0500 0000      		nop
 1725               	.LVL142:
 1726               	.LBE176:
 1727               	.LBE175:
 701:setup.c       **** 	_delay_us(250); // Wait byte program time
 702:setup.c       **** 	
 703:setup.c       **** 	// Set data pins inputs
 704:setup.c       **** 	PORT_DATA7_0 = 0;
 1728               		.loc 1 704 0
 1729 0502 15BA      		out 0x15,__zero_reg__
 705:setup.c       **** 	DDR_DATA7_0 = 0;
 1730               		.loc 1 705 0
 1731 0504 14BA      		out 0x14,__zero_reg__
 706:setup.c       **** 	
 707:setup.c       **** 	// Pulse reset
 708:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1732               		.loc 1 708 0
 1733 0506 3A98      		cbi 0x7,2
 1734               	.LVL143:
 1735               	.LBB177:
 1736               	.LBB178:
 1737               		.loc 2 276 0
 1738 0508 95E8      		ldi r25,lo8(-123)
 1739 050a 9A95      	1:	dec r25
 1740 050c 01F4      		brne 1b
 1741 050e 0000      		nop
 1742               	.LVL144:
 1743               	.LBE178:
 1744               	.LBE177:
 709:setup.c       **** 	_delay_us(50);
 710:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1745               		.loc 1 710 0
 1746 0510 3A9A      		sbi 0x7,2
 1747               	.LVL145:
 1748               	.LBB179:
 1749               	.LBB180:
 1750               		.loc 2 276 0
 1751 0512 85E8      		ldi r24,lo8(-123)
 1752 0514 8A95      	1:	dec r24
 1753 0516 01F4      		brne 1b
 1754 0518 0000      		nop
 1755               	.LVL146:
 1756               	/* epilogue start */
 1757               	.LBE180:
 1758               	.LBE179:
 711:setup.c       **** 	_delay_us(50);
 712:setup.c       **** }
 1759               		.loc 1 712 0
 1760 051a DF91      		pop r29
 1761 051c CF91      		pop r28
 1762               	.LVL147:
 1763 051e 1F91      		pop r17
 1764               	.LVL148:
 1765 0520 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE39:
 1769               	.global	gb_flash_write_byte_bank1_commands
 1771               	gb_flash_write_byte_bank1_commands:
 1772               	.LFB40:
 713:setup.c       **** 
 714:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 715:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 716:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1773               		.loc 1 716 0
 1774               		.cfi_startproc
 1775               	.LVL149:
 1776 0522 FF92      		push r15
 1777               	.LCFI32:
 1778               		.cfi_def_cfa_offset 3
 1779               		.cfi_offset 15, -2
 1780 0524 0F93      		push r16
 1781               	.LCFI33:
 1782               		.cfi_def_cfa_offset 4
 1783               		.cfi_offset 16, -3
 1784 0526 1F93      		push r17
 1785               	.LCFI34:
 1786               		.cfi_def_cfa_offset 5
 1787               		.cfi_offset 17, -4
 1788 0528 CF93      		push r28
 1789               	.LCFI35:
 1790               		.cfi_def_cfa_offset 6
 1791               		.cfi_offset 28, -5
 1792 052a DF93      		push r29
 1793               	.LCFI36:
 1794               		.cfi_def_cfa_offset 7
 1795               		.cfi_offset 29, -6
 1796               	/* prologue: function */
 1797               	/* frame size = 0 */
 1798               	/* stack size = 5 */
 1799               	.L__stack_usage = 5
 1800 052c EC01      		movw r28,r24
 1801 052e 162F      		mov r17,r22
 717:setup.c       **** 	// Set bank 1
 718:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1802               		.loc 1 718 0
 1803 0530 FF24      		clr r15
 1804 0532 FA94      		dec r15
 1805 0534 F4BA      		out 0x14,r15
 1806               	.LVL150:
 1807               	.LBB181:
 1808               	.LBB182:
 248:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1809               		.loc 1 248 0
 1810 0536 01E2      		ldi r16,lo8(33)
 1811 0538 0BBB      		out 0x1b,r16
 249:setup.c       **** }
 1812               		.loc 1 249 0
 1813 053a 18BA      		out 0x18,__zero_reg__
 1814               	.LVL151:
 1815               	.LBE182:
 1816               	.LBE181:
 719:setup.c       **** 	set_16bit_address(0x2100);
 720:setup.c       **** 	PORT_DATA7_0 = 1;
 1817               		.loc 1 720 0
 1818 053c 81E0      		ldi r24,lo8(1)
 1819               	.LVL152:
 1820 053e 85BB      		out 0x15,r24
 721:setup.c       **** 	wrPin_low; // Pulse WR
 1821               		.loc 1 721 0
 1822 0540 9698      		cbi 0x12,6
 722:setup.c       **** 	asm volatile("nop");
 1823               		.loc 1 722 0
 1824               	/* #APP */
 1825               	 ;  722 "setup.c" 1
 1826 0542 0000      		nop
 1827               	 ;  0 "" 2
 723:setup.c       **** 	wrPin_high;
 1828               		.loc 1 723 0
 1829               	/* #NOAPP */
 1830 0544 969A      		sbi 0x12,6
 724:setup.c       **** 	
 725:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1831               		.loc 1 725 0
 1832 0546 6091 0000 		lds r22,flashWriteCycle+2
 1833               	.LVL153:
 1834 054a 8091 0000 		lds r24,flashWriteCycle
 1835 054e 9091 0000 		lds r25,flashWriteCycle+1
 1836 0552 00D0      		rcall gb_flash_write_bus_cycle
 1837               	.LVL154:
 726:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1838               		.loc 1 726 0
 1839 0554 6091 0000 		lds r22,flashWriteCycle+6
 1840 0558 8091 0000 		lds r24,flashWriteCycle+4
 1841 055c 9091 0000 		lds r25,flashWriteCycle+4+1
 1842 0560 00D0      		rcall gb_flash_write_bus_cycle
 1843               	.LVL155:
 727:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1844               		.loc 1 727 0
 1845 0562 6091 0000 		lds r22,flashWriteCycle+10
 1846 0566 8091 0000 		lds r24,flashWriteCycle+8
 1847 056a 9091 0000 		lds r25,flashWriteCycle+8+1
 1848 056e 00D0      		rcall gb_flash_write_bus_cycle
 1849               	.LVL156:
 728:setup.c       **** 	
 729:setup.c       **** 	
 730:setup.c       **** 	// Set bank back
 731:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1850               		.loc 1 731 0
 1851 0570 F4BA      		out 0x14,r15
 1852               	.LVL157:
 1853               	.LBB183:
 1854               	.LBB184:
 248:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1855               		.loc 1 248 0
 1856 0572 0BBB      		out 0x1b,r16
 249:setup.c       **** }
 1857               		.loc 1 249 0
 1858 0574 18BA      		out 0x18,__zero_reg__
 1859               	.LVL158:
 1860               	.LBE184:
 1861               	.LBE183:
 732:setup.c       **** 	set_16bit_address(0x2100);
 733:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1862               		.loc 1 733 0
 1863 0576 8091 0000 		lds r24,lastBankAccessed
 1864 057a 85BB      		out 0x15,r24
 734:setup.c       **** 	wrPin_low; // Pulse WR
 1865               		.loc 1 734 0
 1866 057c 9698      		cbi 0x12,6
 735:setup.c       **** 	asm volatile("nop");
 1867               		.loc 1 735 0
 1868               	/* #APP */
 1869               	 ;  735 "setup.c" 1
 1870 057e 0000      		nop
 1871               	 ;  0 "" 2
 736:setup.c       **** 	wrPin_high;
 1872               		.loc 1 736 0
 1873               	/* #NOAPP */
 1874 0580 969A      		sbi 0x12,6
 737:setup.c       **** 	
 738:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1875               		.loc 1 738 0
 1876 0582 612F      		mov r22,r17
 1877 0584 CE01      		movw r24,r28
 1878 0586 00D0      		rcall gb_flash_write_bus_cycle
 1879               	.LVL159:
 1880               	.LBB185:
 1881               	.LBB186:
 1882               		.loc 2 276 0
 1883 0588 8AE1      		ldi r24,lo8(26)
 1884 058a 8A95      	1:	dec r24
 1885 058c 01F4      		brne 1b
 1886 058e 00C0      		rjmp .
 1887               	.LVL160:
 1888               	.LBE186:
 1889               	.LBE185:
 739:setup.c       **** 	_delay_us(10); // Wait byte program time
 740:setup.c       **** 	
 741:setup.c       **** 	// Set data pins inputs
 742:setup.c       **** 	PORT_DATA7_0 = 0;
 1890               		.loc 1 742 0
 1891 0590 15BA      		out 0x15,__zero_reg__
 743:setup.c       **** 	DDR_DATA7_0 = 0;
 1892               		.loc 1 743 0
 1893 0592 14BA      		out 0x14,__zero_reg__
 744:setup.c       **** 	
 745:setup.c       **** 	// Verify data
 746:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1894               		.loc 1 746 0
 1895 0594 CE01      		movw r24,r28
 1896 0596 00D0      		rcall gb_flash_read_byte
 1897               	.LVL161:
 1898               	.L79:
 747:setup.c       **** 	while (data != dataVerify) {
 1899               		.loc 1 747 0
 1900 0598 8117      		cp r24,r17
 1901 059a 01F0      		breq .L81
 748:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1902               		.loc 1 748 0
 1903 059c CE01      		movw r24,r28
 1904               	.LVL162:
 1905 059e 00D0      		rcall gb_flash_read_byte
 1906               	.LVL163:
 1907               	.LBB187:
 1908               	.LBB188:
 1909               		.loc 2 276 0
 1910 05a0 9DE0      		ldi r25,lo8(13)
 1911 05a2 9A95      	1:	dec r25
 1912 05a4 01F4      		brne 1b
 1913 05a6 0000      		nop
 1914 05a8 00C0      		rjmp .L79
 1915               	.LVL164:
 1916               	.L81:
 1917               	/* epilogue start */
 1918               	.LBE188:
 1919               	.LBE187:
 749:setup.c       **** 		_delay_us(5);
 750:setup.c       **** 	}
 751:setup.c       **** }
 1920               		.loc 1 751 0
 1921 05aa DF91      		pop r29
 1922 05ac CF91      		pop r28
 1923               	.LVL165:
 1924 05ae 1F91      		pop r17
 1925               	.LVL166:
 1926 05b0 0F91      		pop r16
 1927 05b2 FF90      		pop r15
 1928 05b4 0895      		ret
 1929               		.cfi_endproc
 1930               	.LFE40:
 1932               	.global	gba_flash_write_bus_cycle
 1934               	gba_flash_write_bus_cycle:
 1935               	.LFB41:
 752:setup.c       **** 
 753:setup.c       **** 
 754:setup.c       **** 
 755:setup.c       **** // ---------- GBA FLASH CARTS ----------
 756:setup.c       **** 
 757:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 758:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1936               		.loc 1 758 0
 1937               		.cfi_startproc
 1938               	.LVL167:
 1939 05b6 0F93      		push r16
 1940               	.LCFI37:
 1941               		.cfi_def_cfa_offset 3
 1942               		.cfi_offset 16, -2
 1943 05b8 1F93      		push r17
 1944               	.LCFI38:
 1945               		.cfi_def_cfa_offset 4
 1946               		.cfi_offset 17, -3
 1947               	/* prologue: function */
 1948               	/* frame size = 0 */
 1949               	/* stack size = 2 */
 1950               	.L__stack_usage = 2
 759:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1951               		.loc 1 759 0
 1952 05ba 8C01      		movw r16,r24
 1953 05bc 2227      		clr r18
 1954 05be 3327      		clr r19
 1955 05c0 05BB      		out 0x15,r16
 760:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1956               		.loc 1 760 0
 1957 05c2 072F      		mov r16,r23
 1958 05c4 182F      		mov r17,r24
 1959 05c6 292F      		mov r18,r25
 1960 05c8 3327      		clr r19
 1961 05ca 0BBB      		out 0x1b,r16
 761:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1962               		.loc 1 761 0
 1963 05cc 68BB      		out 0x18,r22
 762:setup.c       **** 	
 763:setup.c       **** 	cs_mreqPin_low;
 1964               		.loc 1 763 0
 1965 05ce 9498      		cbi 0x12,4
 764:setup.c       **** 	
 765:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1966               		.loc 1 765 0
 1967 05d0 5BBB      		out 0x1b,r21
 766:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1968               		.loc 1 766 0
 1969 05d2 48BB      		out 0x18,r20
 767:setup.c       **** 	
 768:setup.c       **** 	wrPin_low;
 1970               		.loc 1 768 0
 1971 05d4 9698      		cbi 0x12,6
 769:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 769 0
 1973               	/* #APP */
 1974               	 ;  769 "setup.c" 1
 1975 05d6 0000      		nop
 1976               	 ;  0 "" 2
 770:setup.c       **** 	asm volatile("nop");
 1977               		.loc 1 770 0
 1978               	 ;  770 "setup.c" 1
 1979 05d8 0000      		nop
 1980               	 ;  0 "" 2
 771:setup.c       **** 	asm volatile("nop");
 1981               		.loc 1 771 0
 1982               	 ;  771 "setup.c" 1
 1983 05da 0000      		nop
 1984               	 ;  0 "" 2
 772:setup.c       **** 	wrPin_high;
 1985               		.loc 1 772 0
 1986               	/* #NOAPP */
 1987 05dc 969A      		sbi 0x12,6
 773:setup.c       **** 	cs_mreqPin_high;
 1988               		.loc 1 773 0
 1989 05de 949A      		sbi 0x12,4
 1990               	/* epilogue start */
 774:setup.c       **** }
 1991               		.loc 1 774 0
 1992 05e0 1F91      		pop r17
 1993 05e2 0F91      		pop r16
 1994 05e4 0895      		ret
 1995               		.cfi_endproc
 1996               	.LFE41:
 1998               	.global	gba_flash_write_cycle_start_swapped
 2000               	gba_flash_write_cycle_start_swapped:
 2001               	.LFB42:
 775:setup.c       **** 
 776:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 777:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2002               		.loc 1 777 0
 2003               		.cfi_startproc
 2004               	/* prologue: function */
 2005               	/* frame size = 0 */
 2006               	/* stack size = 0 */
 2007               	.L__stack_usage = 0
 778:setup.c       **** 	// Set outputs
 779:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2008               		.loc 1 779 0
 2009 05e6 8FEF      		ldi r24,lo8(-1)
 2010 05e8 84BB      		out 0x14,r24
 780:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2011               		.loc 1 780 0
 2012 05ea 8ABB      		out 0x1a,r24
 781:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2013               		.loc 1 781 0
 2014 05ec 87BB      		out 0x17,r24
 782:setup.c       **** 	
 783:setup.c       **** 	// 0x555, 0xA9
 784:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2015               		.loc 1 784 0
 2016 05ee 15BA      		out 0x15,__zero_reg__
 785:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2017               		.loc 1 785 0
 2018 05f0 95E0      		ldi r25,lo8(5)
 2019 05f2 9BBB      		out 0x1b,r25
 786:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2020               		.loc 1 786 0
 2021 05f4 85E5      		ldi r24,lo8(85)
 2022 05f6 88BB      		out 0x18,r24
 787:setup.c       **** 	cs_mreqPin_low;
 2023               		.loc 1 787 0
 2024 05f8 9498      		cbi 0x12,4
 788:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2025               		.loc 1 788 0
 2026 05fa 1BBA      		out 0x1b,__zero_reg__
 789:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2027               		.loc 1 789 0
 2028 05fc 29EA      		ldi r18,lo8(-87)
 2029 05fe 28BB      		out 0x18,r18
 790:setup.c       **** 	wrPin_low;
 2030               		.loc 1 790 0
 2031 0600 9698      		cbi 0x12,6
 791:setup.c       **** 	asm volatile("nop");
 2032               		.loc 1 791 0
 2033               	/* #APP */
 2034               	 ;  791 "setup.c" 1
 2035 0602 0000      		nop
 2036               	 ;  0 "" 2
 792:setup.c       **** 	asm volatile("nop");
 2037               		.loc 1 792 0
 2038               	 ;  792 "setup.c" 1
 2039 0604 0000      		nop
 2040               	 ;  0 "" 2
 793:setup.c       **** 	asm volatile("nop");
 2041               		.loc 1 793 0
 2042               	 ;  793 "setup.c" 1
 2043 0606 0000      		nop
 2044               	 ;  0 "" 2
 794:setup.c       **** 	wrPin_high;
 2045               		.loc 1 794 0
 2046               	/* #NOAPP */
 2047 0608 969A      		sbi 0x12,6
 795:setup.c       **** 	cs_mreqPin_high;
 2048               		.loc 1 795 0
 2049 060a 949A      		sbi 0x12,4
 796:setup.c       **** 	
 797:setup.c       **** 	// 0x2AA, 0x56
 798:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2050               		.loc 1 798 0
 2051 060c 15BA      		out 0x15,__zero_reg__
 799:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2052               		.loc 1 799 0
 2053 060e 22E0      		ldi r18,lo8(2)
 2054 0610 2BBB      		out 0x1b,r18
 800:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2055               		.loc 1 800 0
 2056 0612 2AEA      		ldi r18,lo8(-86)
 2057 0614 28BB      		out 0x18,r18
 801:setup.c       **** 	cs_mreqPin_low;
 2058               		.loc 1 801 0
 2059 0616 9498      		cbi 0x12,4
 802:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2060               		.loc 1 802 0
 2061 0618 1BBA      		out 0x1b,__zero_reg__
 803:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2062               		.loc 1 803 0
 2063 061a 26E5      		ldi r18,lo8(86)
 2064 061c 28BB      		out 0x18,r18
 804:setup.c       **** 	wrPin_low;
 2065               		.loc 1 804 0
 2066 061e 9698      		cbi 0x12,6
 805:setup.c       **** 	asm volatile("nop");
 2067               		.loc 1 805 0
 2068               	/* #APP */
 2069               	 ;  805 "setup.c" 1
 2070 0620 0000      		nop
 2071               	 ;  0 "" 2
 806:setup.c       **** 	asm volatile("nop");
 2072               		.loc 1 806 0
 2073               	 ;  806 "setup.c" 1
 2074 0622 0000      		nop
 2075               	 ;  0 "" 2
 807:setup.c       **** 	asm volatile("nop");
 2076               		.loc 1 807 0
 2077               	 ;  807 "setup.c" 1
 2078 0624 0000      		nop
 2079               	 ;  0 "" 2
 808:setup.c       **** 	wrPin_high;
 2080               		.loc 1 808 0
 2081               	/* #NOAPP */
 2082 0626 969A      		sbi 0x12,6
 809:setup.c       **** 	cs_mreqPin_high;
 2083               		.loc 1 809 0
 2084 0628 949A      		sbi 0x12,4
 810:setup.c       **** 	
 811:setup.c       **** 	// 0x555, 0xA0;
 812:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2085               		.loc 1 812 0
 2086 062a 15BA      		out 0x15,__zero_reg__
 813:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2087               		.loc 1 813 0
 2088 062c 9BBB      		out 0x1b,r25
 814:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2089               		.loc 1 814 0
 2090 062e 88BB      		out 0x18,r24
 815:setup.c       **** 	cs_mreqPin_low;
 2091               		.loc 1 815 0
 2092 0630 9498      		cbi 0x12,4
 816:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2093               		.loc 1 816 0
 2094 0632 1BBA      		out 0x1b,__zero_reg__
 817:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2095               		.loc 1 817 0
 2096 0634 80EA      		ldi r24,lo8(-96)
 2097 0636 88BB      		out 0x18,r24
 818:setup.c       **** 	wrPin_low;
 2098               		.loc 1 818 0
 2099 0638 9698      		cbi 0x12,6
 819:setup.c       **** 	asm volatile("nop");
 2100               		.loc 1 819 0
 2101               	/* #APP */
 2102               	 ;  819 "setup.c" 1
 2103 063a 0000      		nop
 2104               	 ;  0 "" 2
 820:setup.c       **** 	asm volatile("nop");
 2105               		.loc 1 820 0
 2106               	 ;  820 "setup.c" 1
 2107 063c 0000      		nop
 2108               	 ;  0 "" 2
 821:setup.c       **** 	asm volatile("nop");
 2109               		.loc 1 821 0
 2110               	 ;  821 "setup.c" 1
 2111 063e 0000      		nop
 2112               	 ;  0 "" 2
 822:setup.c       **** 	wrPin_high;
 2113               		.loc 1 822 0
 2114               	/* #NOAPP */
 2115 0640 969A      		sbi 0x12,6
 823:setup.c       **** 	cs_mreqPin_high;
 2116               		.loc 1 823 0
 2117 0642 949A      		sbi 0x12,4
 2118 0644 0895      		ret
 2119               		.cfi_endproc
 2120               	.LFE42:
 2122               	.global	gba_flash_write_cycle_start
 2124               	gba_flash_write_cycle_start:
 2125               	.LFB43:
 824:setup.c       **** }
 825:setup.c       **** 
 826:setup.c       **** 
 827:setup.c       **** // Send the first 3 write cycles to the flash
 828:setup.c       **** void gba_flash_write_cycle_start(void) {
 2126               		.loc 1 828 0
 2127               		.cfi_startproc
 2128               	/* prologue: function */
 2129               	/* frame size = 0 */
 2130               	/* stack size = 0 */
 2131               	.L__stack_usage = 0
 829:setup.c       **** 	// Set outputs
 830:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2132               		.loc 1 830 0
 2133 0646 8FEF      		ldi r24,lo8(-1)
 2134 0648 84BB      		out 0x14,r24
 831:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2135               		.loc 1 831 0
 2136 064a 8ABB      		out 0x1a,r24
 832:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2137               		.loc 1 832 0
 2138 064c 87BB      		out 0x17,r24
 833:setup.c       **** 	
 834:setup.c       **** 	// 0x555, 0xAA
 835:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2139               		.loc 1 835 0
 2140 064e 15BA      		out 0x15,__zero_reg__
 836:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2141               		.loc 1 836 0
 2142 0650 95E0      		ldi r25,lo8(5)
 2143 0652 9BBB      		out 0x1b,r25
 837:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2144               		.loc 1 837 0
 2145 0654 85E5      		ldi r24,lo8(85)
 2146 0656 88BB      		out 0x18,r24
 838:setup.c       **** 	cs_mreqPin_low;
 2147               		.loc 1 838 0
 2148 0658 9498      		cbi 0x12,4
 839:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2149               		.loc 1 839 0
 2150 065a 1BBA      		out 0x1b,__zero_reg__
 840:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2151               		.loc 1 840 0
 2152 065c 2AEA      		ldi r18,lo8(-86)
 2153 065e 28BB      		out 0x18,r18
 841:setup.c       **** 	wrPin_low;
 2154               		.loc 1 841 0
 2155 0660 9698      		cbi 0x12,6
 842:setup.c       **** 	asm volatile("nop");
 2156               		.loc 1 842 0
 2157               	/* #APP */
 2158               	 ;  842 "setup.c" 1
 2159 0662 0000      		nop
 2160               	 ;  0 "" 2
 843:setup.c       **** 	asm volatile("nop");
 2161               		.loc 1 843 0
 2162               	 ;  843 "setup.c" 1
 2163 0664 0000      		nop
 2164               	 ;  0 "" 2
 844:setup.c       **** 	asm volatile("nop");
 2165               		.loc 1 844 0
 2166               	 ;  844 "setup.c" 1
 2167 0666 0000      		nop
 2168               	 ;  0 "" 2
 845:setup.c       **** 	wrPin_high;
 2169               		.loc 1 845 0
 2170               	/* #NOAPP */
 2171 0668 969A      		sbi 0x12,6
 846:setup.c       **** 	cs_mreqPin_high;
 2172               		.loc 1 846 0
 2173 066a 949A      		sbi 0x12,4
 847:setup.c       **** 	
 848:setup.c       **** 	// 0x2AA, 0x55
 849:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2174               		.loc 1 849 0
 2175 066c 15BA      		out 0x15,__zero_reg__
 850:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2176               		.loc 1 850 0
 2177 066e 32E0      		ldi r19,lo8(2)
 2178 0670 3BBB      		out 0x1b,r19
 851:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2179               		.loc 1 851 0
 2180 0672 28BB      		out 0x18,r18
 852:setup.c       **** 	cs_mreqPin_low;
 2181               		.loc 1 852 0
 2182 0674 9498      		cbi 0x12,4
 853:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2183               		.loc 1 853 0
 2184 0676 1BBA      		out 0x1b,__zero_reg__
 854:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2185               		.loc 1 854 0
 2186 0678 88BB      		out 0x18,r24
 855:setup.c       **** 	wrPin_low;
 2187               		.loc 1 855 0
 2188 067a 9698      		cbi 0x12,6
 856:setup.c       **** 	asm volatile("nop");
 2189               		.loc 1 856 0
 2190               	/* #APP */
 2191               	 ;  856 "setup.c" 1
 2192 067c 0000      		nop
 2193               	 ;  0 "" 2
 857:setup.c       **** 	asm volatile("nop");
 2194               		.loc 1 857 0
 2195               	 ;  857 "setup.c" 1
 2196 067e 0000      		nop
 2197               	 ;  0 "" 2
 858:setup.c       **** 	asm volatile("nop");
 2198               		.loc 1 858 0
 2199               	 ;  858 "setup.c" 1
 2200 0680 0000      		nop
 2201               	 ;  0 "" 2
 859:setup.c       **** 	wrPin_high;
 2202               		.loc 1 859 0
 2203               	/* #NOAPP */
 2204 0682 969A      		sbi 0x12,6
 860:setup.c       **** 	cs_mreqPin_high;
 2205               		.loc 1 860 0
 2206 0684 949A      		sbi 0x12,4
 861:setup.c       **** 	
 862:setup.c       **** 	// 0x555, 0xA0;
 863:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2207               		.loc 1 863 0
 2208 0686 15BA      		out 0x15,__zero_reg__
 864:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2209               		.loc 1 864 0
 2210 0688 9BBB      		out 0x1b,r25
 865:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2211               		.loc 1 865 0
 2212 068a 88BB      		out 0x18,r24
 866:setup.c       **** 	cs_mreqPin_low;
 2213               		.loc 1 866 0
 2214 068c 9498      		cbi 0x12,4
 867:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2215               		.loc 1 867 0
 2216 068e 1BBA      		out 0x1b,__zero_reg__
 868:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2217               		.loc 1 868 0
 2218 0690 80EA      		ldi r24,lo8(-96)
 2219 0692 88BB      		out 0x18,r24
 869:setup.c       **** 	wrPin_low;
 2220               		.loc 1 869 0
 2221 0694 9698      		cbi 0x12,6
 870:setup.c       **** 	asm volatile("nop");
 2222               		.loc 1 870 0
 2223               	/* #APP */
 2224               	 ;  870 "setup.c" 1
 2225 0696 0000      		nop
 2226               	 ;  0 "" 2
 871:setup.c       **** 	asm volatile("nop");
 2227               		.loc 1 871 0
 2228               	 ;  871 "setup.c" 1
 2229 0698 0000      		nop
 2230               	 ;  0 "" 2
 872:setup.c       **** 	asm volatile("nop");
 2231               		.loc 1 872 0
 2232               	 ;  872 "setup.c" 1
 2233 069a 0000      		nop
 2234               	 ;  0 "" 2
 873:setup.c       **** 	wrPin_high;
 2235               		.loc 1 873 0
 2236               	/* #NOAPP */
 2237 069c 969A      		sbi 0x12,6
 874:setup.c       **** 	cs_mreqPin_high;
 2238               		.loc 1 874 0
 2239 069e 949A      		sbi 0x12,4
 2240 06a0 0895      		ret
 2241               		.cfi_endproc
 2242               	.LFE43:
 2244               	.global	gba_flash_write_byte
 2246               	gba_flash_write_byte:
 2247               	.LFB44:
 875:setup.c       **** }	
 876:setup.c       **** 
 877:setup.c       **** 
 878:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 879:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 880:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2248               		.loc 1 880 0
 2249               		.cfi_startproc
 2250               	.LVL168:
 2251 06a2 CF92      		push r12
 2252               	.LCFI39:
 2253               		.cfi_def_cfa_offset 3
 2254               		.cfi_offset 12, -2
 2255 06a4 DF92      		push r13
 2256               	.LCFI40:
 2257               		.cfi_def_cfa_offset 4
 2258               		.cfi_offset 13, -3
 2259 06a6 EF92      		push r14
 2260               	.LCFI41:
 2261               		.cfi_def_cfa_offset 5
 2262               		.cfi_offset 14, -4
 2263 06a8 FF92      		push r15
 2264               	.LCFI42:
 2265               		.cfi_def_cfa_offset 6
 2266               		.cfi_offset 15, -5
 2267 06aa CF93      		push r28
 2268               	.LCFI43:
 2269               		.cfi_def_cfa_offset 7
 2270               		.cfi_offset 28, -6
 2271 06ac DF93      		push r29
 2272               	.LCFI44:
 2273               		.cfi_def_cfa_offset 8
 2274               		.cfi_offset 29, -7
 2275               	/* prologue: function */
 2276               	/* frame size = 0 */
 2277               	/* stack size = 6 */
 2278               	.L__stack_usage = 6
 2279 06ae 6B01      		movw r12,r22
 2280 06b0 7C01      		movw r14,r24
 2281 06b2 EA01      		movw r28,r20
 881:setup.c       **** 	if (isD0D1Swapped == 0) {
 2282               		.loc 1 881 0
 2283 06b4 2111      		cpse r18,__zero_reg__
 2284 06b6 00C0      		rjmp .L86
 882:setup.c       **** 		gba_flash_write_cycle_start();
 2285               		.loc 1 882 0
 2286 06b8 00D0      		rcall gba_flash_write_cycle_start
 2287               	.LVL169:
 2288 06ba 00C0      		rjmp .L87
 2289               	.LVL170:
 2290               	.L86:
 883:setup.c       **** 	}
 884:setup.c       **** 	else {
 885:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2291               		.loc 1 885 0
 2292 06bc 00D0      		rcall gba_flash_write_cycle_start_swapped
 2293               	.LVL171:
 2294               	.L87:
 886:setup.c       **** 	}
 887:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2295               		.loc 1 887 0
 2296 06be AE01      		movw r20,r28
 2297 06c0 C701      		movw r24,r14
 2298 06c2 B601      		movw r22,r12
 2299 06c4 00D0      		rcall gba_flash_write_bus_cycle
 2300               	.LVL172:
 2301               	.LBB189:
 2302               	.LBB190:
 2303               		.loc 2 276 0
 2304 06c6 25E0      		ldi r18,lo8(5)
 2305 06c8 2A95      	1:	dec r18
 2306 06ca 01F4      		brne 1b
 2307 06cc 0000      		nop
 2308               	.LVL173:
 2309               	.LBE190:
 2310               	.LBE189:
 888:setup.c       **** 	_delay_us(2); // Wait byte program time
 889:setup.c       **** 	
 890:setup.c       **** 	// Verify data
 891:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2311               		.loc 1 891 0
 2312 06ce C701      		movw r24,r14
 2313 06d0 B601      		movw r22,r12
 2314 06d2 00D0      		rcall gba_read_16bit_data
 2315               	.LVL174:
 2316               	.L88:
 892:setup.c       **** 	while (data != dataVerify) {
 2317               		.loc 1 892 0
 2318 06d4 8C17      		cp r24,r28
 2319 06d6 9D07      		cpc r25,r29
 2320 06d8 01F0      		breq .L90
 893:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2321               		.loc 1 893 0
 2322 06da C701      		movw r24,r14
 2323 06dc B601      		movw r22,r12
 2324 06de 00D0      		rcall gba_read_16bit_data
 2325               	.LVL175:
 2326               	.LBB191:
 2327               	.LBB192:
 2328               		.loc 2 276 0
 2329 06e0 25E0      		ldi r18,lo8(5)
 2330 06e2 2A95      	1:	dec r18
 2331 06e4 01F4      		brne 1b
 2332 06e6 0000      		nop
 2333 06e8 00C0      		rjmp .L88
 2334               	.LVL176:
 2335               	.L90:
 2336               	/* epilogue start */
 2337               	.LBE192:
 2338               	.LBE191:
 894:setup.c       **** 		_delay_us(2);
 895:setup.c       **** 	}
 896:setup.c       **** }
 2339               		.loc 1 896 0
 2340 06ea DF91      		pop r29
 2341 06ec CF91      		pop r28
 2342               	.LVL177:
 2343 06ee FF90      		pop r15
 2344 06f0 EF90      		pop r14
 2345 06f2 DF90      		pop r13
 2346 06f4 CF90      		pop r12
 2347               	.LVL178:
 2348 06f6 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE44:
 2352               	.global	setup
 2354               	setup:
 2355               	.LFB45:
 897:setup.c       **** 
 898:setup.c       **** 
 899:setup.c       **** // Setup
 900:setup.c       **** void setup(void) {
 2356               		.loc 1 900 0
 2357               		.cfi_startproc
 2358               	/* prologue: function */
 2359               	/* frame size = 0 */
 2360               	/* stack size = 0 */
 2361               	.L__stack_usage = 0
 901:setup.c       **** 	// Turn off watchdog
 902:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2362               		.loc 1 902 0
 2363 06f8 84B7      		in r24,0x34
 2364 06fa 877F      		andi r24,lo8(-9)
 2365 06fc 84BF      		out 0x34,r24
 903:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2366               		.loc 1 903 0
 2367 06fe 88E1      		ldi r24,lo8(24)
 2368 0700 81BD      		out 0x21,r24
 904:setup.c       **** 	WDTCR = 0;
 2369               		.loc 1 904 0
 2370 0702 11BC      		out 0x21,__zero_reg__
 905:setup.c       **** 	
 906:setup.c       **** 	// Reset common lines
 907:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2371               		.loc 1 907 0
 2372 0704 00D0      		rcall rd_wr_csmreq_cs2_reset
 2373               	.LVL179:
 908:setup.c       **** 	
 909:setup.c       **** 	// Set outputs
 910:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2374               		.loc 1 910 0
 2375 0706 81B3      		in r24,0x11
 2376 0708 886F      		ori r24,lo8(-8)
 2377 070a 81BB      		out 0x11,r24
 911:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2378               		.loc 1 911 0
 2379 070c 86B1      		in r24,0x6
 2380 070e 8560      		ori r24,lo8(5)
 2381 0710 86B9      		out 0x6,r24
 912:setup.c       **** 	
 913:setup.c       **** 	// Set all pins as inputs
 914:setup.c       **** 	PORT_DATA7_0 = 0;
 2382               		.loc 1 914 0
 2383 0712 15BA      		out 0x15,__zero_reg__
 915:setup.c       **** 	DDR_DATA7_0 = 0;
 2384               		.loc 1 915 0
 2385 0714 14BA      		out 0x14,__zero_reg__
 916:setup.c       **** 	PORT_ADDR7_0 = 0;
 2386               		.loc 1 916 0
 2387 0716 18BA      		out 0x18,__zero_reg__
 917:setup.c       **** 	DDR_ADDR7_0 = 0;
 2388               		.loc 1 917 0
 2389 0718 17BA      		out 0x17,__zero_reg__
 918:setup.c       **** 	PORT_ADDR15_8 = 0;
 2390               		.loc 1 918 0
 2391 071a 1BBA      		out 0x1b,__zero_reg__
 919:setup.c       **** 	DDR_ADDR15_8 = 0;
 2392               		.loc 1 919 0
 2393 071c 1ABA      		out 0x1a,__zero_reg__
 920:setup.c       **** 	
 921:setup.c       **** 	// Light up 3.3V or 5V
 922:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2394               		.loc 1 922 0
 2395 071e 829B      		sbis 0x10,2
 2396 0720 00C0      		rjmp .L92
 923:setup.c       **** 		PORTD |= (1<<LED_5V);
 2397               		.loc 1 923 0
 2398 0722 979A      		sbi 0x12,7
 924:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2399               		.loc 1 924 0
 2400 0724 3898      		cbi 0x7,0
 925:setup.c       **** 		
 926:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 927:setup.c       **** 		cs2Pin_low;
 2401               		.loc 1 927 0
 2402 0726 3A98      		cbi 0x7,2
 2403               	.LVL180:
 2404               	.LBB193:
 2405               	.LBB194:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2406               		.loc 2 187 0
 2407 0728 2FE7      		ldi r18,lo8(79999)
 2408 072a 88E3      		ldi r24,hi8(79999)
 2409 072c 91E0      		ldi r25,hlo8(79999)
 2410 072e 2150      	1:	subi r18,1
 2411 0730 8040      		sbci r24,0
 2412 0732 9040      		sbci r25,0
 2413 0734 01F4      		brne 1b
 2414 0736 00C0      		rjmp .
 2415 0738 0000      		nop
 2416               	.LVL181:
 2417               	.LBE194:
 2418               	.LBE193:
 928:setup.c       **** 		_delay_ms(50);
 929:setup.c       **** 		cs2Pin_high;
 2419               		.loc 1 929 0
 2420 073a 3A9A      		sbi 0x7,2
 2421 073c 00C0      		rjmp .L93
 2422               	.L92:
 930:setup.c       **** 	}
 931:setup.c       **** 	else {
 932:setup.c       **** 		PORTE |= (1<<LED_3V);
 2423               		.loc 1 932 0
 2424 073e 389A      		sbi 0x7,0
 933:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2425               		.loc 1 933 0
 2426 0740 9798      		cbi 0x12,7
 2427               	.L93:
 934:setup.c       **** 	}
 935:setup.c       **** 	
 936:setup.c       **** 	// Light LED
 937:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2428               		.loc 1 937 0
 2429 0742 939A      		sbi 0x12,3
 2430               	.LVL182:
 2431               	.LBB195:
 2432               	.LBB196:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2433               		.loc 2 187 0
 2434 0744 2FEF      		ldi r18,lo8(799999)
 2435 0746 84E3      		ldi r24,hi8(799999)
 2436 0748 9CE0      		ldi r25,hlo8(799999)
 2437 074a 2150      	1:	subi r18,1
 2438 074c 8040      		sbci r24,0
 2439 074e 9040      		sbci r25,0
 2440 0750 01F4      		brne 1b
 2441 0752 00C0      		rjmp .
 2442 0754 0000      		nop
 2443               	.LVL183:
 2444               	.LBE196:
 2445               	.LBE195:
 938:setup.c       **** 	_delay_ms(500);
 939:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2446               		.loc 1 939 0
 2447 0756 9398      		cbi 0x12,3
 940:setup.c       **** 	
 941:setup.c       **** 	// Setup USART
 942:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2448               		.loc 1 942 0
 2449 0758 19B8      		out 0x9,__zero_reg__
 943:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2450               		.loc 1 943 0
 2451 075a 599A      		sbi 0xb,1
 944:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2452               		.loc 1 944 0
 2453 075c 539A      		sbi 0xa,3
 945:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2454               		.loc 1 945 0
 2455 075e 549A      		sbi 0xa,4
 946:setup.c       **** 	
 947:setup.c       **** 	// Turn on interrupts
 948:setup.c       **** 	sei();
 2456               		.loc 1 948 0
 2457               	/* #APP */
 2458               	 ;  948 "setup.c" 1
 2459 0760 7894      		sei
 2460               	 ;  0 "" 2
 2461               	/* #NOAPP */
 2462 0762 0895      		ret
 2463               		.cfi_endproc
 2464               	.LFE45:
 2466               		.section	.text.startup,"ax",@progbits
 2467               	.global	main
 2469               	main:
 2470               	.LFB46:
 2471               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R18
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 3/07/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 2
  53:main.c        **** #define FIRMWARE_VERSION 18
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2472               		.loc 3 66 0
 2473               		.cfi_startproc
 2474 0000 CF93      		push r28
 2475               	.LCFI45:
 2476               		.cfi_def_cfa_offset 3
 2477               		.cfi_offset 28, -2
 2478 0002 DF93      		push r29
 2479               	.LCFI46:
 2480               		.cfi_def_cfa_offset 4
 2481               		.cfi_offset 29, -3
 2482 0004 CDB7      		in r28,__SP_L__
 2483 0006 DEB7      		in r29,__SP_H__
 2484               	.LCFI47:
 2485               		.cfi_def_cfa_register 28
 2486 0008 2897      		sbiw r28,8
 2487               	.LCFI48:
 2488               		.cfi_def_cfa_offset 12
 2489 000a 0FB6      		in __tmp_reg__,__SREG__
 2490 000c F894      		cli
 2491 000e DEBF      		out __SP_H__,r29
 2492 0010 0FBE      		out __SREG__,__tmp_reg__
 2493 0012 CDBF      		out __SP_L__,r28
 2494               	/* prologue: function */
 2495               	/* frame size = 8 */
 2496               	/* stack size = 10 */
 2497               	.L__stack_usage = 10
  67:main.c        **** 	setup();
 2498               		.loc 3 67 0
 2499 0014 00D0      		rcall setup
 2500               	.LVL184:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t cartMode = GB_MODE;
  72:main.c        **** 	uint8_t resetCommonLines = 1;
 2501               		.loc 3 72 0
 2502 0016 21E0      		ldi r18,lo8(1)
 2503 0018 2D83      		std Y+5,r18
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
 2504               		.loc 3 70 0
 2505 001a 81E0      		ldi r24,lo8(1)
 2506 001c 8887      		std Y+8,r24
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2507               		.loc 3 69 0
 2508 001e C12C      		mov r12,__zero_reg__
 2509 0020 D12C      		mov r13,__zero_reg__
 2510 0022 7601      		movw r14,r12
 2511               	.LVL185:
 2512               	.L95:
  73:main.c        **** 	
  74:main.c        **** 	while(1) {
  75:main.c        **** 		if (resetCommonLines == 1) {
 2513               		.loc 3 75 0
 2514 0024 AD81      		ldd r26,Y+5
 2515 0026 A130      		cpi r26,lo8(1)
 2516 0028 01F4      		brne .L96
 2517               	.LVL186:
 2518               	.L287:
  76:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2519               		.loc 3 76 0
 2520 002a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2521               	.LVL187:
 2522               	.L96:
  77:main.c        **** 		}
  78:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2523               		.loc 3 78 0
 2524 002c 00D0      		rcall USART_Receive
 2525               	.LVL188:
 2526 002e 8093 0000 		sts receivedChar,r24
  79:main.c        **** 		
  80:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  81:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
 2527               		.loc 3 81 0
 2528 0032 829B      		sbis 0x10,2
 2529 0034 00C0      		rjmp .L97
 2530               	.LVL189:
  82:main.c        **** 			cartMode = GB_MODE;
  83:main.c        **** 			PORTD |= (1<<LED_5V);
 2531               		.loc 3 83 0
 2532 0036 979A      		sbi 0x12,7
  84:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2533               		.loc 3 84 0
 2534 0038 3898      		cbi 0x7,0
  82:main.c        **** 			cartMode = GB_MODE;
 2535               		.loc 3 82 0
 2536 003a 81E0      		ldi r24,lo8(1)
 2537 003c 00C0      		rjmp .L98
 2538               	.LVL190:
 2539               	.L97:
  85:main.c        **** 		}
  86:main.c        **** 		else {
  87:main.c        **** 			cartMode = GBA_MODE;
  88:main.c        **** 			PORTE |= (1<<LED_3V);
 2540               		.loc 3 88 0
 2541 003e 389A      		sbi 0x7,0
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2542               		.loc 3 89 0
 2543 0040 9798      		cbi 0x12,7
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2544               		.loc 3 87 0
 2545 0042 82E0      		ldi r24,lo8(2)
 2546               	.LVL191:
 2547               	.L98:
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Return the cart mode in use
  93:main.c        **** 		if (receivedChar == CART_MODE) {
 2548               		.loc 3 93 0
 2549 0044 9091 0000 		lds r25,receivedChar
 2550 0048 9334      		cpi r25,lo8(67)
 2551 004a 01F4      		brne .+2
 2552 004c 00C0      		rjmp .L288
  94:main.c        **** 			USART_Transmit(cartMode);
  95:main.c        **** 		}
  96:main.c        **** 		
  97:main.c        **** 		// Change to GB mode or GBA mode if requested
  98:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2553               		.loc 3 98 0
 2554 004e 9734      		cpi r25,lo8(71)
 2555 0050 01F4      		brne .L101
  99:main.c        **** 			gb_mode();
 2556               		.loc 3 99 0
 2557 0052 00D0      		rcall gb_mode
 2558               	.LVL192:
 2559 0054 00C0      		rjmp .L95
 2560               	.LVL193:
 2561               	.L101:
 100:main.c        **** 		}
 101:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2562               		.loc 3 101 0
 2563 0056 9736      		cpi r25,lo8(103)
 2564 0058 01F4      		brne .+2
 2565 005a 00C0      		rjmp .L290
 102:main.c        **** 			gba_mode();
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Set address
 106:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2566               		.loc 3 106 0
 2567 005c 9134      		cpi r25,lo8(65)
 2568 005e 01F4      		brne .L103
 107:main.c        **** 			usart_read_chars(); // Read start address
 2569               		.loc 3 107 0
 2570 0060 00D0      		rcall usart_read_chars
 2571               	.LVL194:
 108:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2572               		.loc 3 108 0
 2573 0062 40E1      		ldi r20,lo8(16)
 2574 0064 50E0      		ldi r21,0
 2575 0066 60E0      		ldi r22,0
 2576 0068 70E0      		ldi r23,0
 2577 006a 80E0      		ldi r24,lo8(receivedBuffer)
 2578 006c 90E0      		ldi r25,hi8(receivedBuffer)
 2579 006e 00D0      		rcall strtol
 2580               	.LVL195:
 2581 0070 6B01      		movw r12,r22
 2582 0072 7C01      		movw r14,r24
 2583               	.LVL196:
 2584 0074 00C0      		rjmp .L95
 2585               	.LVL197:
 2586               	.L103:
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 113:main.c        **** 		
 114:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 115:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2587               		.loc 3 115 0
 2588 0076 9235      		cpi r25,lo8(82)
 2589 0078 01F4      		brne .L104
 116:main.c        **** 			gb_mode();
 2590               		.loc 3 116 0
 2591 007a 00D0      		rcall gb_mode
 2592               	.LVL198:
 117:main.c        **** 			receivedChar = '1';
 2593               		.loc 3 117 0
 2594 007c B1E3      		ldi r27,lo8(49)
 2595 007e B093 0000 		sts receivedChar,r27
 2596               	.LVL199:
 2597               	.L105:
 118:main.c        **** 			while (receivedChar == '1') {
 2598               		.loc 3 118 0
 2599 0082 8091 0000 		lds r24,receivedChar
 2600 0086 8133      		cpi r24,lo8(49)
 2601 0088 01F4      		brne .L95
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2602               		.loc 3 119 0
 2603 008a 939A      		sbi 0x12,3
 2604               	.LVL200:
 2605 008c 00E0      		ldi r16,0
 2606 008e 10E0      		ldi r17,0
 2607               	.LVL201:
 2608               	.L106:
 2609               	.LBB197:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2610               		.loc 3 121 0 discriminator 3
 2611 0090 C801      		movw r24,r16
 2612 0092 8C0D      		add r24,r12
 2613 0094 9D1D      		adc r25,r13
 2614 0096 00D0      		rcall read_8bit_data
 2615               	.LVL202:
 2616 0098 00D0      		rcall USART_Transmit
 2617               	.LVL203:
 2618 009a 0F5F      		subi r16,-1
 2619 009c 1F4F      		sbci r17,-1
 2620               	.LVL204:
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2621               		.loc 3 120 0 discriminator 3
 2622 009e 0034      		cpi r16,64
 2623 00a0 1105      		cpc r17,__zero_reg__
 2624 00a2 01F4      		brne .L106
 2625 00a4 E0E4      		ldi r30,64
 2626 00a6 CE0E      		add r12,r30
 2627 00a8 D11C      		adc r13,__zero_reg__
 2628 00aa E11C      		adc r14,__zero_reg__
 2629 00ac F11C      		adc r15,__zero_reg__
 2630               	.LBE197:
 122:main.c        **** 					address++;
 123:main.c        **** 				}
 124:main.c        **** 				
 125:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2631               		.loc 3 125 0
 2632 00ae 9398      		cbi 0x12,3
 126:main.c        **** 				receivedChar = USART_Receive();
 2633               		.loc 3 126 0
 2634 00b0 00D0      		rcall USART_Receive
 2635               	.LVL205:
 2636 00b2 8093 0000 		sts receivedChar,r24
 2637 00b6 00C0      		rjmp .L105
 2638               	.LVL206:
 2639               	.L104:
 127:main.c        **** 			}
 128:main.c        **** 		}
 129:main.c        **** 		
 130:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 131:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2640               		.loc 3 131 0
 2641 00b8 9735      		cpi r25,lo8(87)
 2642 00ba 01F4      		brne .L108
 132:main.c        **** 			gb_mode();
 2643               		.loc 3 132 0
 2644 00bc 00D0      		rcall gb_mode
 2645               	.LVL207:
 133:main.c        **** 			
 134:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 135:main.c        **** 			usart_read_bytes(64);
 2646               		.loc 3 135 0
 2647 00be 80E4      		ldi r24,lo8(64)
 2648 00c0 90E0      		ldi r25,0
 2649 00c2 00D0      		rcall usart_read_bytes
 2650               	.LVL208:
 136:main.c        **** 			
 137:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2651               		.loc 3 137 0
 2652 00c4 939A      		sbi 0x12,3
 2653               	.LVL209:
 2654 00c6 50E0      		ldi r21,lo8(receivedBuffer)
 2655 00c8 A52E      		mov r10,r21
 2656 00ca 50E0      		ldi r21,hi8(receivedBuffer)
 2657 00cc B52E      		mov r11,r21
 2658 00ce 00E0      		ldi r16,0
 2659 00d0 10E0      		ldi r17,0
 2660               	.LVL210:
 2661               	.L109:
 2662               	.LBB198:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2663               		.loc 3 139 0 discriminator 3
 2664 00d2 D501      		movw r26,r10
 2665 00d4 6D91      		ld r22,X+
 2666 00d6 5D01      		movw r10,r26
 2667 00d8 C801      		movw r24,r16
 2668 00da 8C0D      		add r24,r12
 2669 00dc 9D1D      		adc r25,r13
 2670 00de 41E0      		ldi r20,lo8(1)
 2671 00e0 00D0      		rcall write_8bit_data
 2672               	.LVL211:
 2673 00e2 0F5F      		subi r16,-1
 2674 00e4 1F4F      		sbci r17,-1
 2675               	.LVL212:
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2676               		.loc 3 138 0 discriminator 3
 2677 00e6 0034      		cpi r16,64
 2678 00e8 1105      		cpc r17,__zero_reg__
 2679 00ea 01F4      		brne .L109
 2680 00ec B0E4      		ldi r27,64
 2681 00ee CB0E      		add r12,r27
 2682 00f0 D11C      		adc r13,__zero_reg__
 2683 00f2 E11C      		adc r14,__zero_reg__
 2684 00f4 F11C      		adc r15,__zero_reg__
 2685 00f6 00C0      		rjmp .L308
 2686               	.LVL213:
 2687               	.L108:
 2688               	.LBE198:
 140:main.c        **** 				address++;
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 144:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 145:main.c        **** 		}
 146:main.c        **** 		
 147:main.c        **** 		// Set bank address and write a byte
 148:main.c        **** 		else if (receivedChar == SET_BANK) {
 2689               		.loc 3 148 0
 2690 00f8 9234      		cpi r25,lo8(66)
 2691 00fa 01F4      		brne .L110
 2692               	.LBB199:
 149:main.c        **** 			gb_mode();
 2693               		.loc 3 149 0
 2694 00fc 00D0      		rcall gb_mode
 2695               	.LVL214:
 150:main.c        **** 			
 151:main.c        **** 			usart_read_chars(); // Read start address
 2696               		.loc 3 151 0
 2697 00fe 00D0      		rcall usart_read_chars
 2698               	.LVL215:
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2699               		.loc 3 152 0
 2700 0100 40E1      		ldi r20,lo8(16)
 2701 0102 50E0      		ldi r21,0
 2702 0104 60E0      		ldi r22,0
 2703 0106 70E0      		ldi r23,0
 2704 0108 80E0      		ldi r24,lo8(receivedBuffer)
 2705 010a 90E0      		ldi r25,hi8(receivedBuffer)
 2706 010c 00D0      		rcall strtol
 2707               	.LVL216:
 2708 010e 4B01      		movw r8,r22
 2709 0110 5C01      		movw r10,r24
 2710               	.LVL217:
 153:main.c        **** 			
 154:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2711               		.loc 3 154 0
 2712 0112 00D0      		rcall USART_Receive
 2713               	.LVL218:
 2714 0114 8093 0000 		sts receivedChar,r24
 155:main.c        **** 			if (receivedChar == 'B') {
 2715               		.loc 3 155 0
 2716 0118 8234      		cpi r24,lo8(66)
 2717 011a 01F0      		breq .+2
 2718 011c 00C0      		rjmp .L95
 2719               	.LBB200:
 156:main.c        **** 				usart_read_chars(); // Read data
 2720               		.loc 3 156 0
 2721 011e 00D0      		rcall usart_read_chars
 2722               	.LVL219:
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2723               		.loc 3 157 0
 2724 0120 80E0      		ldi r24,lo8(receivedBuffer)
 2725 0122 90E0      		ldi r25,hi8(receivedBuffer)
 2726 0124 00D0      		rcall atoi
 2727               	.LVL220:
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2728               		.loc 3 158 0
 2729 0126 8093 0000 		sts lastBankAccessed,r24
 159:main.c        **** 				
 160:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2730               		.loc 3 160 0
 2731 012a 40E0      		ldi r20,0
 2732 012c 682F      		mov r22,r24
 2733 012e C401      		movw r24,r8
 2734               	.LVL221:
 2735 0130 00D0      		rcall write_8bit_data
 2736               	.LVL222:
 2737 0132 00C0      		rjmp .L95
 2738               	.LVL223:
 2739               	.L110:
 2740               	.LBE200:
 2741               	.LBE199:
 161:main.c        **** 			}
 162:main.c        **** 		}
 163:main.c        **** 		
 164:main.c        **** 		
 165:main.c        **** 		// ****** Gameboy Advance ******
 166:main.c        **** 		
 167:main.c        **** 		// ---------- ROM ----------
 168:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 169:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2742               		.loc 3 169 0
 2743 0134 9237      		cpi r25,lo8(114)
 2744 0136 01F0      		breq .L111
 2745               		.loc 3 169 0 is_stmt 0 discriminator 1
 2746 0138 9A36      		cpi r25,lo8(106)
 2747 013a 01F4      		brne .L112
 2748               	.L111:
 2749               	.LBB201:
 170:main.c        **** 			gba_mode();
 2750               		.loc 3 170 0 is_stmt 1
 2751 013c 00D0      		rcall gba_mode
 2752               	.LVL224:
 171:main.c        **** 			
 172:main.c        **** 			uint8_t readEnd = 32;
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2753               		.loc 3 173 0
 2754 013e 8091 0000 		lds r24,receivedChar
 2755 0142 8A36      		cpi r24,lo8(106)
 2756 0144 01F4      		brne .L232
 174:main.c        **** 				readEnd = 128;
 2757               		.loc 3 174 0
 2758 0146 10E8      		ldi r17,lo8(-128)
 2759 0148 00C0      		rjmp .L113
 2760               	.L232:
 172:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2761               		.loc 3 172 0
 2762 014a 10E2      		ldi r17,lo8(32)
 2763               	.L113:
 2764               	.LVL225:
 175:main.c        **** 			}
 176:main.c        **** 			
 177:main.c        **** 			receivedChar = '1';
 2765               		.loc 3 177 0
 2766 014c E1E3      		ldi r30,lo8(49)
 2767 014e E093 0000 		sts receivedChar,r30
 2768 0152 8824      		clr r8
 2769 0154 8A94      		dec r8
 2770 0156 810E      		add r8,r17
 2771 0158 912C      		mov r9,__zero_reg__
 2772 015a A12C      		mov r10,__zero_reg__
 2773 015c B12C      		mov r11,__zero_reg__
 2774 015e FFEF      		ldi r31,-1
 2775 0160 8F1A      		sub r8,r31
 2776 0162 9F0A      		sbc r9,r31
 2777 0164 AF0A      		sbc r10,r31
 2778 0166 BF0A      		sbc r11,r31
 2779               	.LVL226:
 2780               	.L114:
 178:main.c        **** 			while (receivedChar == '1') {
 2781               		.loc 3 178 0
 2782 0168 8091 0000 		lds r24,receivedChar
 2783 016c 8133      		cpi r24,lo8(49)
 2784 016e 01F0      		breq .+2
 2785 0170 00C0      		rjmp .L95
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2786               		.loc 3 179 0
 2787 0172 939A      		sbi 0x12,3
 2788               	.LVL227:
 2789 0174 2601      		movw r4,r12
 2790 0176 3701      		movw r6,r14
 2791               	.LVL228:
 2792               	.L115:
 2793               	.LBB202:
 2794               	.LBB203:
 180:main.c        **** 				
 181:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2795               		.loc 3 182 0 discriminator 3
 2796 0178 C301      		movw r24,r6
 2797 017a B201      		movw r22,r4
 2798 017c 00D0      		rcall gba_read_16bit_data
 2799               	.LVL229:
 2800 017e 092F      		mov r16,r25
 2801               	.LVL230:
 183:main.c        **** 					
 184:main.c        **** 					// Low byte & High byte
 185:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 2802               		.loc 3 185 0 discriminator 3
 2803 0180 00D0      		rcall USART_Transmit
 2804               	.LVL231:
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 2805               		.loc 3 186 0 discriminator 3
 2806 0182 802F      		mov r24,r16
 2807 0184 00D0      		rcall USART_Transmit
 2808               	.LVL232:
 187:main.c        **** 					
 188:main.c        **** 					address++;
 2809               		.loc 3 188 0 discriminator 3
 2810 0186 2FEF      		ldi r18,-1
 2811 0188 421A      		sub r4,r18
 2812 018a 520A      		sbc r5,r18
 2813 018c 620A      		sbc r6,r18
 2814 018e 720A      		sbc r7,r18
 2815               	.LVL233:
 2816               	.LBE203:
 181:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2817               		.loc 3 181 0 discriminator 3
 2818 0190 842D      		mov r24,r4
 2819 0192 8C19      		sub r24,r12
 2820 0194 8117      		cp r24,r17
 2821 0196 00F0      		brlo .L115
 2822 0198 C80C      		add r12,r8
 2823 019a D91C      		adc r13,r9
 2824 019c EA1C      		adc r14,r10
 2825 019e FB1C      		adc r15,r11
 2826               	.LVL234:
 2827               	.LBE202:
 189:main.c        **** 				}
 190:main.c        **** 				
 191:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2828               		.loc 3 191 0
 2829 01a0 9398      		cbi 0x12,3
 192:main.c        **** 				receivedChar = USART_Receive();
 2830               		.loc 3 192 0
 2831 01a2 00D0      		rcall USART_Receive
 2832               	.LVL235:
 2833 01a4 8093 0000 		sts receivedChar,r24
 2834 01a8 00C0      		rjmp .L114
 2835               	.LVL236:
 2836               	.L112:
 2837               	.LBE201:
 193:main.c        **** 			}
 194:main.c        **** 		}
 195:main.c        **** 		
 196:main.c        **** 		// ---------- SRAM ----------
 197:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 198:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2838               		.loc 3 198 0
 2839 01aa 9D36      		cpi r25,lo8(109)
 2840 01ac 01F4      		brne .L117
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2841               		.loc 3 199 0
 2842 01ae 00D0      		rcall gb_mode
 2843               	.LVL237:
 200:main.c        **** 			
 201:main.c        **** 			receivedChar = '1';
 2844               		.loc 3 201 0
 2845 01b0 81E3      		ldi r24,lo8(49)
 2846               	.LVL238:
 2847               	.L293:
 202:main.c        **** 			while (receivedChar == '1') {
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 206:main.c        **** 					address++;
 207:main.c        **** 				}
 208:main.c        **** 				
 209:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 210:main.c        **** 				receivedChar = USART_Receive();
 2848               		.loc 3 210 0
 2849 01b2 8093 0000 		sts receivedChar,r24
 2850               	.LVL239:
 202:main.c        **** 			while (receivedChar == '1') {
 2851               		.loc 3 202 0
 2852 01b6 8091 0000 		lds r24,receivedChar
 2853 01ba 8133      		cpi r24,lo8(49)
 2854 01bc 01F4      		brne .L290
 203:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2855               		.loc 3 203 0
 2856 01be 939A      		sbi 0x12,3
 2857               	.LVL240:
 2858 01c0 00E0      		ldi r16,0
 2859 01c2 10E0      		ldi r17,0
 2860               	.LVL241:
 2861               	.L119:
 2862               	.LBB204:
 205:main.c        **** 					address++;
 2863               		.loc 3 205 0 discriminator 3
 2864 01c4 C801      		movw r24,r16
 2865 01c6 8C0D      		add r24,r12
 2866 01c8 9D1D      		adc r25,r13
 2867 01ca 00D0      		rcall gba_read_ram_8bit_data
 2868               	.LVL242:
 2869 01cc 00D0      		rcall USART_Transmit
 2870               	.LVL243:
 2871 01ce 0F5F      		subi r16,-1
 2872 01d0 1F4F      		sbci r17,-1
 2873               	.LVL244:
 204:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2874               		.loc 3 204 0 discriminator 3
 2875 01d2 0034      		cpi r16,64
 2876 01d4 1105      		cpc r17,__zero_reg__
 2877 01d6 01F4      		brne .L119
 2878 01d8 90E4      		ldi r25,64
 2879 01da C90E      		add r12,r25
 2880 01dc D11C      		adc r13,__zero_reg__
 2881 01de E11C      		adc r14,__zero_reg__
 2882 01e0 F11C      		adc r15,__zero_reg__
 2883               	.LBE204:
 209:main.c        **** 				receivedChar = USART_Receive();
 2884               		.loc 3 209 0
 2885 01e2 9398      		cbi 0x12,3
 2886               		.loc 3 210 0
 2887 01e4 00D0      		rcall USART_Receive
 2888               	.LVL245:
 2889 01e6 00C0      		rjmp .L293
 2890               	.LVL246:
 2891               	.L117:
 211:main.c        **** 			}
 212:main.c        **** 			
 213:main.c        **** 			gba_mode(); // Set back
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 217:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2892               		.loc 3 217 0
 2893 01e8 9737      		cpi r25,lo8(119)
 2894 01ea 01F4      		brne .L121
 218:main.c        **** 			gb_mode();
 2895               		.loc 3 218 0
 2896 01ec 00D0      		rcall gb_mode
 2897               	.LVL247:
 219:main.c        **** 			
 220:main.c        **** 			usart_read_bytes(64);
 2898               		.loc 3 220 0
 2899 01ee 80E4      		ldi r24,lo8(64)
 2900 01f0 90E0      		ldi r25,0
 2901 01f2 00D0      		rcall usart_read_bytes
 2902               	.LVL248:
 221:main.c        **** 			
 222:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2903               		.loc 3 222 0
 2904 01f4 939A      		sbi 0x12,3
 2905               	.LVL249:
 2906 01f6 40E0      		ldi r20,lo8(receivedBuffer)
 2907 01f8 A42E      		mov r10,r20
 2908 01fa 40E0      		ldi r20,hi8(receivedBuffer)
 2909 01fc B42E      		mov r11,r20
 2910 01fe 00E0      		ldi r16,0
 2911 0200 10E0      		ldi r17,0
 2912               	.LVL250:
 2913               	.L122:
 2914               	.LBB205:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2915               		.loc 3 224 0 discriminator 3
 2916 0202 D501      		movw r26,r10
 2917 0204 6D91      		ld r22,X+
 2918 0206 5D01      		movw r10,r26
 2919 0208 C801      		movw r24,r16
 2920 020a 8C0D      		add r24,r12
 2921 020c 9D1D      		adc r25,r13
 2922 020e 00D0      		rcall gba_write_ram_8bit_data
 2923               	.LVL251:
 2924 0210 0F5F      		subi r16,-1
 2925 0212 1F4F      		sbci r17,-1
 2926               	.LVL252:
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2927               		.loc 3 223 0 discriminator 3
 2928 0214 0034      		cpi r16,64
 2929 0216 1105      		cpc r17,__zero_reg__
 2930 0218 01F4      		brne .L122
 2931 021a B0E4      		ldi r27,64
 2932 021c CB0E      		add r12,r27
 2933 021e D11C      		adc r13,__zero_reg__
 2934 0220 E11C      		adc r14,__zero_reg__
 2935 0222 F11C      		adc r15,__zero_reg__
 2936               	.LVL253:
 2937               	.L292:
 2938               	.LBE205:
 225:main.c        **** 				address++;
 226:main.c        **** 			}
 227:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2939               		.loc 3 227 0
 2940 0224 81E3      		ldi r24,lo8(49)
 2941 0226 00D0      		rcall USART_Transmit
 2942               	.LVL254:
 228:main.c        **** 			
 229:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2943               		.loc 3 229 0
 2944 0228 9398      		cbi 0x12,3
 2945               	.L290:
 230:main.c        **** 			gba_mode(); // Set back
 2946               		.loc 3 230 0
 2947 022a 00D0      		rcall gba_mode
 2948               	.LVL255:
 2949 022c 00C0      		rjmp .L95
 2950               	.LVL256:
 2951               	.L121:
 231:main.c        **** 		}
 232:main.c        **** 		
 233:main.c        **** 		// Write 1 byte to SRAM address
 234:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 2952               		.loc 3 234 0
 2953 022e 9F36      		cpi r25,lo8(111)
 2954 0230 01F4      		brne .L123
 2955               	.LBB206:
 235:main.c        **** 			gb_mode();
 2956               		.loc 3 235 0
 2957 0232 00D0      		rcall gb_mode
 2958               	.LVL257:
 236:main.c        **** 			
 237:main.c        **** 			uint8_t data = USART_Receive();
 2959               		.loc 3 237 0
 2960 0234 00D0      		rcall USART_Receive
 2961               	.LVL258:
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2962               		.loc 3 238 0
 2963 0236 682F      		mov r22,r24
 2964 0238 C601      		movw r24,r12
 2965               	.LVL259:
 2966 023a 00D0      		rcall gba_write_ram_8bit_data
 2967               	.LVL260:
 2968 023c 00C0      		rjmp .L295
 2969               	.LVL261:
 2970               	.L123:
 2971               	.LBE206:
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 240:main.c        **** 			
 241:main.c        **** 			gba_mode(); // Set back
 242:main.c        **** 		}
 243:main.c        **** 		
 244:main.c        **** 		
 245:main.c        **** 		// ---------- FLASH ----------
 246:main.c        **** 		// Read the Flash Manufacturer and Device ID
 247:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 2972               		.loc 3 247 0
 2973 023e 9936      		cpi r25,lo8(105)
 2974 0240 01F4      		brne .L124
 248:main.c        **** 			gb_mode();
 2975               		.loc 3 248 0
 2976 0242 00D0      		rcall gb_mode
 2977               	.LVL262:
 249:main.c        **** 			
 250:main.c        **** 			flash_read_chip_id();
 2978               		.loc 3 250 0
 2979 0244 00D0      		rcall flash_read_chip_id
 2980               	.LVL263:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2981               		.loc 3 251 0
 2982 0246 8091 0000 		lds r24,flashChipIdBuffer
 2983 024a 00D0      		rcall USART_Transmit
 2984               	.LVL264:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2985               		.loc 3 252 0
 2986 024c 8091 0000 		lds r24,flashChipIdBuffer+1
 2987               	.L294:
 2988 0250 00D0      		rcall USART_Transmit
 2989               	.LVL265:
 2990 0252 00C0      		rjmp .L290
 2991               	.LVL266:
 2992               	.L124:
 253:main.c        **** 			
 254:main.c        **** 			gba_mode(); // Set back
 255:main.c        **** 		}
 256:main.c        **** 		
 257:main.c        **** 		// Change bank
 258:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 2993               		.loc 3 258 0
 2994 0254 9B36      		cpi r25,lo8(107)
 2995 0256 01F4      		brne .L125
 2996               	.LBB207:
 259:main.c        **** 			usart_read_chars(); // Read data
 2997               		.loc 3 259 0
 2998 0258 00D0      		rcall usart_read_chars
 2999               	.LVL267:
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3000               		.loc 3 260 0
 3001 025a 80E0      		ldi r24,lo8(receivedBuffer)
 3002 025c 90E0      		ldi r25,hi8(receivedBuffer)
 3003 025e 00D0      		rcall atoi
 3004               	.LVL268:
 3005 0260 182F      		mov r17,r24
 3006               	.LVL269:
 261:main.c        **** 			
 262:main.c        **** 			gb_mode();
 3007               		.loc 3 262 0
 3008 0262 00D0      		rcall gb_mode
 3009               	.LVL270:
 263:main.c        **** 			flash_switch_bank(bank);
 3010               		.loc 3 263 0
 3011 0264 812F      		mov r24,r17
 3012 0266 00D0      		rcall flash_switch_bank
 3013               	.LVL271:
 3014 0268 00C0      		rjmp .L290
 3015               	.LVL272:
 3016               	.L125:
 3017               	.LBE207:
 264:main.c        **** 			
 265:main.c        **** 			gba_mode(); // Set back
 266:main.c        **** 		}
 267:main.c        **** 		
 268:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 269:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 3018               		.loc 3 269 0
 3019 026a 9337      		cpi r25,lo8(115)
 3020 026c 01F4      		brne .L126
 3021               	.LBB208:
 270:main.c        **** 			gb_mode();
 3022               		.loc 3 270 0
 3023 026e 00D0      		rcall gb_mode
 3024               	.LVL273:
 271:main.c        **** 			
 272:main.c        **** 			usart_read_chars(); // Read sector
 3025               		.loc 3 272 0
 3026 0270 00D0      		rcall usart_read_chars
 3027               	.LVL274:
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3028               		.loc 3 273 0
 3029 0272 40E1      		ldi r20,lo8(16)
 3030 0274 50E0      		ldi r21,0
 3031 0276 60E0      		ldi r22,0
 3032 0278 70E0      		ldi r23,0
 3033 027a 80E0      		ldi r24,lo8(receivedBuffer)
 3034 027c 90E0      		ldi r25,hi8(receivedBuffer)
 3035 027e 00D0      		rcall strtol
 3036               	.LVL275:
 3037 0280 862F      		mov r24,r22
 3038               	.LVL276:
 274:main.c        **** 			
 275:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 3039               		.loc 3 275 0
 3040 0282 00D0      		rcall flash_erase_4k_sector
 3041               	.LVL277:
 3042               	.L295:
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3043               		.loc 3 276 0
 3044 0284 81E3      		ldi r24,lo8(49)
 3045 0286 00C0      		rjmp .L294
 3046               	.LVL278:
 3047               	.L126:
 3048               	.LBE208:
 277:main.c        **** 			
 278:main.c        **** 			gba_mode(); // Set back
 279:main.c        **** 		}
 280:main.c        **** 		
 281:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 282:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 3049               		.loc 3 282 0
 3050 0288 9236      		cpi r25,lo8(98)
 3051 028a 01F4      		brne .L127
 283:main.c        **** 			gb_mode();
 3052               		.loc 3 283 0
 3053 028c 00D0      		rcall gb_mode
 3054               	.LVL279:
 284:main.c        **** 			
 285:main.c        **** 			usart_read_bytes(64);
 3055               		.loc 3 285 0
 3056 028e 80E4      		ldi r24,lo8(64)
 3057 0290 90E0      		ldi r25,0
 3058 0292 00D0      		rcall usart_read_bytes
 3059               	.LVL280:
 286:main.c        **** 			
 287:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3060               		.loc 3 287 0
 3061 0294 939A      		sbi 0x12,3
 3062               	.LVL281:
 3063 0296 30E0      		ldi r19,lo8(receivedBuffer)
 3064 0298 A32E      		mov r10,r19
 3065 029a 30E0      		ldi r19,hi8(receivedBuffer)
 3066 029c B32E      		mov r11,r19
 3067 029e 00E0      		ldi r16,0
 3068 02a0 10E0      		ldi r17,0
 3069               	.LVL282:
 3070               	.L128:
 3071               	.LBB209:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3072               		.loc 3 289 0 discriminator 3
 3073 02a2 F501      		movw r30,r10
 3074 02a4 6191      		ld r22,Z+
 3075 02a6 5F01      		movw r10,r30
 3076 02a8 C801      		movw r24,r16
 3077 02aa 8C0D      		add r24,r12
 3078 02ac 9D1D      		adc r25,r13
 3079 02ae 00D0      		rcall flash_write_byte
 3080               	.LVL283:
 3081 02b0 0F5F      		subi r16,-1
 3082 02b2 1F4F      		sbci r17,-1
 3083               	.LVL284:
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3084               		.loc 3 288 0 discriminator 3
 3085 02b4 0034      		cpi r16,64
 3086 02b6 1105      		cpc r17,__zero_reg__
 3087 02b8 01F4      		brne .L128
 3088 02ba F0E4      		ldi r31,64
 3089 02bc CF0E      		add r12,r31
 3090 02be D11C      		adc r13,__zero_reg__
 3091 02c0 E11C      		adc r14,__zero_reg__
 3092 02c2 F11C      		adc r15,__zero_reg__
 3093 02c4 00C0      		rjmp .L292
 3094               	.LVL285:
 3095               	.L127:
 3096               	.LBE209:
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 293:main.c        **** 			
 294:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 3097               		.loc 3 299 0
 3098 02c6 9136      		cpi r25,lo8(97)
 3099 02c8 01F4      		brne .L129
 300:main.c        **** 			gb_mode();
 3100               		.loc 3 300 0
 3101 02ca 00D0      		rcall gb_mode
 3102               	.LVL286:
 301:main.c        **** 			
 302:main.c        **** 			usart_read_bytes(128);
 3103               		.loc 3 302 0
 3104 02cc 80E8      		ldi r24,lo8(-128)
 3105 02ce 90E0      		ldi r25,0
 3106 02d0 00D0      		rcall usart_read_bytes
 3107               	.LVL287:
 303:main.c        **** 			
 304:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3108               		.loc 3 304 0
 3109 02d2 939A      		sbi 0x12,3
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3110               		.loc 3 305 0
 3111 02d4 C601      		movw r24,r12
 3112 02d6 00D0      		rcall flash_write_sector
 3113               	.LVL288:
 306:main.c        **** 			address++;
 3114               		.loc 3 306 0
 3115 02d8 2FEF      		ldi r18,-1
 3116 02da C21A      		sub r12,r18
 3117 02dc D20A      		sbc r13,r18
 3118 02de E20A      		sbc r14,r18
 3119 02e0 F20A      		sbc r15,r18
 3120               	.LVL289:
 3121 02e2 00C0      		rjmp .L292
 3122               	.LVL290:
 3123               	.L129:
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 308:main.c        **** 			
 309:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 310:main.c        **** 			gba_mode(); // Set back
 311:main.c        **** 		}
 312:main.c        **** 		
 313:main.c        **** 		
 314:main.c        **** 		// ---------- EEPROM ----------
 315:main.c        **** 		// Set EEPROM size
 316:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 3124               		.loc 3 316 0
 3125 02e4 9335      		cpi r25,lo8(83)
 3126 02e6 01F4      		brne .L130
 317:main.c        **** 			usart_read_chars(); // Read size
 3127               		.loc 3 317 0
 3128 02e8 00D0      		rcall usart_read_chars
 3129               	.LVL291:
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3130               		.loc 3 318 0
 3131 02ea 40E1      		ldi r20,lo8(16)
 3132 02ec 50E0      		ldi r21,0
 3133 02ee 60E0      		ldi r22,0
 3134 02f0 70E0      		ldi r23,0
 3135 02f2 80E0      		ldi r24,lo8(receivedBuffer)
 3136 02f4 90E0      		ldi r25,hi8(receivedBuffer)
 3137 02f6 00D0      		rcall strtol
 3138               	.LVL292:
 3139 02f8 6887      		std Y+8,r22
 3140               	.LVL293:
 3141 02fa 00C0      		rjmp .L95
 3142               	.LVL294:
 3143               	.L130:
 319:main.c        **** 		}
 320:main.c        **** 		
 321:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 322:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 3144               		.loc 3 322 0
 3145 02fc 9536      		cpi r25,lo8(101)
 3146 02fe 01F4      		brne .L131
 323:main.c        **** 			gba_eeprom_mode();
 3147               		.loc 3 323 0
 3148 0300 00D0      		rcall gba_eeprom_mode
 3149               	.LVL295:
 324:main.c        **** 			
 325:main.c        **** 			receivedChar = '1';
 3150               		.loc 3 325 0
 3151 0302 81E3      		ldi r24,lo8(49)
 3152               	.L296:
 326:main.c        **** 			while (receivedChar == '1') {
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 329:main.c        **** 				
 330:main.c        **** 				// Send back the 8 bytes of data
 331:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 333:main.c        **** 				}
 334:main.c        **** 				address++; // Increment to next 8 bytes
 335:main.c        **** 				
 336:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 337:main.c        **** 				receivedChar = USART_Receive();
 3153               		.loc 3 337 0
 3154 0304 8093 0000 		sts receivedChar,r24
 326:main.c        **** 			while (receivedChar == '1') {
 3155               		.loc 3 326 0
 3156 0308 8091 0000 		lds r24,receivedChar
 3157 030c 8133      		cpi r24,lo8(49)
 3158 030e 01F0      		breq .+2
 3159 0310 00C0      		rjmp .L290
 327:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3160               		.loc 3 327 0
 3161 0312 939A      		sbi 0x12,3
 328:main.c        **** 				
 3162               		.loc 3 328 0
 3163 0314 6885      		ldd r22,Y+8
 3164 0316 C601      		movw r24,r12
 3165 0318 00D0      		rcall gba_eeprom_read
 3166               	.LVL296:
 3167 031a 00E0      		ldi r16,lo8(eepromBuffer)
 3168 031c 10E0      		ldi r17,hi8(eepromBuffer)
 3169               	.LVL297:
 3170               	.L133:
 3171               	.LBB210:
 332:main.c        **** 				}
 3172               		.loc 3 332 0 discriminator 3
 3173 031e D801      		movw r26,r16
 3174 0320 8D91      		ld r24,X+
 3175 0322 8D01      		movw r16,r26
 3176               	.LVL298:
 3177 0324 00D0      		rcall USART_Transmit
 3178               	.LVL299:
 331:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3179               		.loc 3 331 0 discriminator 3
 3180 0326 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3181 0328 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3182 032a E017      		cp r30,r16
 3183 032c F107      		cpc r31,r17
 3184 032e 01F4      		brne .L133
 3185               	.LBE210:
 334:main.c        **** 				
 3186               		.loc 3 334 0
 3187 0330 FFEF      		ldi r31,-1
 3188 0332 CF1A      		sub r12,r31
 3189 0334 DF0A      		sbc r13,r31
 3190 0336 EF0A      		sbc r14,r31
 3191 0338 FF0A      		sbc r15,r31
 3192               	.LVL300:
 336:main.c        **** 				receivedChar = USART_Receive();
 3193               		.loc 3 336 0
 3194 033a 9398      		cbi 0x12,3
 3195               		.loc 3 337 0
 3196 033c 00D0      		rcall USART_Receive
 3197               	.LVL301:
 3198 033e 00C0      		rjmp .L296
 3199               	.LVL302:
 3200               	.L131:
 338:main.c        **** 			}
 339:main.c        **** 			
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 344:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3201               		.loc 3 344 0
 3202 0340 9037      		cpi r25,lo8(112)
 3203 0342 01F4      		brne .L135
 345:main.c        **** 			gba_eeprom_mode();
 3204               		.loc 3 345 0
 3205 0344 00D0      		rcall gba_eeprom_mode
 3206               	.LVL303:
 3207 0346 00E0      		ldi r16,lo8(eepromBuffer)
 3208 0348 10E0      		ldi r17,hi8(eepromBuffer)
 3209               	.LVL304:
 3210               	.L136:
 3211               	.LBB211:
 346:main.c        **** 			
 347:main.c        **** 			// Read 8 bytes from USART and place in buffer
 348:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3212               		.loc 3 349 0 discriminator 3
 3213 034a 00D0      		rcall USART_Receive
 3214               	.LVL305:
 3215 034c D801      		movw r26,r16
 3216 034e 8D93      		st X+,r24
 3217 0350 8D01      		movw r16,r26
 3218               	.LVL306:
 348:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3219               		.loc 3 348 0 discriminator 3
 3220 0352 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3221 0354 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3222 0356 EA17      		cp r30,r26
 3223 0358 FB07      		cpc r31,r27
 3224 035a 01F4      		brne .L136
 3225               	.LBE211:
 350:main.c        **** 			}
 351:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3226               		.loc 3 351 0
 3227 035c 939A      		sbi 0x12,3
 352:main.c        **** 			
 353:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3228               		.loc 3 353 0
 3229 035e 6885      		ldd r22,Y+8
 3230 0360 C601      		movw r24,r12
 3231 0362 00D0      		rcall gba_eeprom_write
 3232               	.LVL307:
 354:main.c        **** 			address++;
 3233               		.loc 3 354 0
 3234 0364 FFEF      		ldi r31,-1
 3235 0366 CF1A      		sub r12,r31
 3236 0368 DF0A      		sbc r13,r31
 3237 036a EF0A      		sbc r14,r31
 3238 036c FF0A      		sbc r15,r31
 3239               	.LVL308:
 3240               	.LBB212:
 3241               	.LBB213:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3242               		.loc 2 187 0
 3243 036e 8FE7      		ldi r24,lo8(15999)
 3244 0370 9EE3      		ldi r25,hi8(15999)
 3245 0372 0197      	1:	sbiw r24,1
 3246 0374 01F4      		brne 1b
 3247 0376 00C0      		rjmp .
 3248 0378 0000      		nop
 3249               	.LVL309:
 3250 037a 00C0      		rjmp .L292
 3251               	.LVL310:
 3252               	.L135:
 3253               	.LBE213:
 3254               	.LBE212:
 355:main.c        **** 			
 356:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 357:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 358:main.c        **** 			
 359:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 360:main.c        **** 			gba_mode(); // Set back
 361:main.c        **** 		}
 362:main.c        **** 		
 363:main.c        **** 		
 364:main.c        **** 		// ---------- GB FLASH CARTS ----------
 365:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 366:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3255               		.loc 3 366 0
 3256 037c 9035      		cpi r25,lo8(80)
 3257 037e 01F4      		brne .L137
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 3258               		.loc 3 367 0
 3259 0380 00D0      		rcall USART_Receive
 3260               	.LVL311:
 3261 0382 8093 0000 		sts flashWriteWePin,r24
 368:main.c        **** 			
 369:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3262               		.loc 3 369 0
 3263 0386 8134      		cpi r24,lo8(65)
 3264 0388 01F0      		breq .+2
 3265 038a 00C0      		rjmp .L95
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3266               		.loc 3 370 0
 3267 038c 319A      		sbi 0x6,1
 371:main.c        **** 				audioPin_high;
 3268               		.loc 3 371 0
 3269 038e 399A      		sbi 0x7,1
 3270 0390 00C0      		rjmp .L95
 3271               	.LVL312:
 3272               	.L137:
 372:main.c        **** 			}
 373:main.c        **** 		}
 374:main.c        **** 		
 375:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 376:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3273               		.loc 3 376 0
 3274 0392 9E34      		cpi r25,lo8(78)
 3275 0394 01F4      		brne .L138
 377:main.c        **** 			flashBank1CommandWrites = 1;
 3276               		.loc 3 377 0
 3277 0396 91E0      		ldi r25,lo8(1)
 3278 0398 9093 0000 		sts flashBank1CommandWrites,r25
 3279 039c 00C0      		rjmp .L95
 3280               	.L138:
 378:main.c        **** 		}
 379:main.c        **** 		
 380:main.c        **** 		// Load the program method to use
 381:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3281               		.loc 3 381 0
 3282 039e 9534      		cpi r25,lo8(69)
 3283 03a0 01F4      		brne .L139
 3284 03a2 00E0      		ldi r16,lo8(flashWriteCycle)
 3285 03a4 10E0      		ldi r17,hi8(flashWriteCycle)
 3286               	.LVL313:
 3287               	.L140:
 3288               	.LBB214:
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 383:main.c        **** 				usart_read_chars(); // Address
 3289               		.loc 3 383 0 discriminator 3
 3290 03a6 00D0      		rcall usart_read_chars
 3291               	.LVL314:
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3292               		.loc 3 384 0 discriminator 3
 3293 03a8 40E1      		ldi r20,lo8(16)
 3294 03aa 50E0      		ldi r21,0
 3295 03ac 60E0      		ldi r22,0
 3296 03ae 70E0      		ldi r23,0
 3297 03b0 80E0      		ldi r24,lo8(receivedBuffer)
 3298 03b2 90E0      		ldi r25,hi8(receivedBuffer)
 3299 03b4 00D0      		rcall strtol
 3300               	.LVL315:
 3301 03b6 D801      		movw r26,r16
 3302 03b8 6D93      		st X+,r22
 3303 03ba 7C93      		st X,r23
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 3304               		.loc 3 385 0 discriminator 3
 3305 03bc 81E3      		ldi r24,lo8(49)
 3306 03be 00D0      		rcall USART_Transmit
 3307               	.LVL316:
 386:main.c        **** 				
 387:main.c        **** 				usart_read_chars(); // Data
 3308               		.loc 3 387 0 discriminator 3
 3309 03c0 00D0      		rcall usart_read_chars
 3310               	.LVL317:
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3311               		.loc 3 388 0 discriminator 3
 3312 03c2 40E1      		ldi r20,lo8(16)
 3313 03c4 50E0      		ldi r21,0
 3314 03c6 60E0      		ldi r22,0
 3315 03c8 70E0      		ldi r23,0
 3316 03ca 80E0      		ldi r24,lo8(receivedBuffer)
 3317 03cc 90E0      		ldi r25,hi8(receivedBuffer)
 3318 03ce 00D0      		rcall strtol
 3319               	.LVL318:
 3320 03d0 F801      		movw r30,r16
 3321 03d2 7383      		std Z+3,r23
 3322 03d4 6283      		std Z+2,r22
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 3323               		.loc 3 389 0 discriminator 3
 3324 03d6 81E3      		ldi r24,lo8(49)
 3325 03d8 00D0      		rcall USART_Transmit
 3326               	.LVL319:
 3327 03da 0C5F      		subi r16,-4
 3328 03dc 1F4F      		sbci r17,-1
 382:main.c        **** 				usart_read_chars(); // Address
 3329               		.loc 3 382 0 discriminator 3
 3330 03de F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3331 03e0 0030      		cpi r16,lo8(flashWriteCycle+12)
 3332 03e2 1F07      		cpc r17,r31
 3333 03e4 01F4      		brne .L140
 3334 03e6 00C0      		rjmp .L95
 3335               	.LVL320:
 3336               	.L139:
 3337               	.LBE214:
 390:main.c        **** 			}
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 394:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3338               		.loc 3 394 0
 3339 03e8 9634      		cpi r25,lo8(70)
 3340 03ea 01F4      		brne .L141
 3341               	.LBB215:
 395:main.c        **** 			usart_read_chars(); // Read address
 3342               		.loc 3 395 0
 3343 03ec 00D0      		rcall usart_read_chars
 3344               	.LVL321:
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3345               		.loc 3 396 0
 3346 03ee 40E1      		ldi r20,lo8(16)
 3347 03f0 50E0      		ldi r21,0
 3348 03f2 60E0      		ldi r22,0
 3349 03f4 70E0      		ldi r23,0
 3350 03f6 80E0      		ldi r24,lo8(receivedBuffer)
 3351 03f8 90E0      		ldi r25,hi8(receivedBuffer)
 3352 03fa 00D0      		rcall strtol
 3353               	.LVL322:
 3354 03fc 4B01      		movw r8,r22
 3355 03fe 5C01      		movw r10,r24
 3356               	.LVL323:
 397:main.c        **** 			
 398:main.c        **** 			usart_read_chars(); // Read data byte
 3357               		.loc 3 398 0
 3358 0400 00D0      		rcall usart_read_chars
 3359               	.LVL324:
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3360               		.loc 3 399 0
 3361 0402 40E1      		ldi r20,lo8(16)
 3362 0404 50E0      		ldi r21,0
 3363 0406 60E0      		ldi r22,0
 3364 0408 70E0      		ldi r23,0
 3365 040a 80E0      		ldi r24,lo8(receivedBuffer)
 3366 040c 90E0      		ldi r25,hi8(receivedBuffer)
 3367 040e 00D0      		rcall strtol
 3368               	.LVL325:
 400:main.c        **** 			
 401:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3369               		.loc 3 401 0
 3370 0410 939A      		sbi 0x12,3
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3371               		.loc 3 402 0
 3372 0412 C401      		movw r24,r8
 3373 0414 00D0      		rcall gb_flash_write_bus_cycle
 3374               	.LVL326:
 3375 0416 00C0      		rjmp .L308
 3376               	.LVL327:
 3377               	.L141:
 3378               	.LBE215:
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 404:main.c        **** 			
 405:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 409:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3379               		.loc 3 409 0
 3380 0418 9435      		cpi r25,lo8(84)
 3381 041a 01F4      		brne .L142
 410:main.c        **** 			usart_read_bytes(64);
 3382               		.loc 3 410 0
 3383 041c 80E4      		ldi r24,lo8(64)
 3384 041e 90E0      		ldi r25,0
 3385               	.LVL328:
 3386 0420 00D0      		rcall usart_read_bytes
 3387               	.LVL329:
 411:main.c        **** 			
 412:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3388               		.loc 3 412 0
 3389 0422 939A      		sbi 0x12,3
 413:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3390               		.loc 3 413 0
 3391 0424 8091 0000 		lds r24,flashBank1CommandWrites
 3392 0428 20E0      		ldi r18,lo8(receivedBuffer)
 3393 042a A22E      		mov r10,r18
 3394 042c 20E0      		ldi r18,hi8(receivedBuffer)
 3395 042e B22E      		mov r11,r18
 3396 0430 00E0      		ldi r16,0
 3397 0432 10E0      		ldi r17,0
 3398 0434 8111      		cpse r24,__zero_reg__
 3399 0436 00C0      		rjmp .L148
 3400               	.LVL330:
 3401               	.L145:
 3402               	.LBB216:
 414:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 415:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3403               		.loc 3 415 0
 3404 0438 D501      		movw r26,r10
 3405 043a 6D91      		ld r22,X+
 3406 043c 5D01      		movw r10,r26
 3407 043e 6F3F      		cpi r22,lo8(-1)
 3408 0440 01F0      		breq .L144
 416:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3409               		.loc 3 416 0
 3410 0442 C801      		movw r24,r16
 3411 0444 8C0D      		add r24,r12
 3412 0446 9D1D      		adc r25,r13
 3413 0448 00D0      		rcall gb_flash_write_byte
 3414               	.LVL331:
 3415               	.L144:
 3416 044a 0F5F      		subi r16,-1
 3417 044c 1F4F      		sbci r17,-1
 3418               	.LVL332:
 414:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3419               		.loc 3 414 0 discriminator 2
 3420 044e 0034      		cpi r16,64
 3421 0450 1105      		cpc r17,__zero_reg__
 3422 0452 01F4      		brne .L145
 3423 0454 00C0      		rjmp .L309
 3424               	.LVL333:
 3425               	.L148:
 3426               	.LBE216:
 3427               	.LBB217:
 417:main.c        **** 					}
 418:main.c        **** 					address++;
 419:main.c        **** 				}
 420:main.c        **** 			}
 421:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 422:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 423:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3428               		.loc 3 423 0
 3429 0456 F501      		movw r30,r10
 3430 0458 6191      		ld r22,Z+
 3431 045a 5F01      		movw r10,r30
 3432 045c 6F3F      		cpi r22,lo8(-1)
 3433 045e 01F0      		breq .L147
 424:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3434               		.loc 3 424 0
 3435 0460 C801      		movw r24,r16
 3436 0462 8C0D      		add r24,r12
 3437 0464 9D1D      		adc r25,r13
 3438 0466 00D0      		rcall gb_flash_write_byte_bank1_commands
 3439               	.LVL334:
 3440               	.L147:
 3441 0468 0F5F      		subi r16,-1
 3442 046a 1F4F      		sbci r17,-1
 3443               	.LVL335:
 422:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3444               		.loc 3 422 0 discriminator 2
 3445 046c 0034      		cpi r16,64
 3446 046e 1105      		cpc r17,__zero_reg__
 3447 0470 01F4      		brne .L148
 3448 0472 F0E4      		ldi r31,64
 3449 0474 CF0E      		add r12,r31
 3450 0476 D11C      		adc r13,__zero_reg__
 3451 0478 E11C      		adc r14,__zero_reg__
 3452 047a F11C      		adc r15,__zero_reg__
 3453               	.LVL336:
 3454 047c 00C0      		rjmp .L297
 3455               	.LVL337:
 3456               	.L142:
 3457               	.LBE217:
 425:main.c        **** 					}
 426:main.c        **** 					address++;
 427:main.c        **** 				}
 428:main.c        **** 			}
 429:main.c        **** 			
 430:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 431:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 432:main.c        **** 		}
 433:main.c        **** 		
 434:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 435:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 3458               		.loc 3 435 0
 3459 047e 9935      		cpi r25,lo8(89)
 3460 0480 01F0      		breq .+2
 3461 0482 00C0      		rjmp .L149
 3462               	.LBB218:
 436:main.c        **** 			usart_read_bytes(32);
 3463               		.loc 3 436 0
 3464 0484 80E2      		ldi r24,lo8(32)
 3465 0486 90E0      		ldi r25,0
 3466               	.LVL338:
 3467 0488 00D0      		rcall usart_read_bytes
 3468               	.LVL339:
 437:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3469               		.loc 3 437 0
 3470 048a 939A      		sbi 0x12,3
 438:main.c        **** 			
 439:main.c        **** 			// Setup buffered write
 440:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 3471               		.loc 3 440 0
 3472 048c 6AEA      		ldi r22,lo8(-86)
 3473 048e 8AEA      		ldi r24,lo8(-86)
 3474 0490 9AE0      		ldi r25,lo8(10)
 3475 0492 00D0      		rcall gb_flash_write_bus_cycle
 3476               	.LVL340:
 441:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3477               		.loc 3 441 0
 3478 0494 65E5      		ldi r22,lo8(85)
 3479 0496 85E5      		ldi r24,lo8(85)
 3480 0498 95E0      		ldi r25,lo8(5)
 3481 049a 00D0      		rcall gb_flash_write_bus_cycle
 3482               	.LVL341:
 442:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3483               		.loc 3 442 0
 3484 049c 5601      		movw r10,r12
 3485 049e 65E2      		ldi r22,lo8(37)
 3486 04a0 C601      		movw r24,r12
 3487 04a2 00D0      		rcall gb_flash_write_bus_cycle
 3488               	.LVL342:
 443:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3489               		.loc 3 443 0
 3490 04a4 6FE1      		ldi r22,lo8(31)
 3491 04a6 C601      		movw r24,r12
 3492 04a8 00D0      		rcall gb_flash_write_bus_cycle
 3493               	.LVL343:
 3494               	.LBB219:
 3495               	.LBB220:
 3496               		.loc 2 276 0
 3497 04aa 22E0      		ldi r18,lo8(2)
 3498 04ac 2A95      	1:	dec r18
 3499 04ae 01F4      		brne 1b
 3500 04b0 00C0      		rjmp .
 3501               	.LVL344:
 3502 04b2 00E0      		ldi r16,lo8(receivedBuffer)
 3503 04b4 10E0      		ldi r17,hi8(receivedBuffer)
 3504 04b6 812C      		mov r8,__zero_reg__
 3505 04b8 912C      		mov r9,__zero_reg__
 3506               	.LVL345:
 3507               	.L150:
 3508               	.LBE220:
 3509               	.LBE219:
 3510               	.LBB221:
 444:main.c        **** 			_delay_us(1);
 445:main.c        **** 			
 446:main.c        **** 			// Write data
 447:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 448:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3511               		.loc 3 448 0 discriminator 3
 3512 04ba D801      		movw r26,r16
 3513 04bc 6D91      		ld r22,X+
 3514 04be 8D01      		movw r16,r26
 3515 04c0 C401      		movw r24,r8
 3516 04c2 8A0D      		add r24,r10
 3517 04c4 9B1D      		adc r25,r11
 3518 04c6 00D0      		rcall gb_flash_write_bus_cycle
 3519               	.LVL346:
 3520 04c8 BFEF      		ldi r27,-1
 3521 04ca 8B1A      		sub r8,r27
 3522 04cc 9B0A      		sbc r9,r27
 3523               	.LVL347:
 447:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3524               		.loc 3 447 0 discriminator 3
 3525 04ce E0E2      		ldi r30,32
 3526 04d0 8E16      		cp r8,r30
 3527 04d2 9104      		cpc r9,__zero_reg__
 3528 04d4 01F4      		brne .L150
 3529 04d6 F0E2      		ldi r31,32
 3530 04d8 CF0E      		add r12,r31
 3531 04da D11C      		adc r13,__zero_reg__
 3532 04dc E11C      		adc r14,__zero_reg__
 3533 04de F11C      		adc r15,__zero_reg__
 3534               	.LBE221:
 449:main.c        **** 				address++;
 450:main.c        **** 			}
 451:main.c        **** 			
 452:main.c        **** 			// Write buffer to flash
 453:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 3535               		.loc 3 453 0
 3536 04e0 C601      		movw r24,r12
 3537 04e2 8097      		sbiw r24,32
 3538 04e4 69E2      		ldi r22,lo8(41)
 3539 04e6 00D0      		rcall gb_flash_write_bus_cycle
 3540               	.LVL348:
 3541               	.LBB222:
 3542               	.LBB223:
 3543               		.loc 2 276 0
 3544 04e8 8FE8      		ldi r24,lo8(399)
 3545 04ea 91E0      		ldi r25,hi8(399)
 3546 04ec 0197      	1:	sbiw r24,1
 3547 04ee 01F4      		brne 1b
 3548 04f0 00C0      		rjmp .
 3549 04f2 0000      		nop
 3550               	.LVL349:
 3551               	.LBE223:
 3552               	.LBE222:
 454:main.c        **** 			_delay_us(200);
 455:main.c        **** 			
 456:main.c        **** 			// Verify last byte written
 457:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3553               		.loc 3 457 0
 3554 04f4 8601      		movw r16,r12
 3555 04f6 0150      		subi r16,1
 3556 04f8 1109      		sbc r17,__zero_reg__
 3557 04fa C801      		movw r24,r16
 3558 04fc 00D0      		rcall gb_flash_read_byte
 3559               	.LVL350:
 458:main.c        **** 			uint8_t verifyCount = 0;
 459:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3560               		.loc 3 459 0
 3561 04fe 98EC      		ldi r25,lo8(-56)
 3562 0500 B92E      		mov r11,r25
 3563               	.LVL351:
 3564               	.L151:
 3565 0502 9091 0000 		lds r25,receivedBuffer+31
 3566 0506 8917      		cp r24,r25
 3567 0508 01F4      		brne .+2
 3568 050a 00C0      		rjmp .L297
 460:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3569               		.loc 3 460 0
 3570 050c C801      		movw r24,r16
 3571               	.LVL352:
 3572 050e 00D0      		rcall gb_flash_read_byte
 3573               	.LVL353:
 3574               	.LBB224:
 3575               	.LBB225:
 3576               		.loc 2 276 0
 3577 0510 9DE0      		ldi r25,lo8(13)
 3578 0512 9A95      	1:	dec r25
 3579 0514 01F4      		brne 1b
 3580 0516 0000      		nop
 3581               	.LVL354:
 3582 0518 BA94      		dec r11
 3583               	.LVL355:
 3584               	.LBE225:
 3585               	.LBE224:
 461:main.c        **** 				_delay_us(5);
 462:main.c        **** 				verifyCount++;
 463:main.c        **** 				
 464:main.c        **** 				if (verifyCount >= 200) {
 3586               		.loc 3 464 0
 3587 051a B110      		cpse r11,__zero_reg__
 3588 051c 00C0      		rjmp .L151
 3589               	.LVL356:
 3590               	.LBB226:
 3591               	.LBB227:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3592               		.loc 2 187 0
 3593 051e AFEF      		ldi r26,lo8(799999)
 3594 0520 B4E3      		ldi r27,hi8(799999)
 3595 0522 ECE0      		ldi r30,hlo8(799999)
 3596 0524 A150      	1:	subi r26,1
 3597 0526 B040      		sbci r27,0
 3598 0528 E040      		sbci r30,0
 3599 052a 01F4      		brne 1b
 3600 052c 00C0      		rjmp .L310
 3601               	.LVL357:
 3602               	.L149:
 3603               	.LBE227:
 3604               	.LBE226:
 3605               	.LBE218:
 465:main.c        **** 					_delay_ms(500);
 466:main.c        **** 					break;
 467:main.c        **** 				}
 468:main.c        **** 			}
 469:main.c        **** 			
 470:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 471:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 472:main.c        **** 		}
 473:main.c        **** 		
 474:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 475:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 3606               		.loc 3 475 0
 3607 052e 9A34      		cpi r25,lo8(74)
 3608 0530 01F4      		brne .L154
 476:main.c        **** 			usart_read_bytes(64);
 3609               		.loc 3 476 0
 3610 0532 80E4      		ldi r24,lo8(64)
 3611 0534 90E0      		ldi r25,0
 3612               	.LVL358:
 3613 0536 00D0      		rcall usart_read_bytes
 3614               	.LVL359:
 477:main.c        **** 			
 478:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3615               		.loc 3 478 0
 3616 0538 939A      		sbi 0x12,3
 3617               	.LVL360:
 3618 053a 10E0      		ldi r17,lo8(receivedBuffer)
 3619 053c A12E      		mov r10,r17
 3620 053e 10E0      		ldi r17,hi8(receivedBuffer)
 3621 0540 B12E      		mov r11,r17
 3622 0542 00E0      		ldi r16,0
 3623 0544 10E0      		ldi r17,0
 3624               	.LVL361:
 3625               	.L156:
 3626               	.LBB228:
 479:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 480:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 3627               		.loc 3 480 0
 3628 0546 D501      		movw r26,r10
 3629 0548 6D91      		ld r22,X+
 3630 054a 5D01      		movw r10,r26
 3631 054c 6F3F      		cpi r22,lo8(-1)
 3632 054e 01F0      		breq .L155
 481:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3633               		.loc 3 481 0
 3634 0550 C801      		movw r24,r16
 3635 0552 8C0D      		add r24,r12
 3636 0554 9D1D      		adc r25,r13
 3637 0556 00D0      		rcall gb_flash_write_byte_special
 3638               	.LVL362:
 3639               	.L155:
 3640 0558 0F5F      		subi r16,-1
 3641 055a 1F4F      		sbci r17,-1
 3642               	.LVL363:
 479:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3643               		.loc 3 479 0 discriminator 2
 3644 055c 0034      		cpi r16,64
 3645 055e 1105      		cpc r17,__zero_reg__
 3646 0560 01F4      		brne .L156
 3647               	.LVL364:
 3648               	.L309:
 3649 0562 B0E4      		ldi r27,64
 3650 0564 CB0E      		add r12,r27
 3651 0566 D11C      		adc r13,__zero_reg__
 3652 0568 E11C      		adc r14,__zero_reg__
 3653 056a F11C      		adc r15,__zero_reg__
 3654 056c 00C0      		rjmp .L297
 3655               	.LVL365:
 3656               	.L154:
 3657               	.LBE228:
 482:main.c        **** 				}
 483:main.c        **** 				address++;
 484:main.c        **** 			}
 485:main.c        **** 			
 486:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 487:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 488:main.c        **** 		}
 489:main.c        **** 		
 490:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 491:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3658               		.loc 3 491 0
 3659 056e 9835      		cpi r25,lo8(88)
 3660 0570 01F0      		breq .+2
 3661 0572 00C0      		rjmp .L157
 3662               	.LBB229:
 492:main.c        **** 			usart_read_bytes(256);
 3663               		.loc 3 492 0
 3664 0574 80E0      		ldi r24,0
 3665 0576 91E0      		ldi r25,lo8(1)
 3666               	.LVL366:
 3667 0578 00D0      		rcall usart_read_bytes
 3668               	.LVL367:
 493:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3669               		.loc 3 493 0
 3670 057a 939A      		sbi 0x12,3
 494:main.c        **** 			
 495:main.c        **** 			// Setup buffered write
 496:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3671               		.loc 3 496 0
 3672 057c 69EA      		ldi r22,lo8(-87)
 3673 057e 8AEA      		ldi r24,lo8(-86)
 3674 0580 9AE0      		ldi r25,lo8(10)
 3675 0582 00D0      		rcall gb_flash_write_bus_cycle
 3676               	.LVL368:
 497:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3677               		.loc 3 497 0
 3678 0584 66E5      		ldi r22,lo8(86)
 3679 0586 85E5      		ldi r24,lo8(85)
 3680 0588 95E0      		ldi r25,lo8(5)
 3681 058a 00D0      		rcall gb_flash_write_bus_cycle
 3682               	.LVL369:
 498:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3683               		.loc 3 498 0
 3684 058c 5601      		movw r10,r12
 3685 058e 66E2      		ldi r22,lo8(38)
 3686 0590 C601      		movw r24,r12
 3687 0592 00D0      		rcall gb_flash_write_bus_cycle
 3688               	.LVL370:
 499:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3689               		.loc 3 499 0
 3690 0594 6FEF      		ldi r22,lo8(-1)
 3691 0596 C601      		movw r24,r12
 3692 0598 00D0      		rcall gb_flash_write_bus_cycle
 3693               	.LVL371:
 3694               	.LBB230:
 3695               	.LBB231:
 3696               		.loc 2 276 0
 3697 059a E5E8      		ldi r30,lo8(-123)
 3698 059c EA95      	1:	dec r30
 3699 059e 01F4      		brne 1b
 3700 05a0 0000      		nop
 3701               	.LVL372:
 3702 05a2 00E0      		ldi r16,lo8(receivedBuffer)
 3703 05a4 10E0      		ldi r17,hi8(receivedBuffer)
 3704               	.LBE231:
 3705               	.LBE230:
 3706               	.LBB232:
 500:main.c        **** 			_delay_us(50);
 501:main.c        **** 			
 502:main.c        **** 			// Write data
 503:main.c        **** 			for (int x = 0; x < 256; x++) {
 3707               		.loc 3 503 0
 3708 05a6 812C      		mov r8,__zero_reg__
 3709 05a8 912C      		mov r9,__zero_reg__
 3710               	.LVL373:
 3711               	.L158:
 504:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3712               		.loc 3 504 0 discriminator 3
 3713 05aa D801      		movw r26,r16
 3714 05ac 6D91      		ld r22,X+
 3715 05ae 8D01      		movw r16,r26
 3716 05b0 C401      		movw r24,r8
 3717 05b2 8A0D      		add r24,r10
 3718 05b4 9B1D      		adc r25,r11
 3719 05b6 00D0      		rcall gb_flash_write_bus_cycle
 3720               	.LVL374:
 503:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3721               		.loc 3 503 0 discriminator 3
 3722 05b8 BFEF      		ldi r27,-1
 3723 05ba 8B1A      		sub r8,r27
 3724 05bc 9B0A      		sbc r9,r27
 3725               	.LVL375:
 3726 05be 8114      		cp r8,__zero_reg__
 3727 05c0 E1E0      		ldi r30,1
 3728 05c2 9E06      		cpc r9,r30
 3729 05c4 01F4      		brne .L158
 3730 05c6 FFEF      		ldi r31,-1
 3731 05c8 DF1A      		sub r13,r31
 3732 05ca EF0A      		sbc r14,r31
 3733 05cc FF0A      		sbc r15,r31
 3734               	.LBE232:
 505:main.c        **** 				address++;
 506:main.c        **** 			}
 507:main.c        **** 			
 508:main.c        **** 			// Write buffer to flash
 509:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 3735               		.loc 3 509 0
 3736 05ce C601      		movw r24,r12
 3737 05d0 9A95      		dec r25
 3738 05d2 6AE2      		ldi r22,lo8(42)
 3739 05d4 00D0      		rcall gb_flash_write_bus_cycle
 3740               	.LVL376:
 510:main.c        **** 			
 511:main.c        **** 			// Verify last byte written
 512:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3741               		.loc 3 512 0
 3742 05d6 8601      		movw r16,r12
 3743 05d8 0150      		subi r16,1
 3744 05da 1109      		sbc r17,__zero_reg__
 3745 05dc C801      		movw r24,r16
 3746 05de 00D0      		rcall gb_flash_read_byte
 3747               	.LVL377:
 3748               	.L159:
 513:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3749               		.loc 3 513 0
 3750 05e0 9091 0000 		lds r25,receivedBuffer+255
 3751 05e4 8917      		cp r24,r25
 3752 05e6 01F4      		brne .+2
 3753 05e8 00C0      		rjmp .L297
 514:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3754               		.loc 3 514 0
 3755 05ea C801      		movw r24,r16
 3756               	.LVL378:
 3757 05ec 00D0      		rcall gb_flash_read_byte
 3758               	.LVL379:
 3759               	.LBB233:
 3760               	.LBB234:
 3761               		.loc 2 276 0
 3762 05ee 2DE0      		ldi r18,lo8(13)
 3763 05f0 2A95      	1:	dec r18
 3764 05f2 01F4      		brne 1b
 3765 05f4 0000      		nop
 3766 05f6 00C0      		rjmp .L159
 3767               	.LVL380:
 3768               	.L157:
 3769               	.LBE234:
 3770               	.LBE233:
 3771               	.LBE229:
 515:main.c        **** 				_delay_us(5);
 516:main.c        **** 			}
 517:main.c        **** 			
 518:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 519:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 520:main.c        **** 		}
 521:main.c        **** 		
 522:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 523:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 3772               		.loc 3 523 0
 3773 05f8 9A35      		cpi r25,lo8(90)
 3774 05fa 01F0      		breq .+2
 3775 05fc 00C0      		rjmp .L161
 524:main.c        **** 			usart_read_bytes(128);
 3776               		.loc 3 524 0
 3777 05fe 80E8      		ldi r24,lo8(-128)
 3778 0600 90E0      		ldi r25,0
 3779               	.LVL381:
 3780 0602 00D0      		rcall usart_read_bytes
 3781               	.LVL382:
 525:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3782               		.loc 3 525 0
 3783 0604 939A      		sbi 0x12,3
 526:main.c        **** 			
 527:main.c        **** 			// Enable flash chip access
 528:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 3784               		.loc 3 528 0
 3785 0606 69E0      		ldi r22,lo8(9)
 3786 0608 80E2      		ldi r24,lo8(32)
 3787 060a 91E0      		ldi r25,lo8(1)
 3788 060c 00D0      		rcall gb_flash_write_bus_cycle
 3789               	.LVL383:
 529:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3790               		.loc 3 529 0
 3791 060e 6AEA      		ldi r22,lo8(-86)
 3792 0610 81E2      		ldi r24,lo8(33)
 3793 0612 91E0      		ldi r25,lo8(1)
 3794 0614 00D0      		rcall gb_flash_write_bus_cycle
 3795               	.LVL384:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3796               		.loc 3 530 0
 3797 0616 65E5      		ldi r22,lo8(85)
 3798 0618 82E2      		ldi r24,lo8(34)
 3799 061a 91E0      		ldi r25,lo8(1)
 3800 061c 00D0      		rcall gb_flash_write_bus_cycle
 3801               	.LVL385:
 531:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3802               		.loc 3 531 0
 3803 061e 65EA      		ldi r22,lo8(-91)
 3804 0620 8FE3      		ldi r24,lo8(63)
 3805 0622 91E0      		ldi r25,lo8(1)
 3806 0624 00D0      		rcall gb_flash_write_bus_cycle
 3807               	.LVL386:
 3808               	.LBB235:
 3809               	.LBB236:
 3810               		.loc 2 276 0
 3811 0626 8DE0      		ldi r24,lo8(13)
 3812 0628 8A95      	1:	dec r24
 3813 062a 01F4      		brne 1b
 3814 062c 0000      		nop
 3815               	.LVL387:
 3816               	.LBE236:
 3817               	.LBE235:
 532:main.c        **** 			_delay_us(5);
 533:main.c        **** 			
 534:main.c        **** 			// Re-Enable writes to MBC registers
 535:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 3818               		.loc 3 535 0
 3819 062e 61E1      		ldi r22,lo8(17)
 3820 0630 80E2      		ldi r24,lo8(32)
 3821 0632 91E0      		ldi r25,lo8(1)
 3822 0634 00D0      		rcall gb_flash_write_bus_cycle
 3823               	.LVL388:
 536:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3824               		.loc 3 536 0
 3825 0636 65EA      		ldi r22,lo8(-91)
 3826 0638 8FE3      		ldi r24,lo8(63)
 3827 063a 91E0      		ldi r25,lo8(1)
 3828 063c 00D0      		rcall gb_flash_write_bus_cycle
 3829               	.LVL389:
 3830               	.LBB237:
 3831               	.LBB238:
 3832               		.loc 2 276 0
 3833 063e 9DE0      		ldi r25,lo8(13)
 3834 0640 9A95      	1:	dec r25
 3835 0642 01F4      		brne 1b
 3836 0644 0000      		nop
 3837               	.LVL390:
 3838               	.LBE238:
 3839               	.LBE237:
 537:main.c        **** 			_delay_us(5);
 538:main.c        **** 			
 539:main.c        **** 			// Bank 1 for commands
 540:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 3840               		.loc 3 540 0
 3841 0646 61E0      		ldi r22,lo8(1)
 3842 0648 80E0      		ldi r24,0
 3843 064a 91E2      		ldi r25,lo8(33)
 3844 064c 00D0      		rcall gb_flash_write_bus_cycle
 3845               	.LVL391:
 3846               	.LBB239:
 3847               	.LBB240:
 3848               		.loc 2 276 0
 3849 064e ADE0      		ldi r26,lo8(13)
 3850 0650 AA95      	1:	dec r26
 3851 0652 01F4      		brne 1b
 3852 0654 0000      		nop
 3853               	.LVL392:
 3854               	.LBE240:
 3855               	.LBE239:
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			
 544:main.c        **** 			// Write setup
 545:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3856               		.loc 3 545 0
 3857 0656 6FE0      		ldi r22,lo8(15)
 3858 0658 80E2      		ldi r24,lo8(32)
 3859 065a 91E0      		ldi r25,lo8(1)
 3860 065c 00D0      		rcall gb_flash_write_bus_cycle
 3861               	.LVL393:
 546:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3862               		.loc 3 546 0
 3863 065e 65E5      		ldi r22,lo8(85)
 3864 0660 85E2      		ldi r24,lo8(37)
 3865 0662 91E0      		ldi r25,lo8(1)
 3866 0664 00D0      		rcall gb_flash_write_bus_cycle
 3867               	.LVL394:
 547:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3868               		.loc 3 547 0
 3869 0666 65E5      		ldi r22,lo8(85)
 3870 0668 86E2      		ldi r24,lo8(38)
 3871 066a 91E0      		ldi r25,lo8(1)
 3872 066c 00D0      		rcall gb_flash_write_bus_cycle
 3873               	.LVL395:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3874               		.loc 3 548 0
 3875 066e 6AEA      		ldi r22,lo8(-86)
 3876 0670 87E2      		ldi r24,lo8(39)
 3877 0672 91E0      		ldi r25,lo8(1)
 3878 0674 00D0      		rcall gb_flash_write_bus_cycle
 3879               	.LVL396:
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3880               		.loc 3 549 0
 3881 0676 65EA      		ldi r22,lo8(-91)
 3882 0678 8FE3      		ldi r24,lo8(63)
 3883 067a 91E0      		ldi r25,lo8(1)
 3884 067c 00D0      		rcall gb_flash_write_bus_cycle
 3885               	.LVL397:
 3886               	.LBB241:
 3887               	.LBB242:
 3888               		.loc 2 276 0
 3889 067e BDE0      		ldi r27,lo8(13)
 3890 0680 BA95      	1:	dec r27
 3891 0682 01F4      		brne 1b
 3892 0684 0000      		nop
 3893               	.LVL398:
 3894               	.LBE242:
 3895               	.LBE241:
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3896               		.loc 3 552 0
 3897 0686 6FE0      		ldi r22,lo8(15)
 3898 0688 80E2      		ldi r24,lo8(32)
 3899 068a 91E0      		ldi r25,lo8(1)
 3900 068c 00D0      		rcall gb_flash_write_bus_cycle
 3901               	.LVL399:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3902               		.loc 3 553 0
 3903 068e 6AE2      		ldi r22,lo8(42)
 3904 0690 85E2      		ldi r24,lo8(37)
 3905 0692 91E0      		ldi r25,lo8(1)
 3906 0694 00D0      		rcall gb_flash_write_bus_cycle
 3907               	.LVL400:
 554:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3908               		.loc 3 554 0
 3909 0696 6AEA      		ldi r22,lo8(-86)
 3910 0698 86E2      		ldi r24,lo8(38)
 3911 069a 91E0      		ldi r25,lo8(1)
 3912 069c 00D0      		rcall gb_flash_write_bus_cycle
 3913               	.LVL401:
 555:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3914               		.loc 3 555 0
 3915 069e 65E5      		ldi r22,lo8(85)
 3916 06a0 87E2      		ldi r24,lo8(39)
 3917 06a2 91E0      		ldi r25,lo8(1)
 3918 06a4 00D0      		rcall gb_flash_write_bus_cycle
 3919               	.LVL402:
 556:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3920               		.loc 3 556 0
 3921 06a6 65EA      		ldi r22,lo8(-91)
 3922 06a8 8FE3      		ldi r24,lo8(63)
 3923 06aa 91E0      		ldi r25,lo8(1)
 3924 06ac 00D0      		rcall gb_flash_write_bus_cycle
 3925               	.LVL403:
 3926               	.LBB243:
 3927               	.LBB244:
 3928               		.loc 2 276 0
 3929 06ae EDE0      		ldi r30,lo8(13)
 3930 06b0 EA95      	1:	dec r30
 3931 06b2 01F4      		brne 1b
 3932 06b4 0000      		nop
 3933               	.LVL404:
 3934               	.LBE244:
 3935               	.LBE243:
 557:main.c        **** 			_delay_us(5);
 558:main.c        **** 			
 559:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3936               		.loc 3 559 0
 3937 06b6 6FE0      		ldi r22,lo8(15)
 3938 06b8 80E2      		ldi r24,lo8(32)
 3939 06ba 91E0      		ldi r25,lo8(1)
 3940 06bc 00D0      		rcall gb_flash_write_bus_cycle
 3941               	.LVL405:
 560:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3942               		.loc 3 560 0
 3943 06be 65E5      		ldi r22,lo8(85)
 3944 06c0 85E2      		ldi r24,lo8(37)
 3945 06c2 91E0      		ldi r25,lo8(1)
 3946 06c4 00D0      		rcall gb_flash_write_bus_cycle
 3947               	.LVL406:
 561:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3948               		.loc 3 561 0
 3949 06c6 65E5      		ldi r22,lo8(85)
 3950 06c8 86E2      		ldi r24,lo8(38)
 3951 06ca 91E0      		ldi r25,lo8(1)
 3952 06cc 00D0      		rcall gb_flash_write_bus_cycle
 3953               	.LVL407:
 562:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 3954               		.loc 3 562 0
 3955 06ce 60EA      		ldi r22,lo8(-96)
 3956 06d0 87E2      		ldi r24,lo8(39)
 3957 06d2 91E0      		ldi r25,lo8(1)
 3958 06d4 00D0      		rcall gb_flash_write_bus_cycle
 3959               	.LVL408:
 563:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3960               		.loc 3 563 0
 3961 06d6 65EA      		ldi r22,lo8(-91)
 3962 06d8 8FE3      		ldi r24,lo8(63)
 3963 06da 91E0      		ldi r25,lo8(1)
 3964 06dc 00D0      		rcall gb_flash_write_bus_cycle
 3965               	.LVL409:
 3966               	.LBB245:
 3967               	.LBB246:
 3968               		.loc 2 276 0
 3969 06de FDE0      		ldi r31,lo8(13)
 3970 06e0 FA95      	1:	dec r31
 3971 06e2 01F4      		brne 1b
 3972 06e4 0000      		nop
 3973               	.LVL410:
 3974               	.LBE246:
 3975               	.LBE245:
 564:main.c        **** 			_delay_us(5);
 565:main.c        **** 			
 566:main.c        **** 			// Set bank back
 567:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 3976               		.loc 3 567 0
 3977 06e6 40E0      		ldi r20,0
 3978 06e8 6091 0000 		lds r22,lastBankAccessed
 3979 06ec 80E0      		ldi r24,0
 3980 06ee 91E2      		ldi r25,lo8(33)
 3981 06f0 00D0      		rcall write_8bit_data
 3982               	.LVL411:
 3983               	.LBB247:
 3984               	.LBB248:
 3985               		.loc 2 276 0
 3986 06f2 2DE0      		ldi r18,lo8(13)
 3987 06f4 2A95      	1:	dec r18
 3988 06f6 01F4      		brne 1b
 3989 06f8 0000      		nop
 3990               	.LVL412:
 3991               	.LBE248:
 3992               	.LBE247:
 568:main.c        **** 			_delay_us(5);
 569:main.c        **** 			
 570:main.c        **** 			// Disable writes to MBC registers
 571:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 3993               		.loc 3 571 0
 3994 06fa 60E1      		ldi r22,lo8(16)
 3995 06fc 80E2      		ldi r24,lo8(32)
 3996 06fe 91E0      		ldi r25,lo8(1)
 3997 0700 00D0      		rcall gb_flash_write_bus_cycle
 3998               	.LVL413:
 572:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3999               		.loc 3 572 0
 4000 0702 65EA      		ldi r22,lo8(-91)
 4001 0704 8FE3      		ldi r24,lo8(63)
 4002 0706 91E0      		ldi r25,lo8(1)
 4003 0708 00D0      		rcall gb_flash_write_bus_cycle
 4004               	.LVL414:
 4005               	.LBB249:
 4006               	.LBB250:
 4007               		.loc 2 276 0
 4008 070a 8DE0      		ldi r24,lo8(13)
 4009 070c 8A95      	1:	dec r24
 4010 070e 01F4      		brne 1b
 4011 0710 0000      		nop
 4012               	.LVL415:
 4013               	.LBE250:
 4014               	.LBE249:
 573:main.c        **** 			_delay_us(5);
 574:main.c        **** 			
 575:main.c        **** 			// Undo Wakeup
 576:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 4015               		.loc 3 576 0
 4016 0712 68E0      		ldi r22,lo8(8)
 4017 0714 80E2      		ldi r24,lo8(32)
 4018 0716 91E0      		ldi r25,lo8(1)
 4019 0718 00D0      		rcall gb_flash_write_bus_cycle
 4020               	.LVL416:
 577:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4021               		.loc 3 577 0
 4022 071a 65EA      		ldi r22,lo8(-91)
 4023 071c 8FE3      		ldi r24,lo8(63)
 4024 071e 91E0      		ldi r25,lo8(1)
 4025 0720 00D0      		rcall gb_flash_write_bus_cycle
 4026               	.LVL417:
 4027               	.LBB251:
 4028               	.LBB252:
 4029               		.loc 2 276 0
 4030 0722 9DE0      		ldi r25,lo8(13)
 4031 0724 9A95      	1:	dec r25
 4032 0726 01F4      		brne 1b
 4033 0728 0000      		nop
 4034               	.LVL418:
 4035 072a 00E0      		ldi r16,lo8(receivedBuffer)
 4036 072c 10E0      		ldi r17,hi8(receivedBuffer)
 4037               	.L162:
 4038               	.LBE252:
 4039               	.LBE251:
 4040               	.LBB253:
 578:main.c        **** 			_delay_us(5);
 579:main.c        **** 			
 580:main.c        **** 			
 581:main.c        **** 			// Write data
 582:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 4041               		.loc 3 582 0 discriminator 1
 4042 072e F0E0      		ldi r31,hi8(receivedBuffer+128)
 4043 0730 0030      		cpi r16,lo8(receivedBuffer+128)
 4044 0732 1F07      		cpc r17,r31
 4045 0734 01F0      		breq .L311
 583:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4046               		.loc 3 583 0 discriminator 3
 4047 0736 D801      		movw r26,r16
 4048 0738 6D91      		ld r22,X+
 4049 073a 8D01      		movw r16,r26
 4050 073c C601      		movw r24,r12
 4051 073e 00D0      		rcall gb_flash_write_bus_cycle
 4052               	.LVL419:
 4053               	.LBB254:
 4054               	.LBB255:
 4055               		.loc 2 276 0 discriminator 3
 4056 0740 BDE0      		ldi r27,lo8(13)
 4057 0742 BA95      	1:	dec r27
 4058 0744 01F4      		brne 1b
 4059 0746 0000      		nop
 4060               	.LVL420:
 4061               	.LBE255:
 4062               	.LBE254:
 584:main.c        **** 				_delay_us(5);
 585:main.c        **** 				address++;
 4063               		.loc 3 585 0 discriminator 3
 4064 0748 EFEF      		ldi r30,-1
 4065 074a CE1A      		sub r12,r30
 4066 074c DE0A      		sbc r13,r30
 4067 074e EE0A      		sbc r14,r30
 4068 0750 FE0A      		sbc r15,r30
 4069               	.LVL421:
 4070 0752 00C0      		rjmp .L162
 4071               	.L311:
 4072               	.LVL422:
 4073               	.LBE253:
 586:main.c        **** 			}
 587:main.c        **** 			
 588:main.c        **** 			// Write buffer to flash
 589:main.c        **** 			address--;
 590:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 4074               		.loc 3 590 0
 4075 0754 6FEF      		ldi r22,lo8(-1)
 4076 0756 D701      		movw r26,r14
 4077 0758 C601      		movw r24,r12
 4078 075a 0197      		sbiw r24,1
 4079 075c A109      		sbc r26,__zero_reg__
 4080 075e B109      		sbc r27,__zero_reg__
 4081               	.LVL423:
 4082 0760 00D0      		rcall gb_flash_write_bus_cycle
 4083               	.LVL424:
 4084               	.LBB256:
 4085               	.LBB257:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4086               		.loc 2 187 0
 4087 0762 8FE1      		ldi r24,lo8(19999)
 4088 0764 9EE4      		ldi r25,hi8(19999)
 4089 0766 0197      	1:	sbiw r24,1
 4090 0768 01F4      		brne 1b
 4091               	.LVL425:
 4092               	.L310:
 4093 076a 00C0      		rjmp .
 4094 076c 0000      		nop
 4095 076e 00C0      		rjmp .L297
 4096               	.LVL426:
 4097               	.L161:
 4098               	.LBE257:
 4099               	.LBE256:
 591:main.c        **** 			address++;
 592:main.c        **** 			_delay_ms(10);
 593:main.c        **** 			
 594:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 595:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 596:main.c        **** 		}
 597:main.c        **** 		
 598:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 599:main.c        **** 		// Intel chips such as 28F640J5
 600:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 4100               		.loc 3 600 0
 4101 0770 9937      		cpi r25,lo8(121)
 4102 0772 01F4      		brne .L164
 601:main.c        **** 			usart_read_bytes(32);
 4103               		.loc 3 601 0
 4104 0774 80E2      		ldi r24,lo8(32)
 4105 0776 90E0      		ldi r25,0
 4106               	.LVL427:
 4107 0778 00D0      		rcall usart_read_bytes
 4108               	.LVL428:
 602:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4109               		.loc 3 602 0
 4110 077a 939A      		sbi 0x12,3
 603:main.c        **** 			
 604:main.c        **** 			// Setup buffered write
 605:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 4111               		.loc 3 605 0
 4112 077c 5601      		movw r10,r12
 4113 077e 68EE      		ldi r22,lo8(-24)
 4114 0780 C601      		movw r24,r12
 4115 0782 00D0      		rcall gb_flash_write_bus_cycle
 4116               	.LVL429:
 4117               	.L165:
 606:main.c        **** 			
 607:main.c        **** 			// Wait until ready
 608:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 609:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 4118               		.loc 3 609 0 discriminator 1
 4119 0784 C501      		movw r24,r10
 4120 0786 00D0      		rcall gb_flash_read_byte
 4121               	.LVL430:
 4122 0788 8038      		cpi r24,lo8(-128)
 4123 078a 01F4      		brne .L165
 610:main.c        **** 			
 611:main.c        **** 			// Set buffer size
 612:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 4124               		.loc 3 612 0
 4125 078c 6FE1      		ldi r22,lo8(31)
 4126 078e C501      		movw r24,r10
 4127 0790 00D0      		rcall gb_flash_write_bus_cycle
 4128               	.LVL431:
 4129 0792 00E0      		ldi r16,lo8(receivedBuffer)
 4130 0794 10E0      		ldi r17,hi8(receivedBuffer)
 4131 0796 812C      		mov r8,__zero_reg__
 4132 0798 912C      		mov r9,__zero_reg__
 4133               	.LVL432:
 4134               	.L166:
 4135               	.LBB258:
 613:main.c        **** 			
 614:main.c        **** 			// Write data to buffer
 615:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 616:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4136               		.loc 3 616 0 discriminator 3
 4137 079a D801      		movw r26,r16
 4138 079c 6D91      		ld r22,X+
 4139 079e 8D01      		movw r16,r26
 4140 07a0 C401      		movw r24,r8
 4141 07a2 8A0D      		add r24,r10
 4142 07a4 9B1D      		adc r25,r11
 4143 07a6 00D0      		rcall gb_flash_write_bus_cycle
 4144               	.LVL433:
 4145 07a8 BFEF      		ldi r27,-1
 4146 07aa 8B1A      		sub r8,r27
 4147 07ac 9B0A      		sbc r9,r27
 4148               	.LVL434:
 615:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4149               		.loc 3 615 0 discriminator 3
 4150 07ae E0E2      		ldi r30,32
 4151 07b0 8E16      		cp r8,r30
 4152 07b2 9104      		cpc r9,__zero_reg__
 4153 07b4 01F4      		brne .L166
 4154 07b6 F0E2      		ldi r31,32
 4155 07b8 CF0E      		add r12,r31
 4156 07ba D11C      		adc r13,__zero_reg__
 4157 07bc E11C      		adc r14,__zero_reg__
 4158 07be F11C      		adc r15,__zero_reg__
 4159               	.LBE258:
 617:main.c        **** 				address++;
 618:main.c        **** 			}
 619:main.c        **** 			
 620:main.c        **** 			// Write buffer to flash
 621:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 4160               		.loc 3 621 0
 4161 07c0 8601      		movw r16,r12
 4162 07c2 0052      		subi r16,32
 4163 07c4 1109      		sbc r17,__zero_reg__
 4164 07c6 60ED      		ldi r22,lo8(-48)
 4165 07c8 C801      		movw r24,r16
 4166 07ca 00D0      		rcall gb_flash_write_bus_cycle
 4167               	.LVL435:
 4168               	.LBB259:
 4169               	.LBB260:
 4170               		.loc 2 276 0
 4171 07cc 87E8      		ldi r24,lo8(391)
 4172 07ce 91E0      		ldi r25,hi8(391)
 4173 07d0 0197      	1:	sbiw r24,1
 4174 07d2 01F4      		brne 1b
 4175 07d4 00C0      		rjmp .
 4176 07d6 0000      		nop
 4177               	.L167:
 4178               	.LBE260:
 4179               	.LBE259:
 622:main.c        **** 			_delay_us(196);
 623:main.c        **** 			
 624:main.c        **** 			// Wait until ready
 625:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 626:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 4180               		.loc 3 626 0 discriminator 1
 4181 07d8 C801      		movw r24,r16
 4182 07da 00D0      		rcall gb_flash_read_byte
 4183               	.LVL436:
 4184 07dc 8038      		cpi r24,lo8(-128)
 4185 07de 01F4      		brne .L167
 4186 07e0 00C0      		rjmp .L297
 4187               	.LVL437:
 4188               	.L164:
 627:main.c        **** 			
 628:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 629:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 630:main.c        **** 		}
 631:main.c        **** 		
 632:main.c        **** 		
 633:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 634:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 635:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4189               		.loc 3 635 0
 4190 07e2 9E36      		cpi r25,lo8(110)
 4191 07e4 01F4      		brne .L168
 4192               	.LBB261:
 636:main.c        **** 			usart_read_chars(); // Read address
 4193               		.loc 3 636 0
 4194 07e6 00D0      		rcall usart_read_chars
 4195               	.LVL438:
 637:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4196               		.loc 3 637 0
 4197 07e8 40E1      		ldi r20,lo8(16)
 4198 07ea 50E0      		ldi r21,0
 4199 07ec 60E0      		ldi r22,0
 4200 07ee 70E0      		ldi r23,0
 4201 07f0 80E0      		ldi r24,lo8(receivedBuffer)
 4202 07f2 90E0      		ldi r25,hi8(receivedBuffer)
 4203 07f4 00D0      		rcall strtol
 4204               	.LVL439:
 4205 07f6 4B01      		movw r8,r22
 4206 07f8 5C01      		movw r10,r24
 4207               	.LVL440:
 638:main.c        **** 			
 639:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 4208               		.loc 3 639 0
 4209 07fa 00D0      		rcall USART_Receive
 4210               	.LVL441:
 4211 07fc 8093 0000 		sts receivedChar,r24
 640:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4212               		.loc 3 640 0
 4213 0800 8E36      		cpi r24,lo8(110)
 4214 0802 01F0      		breq .+2
 4215 0804 00C0      		rjmp .L95
 4216               	.LBB262:
 641:main.c        **** 				usart_read_chars(); // Read data
 4217               		.loc 3 641 0
 4218 0806 00D0      		rcall usart_read_chars
 4219               	.LVL442:
 642:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4220               		.loc 3 642 0
 4221 0808 40E1      		ldi r20,lo8(16)
 4222 080a 50E0      		ldi r21,0
 4223 080c 60E0      		ldi r22,0
 4224 080e 70E0      		ldi r23,0
 4225 0810 80E0      		ldi r24,lo8(receivedBuffer)
 4226 0812 90E0      		ldi r25,hi8(receivedBuffer)
 4227 0814 00D0      		rcall strtol
 4228               	.LVL443:
 643:main.c        **** 				
 644:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 4229               		.loc 3 644 0
 4230 0816 939A      		sbi 0x12,3
 645:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4231               		.loc 3 645 0
 4232 0818 AFEF      		ldi r26,lo8(-1)
 4233 081a A4BB      		out 0x14,r26
 646:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4234               		.loc 3 646 0
 4235 081c AABB      		out 0x1a,r26
 647:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4236               		.loc 3 647 0
 4237 081e A7BB      		out 0x17,r26
 648:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4238               		.loc 3 648 0
 4239 0820 AB01      		movw r20,r22
 4240 0822 C501      		movw r24,r10
 4241 0824 B401      		movw r22,r8
 4242               	.LVL444:
 4243 0826 00D0      		rcall gba_flash_write_bus_cycle
 4244               	.LVL445:
 4245               	.L308:
 649:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4246               		.loc 3 649 0
 4247 0828 9398      		cbi 0x12,3
 650:main.c        **** 				
 651:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 4248               		.loc 3 651 0
 4249 082a 81E3      		ldi r24,lo8(49)
 4250 082c 00C0      		rjmp .L288
 4251               	.LVL446:
 4252               	.L168:
 4253               	.LBE262:
 4254               	.LBE261:
 652:main.c        **** 			}
 653:main.c        **** 		}
 654:main.c        **** 		
 655:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 656:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 4255               		.loc 3 656 0
 4256 082e 9137      		cpi r25,lo8(113)
 4257 0830 01F0      		breq .L169
 4258               		.loc 3 656 0 is_stmt 0 discriminator 1
 4259 0832 9437      		cpi r25,lo8(116)
 4260 0834 01F4      		brne .L170
 4261               	.L169:
 4262               	.LBB263:
 657:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4263               		.loc 3 657 0 is_stmt 1
 4264 0836 939A      		sbi 0x12,3
 4265               	.LVL447:
 658:main.c        **** 			
 659:main.c        **** 			int readLength = 64;
 660:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4266               		.loc 3 660 0
 4267 0838 8091 0000 		lds r24,receivedChar
 4268               	.LVL448:
 4269 083c 8437      		cpi r24,lo8(116)
 4270 083e 01F4      		brne .L233
 661:main.c        **** 				readLength = 256;
 4271               		.loc 3 661 0
 4272 0840 00E0      		ldi r16,0
 4273 0842 11E0      		ldi r17,lo8(1)
 4274 0844 00C0      		rjmp .L171
 4275               	.L233:
 659:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4276               		.loc 3 659 0
 4277 0846 00E4      		ldi r16,lo8(64)
 4278 0848 10E0      		ldi r17,0
 4279               	.L171:
 4280               	.LVL449:
 662:main.c        **** 			}
 663:main.c        **** 			usart_read_bytes(readLength);
 4281               		.loc 3 663 0
 4282 084a C801      		movw r24,r16
 4283 084c 00D0      		rcall usart_read_bytes
 4284               	.LVL450:
 4285 084e B0E0      		ldi r27,lo8(receivedBuffer)
 4286 0850 AB2E      		mov r10,r27
 4287 0852 B0E0      		ldi r27,hi8(receivedBuffer)
 4288 0854 BB2E      		mov r11,r27
 4289 0856 2601      		movw r4,r12
 4290 0858 3701      		movw r6,r14
 4291               	.LVL451:
 4292               	.L173:
 4293               	.LBB264:
 4294               	.LBB265:
 664:main.c        **** 			
 665:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 666:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4295               		.loc 3 666 0
 4296 085a F501      		movw r30,r10
 4297 085c 4181      		ldd r20,Z+1
 4298 085e 50E0      		ldi r21,0
 4299 0860 542F      		mov r21,r20
 4300 0862 4427      		clr r20
 4301 0864 8081      		ld r24,Z
 4302 0866 482B      		or r20,r24
 4303               	.LVL452:
 667:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4304               		.loc 3 667 0
 4305 0868 4F3F      		cpi r20,-1
 4306 086a FFEF      		ldi r31,-1
 4307 086c 5F07      		cpc r21,r31
 4308 086e 01F0      		breq .L172
 668:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4309               		.loc 3 668 0
 4310 0870 21E0      		ldi r18,lo8(1)
 4311 0872 C301      		movw r24,r6
 4312 0874 B201      		movw r22,r4
 4313 0876 00D0      		rcall gba_flash_write_byte
 4314               	.LVL453:
 4315               	.L172:
 669:main.c        **** 				}
 670:main.c        **** 				address++;
 4316               		.loc 3 670 0 discriminator 2
 4317 0878 2FEF      		ldi r18,-1
 4318 087a 421A      		sub r4,r18
 4319 087c 520A      		sbc r5,r18
 4320 087e 620A      		sbc r6,r18
 4321 0880 720A      		sbc r7,r18
 4322               	.LVL454:
 4323 0882 82E0      		ldi r24,2
 4324 0884 A80E      		add r10,r24
 4325 0886 B11C      		adc r11,__zero_reg__
 4326               	.LVL455:
 4327               	.LBE265:
 665:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4328               		.loc 3 665 0 discriminator 2
 4329 0888 C501      		movw r24,r10
 4330 088a 8050      		subi r24,lo8(receivedBuffer)
 4331 088c 9040      		sbci r25,hi8(receivedBuffer)
 4332 088e 8017      		cp r24,r16
 4333 0890 9107      		cpc r25,r17
 4334 0892 04F0      		brlt .L173
 4335 0894 9FEF      		ldi r25,-1
 4336 0896 C91A      		sub r12,r25
 4337 0898 D90A      		sbc r13,r25
 4338 089a E90A      		sbc r14,r25
 4339 089c F90A      		sbc r15,r25
 4340 089e 0150      		subi r16,1
 4341 08a0 1109      		sbc r17,__zero_reg__
 4342               	.LVL456:
 4343 08a2 1695      		lsr r17
 4344 08a4 0795      		ror r16
 4345               	.LVL457:
 4346 08a6 C00E      		add r12,r16
 4347 08a8 D11E      		adc r13,r17
 4348 08aa E11C      		adc r14,__zero_reg__
 4349 08ac F11C      		adc r15,__zero_reg__
 4350 08ae 00C0      		rjmp .L297
 4351               	.LVL458:
 4352               	.L170:
 4353               	.LBE264:
 4354               	.LBE263:
 671:main.c        **** 			}
 672:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 673:main.c        **** 			
 674:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 675:main.c        **** 		}
 676:main.c        **** 		
 677:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 678:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 4355               		.loc 3 678 0
 4356 08b0 9636      		cpi r25,lo8(102)
 4357 08b2 01F4      		brne .L174
 4358               	.LBB266:
 679:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4359               		.loc 3 679 0
 4360 08b4 939A      		sbi 0x12,3
 4361               	.LVL459:
 680:main.c        **** 			
 681:main.c        **** 			int readLength = 256;
 682:main.c        **** 			usart_read_bytes(readLength);
 4362               		.loc 3 682 0
 4363 08b6 80E0      		ldi r24,0
 4364 08b8 91E0      		ldi r25,lo8(1)
 4365               	.LVL460:
 4366 08ba 00D0      		rcall usart_read_bytes
 4367               	.LVL461:
 4368 08bc 00E0      		ldi r16,lo8(receivedBuffer)
 4369 08be 10E0      		ldi r17,hi8(receivedBuffer)
 4370 08c0 4601      		movw r8,r12
 4371 08c2 5701      		movw r10,r14
 4372               	.LVL462:
 4373               	.L176:
 4374               	.LBB267:
 4375               	.LBB268:
 683:main.c        **** 			
 684:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 685:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4376               		.loc 3 685 0
 4377 08c4 D801      		movw r26,r16
 4378 08c6 1196      		adiw r26,1
 4379 08c8 4C91      		ld r20,X
 4380 08ca 1197      		sbiw r26,1
 4381 08cc 50E0      		ldi r21,0
 4382 08ce 542F      		mov r21,r20
 4383 08d0 4427      		clr r20
 4384 08d2 8C91      		ld r24,X
 4385 08d4 482B      		or r20,r24
 4386               	.LVL463:
 686:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4387               		.loc 3 686 0
 4388 08d6 4F3F      		cpi r20,-1
 4389 08d8 BFEF      		ldi r27,-1
 4390 08da 5B07      		cpc r21,r27
 4391 08dc 01F0      		breq .L175
 687:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4392               		.loc 3 687 0
 4393 08de 20E0      		ldi r18,0
 4394 08e0 C501      		movw r24,r10
 4395 08e2 B401      		movw r22,r8
 4396 08e4 00D0      		rcall gba_flash_write_byte
 4397               	.LVL464:
 4398               	.L175:
 688:main.c        **** 				}
 689:main.c        **** 				address++;
 4399               		.loc 3 689 0 discriminator 2
 4400 08e6 EFEF      		ldi r30,-1
 4401 08e8 8E1A      		sub r8,r30
 4402 08ea 9E0A      		sbc r9,r30
 4403 08ec AE0A      		sbc r10,r30
 4404 08ee BE0A      		sbc r11,r30
 4405               	.LVL465:
 4406 08f0 0E5F      		subi r16,-2
 4407 08f2 1F4F      		sbci r17,-1
 4408               	.LVL466:
 4409               	.LBE268:
 684:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4410               		.loc 3 684 0 discriminator 2
 4411 08f4 F0E0      		ldi r31,hi8(receivedBuffer+256)
 4412 08f6 0030      		cpi r16,lo8(receivedBuffer+256)
 4413 08f8 1F07      		cpc r17,r31
 4414 08fa 01F4      		brne .L176
 4415 08fc 20E8      		ldi r18,-128
 4416 08fe C20E      		add r12,r18
 4417 0900 D11C      		adc r13,__zero_reg__
 4418 0902 E11C      		adc r14,__zero_reg__
 4419 0904 F11C      		adc r15,__zero_reg__
 4420 0906 00C0      		rjmp .L297
 4421               	.LVL467:
 4422               	.L174:
 4423               	.LBE267:
 4424               	.LBE266:
 690:main.c        **** 			}
 691:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 692:main.c        **** 			
 693:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 694:main.c        **** 		}
 695:main.c        **** 		
 696:main.c        **** 		// Intel flash command based chips
 697:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 698:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 4425               		.loc 3 698 0
 4426 0908 9C36      		cpi r25,lo8(108)
 4427 090a 01F0      		breq .+2
 4428 090c 00C0      		rjmp .L177
 4429               	.LBB269:
 699:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4430               		.loc 3 699 0
 4431 090e 939A      		sbi 0x12,3
 700:main.c        **** 			usart_read_bytes(64);
 4432               		.loc 3 700 0
 4433 0910 80E4      		ldi r24,lo8(64)
 4434 0912 90E0      		ldi r25,0
 4435               	.LVL468:
 4436 0914 00D0      		rcall usart_read_bytes
 4437               	.LVL469:
 701:main.c        **** 			
 702:main.c        **** 			// Set address lines as outputs
 703:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4438               		.loc 3 703 0
 4439 0916 8FEF      		ldi r24,lo8(-1)
 4440 0918 84BB      		out 0x14,r24
 704:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4441               		.loc 3 704 0
 4442 091a 8ABB      		out 0x1a,r24
 705:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4443               		.loc 3 705 0
 4444 091c 87BB      		out 0x17,r24
 706:main.c        **** 			
 707:main.c        **** 			// Unlock
 708:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 4445               		.loc 3 708 0
 4446 091e 40E6      		ldi r20,lo8(96)
 4447 0920 50E0      		ldi r21,0
 4448 0922 C701      		movw r24,r14
 4449 0924 B601      		movw r22,r12
 4450 0926 00D0      		rcall gba_flash_write_bus_cycle
 4451               	.LVL470:
 709:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4452               		.loc 3 709 0
 4453 0928 40ED      		ldi r20,lo8(-48)
 4454 092a 50E0      		ldi r21,0
 4455 092c C701      		movw r24,r14
 4456 092e B601      		movw r22,r12
 4457 0930 00D0      		rcall gba_flash_write_bus_cycle
 4458               	.LVL471:
 710:main.c        **** 			
 711:main.c        **** 			// Buffered write command
 712:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 4459               		.loc 3 712 0
 4460 0932 48EE      		ldi r20,lo8(-24)
 4461 0934 50E0      		ldi r21,0
 4462 0936 C701      		movw r24,r14
 4463 0938 B601      		movw r22,r12
 4464 093a 00D0      		rcall gba_flash_write_bus_cycle
 4465               	.LVL472:
 4466               	.LBB270:
 4467               	.LBB271:
 4468               		.loc 2 276 0
 4469 093c 95E8      		ldi r25,lo8(-123)
 4470 093e 9A95      	1:	dec r25
 4471 0940 01F4      		brne 1b
 4472 0942 0000      		nop
 4473               	.LVL473:
 4474               	.LBE271:
 4475               	.LBE270:
 713:main.c        **** 			_delay_us(50);
 714:main.c        **** 			
 715:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 716:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 4476               		.loc 3 716 0
 4477 0944 C701      		movw r24,r14
 4478 0946 B601      		movw r22,r12
 4479 0948 00D0      		rcall gba_read_16bit_data
 4480               	.LVL474:
 4481               	.L178:
 717:main.c        **** 			while (dataVerify != 0x0080) {
 4482               		.loc 3 717 0
 4483 094a 8038      		cpi r24,-128
 4484 094c 9105      		cpc r25,__zero_reg__
 4485 094e 01F0      		breq .L312
 718:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4486               		.loc 3 718 0
 4487 0950 C701      		movw r24,r14
 4488 0952 B601      		movw r22,r12
 4489 0954 00D0      		rcall gba_read_16bit_data
 4490               	.LVL475:
 4491               	.LBB272:
 4492               	.LBB273:
 4493               		.loc 2 276 0
 4494 0956 A5E8      		ldi r26,lo8(-123)
 4495 0958 AA95      	1:	dec r26
 4496 095a 01F4      		brne 1b
 4497 095c 0000      		nop
 4498 095e 00C0      		rjmp .L178
 4499               	.LVL476:
 4500               	.L312:
 4501               	.LBE273:
 4502               	.LBE272:
 719:main.c        **** 				_delay_us(50);
 720:main.c        **** 			}
 721:main.c        **** 			
 722:main.c        **** 			
 723:main.c        **** 			// Set address lines as outputs
 724:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4503               		.loc 3 724 0
 4504 0960 BFEF      		ldi r27,lo8(-1)
 4505 0962 B4BB      		out 0x14,r27
 725:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4506               		.loc 3 725 0
 4507 0964 BABB      		out 0x1a,r27
 726:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4508               		.loc 3 726 0
 4509 0966 B7BB      		out 0x17,r27
 727:main.c        **** 			
 728:main.c        **** 			// Set length
 729:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 4510               		.loc 3 729 0
 4511 0968 4FE1      		ldi r20,lo8(31)
 4512 096a 50E0      		ldi r21,0
 4513 096c C701      		movw r24,r14
 4514 096e B601      		movw r22,r12
 4515 0970 00D0      		rcall gba_flash_write_bus_cycle
 4516               	.LVL477:
 4517 0972 00E0      		ldi r16,lo8(receivedBuffer)
 4518 0974 10E0      		ldi r17,hi8(receivedBuffer)
 4519 0976 4601      		movw r8,r12
 4520 0978 5701      		movw r10,r14
 4521               	.LVL478:
 4522               	.L180:
 4523               	.LBB274:
 4524               	.LBB275:
 730:main.c        **** 			
 731:main.c        **** 			// Write data
 732:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 733:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 734:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4525               		.loc 3 734 0 discriminator 3
 4526 097a F801      		movw r30,r16
 4527 097c 4181      		ldd r20,Z+1
 4528 097e 50E0      		ldi r21,0
 4529 0980 542F      		mov r21,r20
 4530 0982 4427      		clr r20
 4531 0984 8081      		ld r24,Z
 4532 0986 482B      		or r20,r24
 4533 0988 C501      		movw r24,r10
 4534 098a B401      		movw r22,r8
 4535 098c 00D0      		rcall gba_flash_write_bus_cycle
 4536               	.LVL479:
 735:main.c        **** 				address++;
 4537               		.loc 3 735 0 discriminator 3
 4538 098e FFEF      		ldi r31,-1
 4539 0990 8F1A      		sub r8,r31
 4540 0992 9F0A      		sbc r9,r31
 4541 0994 AF0A      		sbc r10,r31
 4542 0996 BF0A      		sbc r11,r31
 4543               	.LVL480:
 4544 0998 0E5F      		subi r16,-2
 4545 099a 1F4F      		sbci r17,-1
 4546               	.LVL481:
 4547               	.LBE275:
 732:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4548               		.loc 3 732 0 discriminator 3
 4549 099c 80E0      		ldi r24,lo8(receivedBuffer+64)
 4550 099e 90E0      		ldi r25,hi8(receivedBuffer+64)
 4551 09a0 8017      		cp r24,r16
 4552 09a2 9107      		cpc r25,r17
 4553 09a4 01F4      		brne .L180
 4554 09a6 90E2      		ldi r25,32
 4555 09a8 C90E      		add r12,r25
 4556 09aa D11C      		adc r13,__zero_reg__
 4557 09ac E11C      		adc r14,__zero_reg__
 4558 09ae F11C      		adc r15,__zero_reg__
 4559               	.LBE274:
 736:main.c        **** 			}
 737:main.c        **** 			
 738:main.c        **** 			// Write buffer to flash
 739:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4560               		.loc 3 739 0
 4561 09b0 40ED      		ldi r20,lo8(-48)
 4562 09b2 50E0      		ldi r21,0
 4563 09b4 C701      		movw r24,r14
 4564 09b6 B601      		movw r22,r12
 4565 09b8 00D0      		rcall gba_flash_write_bus_cycle
 4566               	.LVL482:
 4567               	.LBB276:
 4568               	.LBB277:
 4569               		.loc 2 276 0
 4570 09ba AFE6      		ldi r26,lo8(879)
 4571 09bc B3E0      		ldi r27,hi8(879)
 4572 09be 1197      	1:	sbiw r26,1
 4573 09c0 01F4      		brne 1b
 4574 09c2 00C0      		rjmp .
 4575 09c4 0000      		nop
 4576               	.LVL483:
 4577               	.LBE277:
 4578               	.LBE276:
 740:main.c        **** 			_delay_us(440);
 741:main.c        **** 			
 742:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 743:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 4579               		.loc 3 743 0
 4580 09c6 C701      		movw r24,r14
 4581 09c8 B601      		movw r22,r12
 4582 09ca 00D0      		rcall gba_read_16bit_data
 4583               	.LVL484:
 4584               	.L181:
 744:main.c        **** 			while (dataVerify != 0x0080) {
 4585               		.loc 3 744 0
 4586 09cc 8038      		cpi r24,-128
 4587 09ce 9105      		cpc r25,__zero_reg__
 4588 09d0 01F0      		breq .L313
 745:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4589               		.loc 3 745 0
 4590 09d2 C701      		movw r24,r14
 4591 09d4 B601      		movw r22,r12
 4592 09d6 00D0      		rcall gba_read_16bit_data
 4593               	.LVL485:
 4594               	.LBB278:
 4595               	.LBB279:
 4596               		.loc 2 276 0
 4597 09d8 B5E8      		ldi r27,lo8(-123)
 4598 09da BA95      	1:	dec r27
 4599 09dc 01F4      		brne 1b
 4600 09de 0000      		nop
 4601 09e0 00C0      		rjmp .L181
 4602               	.LVL486:
 4603               	.L313:
 4604               	.LBE279:
 4605               	.LBE278:
 746:main.c        **** 				_delay_us(50);
 747:main.c        **** 			}
 748:main.c        **** 			
 749:main.c        **** 			
 750:main.c        **** 			// Set address lines as outputs
 751:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4606               		.loc 3 751 0
 4607 09e2 EFEF      		ldi r30,lo8(-1)
 4608 09e4 E4BB      		out 0x14,r30
 752:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4609               		.loc 3 752 0
 4610 09e6 EABB      		out 0x1a,r30
 753:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4611               		.loc 3 753 0
 4612 09e8 E7BB      		out 0x17,r30
 754:main.c        **** 			
 755:main.c        **** 			// Back to reading mode
 756:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 4613               		.loc 3 756 0
 4614 09ea 4FEF      		ldi r20,lo8(-1)
 4615 09ec 50E0      		ldi r21,0
 4616 09ee C701      		movw r24,r14
 4617 09f0 B601      		movw r22,r12
 4618 09f2 00D0      		rcall gba_flash_write_bus_cycle
 4619               	.LVL487:
 4620 09f4 00C0      		rjmp .L297
 4621               	.LVL488:
 4622               	.L177:
 4623               	.LBE269:
 757:main.c        **** 			
 758:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 759:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 760:main.c        **** 		}
 761:main.c        **** 		
 762:main.c        **** 		// Intel word programming
 763:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 4624               		.loc 3 763 0
 4625 09f6 9537      		cpi r25,lo8(117)
 4626 09f8 01F0      		breq .+2
 4627 09fa 00C0      		rjmp .L183
 764:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4628               		.loc 3 764 0
 4629 09fc 939A      		sbi 0x12,3
 765:main.c        **** 			usart_read_bytes(64);
 4630               		.loc 3 765 0
 4631 09fe 80E4      		ldi r24,lo8(64)
 4632 0a00 90E0      		ldi r25,0
 4633               	.LVL489:
 4634 0a02 00D0      		rcall usart_read_bytes
 4635               	.LVL490:
 4636 0a04 50E0      		ldi r21,lo8(receivedBuffer)
 4637 0a06 A52E      		mov r10,r21
 4638 0a08 50E0      		ldi r21,hi8(receivedBuffer)
 4639 0a0a B52E      		mov r11,r21
 4640 0a0c 2601      		movw r4,r12
 4641 0a0e 3701      		movw r6,r14
 4642               	.LVL491:
 4643               	.L186:
 4644               	.LBB280:
 4645               	.LBB281:
 766:main.c        **** 			
 767:main.c        **** 			// Write data
 768:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 769:main.c        **** 				// Set address lines as outputs
 770:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4646               		.loc 3 770 0
 4647 0a10 FFEF      		ldi r31,lo8(-1)
 4648 0a12 F4BB      		out 0x14,r31
 771:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4649               		.loc 3 771 0
 4650 0a14 FABB      		out 0x1a,r31
 772:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4651               		.loc 3 772 0
 4652 0a16 F7BB      		out 0x17,r31
 773:main.c        **** 				
 774:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4653               		.loc 3 774 0
 4654 0a18 D501      		movw r26,r10
 4655 0a1a 1196      		adiw r26,1
 4656 0a1c 0C91      		ld r16,X
 4657 0a1e 1197      		sbiw r26,1
 4658 0a20 10E0      		ldi r17,0
 4659 0a22 102F      		mov r17,r16
 4660 0a24 0027      		clr r16
 4661 0a26 8C91      		ld r24,X
 4662 0a28 082B      		or r16,r24
 4663               	.LVL492:
 775:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4664               		.loc 3 775 0
 4665 0a2a 40E4      		ldi r20,lo8(64)
 4666 0a2c 50E0      		ldi r21,0
 4667 0a2e C301      		movw r24,r6
 4668 0a30 B201      		movw r22,r4
 4669 0a32 00D0      		rcall gba_flash_write_bus_cycle
 4670               	.LVL493:
 776:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4671               		.loc 3 776 0
 4672 0a34 A801      		movw r20,r16
 4673 0a36 C301      		movw r24,r6
 4674 0a38 B201      		movw r22,r4
 4675 0a3a 00D0      		rcall gba_flash_write_bus_cycle
 4676               	.LVL494:
 777:main.c        **** 				
 778:main.c        **** 				// Verify status ok
 779:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4677               		.loc 3 779 0
 4678 0a3c C301      		movw r24,r6
 4679 0a3e B201      		movw r22,r4
 4680 0a40 00D0      		rcall gba_read_16bit_data
 4681               	.LVL495:
 4682               	.L184:
 780:main.c        **** 				while ((status & 0x80) == 0) {
 4683               		.loc 3 780 0
 4684 0a42 87FD      		sbrc r24,7
 4685 0a44 00C0      		rjmp .L314
 781:main.c        **** 					status = gba_read_16bit_data(address);
 4686               		.loc 3 781 0
 4687 0a46 C301      		movw r24,r6
 4688 0a48 B201      		movw r22,r4
 4689 0a4a 00D0      		rcall gba_read_16bit_data
 4690               	.LVL496:
 4691               	.LBB282:
 4692               	.LBB283:
 4693               		.loc 2 276 0
 4694 0a4c B5E0      		ldi r27,lo8(5)
 4695 0a4e BA95      	1:	dec r27
 4696 0a50 01F4      		brne 1b
 4697 0a52 0000      		nop
 4698 0a54 00C0      		rjmp .L184
 4699               	.LVL497:
 4700               	.L314:
 4701               	.LBE283:
 4702               	.LBE282:
 782:main.c        **** 					_delay_us(2);
 783:main.c        **** 				}
 784:main.c        **** 				address++;
 4703               		.loc 3 784 0 discriminator 2
 4704 0a56 EFEF      		ldi r30,-1
 4705 0a58 4E1A      		sub r4,r30
 4706 0a5a 5E0A      		sbc r5,r30
 4707 0a5c 6E0A      		sbc r6,r30
 4708 0a5e 7E0A      		sbc r7,r30
 4709               	.LVL498:
 4710 0a60 F2E0      		ldi r31,2
 4711 0a62 AF0E      		add r10,r31
 4712 0a64 B11C      		adc r11,__zero_reg__
 4713               	.LVL499:
 4714               	.LBE281:
 768:main.c        **** 				// Set address lines as outputs
 4715               		.loc 3 768 0 discriminator 2
 4716 0a66 20E0      		ldi r18,lo8(receivedBuffer+64)
 4717 0a68 A216      		cp r10,r18
 4718 0a6a 20E0      		ldi r18,hi8(receivedBuffer+64)
 4719 0a6c B206      		cpc r11,r18
 4720 0a6e 01F4      		brne .L186
 4721 0a70 80E2      		ldi r24,32
 4722 0a72 C80E      		add r12,r24
 4723 0a74 D11C      		adc r13,__zero_reg__
 4724 0a76 E11C      		adc r14,__zero_reg__
 4725 0a78 F11C      		adc r15,__zero_reg__
 4726 0a7a 00C0      		rjmp .L297
 4727               	.LVL500:
 4728               	.L183:
 4729               	.LBE280:
 785:main.c        **** 			}
 786:main.c        **** 			
 787:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 788:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 789:main.c        **** 		}
 790:main.c        **** 		
 791:main.c        **** 		// Intel flash command based chips, two chips interleaved (Flash2Advance 256M cart)
 792:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 793:main.c        **** 		// Thanks to lesserkuma for adding support
 794:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE) {
 4730               		.loc 3 794 0
 4731 0a7c 9637      		cpi r25,lo8(118)
 4732 0a7e 01F0      		breq .+2
 4733 0a80 00C0      		rjmp .L187
 795:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4734               		.loc 3 795 0
 4735 0a82 939A      		sbi 0x12,3
 796:main.c        **** 			usart_read_bytes(256);
 4736               		.loc 3 796 0
 4737 0a84 80E0      		ldi r24,0
 4738 0a86 91E0      		ldi r25,lo8(1)
 4739               	.LVL501:
 4740 0a88 00D0      		rcall usart_read_bytes
 4741               	.LVL502:
 4742 0a8a 30E0      		ldi r19,lo8(receivedBuffer)
 4743 0a8c 232E      		mov r2,r19
 4744 0a8e 30E0      		ldi r19,hi8(receivedBuffer)
 4745 0a90 332E      		mov r3,r19
 4746 0a92 4601      		movw r8,r12
 4747 0a94 5701      		movw r10,r14
 4748               	.LVL503:
 4749               	.L193:
 4750               	.LBB284:
 4751               	.LBB285:
 797:main.c        **** 			
 798:main.c        **** 			// Loop four times, transferring 256 bytes over USB at once is faster than doing four transfers
 799:main.c        **** 			for (int c = 0; c < 4; c++) {
 800:main.c        **** 				// Set address lines as outputs
 801:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4752               		.loc 3 801 0
 4753 0a96 9FEF      		ldi r25,lo8(-1)
 4754 0a98 94BB      		out 0x14,r25
 802:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4755               		.loc 3 802 0
 4756 0a9a 9ABB      		out 0x1a,r25
 803:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4757               		.loc 3 803 0
 4758 0a9c 97BB      		out 0x17,r25
 804:main.c        **** 				
 805:main.c        **** 				// Setup buffered write
 806:main.c        **** 				gba_flash_write_bus_cycle(address, 0xE8);
 4759               		.loc 3 806 0
 4760 0a9e 48EE      		ldi r20,lo8(-24)
 4761 0aa0 50E0      		ldi r21,0
 4762 0aa2 C501      		movw r24,r10
 4763 0aa4 B401      		movw r22,r8
 4764 0aa6 00D0      		rcall gba_flash_write_bus_cycle
 4765               	.LVL504:
 4766 0aa8 D501      		movw r26,r10
 4767 0aaa C401      		movw r24,r8
 4768 0aac 0196      		adiw r24,1
 4769 0aae A11D      		adc r26,__zero_reg__
 4770 0ab0 B11D      		adc r27,__zero_reg__
 4771 0ab2 8983      		std Y+1,r24
 4772 0ab4 9A83      		std Y+2,r25
 4773 0ab6 AB83      		std Y+3,r26
 4774 0ab8 BC83      		std Y+4,r27
 807:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 4775               		.loc 3 807 0
 4776 0aba 48EE      		ldi r20,lo8(-24)
 4777 0abc 50E0      		ldi r21,0
 4778 0abe BC01      		movw r22,r24
 4779 0ac0 CD01      		movw r24,r26
 4780 0ac2 00D0      		rcall gba_flash_write_bus_cycle
 4781               	.LVL505:
 4782               	.L188:
 808:main.c        **** 				
 809:main.c        **** 				// Wait until both chips are ready
 810:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4783               		.loc 3 810 0 discriminator 1
 4784 0ac4 C501      		movw r24,r10
 4785 0ac6 B401      		movw r22,r8
 4786 0ac8 00D0      		rcall gba_read_16bit_data
 4787               	.LVL506:
 4788 0aca 8038      		cpi r24,-128
 4789 0acc 9105      		cpc r25,__zero_reg__
 4790 0ace 01F4      		brne .L188
 4791               	.L189:
 811:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4792               		.loc 3 811 0 discriminator 1
 4793 0ad0 6981      		ldd r22,Y+1
 4794 0ad2 7A81      		ldd r23,Y+2
 4795 0ad4 8B81      		ldd r24,Y+3
 4796 0ad6 9C81      		ldd r25,Y+4
 4797 0ad8 00D0      		rcall gba_read_16bit_data
 4798               	.LVL507:
 4799 0ada 8038      		cpi r24,-128
 4800 0adc 9105      		cpc r25,__zero_reg__
 4801 0ade 01F4      		brne .L189
 812:main.c        **** 				
 813:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 814:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 815:main.c        **** 				
 816:main.c        **** 				// Set address lines as outputs
 817:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4802               		.loc 3 817 0
 4803 0ae0 9FEF      		ldi r25,lo8(-1)
 4804 0ae2 94BB      		out 0x14,r25
 818:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4805               		.loc 3 818 0
 4806 0ae4 9ABB      		out 0x1a,r25
 819:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4807               		.loc 3 819 0
 4808 0ae6 97BB      		out 0x17,r25
 820:main.c        **** 				
 821:main.c        **** 				// Set length (number of words+1 to write)
 822:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // 16 words
 4809               		.loc 3 822 0
 4810 0ae8 4FE0      		ldi r20,lo8(15)
 4811 0aea 50E0      		ldi r21,0
 4812 0aec C501      		movw r24,r10
 4813 0aee B401      		movw r22,r8
 4814 0af0 00D0      		rcall gba_flash_write_bus_cycle
 4815               	.LVL508:
 823:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
 4816               		.loc 3 823 0
 4817 0af2 4FE0      		ldi r20,lo8(15)
 4818 0af4 50E0      		ldi r21,0
 4819 0af6 6981      		ldd r22,Y+1
 4820 0af8 7A81      		ldd r23,Y+2
 4821 0afa 8B81      		ldd r24,Y+3
 4822 0afc 9C81      		ldd r25,Y+4
 4823 0afe 00D0      		rcall gba_flash_write_bus_cycle
 4824               	.LVL509:
 4825 0b00 8101      		movw r16,r2
 4826 0b02 2401      		movw r4,r8
 4827 0b04 3501      		movw r6,r10
 4828               	.LBB286:
 824:main.c        **** 				
 825:main.c        **** 				// Write data (32 words total)
 826:main.c        **** 				uint16_t combinedBytes;
 827:main.c        **** 				for (int x = 0; x < 64; x += 2) {
 4829               		.loc 3 827 0
 4830 0b06 1F82      		std Y+7,__zero_reg__
 4831 0b08 1E82      		std Y+6,__zero_reg__
 4832               	.LVL510:
 4833               	.L190:
 828:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 829:main.c        **** 					gba_flash_write_bus_cycle(address, combinedBytes);
 4834               		.loc 3 829 0 discriminator 3
 4835 0b0a D801      		movw r26,r16
 4836 0b0c 1196      		adiw r26,1
 4837 0b0e 4C91      		ld r20,X
 4838 0b10 1197      		sbiw r26,1
 4839 0b12 50E0      		ldi r21,0
 4840 0b14 542F      		mov r21,r20
 4841 0b16 4427      		clr r20
 4842 0b18 8C91      		ld r24,X
 4843 0b1a 482B      		or r20,r24
 4844 0b1c C301      		movw r24,r6
 4845 0b1e B201      		movw r22,r4
 4846 0b20 00D0      		rcall gba_flash_write_bus_cycle
 4847               	.LVL511:
 830:main.c        **** 					address++;
 4848               		.loc 3 830 0 discriminator 3
 4849 0b22 BFEF      		ldi r27,-1
 4850 0b24 4B1A      		sub r4,r27
 4851 0b26 5B0A      		sbc r5,r27
 4852 0b28 6B0A      		sbc r6,r27
 4853 0b2a 7B0A      		sbc r7,r27
 4854               	.LVL512:
 827:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 4855               		.loc 3 827 0 discriminator 3
 4856 0b2c EE81      		ldd r30,Y+6
 4857 0b2e FF81      		ldd r31,Y+7
 4858 0b30 3296      		adiw r30,2
 4859 0b32 FF83      		std Y+7,r31
 4860 0b34 EE83      		std Y+6,r30
 4861               	.LVL513:
 4862 0b36 0E5F      		subi r16,-2
 4863 0b38 1F4F      		sbci r17,-1
 4864 0b3a E034      		cpi r30,64
 4865 0b3c F105      		cpc r31,__zero_reg__
 4866 0b3e 01F4      		brne .L190
 4867 0b40 2401      		movw r4,r8
 4868 0b42 3501      		movw r6,r10
 4869               	.LVL514:
 4870 0b44 F0E2      		ldi r31,32
 4871 0b46 4F0E      		add r4,r31
 4872 0b48 511C      		adc r5,__zero_reg__
 4873 0b4a 611C      		adc r6,__zero_reg__
 4874 0b4c 711C      		adc r7,__zero_reg__
 4875               	.LBE286:
 831:main.c        **** 				}
 832:main.c        **** 				
 833:main.c        **** 				// Write buffer to flash
 834:main.c        **** 				gba_flash_write_bus_cycle(address-32, 0xD0);
 4876               		.loc 3 834 0
 4877 0b4e 40ED      		ldi r20,lo8(-48)
 4878 0b50 50E0      		ldi r21,0
 4879 0b52 C501      		movw r24,r10
 4880 0b54 B401      		movw r22,r8
 4881 0b56 00D0      		rcall gba_flash_write_bus_cycle
 4882               	.LVL515:
 835:main.c        **** 				gba_flash_write_bus_cycle(address-32+1, 0xD0);
 4883               		.loc 3 835 0
 4884 0b58 40ED      		ldi r20,lo8(-48)
 4885 0b5a 50E0      		ldi r21,0
 4886 0b5c 6981      		ldd r22,Y+1
 4887 0b5e 7A81      		ldd r23,Y+2
 4888 0b60 8B81      		ldd r24,Y+3
 4889 0b62 9C81      		ldd r25,Y+4
 4890 0b64 00D0      		rcall gba_flash_write_bus_cycle
 4891               	.LVL516:
 4892               	.L191:
 836:main.c        **** 				
 837:main.c        **** 				// Wait until ready
 838:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4893               		.loc 3 838 0 discriminator 1
 4894 0b66 C301      		movw r24,r6
 4895 0b68 B201      		movw r22,r4
 4896 0b6a 00D0      		rcall gba_read_16bit_data
 4897               	.LVL517:
 4898 0b6c 8038      		cpi r24,-128
 4899 0b6e 9105      		cpc r25,__zero_reg__
 4900 0b70 01F4      		brne .L191
 839:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4901               		.loc 3 839 0
 4902 0b72 21E2      		ldi r18,33
 4903 0b74 820E      		add r8,r18
 4904 0b76 911C      		adc r9,__zero_reg__
 4905 0b78 A11C      		adc r10,__zero_reg__
 4906 0b7a B11C      		adc r11,__zero_reg__
 4907               	.L192:
 4908               		.loc 3 839 0 is_stmt 0 discriminator 1
 4909 0b7c C501      		movw r24,r10
 4910 0b7e B401      		movw r22,r8
 4911 0b80 00D0      		rcall gba_read_16bit_data
 4912               	.LVL518:
 4913 0b82 8038      		cpi r24,-128
 4914 0b84 9105      		cpc r25,__zero_reg__
 4915 0b86 01F4      		brne .L192
 4916               	.LVL519:
 4917 0b88 80E4      		ldi r24,64
 4918 0b8a 280E      		add r2,r24
 4919 0b8c 311C      		adc r3,__zero_reg__
 4920               	.LBE285:
 799:main.c        **** 				// Set address lines as outputs
 4921               		.loc 3 799 0 is_stmt 1 discriminator 2
 4922 0b8e 90E0      		ldi r25,lo8(receivedBuffer+256)
 4923 0b90 2916      		cp r2,r25
 4924 0b92 90E0      		ldi r25,hi8(receivedBuffer+256)
 4925 0b94 3906      		cpc r3,r25
 4926 0b96 01F0      		breq .L315
 4927               	.LBB288:
 4928               	.LBB287:
 830:main.c        **** 				}
 4929               		.loc 3 830 0
 4930 0b98 5301      		movw r10,r6
 4931 0b9a 4201      		movw r8,r4
 4932 0b9c 00C0      		rjmp .L193
 4933               	.L315:
 4934 0b9e A0E8      		ldi r26,-128
 4935 0ba0 CA0E      		add r12,r26
 4936 0ba2 D11C      		adc r13,__zero_reg__
 4937 0ba4 E11C      		adc r14,__zero_reg__
 4938 0ba6 F11C      		adc r15,__zero_reg__
 4939 0ba8 00C0      		rjmp .L297
 4940               	.LVL520:
 4941               	.L187:
 4942               	.LBE287:
 4943               	.LBE288:
 4944               	.LBE284:
 840:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 841:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 842:main.c        **** 			}
 843:main.c        **** 			
 844:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 845:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 846:main.c        **** 		}
 847:main.c        **** 
 848:main.c        **** 		// Sharp LH28F320BJE programming (Thanks to lesserkuma for adding support)
 849:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_SHARP_64BYTE) {
 4945               		.loc 3 849 0
 4946 0baa 9837      		cpi r25,lo8(120)
 4947 0bac 01F0      		breq .+2
 4948 0bae 00C0      		rjmp .L194
 4949               	.LVL521:
 4950               	.LBB289:
 850:main.c        **** 			uint16_t status = 0;
 851:main.c        **** 			
 852:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4951               		.loc 3 852 0
 4952 0bb0 939A      		sbi 0x12,3
 853:main.c        **** 			usart_read_bytes(64);
 4953               		.loc 3 853 0
 4954 0bb2 80E4      		ldi r24,lo8(64)
 4955 0bb4 90E0      		ldi r25,0
 4956               	.LVL522:
 4957 0bb6 00D0      		rcall usart_read_bytes
 4958               	.LVL523:
 4959 0bb8 90E0      		ldi r25,lo8(receivedBuffer)
 4960 0bba A92E      		mov r10,r25
 4961 0bbc 90E0      		ldi r25,hi8(receivedBuffer)
 4962 0bbe B92E      		mov r11,r25
 4963 0bc0 2601      		movw r4,r12
 4964 0bc2 3701      		movw r6,r14
 850:main.c        **** 			uint16_t status = 0;
 4965               		.loc 3 850 0
 4966 0bc4 912C      		mov r9,__zero_reg__
 4967               	.LVL524:
 4968               	.L198:
 4969               	.LBB290:
 4970               	.LBB291:
 854:main.c        **** 			
 855:main.c        **** 			// Write data
 856:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 857:main.c        **** 				// Wait until ready
 858:main.c        **** 				while ((status & 0x80) != 0x80) {
 4971               		.loc 3 858 0
 4972 0bc6 97FC      		sbrc r9,7
 4973 0bc8 00C0      		rjmp .L316
 859:main.c        **** 					// Set address lines as outputs
 860:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4974               		.loc 3 860 0
 4975 0bca BFEF      		ldi r27,lo8(-1)
 4976 0bcc B4BB      		out 0x14,r27
 861:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4977               		.loc 3 861 0
 4978 0bce BABB      		out 0x1a,r27
 862:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4979               		.loc 3 862 0
 4980 0bd0 B7BB      		out 0x17,r27
 863:main.c        **** 					
 864:main.c        **** 					gba_flash_write_bus_cycle(address, 0x70); // Query status register
 4981               		.loc 3 864 0
 4982 0bd2 40E7      		ldi r20,lo8(112)
 4983 0bd4 50E0      		ldi r21,0
 4984 0bd6 C301      		movw r24,r6
 4985 0bd8 B201      		movw r22,r4
 4986 0bda 00D0      		rcall gba_flash_write_bus_cycle
 4987               	.LVL525:
 865:main.c        **** 					status = gba_read_16bit_data(address);
 4988               		.loc 3 865 0
 4989 0bdc C301      		movw r24,r6
 4990 0bde B201      		movw r22,r4
 4991 0be0 00D0      		rcall gba_read_16bit_data
 4992               	.LVL526:
 4993 0be2 982E      		mov r9,r24
 4994 0be4 00C0      		rjmp .L198
 4995               	.L316:
 866:main.c        **** 				}
 867:main.c        **** 				
 868:main.c        **** 				// Set address lines as outputs
 869:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4996               		.loc 3 869 0 discriminator 2
 4997 0be6 EFEF      		ldi r30,lo8(-1)
 4998 0be8 E4BB      		out 0x14,r30
 870:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4999               		.loc 3 870 0 discriminator 2
 5000 0bea EABB      		out 0x1a,r30
 871:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5001               		.loc 3 871 0 discriminator 2
 5002 0bec E7BB      		out 0x17,r30
 872:main.c        **** 				
 873:main.c        **** 				// Write one word to flash
 874:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5003               		.loc 3 874 0 discriminator 2
 5004 0bee D501      		movw r26,r10
 5005 0bf0 1196      		adiw r26,1
 5006 0bf2 0C91      		ld r16,X
 5007 0bf4 1197      		sbiw r26,1
 5008 0bf6 10E0      		ldi r17,0
 5009 0bf8 102F      		mov r17,r16
 5010 0bfa 0027      		clr r16
 5011 0bfc 8C91      		ld r24,X
 5012 0bfe 082B      		or r16,r24
 5013               	.LVL527:
 875:main.c        **** 				gba_flash_write_bus_cycle(address, 0x10);
 5014               		.loc 3 875 0 discriminator 2
 5015 0c00 40E1      		ldi r20,lo8(16)
 5016 0c02 50E0      		ldi r21,0
 5017 0c04 C301      		movw r24,r6
 5018 0c06 B201      		movw r22,r4
 5019 0c08 00D0      		rcall gba_flash_write_bus_cycle
 5020               	.LVL528:
 876:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5021               		.loc 3 876 0 discriminator 2
 5022 0c0a A801      		movw r20,r16
 5023 0c0c C301      		movw r24,r6
 5024 0c0e B201      		movw r22,r4
 5025 0c10 00D0      		rcall gba_flash_write_bus_cycle
 5026               	.LVL529:
 5027               	.LBB292:
 5028               	.LBB293:
 5029               		.loc 2 276 0 discriminator 2
 5030 0c12 BAE6      		ldi r27,lo8(106)
 5031 0c14 BA95      	1:	dec r27
 5032 0c16 01F4      		brne 1b
 5033 0c18 00C0      		rjmp .
 5034               	.LVL530:
 5035               	.LBE293:
 5036               	.LBE292:
 877:main.c        **** 				_delay_us(40);
 878:main.c        **** 				
 879:main.c        **** 				address++;
 5037               		.loc 3 879 0 discriminator 2
 5038 0c1a EFEF      		ldi r30,-1
 5039 0c1c 4E1A      		sub r4,r30
 5040 0c1e 5E0A      		sbc r5,r30
 5041 0c20 6E0A      		sbc r6,r30
 5042 0c22 7E0A      		sbc r7,r30
 5043               	.LVL531:
 5044 0c24 F2E0      		ldi r31,2
 5045 0c26 AF0E      		add r10,r31
 5046 0c28 B11C      		adc r11,__zero_reg__
 5047               	.LVL532:
 5048               	.LBE291:
 856:main.c        **** 				// Wait until ready
 5049               		.loc 3 856 0 discriminator 2
 5050 0c2a 80E0      		ldi r24,lo8(receivedBuffer+64)
 5051 0c2c 90E0      		ldi r25,hi8(receivedBuffer+64)
 5052 0c2e 8A15      		cp r24,r10
 5053 0c30 9B05      		cpc r25,r11
 5054 0c32 01F4      		brne .L198
 5055 0c34 90E2      		ldi r25,32
 5056 0c36 C90E      		add r12,r25
 5057 0c38 D11C      		adc r13,__zero_reg__
 5058 0c3a E11C      		adc r14,__zero_reg__
 5059 0c3c F11C      		adc r15,__zero_reg__
 5060               	.LVL533:
 5061               	.L297:
 5062               	.LBE290:
 880:main.c        **** 			}
 881:main.c        **** 			
 882:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 5063               		.loc 3 882 0
 5064 0c3e 81E3      		ldi r24,lo8(49)
 5065 0c40 00C0      		rjmp .L291
 5066               	.LVL534:
 5067               	.L194:
 5068               	.LBE289:
 883:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 884:main.c        **** 		}
 885:main.c        **** 		
 886:main.c        **** 		
 887:main.c        **** 		// ---------- General commands ----------
 888:main.c        **** 		// Set any pin as input/output
 889:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 890:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 5069               		.loc 3 890 0
 5070 0c42 9934      		cpi r25,lo8(73)
 5071 0c44 01F0      		breq .L199
 5072               		.loc 3 890 0 is_stmt 0 discriminator 1
 5073 0c46 9F34      		cpi r25,lo8(79)
 5074 0c48 01F0      		breq .+2
 5075 0c4a 00C0      		rjmp .L200
 5076               	.L199:
 5077               	.LBB294:
 891:main.c        **** 			char portChar = USART_Receive();
 5078               		.loc 3 891 0 is_stmt 1
 5079 0c4c 00D0      		rcall USART_Receive
 5080               	.LVL535:
 5081 0c4e 182F      		mov r17,r24
 5082               	.LVL536:
 892:main.c        **** 			usart_read_chars();
 5083               		.loc 3 892 0
 5084 0c50 00D0      		rcall usart_read_chars
 5085               	.LVL537:
 893:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5086               		.loc 3 893 0
 5087 0c52 40E1      		ldi r20,lo8(16)
 5088 0c54 50E0      		ldi r21,0
 5089 0c56 60E0      		ldi r22,0
 5090 0c58 70E0      		ldi r23,0
 5091 0c5a 80E0      		ldi r24,lo8(receivedBuffer)
 5092 0c5c 90E0      		ldi r25,hi8(receivedBuffer)
 5093 0c5e 00D0      		rcall strtol
 5094               	.LVL538:
 894:main.c        **** 			
 895:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5095               		.loc 3 895 0
 5096 0c60 939A      		sbi 0x12,3
 896:main.c        **** 			if (receivedChar == SET_INPUT) {
 5097               		.loc 3 896 0
 5098 0c62 8091 0000 		lds r24,receivedChar
 5099 0c66 8934      		cpi r24,lo8(73)
 5100 0c68 01F4      		brne .L201
 897:main.c        **** 				if (portChar == 'A') {
 5101               		.loc 3 897 0
 5102 0c6a 1134      		cpi r17,lo8(65)
 5103 0c6c 01F4      		brne .L202
 898:main.c        **** 					DDRA &= ~(setValue);
 5104               		.loc 3 898 0
 5105 0c6e 8AB3      		in r24,0x1a
 5106 0c70 6095      		com r22
 5107               	.LVL539:
 5108 0c72 6823      		and r22,r24
 5109               	.LVL540:
 5110 0c74 00C0      		rjmp .L299
 5111               	.LVL541:
 5112               	.L202:
 899:main.c        **** 				}
 900:main.c        **** 				else if (portChar == 'B') {
 5113               		.loc 3 900 0
 5114 0c76 1234      		cpi r17,lo8(66)
 5115 0c78 01F4      		brne .L204
 901:main.c        **** 					DDRB &= ~(setValue);
 5116               		.loc 3 901 0
 5117 0c7a 87B3      		in r24,0x17
 5118 0c7c 6095      		com r22
 5119               	.LVL542:
 5120 0c7e 6823      		and r22,r24
 5121               	.LVL543:
 5122 0c80 00C0      		rjmp .L300
 5123               	.LVL544:
 5124               	.L204:
 902:main.c        **** 				}
 903:main.c        **** 				else if (portChar == 'C') {
 5125               		.loc 3 903 0
 5126 0c82 1334      		cpi r17,lo8(67)
 5127 0c84 01F4      		brne .L205
 904:main.c        **** 					DDRC &= ~(setValue);
 5128               		.loc 3 904 0
 5129 0c86 84B3      		in r24,0x14
 5130 0c88 6095      		com r22
 5131               	.LVL545:
 5132 0c8a 6823      		and r22,r24
 5133               	.LVL546:
 5134 0c8c 00C0      		rjmp .L305
 5135               	.LVL547:
 5136               	.L205:
 905:main.c        **** 				}
 906:main.c        **** 				else if (portChar == 'D') {
 5137               		.loc 3 906 0
 5138 0c8e 1434      		cpi r17,lo8(68)
 5139 0c90 01F4      		brne .L206
 907:main.c        **** 					DDRD &= ~(setValue);
 5140               		.loc 3 907 0
 5141 0c92 81B3      		in r24,0x11
 5142 0c94 6095      		com r22
 5143               	.LVL548:
 5144 0c96 6823      		and r22,r24
 5145               	.LVL549:
 5146 0c98 00C0      		rjmp .L306
 5147               	.LVL550:
 5148               	.L206:
 908:main.c        **** 				}
 909:main.c        **** 				else if (portChar == 'E') {
 5149               		.loc 3 909 0
 5150 0c9a 1534      		cpi r17,lo8(69)
 5151 0c9c 01F0      		breq .+2
 5152 0c9e 00C0      		rjmp .L225
 910:main.c        **** 					DDRE &= ~(setValue);
 5153               		.loc 3 910 0
 5154 0ca0 86B1      		in r24,0x6
 5155 0ca2 6095      		com r22
 5156               	.LVL551:
 5157 0ca4 6823      		and r22,r24
 5158               	.LVL552:
 5159 0ca6 00C0      		rjmp .L307
 5160               	.LVL553:
 5161               	.L201:
 911:main.c        **** 				}
 912:main.c        **** 			}
 913:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 5162               		.loc 3 913 0
 5163 0ca8 8F34      		cpi r24,lo8(79)
 5164 0caa 01F0      		breq .+2
 5165 0cac 00C0      		rjmp .L225
 914:main.c        **** 				if (portChar == 'A') {
 5166               		.loc 3 914 0
 5167 0cae 1134      		cpi r17,lo8(65)
 5168 0cb0 01F4      		brne .L207
 915:main.c        **** 					DDRA |= (setValue);
 5169               		.loc 3 915 0
 5170 0cb2 8AB3      		in r24,0x1a
 5171 0cb4 682B      		or r22,r24
 5172               	.LVL554:
 5173               	.L299:
 5174 0cb6 6ABB      		out 0x1a,r22
 5175 0cb8 00C0      		rjmp .L225
 5176               	.LVL555:
 5177               	.L207:
 916:main.c        **** 				}
 917:main.c        **** 				else if (portChar == 'B') {
 5178               		.loc 3 917 0
 5179 0cba 1234      		cpi r17,lo8(66)
 5180 0cbc 01F4      		brne .L208
 918:main.c        **** 					DDRB |= (setValue);
 5181               		.loc 3 918 0
 5182 0cbe 87B3      		in r24,0x17
 5183 0cc0 682B      		or r22,r24
 5184               	.LVL556:
 5185               	.L300:
 5186 0cc2 67BB      		out 0x17,r22
 5187 0cc4 00C0      		rjmp .L225
 5188               	.LVL557:
 5189               	.L208:
 919:main.c        **** 				}
 920:main.c        **** 				else if (portChar == 'C') {
 5190               		.loc 3 920 0
 5191 0cc6 1334      		cpi r17,lo8(67)
 5192 0cc8 01F4      		brne .L209
 921:main.c        **** 					DDRC |= (setValue);
 5193               		.loc 3 921 0
 5194 0cca 84B3      		in r24,0x14
 5195 0ccc 682B      		or r22,r24
 5196               	.LVL558:
 5197               	.L305:
 5198 0cce 64BB      		out 0x14,r22
 5199 0cd0 00C0      		rjmp .L225
 5200               	.LVL559:
 5201               	.L209:
 922:main.c        **** 				}
 923:main.c        **** 				else if (portChar == 'D') {
 5202               		.loc 3 923 0
 5203 0cd2 1434      		cpi r17,lo8(68)
 5204 0cd4 01F4      		brne .L210
 924:main.c        **** 					DDRD |= (setValue);
 5205               		.loc 3 924 0
 5206 0cd6 81B3      		in r24,0x11
 5207 0cd8 682B      		or r22,r24
 5208               	.LVL560:
 5209               	.L306:
 5210 0cda 61BB      		out 0x11,r22
 5211 0cdc 00C0      		rjmp .L225
 5212               	.LVL561:
 5213               	.L210:
 925:main.c        **** 				}
 926:main.c        **** 				else if (portChar == 'E') {
 5214               		.loc 3 926 0
 5215 0cde 1534      		cpi r17,lo8(69)
 5216 0ce0 01F0      		breq .+2
 5217 0ce2 00C0      		rjmp .L225
 927:main.c        **** 					DDRE |= (setValue);
 5218               		.loc 3 927 0
 5219 0ce4 86B1      		in r24,0x6
 5220 0ce6 682B      		or r22,r24
 5221               	.LVL562:
 5222               	.L307:
 5223 0ce8 66B9      		out 0x6,r22
 5224 0cea 00C0      		rjmp .L225
 5225               	.LVL563:
 5226               	.L200:
 5227               	.LBE294:
 928:main.c        **** 				}
 929:main.c        **** 			}
 930:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 931:main.c        **** 		}
 932:main.c        **** 		
 933:main.c        **** 		// Set pin output as low
 934:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 5228               		.loc 3 934 0
 5229 0cec 9C34      		cpi r25,lo8(76)
 5230 0cee 01F4      		brne .L211
 5231               	.LBB295:
 935:main.c        **** 			char portChar = USART_Receive();			
 5232               		.loc 3 935 0
 5233 0cf0 00D0      		rcall USART_Receive
 5234               	.LVL564:
 5235 0cf2 182F      		mov r17,r24
 5236               	.LVL565:
 936:main.c        **** 			usart_read_chars();
 5237               		.loc 3 936 0
 5238 0cf4 00D0      		rcall usart_read_chars
 5239               	.LVL566:
 937:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5240               		.loc 3 937 0
 5241 0cf6 40E1      		ldi r20,lo8(16)
 5242 0cf8 50E0      		ldi r21,0
 5243 0cfa 60E0      		ldi r22,0
 5244 0cfc 70E0      		ldi r23,0
 5245 0cfe 80E0      		ldi r24,lo8(receivedBuffer)
 5246 0d00 90E0      		ldi r25,hi8(receivedBuffer)
 5247 0d02 00D0      		rcall strtol
 5248               	.LVL567:
 938:main.c        **** 			
 939:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5249               		.loc 3 939 0
 5250 0d04 939A      		sbi 0x12,3
 940:main.c        **** 			if (portChar == 'A') {
 5251               		.loc 3 940 0
 5252 0d06 1134      		cpi r17,lo8(65)
 5253 0d08 01F4      		brne .L212
 941:main.c        **** 				PORTA &= ~(setValue);
 5254               		.loc 3 941 0
 5255 0d0a 8BB3      		in r24,0x1b
 5256 0d0c 6095      		com r22
 5257               	.LVL568:
 5258 0d0e 6823      		and r22,r24
 5259               	.LVL569:
 5260 0d10 00C0      		rjmp .L304
 5261               	.LVL570:
 5262               	.L212:
 942:main.c        **** 			}
 943:main.c        **** 			else if (portChar == 'B') {
 5263               		.loc 3 943 0
 5264 0d12 1234      		cpi r17,lo8(66)
 5265 0d14 01F4      		brne .L214
 944:main.c        **** 				PORTB &= ~(setValue);
 5266               		.loc 3 944 0
 5267 0d16 88B3      		in r24,0x18
 5268 0d18 6095      		com r22
 5269               	.LVL571:
 5270 0d1a 6823      		and r22,r24
 5271               	.LVL572:
 5272 0d1c 00C0      		rjmp .L303
 5273               	.LVL573:
 5274               	.L214:
 945:main.c        **** 			}
 946:main.c        **** 			else if (portChar == 'C') {
 5275               		.loc 3 946 0
 5276 0d1e 1334      		cpi r17,lo8(67)
 5277 0d20 01F4      		brne .L215
 947:main.c        **** 				PORTC &= ~(setValue);
 5278               		.loc 3 947 0
 5279 0d22 85B3      		in r24,0x15
 5280 0d24 6095      		com r22
 5281               	.LVL574:
 5282 0d26 6823      		and r22,r24
 5283               	.LVL575:
 5284 0d28 00C0      		rjmp .L302
 5285               	.LVL576:
 5286               	.L215:
 948:main.c        **** 			}
 949:main.c        **** 			else if (portChar == 'D') {
 5287               		.loc 3 949 0
 5288 0d2a 1434      		cpi r17,lo8(68)
 5289 0d2c 01F4      		brne .L216
 950:main.c        **** 				PORTD &= ~(setValue);
 5290               		.loc 3 950 0
 5291 0d2e 82B3      		in r24,0x12
 5292 0d30 6095      		com r22
 5293               	.LVL577:
 5294 0d32 6823      		and r22,r24
 5295               	.LVL578:
 5296 0d34 00C0      		rjmp .L301
 5297               	.LVL579:
 5298               	.L216:
 951:main.c        **** 			}
 952:main.c        **** 			else if (portChar == 'E') {
 5299               		.loc 3 952 0
 5300 0d36 1534      		cpi r17,lo8(69)
 5301 0d38 01F0      		breq .+2
 5302 0d3a 00C0      		rjmp .L225
 953:main.c        **** 				PORTE &= ~(setValue);
 5303               		.loc 3 953 0
 5304 0d3c 87B1      		in r24,0x7
 5305 0d3e 6095      		com r22
 5306               	.LVL580:
 5307 0d40 6823      		and r22,r24
 5308               	.LVL581:
 5309 0d42 00C0      		rjmp .L298
 5310               	.LVL582:
 5311               	.L211:
 5312               	.LBE295:
 954:main.c        **** 			}
 955:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 956:main.c        **** 		}
 957:main.c        **** 		
 958:main.c        **** 		// Set pin output as high
 959:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 5313               		.loc 3 959 0
 5314 0d44 9834      		cpi r25,lo8(72)
 5315 0d46 01F4      		brne .L217
 5316               	.LBB296:
 960:main.c        **** 			char portChar = USART_Receive();			
 5317               		.loc 3 960 0
 5318 0d48 00D0      		rcall USART_Receive
 5319               	.LVL583:
 5320 0d4a 182F      		mov r17,r24
 5321               	.LVL584:
 961:main.c        **** 			usart_read_chars();
 5322               		.loc 3 961 0
 5323 0d4c 00D0      		rcall usart_read_chars
 5324               	.LVL585:
 962:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5325               		.loc 3 962 0
 5326 0d4e 40E1      		ldi r20,lo8(16)
 5327 0d50 50E0      		ldi r21,0
 5328 0d52 60E0      		ldi r22,0
 5329 0d54 70E0      		ldi r23,0
 5330 0d56 80E0      		ldi r24,lo8(receivedBuffer)
 5331 0d58 90E0      		ldi r25,hi8(receivedBuffer)
 5332 0d5a 00D0      		rcall strtol
 5333               	.LVL586:
 963:main.c        **** 			
 964:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5334               		.loc 3 964 0
 5335 0d5c 939A      		sbi 0x12,3
 965:main.c        **** 			if (portChar == 'A') {
 5336               		.loc 3 965 0
 5337 0d5e 1134      		cpi r17,lo8(65)
 5338 0d60 01F4      		brne .L218
 966:main.c        **** 				PORTA |= (setValue);
 5339               		.loc 3 966 0
 5340 0d62 8BB3      		in r24,0x1b
 5341 0d64 682B      		or r22,r24
 5342               	.LVL587:
 5343               	.L304:
 5344 0d66 6BBB      		out 0x1b,r22
 5345 0d68 00C0      		rjmp .L225
 5346               	.LVL588:
 5347               	.L218:
 967:main.c        **** 			}
 968:main.c        **** 			else if (portChar == 'B') {
 5348               		.loc 3 968 0
 5349 0d6a 1234      		cpi r17,lo8(66)
 5350 0d6c 01F4      		brne .L220
 969:main.c        **** 				PORTB |= (setValue);
 5351               		.loc 3 969 0
 5352 0d6e 88B3      		in r24,0x18
 5353 0d70 682B      		or r22,r24
 5354               	.LVL589:
 5355               	.L303:
 5356 0d72 68BB      		out 0x18,r22
 5357 0d74 00C0      		rjmp .L225
 5358               	.LVL590:
 5359               	.L220:
 970:main.c        **** 			}
 971:main.c        **** 			else if (portChar == 'C') {
 5360               		.loc 3 971 0
 5361 0d76 1334      		cpi r17,lo8(67)
 5362 0d78 01F4      		brne .L221
 972:main.c        **** 				PORTC |= (setValue);
 5363               		.loc 3 972 0
 5364 0d7a 85B3      		in r24,0x15
 5365 0d7c 682B      		or r22,r24
 5366               	.LVL591:
 5367               	.L302:
 5368 0d7e 65BB      		out 0x15,r22
 5369 0d80 00C0      		rjmp .L225
 5370               	.LVL592:
 5371               	.L221:
 973:main.c        **** 			}
 974:main.c        **** 			else if (portChar == 'D') {
 5372               		.loc 3 974 0
 5373 0d82 1434      		cpi r17,lo8(68)
 5374 0d84 01F4      		brne .L222
 975:main.c        **** 				PORTD |= (setValue);
 5375               		.loc 3 975 0
 5376 0d86 82B3      		in r24,0x12
 5377 0d88 682B      		or r22,r24
 5378               	.LVL593:
 5379               	.L301:
 5380 0d8a 62BB      		out 0x12,r22
 5381 0d8c 00C0      		rjmp .L225
 5382               	.LVL594:
 5383               	.L222:
 976:main.c        **** 			}
 977:main.c        **** 			else if (portChar == 'E') {
 5384               		.loc 3 977 0
 5385 0d8e 1534      		cpi r17,lo8(69)
 5386 0d90 01F4      		brne .L225
 978:main.c        **** 				PORTE |= (setValue);
 5387               		.loc 3 978 0
 5388 0d92 87B1      		in r24,0x7
 5389 0d94 682B      		or r22,r24
 5390               	.LVL595:
 5391               	.L298:
 5392 0d96 67B9      		out 0x7,r22
 5393 0d98 00C0      		rjmp .L225
 5394               	.LVL596:
 5395               	.L217:
 5396               	.LBE296:
 979:main.c        **** 			}
 980:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 981:main.c        **** 		}
 982:main.c        **** 		
 983:main.c        **** 		// Read all pins of a PORT and return the value
 984:main.c        **** 		else if (receivedChar == READ_INPUT) {
 5397               		.loc 3 984 0
 5398 0d9a 9434      		cpi r25,lo8(68)
 5399 0d9c 01F4      		brne .L223
 5400               	.LBB297:
 985:main.c        **** 			char portChar = USART_Receive();			
 5401               		.loc 3 985 0
 5402 0d9e 00D0      		rcall USART_Receive
 5403               	.LVL597:
 986:main.c        **** 			
 987:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5404               		.loc 3 987 0
 5405 0da0 939A      		sbi 0x12,3
 988:main.c        **** 			if (portChar == 'A') {
 5406               		.loc 3 988 0
 5407 0da2 8134      		cpi r24,lo8(65)
 5408 0da4 01F4      		brne .L224
 989:main.c        **** 				USART_Transmit(PINA);
 5409               		.loc 3 989 0
 5410 0da6 89B3      		in r24,0x19
 5411               	.LVL598:
 5412 0da8 00C0      		rjmp .L291
 5413               	.LVL599:
 5414               	.L224:
 990:main.c        **** 			}
 991:main.c        **** 			else if (portChar == 'B') {
 5415               		.loc 3 991 0
 5416 0daa 8234      		cpi r24,lo8(66)
 5417 0dac 01F4      		brne .L226
 992:main.c        **** 				USART_Transmit(PINB);
 5418               		.loc 3 992 0
 5419 0dae 86B3      		in r24,0x16
 5420               	.LVL600:
 5421 0db0 00C0      		rjmp .L291
 5422               	.LVL601:
 5423               	.L226:
 993:main.c        **** 			}
 994:main.c        **** 			else if (portChar == 'C') {
 5424               		.loc 3 994 0
 5425 0db2 8334      		cpi r24,lo8(67)
 5426 0db4 01F4      		brne .L227
 995:main.c        **** 				USART_Transmit(PINC);
 5427               		.loc 3 995 0
 5428 0db6 83B3      		in r24,0x13
 5429               	.LVL602:
 5430 0db8 00C0      		rjmp .L291
 5431               	.LVL603:
 5432               	.L227:
 996:main.c        **** 			}
 997:main.c        **** 			else if (portChar == 'D') {
 5433               		.loc 3 997 0
 5434 0dba 8434      		cpi r24,lo8(68)
 5435 0dbc 01F4      		brne .L228
 998:main.c        **** 				USART_Transmit(PIND);
 5436               		.loc 3 998 0
 5437 0dbe 80B3      		in r24,0x10
 5438               	.LVL604:
 5439 0dc0 00C0      		rjmp .L291
 5440               	.LVL605:
 5441               	.L228:
 999:main.c        **** 			}
1000:main.c        **** 			else if (portChar == 'E') {
 5442               		.loc 3 1000 0
 5443 0dc2 8534      		cpi r24,lo8(69)
 5444 0dc4 01F4      		brne .L225
1001:main.c        **** 				USART_Transmit(PINE);
 5445               		.loc 3 1001 0
 5446 0dc6 85B1      		in r24,0x5
 5447               	.LVL606:
 5448               	.L291:
 5449 0dc8 00D0      		rcall USART_Transmit
 5450               	.LVL607:
 5451               	.L225:
1002:main.c        **** 			}
1003:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 5452               		.loc 3 1003 0
 5453 0dca 9398      		cbi 0x12,3
 5454               	.LBE297:
 5455 0dcc 00C0      		rjmp .L95
 5456               	.LVL608:
 5457               	.L223:
1004:main.c        **** 		}
1005:main.c        **** 		
1006:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
1007:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5458               		.loc 3 1007 0
 5459 0dce 9D34      		cpi r25,lo8(77)
 5460 0dd0 01F4      		brne .L229
 5461               	.LBB298:
1008:main.c        **** 			char commonChar = USART_Receive();
 5462               		.loc 3 1008 0
 5463 0dd2 00D0      		rcall USART_Receive
 5464               	.LVL609:
1009:main.c        **** 			if (commonChar == '1') {
 5465               		.loc 3 1009 0
 5466 0dd4 8133      		cpi r24,lo8(49)
 5467 0dd6 01F4      		brne .L317
1010:main.c        **** 				resetCommonLines = 1;
 5468               		.loc 3 1010 0
 5469 0dd8 91E0      		ldi r25,lo8(1)
 5470 0dda 9D83      		std Y+5,r25
 5471 0ddc 00C0      		rjmp .L287
 5472               	.L317:
1011:main.c        **** 			}
1012:main.c        **** 			else if (commonChar == '0') {
 5473               		.loc 3 1012 0
 5474 0dde 8033      		cpi r24,lo8(48)
 5475 0de0 01F0      		breq .+2
 5476 0de2 00C0      		rjmp .L95
1013:main.c        **** 				resetCommonLines = 0;
 5477               		.loc 3 1013 0
 5478 0de4 1D82      		std Y+5,__zero_reg__
 5479 0de6 00C0      		rjmp .L96
 5480               	.LVL610:
 5481               	.L229:
 5482               	.LBE298:
1014:main.c        **** 			}
1015:main.c        **** 		}
1016:main.c        **** 		
1017:main.c        **** 		// Send back the PCB version number
1018:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5483               		.loc 3 1018 0
 5484 0de8 9836      		cpi r25,lo8(104)
 5485 0dea 01F4      		brne .L230
1019:main.c        **** 			USART_Transmit(PCB_VERSION);
 5486               		.loc 3 1019 0
 5487 0dec 82E0      		ldi r24,lo8(2)
 5488               	.LVL611:
 5489 0dee 00C0      		rjmp .L288
 5490               	.LVL612:
 5491               	.L230:
1020:main.c        **** 		}
1021:main.c        **** 		
1022:main.c        **** 		// Send back the firmware version number
1023:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5492               		.loc 3 1023 0
 5493 0df0 9635      		cpi r25,lo8(86)
 5494 0df2 01F4      		brne .L231
1024:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5495               		.loc 3 1024 0
 5496 0df4 82E1      		ldi r24,lo8(18)
 5497               	.LVL613:
 5498               	.L288:
 5499 0df6 00D0      		rcall USART_Transmit
 5500               	.LVL614:
 5501 0df8 00C0      		rjmp .L95
 5502               	.LVL615:
 5503               	.L231:
1025:main.c        **** 		}
1026:main.c        **** 		
1027:main.c        **** 		// Reset the AVR if it matches the number
1028:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5504               		.loc 3 1028 0
 5505 0dfa 9A32      		cpi r25,lo8(42)
 5506 0dfc 01F0      		breq .+2
 5507 0dfe 00C0      		rjmp .L95
 5508               	.LBB299:
1029:main.c        **** 			usart_read_chars();
 5509               		.loc 3 1029 0
 5510 0e00 00D0      		rcall usart_read_chars
 5511               	.LVL616:
1030:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5512               		.loc 3 1030 0
 5513 0e02 40E1      		ldi r20,lo8(16)
 5514 0e04 50E0      		ldi r21,0
 5515 0e06 60E0      		ldi r22,0
 5516 0e08 70E0      		ldi r23,0
 5517 0e0a 80E0      		ldi r24,lo8(receivedBuffer)
 5518 0e0c 90E0      		ldi r25,hi8(receivedBuffer)
 5519 0e0e 00D0      		rcall strtol
 5520               	.LVL617:
1031:main.c        **** 			if (resetValue == RESET_VALUE) {
 5521               		.loc 3 1031 0
 5522 0e10 613E      		cpi r22,-31
 5523 0e12 754E      		sbci r23,-27
 5524 0e14 8740      		sbci r24,7
 5525 0e16 9105      		cpc r25,__zero_reg__
 5526 0e18 01F0      		breq .+2
 5527 0e1a 00C0      		rjmp .L95
1032:main.c        **** 				// Clear watchdog flag
1033:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5528               		.loc 3 1033 0
 5529 0e1c 84B7      		in r24,0x34
 5530 0e1e 877F      		andi r24,lo8(-9)
 5531 0e20 84BF      		out 0x34,r24
1034:main.c        **** 				
1035:main.c        **** 				// Start timed sequence
1036:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5532               		.loc 3 1036 0
 5533 0e22 B8E1      		ldi r27,lo8(24)
 5534 0e24 B1BD      		out 0x21,r27
1037:main.c        **** 				
1038:main.c        **** 				// Reset in 250 ms
1039:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5535               		.loc 3 1039 0
 5536 0e26 8CE0      		ldi r24,lo8(12)
 5537 0e28 81BD      		out 0x21,r24
 5538               	.LVL618:
 5539               	.LBB300:
 5540               	.LBB301:
 5541               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5542               		.loc 4 105 0
 5543 0e2a 8FEF      		ldi r24,lo8(-1)
 5544 0e2c 9FEF      		ldi r25,lo8(-1)
 5545               	/* #APP */
 5546               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5547 0e2e 0197      		1: sbiw r24,1
 5548 0e30 01F4      		brne 1b
 5549               	 ;  0 "" 2
 5550               	.LVL619:
 5551               	/* #NOAPP */
 5552 0e32 00C0      		rjmp .L95
 5553               	.LBE301:
 5554               	.LBE300:
 5555               	.LBE299:
 5556               		.cfi_endproc
 5557               	.LFE46:
 5559               	.global	lastBankAccessed
 5560               		.section .bss
 5563               	lastBankAccessed:
 5564 0000 00        		.zero	1
 5565               	.global	flashBank1CommandWrites
 5568               	flashBank1CommandWrites:
 5569 0001 00        		.zero	1
 5570               		.comm	flashWriteCycle,12,1
 5571               		.comm	flashWriteWePin,1,1
 5572               		.comm	flashChipIdBuffer,2,1
 5573               		.comm	eepromBuffer,8,1
 5574               		.comm	receivedChar,1,1
 5575               		.comm	receivedBuffer,256,1
 5576               		.text
 5577               	.Letext0:
 5578               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5579               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1546   .text:0000043c gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1646   .text:000004a0 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:5568   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:5563   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1771   .text:00000522 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:1934   .text:000005b6 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:2000   .text:000005e6 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:2124   .text:00000646 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:2246   .text:000006a2 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:2354   .text:000006f8 setup
C:\Users\Alex\AppData\Local\Temp\cckyaxWa.s:2469   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
