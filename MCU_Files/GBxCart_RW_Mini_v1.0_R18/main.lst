   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW Mini
   3:setup.c       ****  PCB version: 1.0
   4:setup.c       ****  Firmware version: R18
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 20/08/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define ACTIVITY_LED PD3
  28:setup.c       **** 
  29:setup.c       **** #define WR_PIN PD6
  30:setup.c       **** #define RD_PIN PD5
  31:setup.c       **** #define CS_MREQ_PIN PD4
  32:setup.c       **** #define CS2_PIN PE2
  33:setup.c       **** #define AUDIO_PIN PE1
  34:setup.c       **** 
  35:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  36:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  37:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  38:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  39:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  40:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  41:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  42:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  43:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  44:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  45:setup.c       **** 
  46:setup.c       **** #define GB_MODE 1
  47:setup.c       **** 
  48:setup.c       **** // GB/GBC
  49:setup.c       **** #define PORT_ADDR7_0 PORTB
  50:setup.c       **** #define PORT_ADDR15_8 PORTA
  51:setup.c       **** #define PORT_DATA7_0 PORTC
  52:setup.c       **** 
  53:setup.c       **** #define DDR_ADDR7_0 DDRB
  54:setup.c       **** #define DDR_ADDR15_8 DDRA
  55:setup.c       **** #define DDR_DATA7_0 DDRC
  56:setup.c       **** 
  57:setup.c       **** #define PIN_ADDR7_0 PINB
  58:setup.c       **** #define PIN_ADDR15_8 PINA
  59:setup.c       **** #define PIN_DATA7_0 PINC
  60:setup.c       **** 
  61:setup.c       **** #define BANK_WRITE 0
  62:setup.c       **** #define MEMORY_WRITE 1
  63:setup.c       **** 
  64:setup.c       **** 
  65:setup.c       **** // GB/GBC commands
  66:setup.c       **** #define SET_START_ADDRESS 'A'
  67:setup.c       **** #define READ_ROM_RAM 'R'
  68:setup.c       **** #define READ_ROM_4000H 'Q'
  69:setup.c       **** #define WRITE_RAM 'W'
  70:setup.c       **** #define SET_BANK 'B'
  71:setup.c       **** #define GB_CART_MODE 'G'
  72:setup.c       **** 
  73:setup.c       **** // Flash Cart commands
  74:setup.c       **** #define GB_FLASH_WE_PIN 'P'
  75:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
  76:setup.c       **** 	#define WE_AS_WR_PIN 'W'
  77:setup.c       **** 
  78:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
  79:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
  80:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
  81:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
  82:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
  83:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
  84:setup.c       **** 
  85:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
  86:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
  87:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
  88:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
  89:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
  90:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
  91:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
  92:setup.c       **** 
  93:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
  94:setup.c       **** 
  95:setup.c       **** #define D0D1_NOT_SWAPPED 0
  96:setup.c       **** #define D0D1_SWAPPED 1
  97:setup.c       **** 
  98:setup.c       **** // General commands
  99:setup.c       **** #define SEND_ACK '1'
 100:setup.c       **** #define CART_MODE 'C'
 101:setup.c       **** #define SET_INPUT 'I'
 102:setup.c       **** #define SET_OUTPUT 'O'
 103:setup.c       **** #define SET_OUTPUT_LOW 'L'
 104:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 105:setup.c       **** #define READ_INPUT 'D'
 106:setup.c       **** #define RESET_COMMON_LINES 'M'
 107:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 108:setup.c       **** #define READ_PCB_VERSION 'h'
 109:setup.c       **** 
 110:setup.c       **** #define RESET_AVR '*'
 111:setup.c       **** #define RESET_VALUE 0x7E5E1
 112:setup.c       **** 
 113:setup.c       **** 
 114:setup.c       **** char receivedBuffer[256];
 115:setup.c       **** char receivedChar;
 116:setup.c       **** 
 117:setup.c       **** char flashWriteWePin;
 118:setup.c       **** uint16_t flashWriteCycle[3][2];
 119:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 120:setup.c       **** uint8_t lastBankAccessed = 0;
 121:setup.c       **** volatile uint8_t writingTimedout = 0;
 122:setup.c       **** 
 123:setup.c       **** uint8_t cartMode = GB_MODE;
 124:setup.c       **** 
 125:setup.c       **** // Receive USART data
 126:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 126 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 127:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 127 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 128:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 128 0
  26 0004 8CB1      		in r24,0xc
 129:setup.c       **** }
  27               		.loc 1 129 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 130:setup.c       **** 
 131:setup.c       **** // Transmit USART data
 132:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 132 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 133:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 133 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 134:setup.c       **** 	UDR = data;
  47               		.loc 1 134 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 135:setup.c       **** }
 136:setup.c       **** 
 137:setup.c       **** // Read 1-256 bytes from the USART 
 138:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 138 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB88:
 139:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 139 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 139 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 140:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 140 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE88:
 141:setup.c       **** 	}
 142:setup.c       **** }
 106               		.loc 1 142 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 143:setup.c       **** 
 144:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 145:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 145 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 146:setup.c       **** 	int x = 0;
 147:setup.c       **** 	while (1) {
 148:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 148 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 149:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 149 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 150:setup.c       **** 			break;
 151:setup.c       **** 		}
 152:setup.c       **** 		x++;
 153:setup.c       **** 	}
 154:setup.c       **** }
 148               		.loc 1 154 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 155:setup.c       **** 
 156:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 157:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 157 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 158:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 158 0
 167 0050 3A9A      		sbi 0x7,2
 159:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 159 0
 169 0052 949A      		sbi 0x12,4
 160:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 160 0
 171 0054 959A      		sbi 0x12,5
 161:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 161 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 162:setup.c       **** }
 163:setup.c       **** 
 164:setup.c       **** 
 165:setup.c       **** 
 166:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 167:setup.c       **** 
 168:setup.c       **** // Set Gameboy mode
 169:setup.c       **** void gb_mode(void) {
 182               		.loc 1 169 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 170:setup.c       **** 	// Set inputs
 171:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 171 0
 189 005a 15BA      		out 0x15,__zero_reg__
 172:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 172 0
 191 005c 14BA      		out 0x14,__zero_reg__
 173:setup.c       **** 	
 174:setup.c       **** 	// Set outputs
 175:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 175 0
 193 005e 18BA      		out 0x18,__zero_reg__
 176:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 176 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 177:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 177 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 178:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 178 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 179:setup.c       **** }
 180:setup.c       **** 
 181:setup.c       **** // Set the 16 bit address on A15-0
 182:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 182 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 183:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 183 0
 217 006a 9BBB      		out 0x1b,r25
 184:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 184 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 185:setup.c       **** }
 186:setup.c       **** 
 187:setup.c       **** // Set the address and read a byte from the 8 bit data line
 188:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 188 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 189:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 189 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 190:setup.c       **** 	
 191:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 191 0
 239 0072 9498      		cbi 0x12,4
 192:setup.c       **** 	rdPin_low;
 240               		.loc 1 192 0
 241 0074 9598      		cbi 0x12,5
 193:setup.c       **** 	
 194:setup.c       **** 	asm volatile("nop"); // Delay a little (At 8MHz - minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 194 0
 243               	/* #APP */
 244               	 ;  194 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 195:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 195 0
 248               	 ;  195 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 196:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 196 0
 252               	 ;  196 "setup.c" 1
 253 007a 0000      		nop
 254               	 ;  0 "" 2
 197:setup.c       **** 	asm volatile("nop");
 255               		.loc 1 197 0
 256               	 ;  197 "setup.c" 1
 257 007c 0000      		nop
 258               	 ;  0 "" 2
 198:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 259               		.loc 1 198 0
 260               	/* #NOAPP */
 261 007e 83B3      		in r24,0x13
 262               	.LVL17:
 199:setup.c       **** 	
 200:setup.c       **** 	rdPin_high;
 263               		.loc 1 200 0
 264 0080 959A      		sbi 0x12,5
 201:setup.c       **** 	cs_mreqPin_high;
 265               		.loc 1 201 0
 266 0082 949A      		sbi 0x12,4
 202:setup.c       **** 	
 203:setup.c       **** 	return data;
 204:setup.c       **** }
 267               		.loc 1 204 0
 268 0084 0895      		ret
 269               		.cfi_endproc
 270               	.LFE19:
 272               	.global	write_8bit_data
 274               	write_8bit_data:
 275               	.LFB20:
 205:setup.c       **** 
 206:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 207:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 276               		.loc 1 207 0
 277               		.cfi_startproc
 278               	.LVL18:
 279 0086 CF93      		push r28
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 28, -2
 283 0088 DF93      		push r29
 284               	.LCFI7:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 29, -3
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 2 */
 290               	.L__stack_usage = 2
 291 008a D62F      		mov r29,r22
 292 008c C42F      		mov r28,r20
 208:setup.c       **** 	set_16bit_address(address);
 293               		.loc 1 208 0
 294 008e 00D0      		rcall set_16bit_address
 295               	.LVL19:
 209:setup.c       **** 	
 210:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 296               		.loc 1 210 0
 297 0090 8FEF      		ldi r24,lo8(-1)
 298 0092 84BB      		out 0x14,r24
 211:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 299               		.loc 1 211 0
 300 0094 D5BB      		out 0x15,r29
 212:setup.c       **** 	
 213:setup.c       **** 	// Pulse WR and mREQ if the type matches
 214:setup.c       **** 	wrPin_low;
 301               		.loc 1 214 0
 302 0096 9698      		cbi 0x12,6
 215:setup.c       **** 	if (type == MEMORY_WRITE) {
 303               		.loc 1 215 0
 304 0098 C130      		cpi r28,lo8(1)
 305 009a 01F4      		brne .L21
 216:setup.c       **** 		cs_mreqPin_low;
 306               		.loc 1 216 0
 307 009c 9498      		cbi 0x12,4
 308               	.L21:
 217:setup.c       **** 	}
 218:setup.c       **** 	
 219:setup.c       **** 	asm volatile("nop");
 309               		.loc 1 219 0
 310               	/* #APP */
 311               	 ;  219 "setup.c" 1
 312 009e 0000      		nop
 313               	 ;  0 "" 2
 220:setup.c       **** 	asm volatile("nop");
 314               		.loc 1 220 0
 315               	 ;  220 "setup.c" 1
 316 00a0 0000      		nop
 317               	 ;  0 "" 2
 221:setup.c       **** 	
 222:setup.c       **** 	if (type == MEMORY_WRITE) {
 318               		.loc 1 222 0
 319               	/* #NOAPP */
 320 00a2 C130      		cpi r28,lo8(1)
 321 00a4 01F4      		brne .L22
 223:setup.c       **** 		cs_mreqPin_high;
 322               		.loc 1 223 0
 323 00a6 949A      		sbi 0x12,4
 324               	.L22:
 224:setup.c       **** 	}
 225:setup.c       **** 	wrPin_high;
 325               		.loc 1 225 0
 326 00a8 969A      		sbi 0x12,6
 226:setup.c       **** 	
 227:setup.c       **** 	// Clear data outputs and set data pins as inputs
 228:setup.c       **** 	PORT_DATA7_0 = 0;
 327               		.loc 1 228 0
 328 00aa 15BA      		out 0x15,__zero_reg__
 229:setup.c       **** 	DDR_DATA7_0 = 0;
 329               		.loc 1 229 0
 330 00ac 14BA      		out 0x14,__zero_reg__
 331               	/* epilogue start */
 230:setup.c       **** }
 332               		.loc 1 230 0
 333 00ae DF91      		pop r29
 334               	.LVL20:
 335 00b0 CF91      		pop r28
 336               	.LVL21:
 337 00b2 0895      		ret
 338               		.cfi_endproc
 339               	.LFE20:
 341               	.global	gb_flash_read_byte
 343               	gb_flash_read_byte:
 344               	.LFB21:
 231:setup.c       **** 
 232:setup.c       **** 
 233:setup.c       **** 
 234:setup.c       **** // ---------- GB FLASH CARTS ----------
 235:setup.c       **** 
 236:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 237:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 345               		.loc 1 237 0
 346               		.cfi_startproc
 347               	.LVL22:
 348               	/* prologue: function */
 349               	/* frame size = 0 */
 350               	/* stack size = 0 */
 351               	.L__stack_usage = 0
 238:setup.c       **** 	PORT_DATA7_0 = 0;
 352               		.loc 1 238 0
 353 00b4 15BA      		out 0x15,__zero_reg__
 239:setup.c       **** 	DDR_DATA7_0 = 0;
 354               		.loc 1 239 0
 355 00b6 14BA      		out 0x14,__zero_reg__
 240:setup.c       **** 	
 241:setup.c       **** 	set_16bit_address(address);
 356               		.loc 1 241 0
 357 00b8 00D0      		rcall set_16bit_address
 358               	.LVL23:
 242:setup.c       **** 	
 243:setup.c       **** 	rdPin_low;
 359               		.loc 1 243 0
 360 00ba 9598      		cbi 0x12,5
 244:setup.c       **** 	asm volatile("nop"); // Delay a little
 361               		.loc 1 244 0
 362               	/* #APP */
 363               	 ;  244 "setup.c" 1
 364 00bc 0000      		nop
 365               	 ;  0 "" 2
 245:setup.c       **** 	asm volatile("nop");
 366               		.loc 1 245 0
 367               	 ;  245 "setup.c" 1
 368 00be 0000      		nop
 369               	 ;  0 "" 2
 246:setup.c       **** 	asm volatile("nop");
 370               		.loc 1 246 0
 371               	 ;  246 "setup.c" 1
 372 00c0 0000      		nop
 373               	 ;  0 "" 2
 247:setup.c       **** 	asm volatile("nop");
 374               		.loc 1 247 0
 375               	 ;  247 "setup.c" 1
 376 00c2 0000      		nop
 377               	 ;  0 "" 2
 248:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 378               		.loc 1 248 0
 379               	/* #NOAPP */
 380 00c4 83B3      		in r24,0x13
 381               	.LVL24:
 249:setup.c       **** 	rdPin_high;
 382               		.loc 1 249 0
 383 00c6 959A      		sbi 0x12,5
 250:setup.c       **** 	
 251:setup.c       **** 	return data;
 252:setup.c       **** }
 384               		.loc 1 252 0
 385 00c8 0895      		ret
 386               		.cfi_endproc
 387               	.LFE21:
 389               	.global	gb_flash_write_bus_cycle
 391               	gb_flash_write_bus_cycle:
 392               	.LFB22:
 253:setup.c       **** 
 254:setup.c       **** // Set the address and data for the write byte cycle to the flash
 255:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 393               		.loc 1 255 0
 394               		.cfi_startproc
 395               	.LVL25:
 396 00ca CF93      		push r28
 397               	.LCFI8:
 398               		.cfi_def_cfa_offset 3
 399               		.cfi_offset 28, -2
 400               	/* prologue: function */
 401               	/* frame size = 0 */
 402               	/* stack size = 1 */
 403               	.L__stack_usage = 1
 404 00cc C62F      		mov r28,r22
 256:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 405               		.loc 1 256 0
 406 00ce 2FEF      		ldi r18,lo8(-1)
 407 00d0 24BB      		out 0x14,r18
 257:setup.c       **** 	set_16bit_address(address);
 408               		.loc 1 257 0
 409 00d2 00D0      		rcall set_16bit_address
 410               	.LVL26:
 258:setup.c       **** 	PORT_DATA7_0 = data;
 411               		.loc 1 258 0
 412 00d4 C5BB      		out 0x15,r28
 259:setup.c       **** 	
 260:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 413               		.loc 1 260 0
 414 00d6 8091 0000 		lds r24,flashWriteWePin
 415 00da 8134      		cpi r24,lo8(65)
 416 00dc 01F4      		brne .L25
 261:setup.c       **** 		audioPin_low; // WE low
 417               		.loc 1 261 0
 418 00de 3998      		cbi 0x7,1
 262:setup.c       **** 		asm volatile("nop");
 419               		.loc 1 262 0
 420               	/* #APP */
 421               	 ;  262 "setup.c" 1
 422 00e0 0000      		nop
 423               	 ;  0 "" 2
 263:setup.c       **** 		asm volatile("nop");
 424               		.loc 1 263 0
 425               	 ;  263 "setup.c" 1
 426 00e2 0000      		nop
 427               	 ;  0 "" 2
 264:setup.c       **** 		asm volatile("nop");
 428               		.loc 1 264 0
 429               	 ;  264 "setup.c" 1
 430 00e4 0000      		nop
 431               	 ;  0 "" 2
 265:setup.c       **** 		asm volatile("nop");
 432               		.loc 1 265 0
 433               	 ;  265 "setup.c" 1
 434 00e6 0000      		nop
 435               	 ;  0 "" 2
 266:setup.c       **** 		asm volatile("nop");
 436               		.loc 1 266 0
 437               	 ;  266 "setup.c" 1
 438 00e8 0000      		nop
 439               	 ;  0 "" 2
 267:setup.c       **** 		asm volatile("nop");
 440               		.loc 1 267 0
 441               	 ;  267 "setup.c" 1
 442 00ea 0000      		nop
 443               	 ;  0 "" 2
 268:setup.c       **** 		audioPin_high; // WE high
 444               		.loc 1 268 0
 445               	/* #NOAPP */
 446 00ec 399A      		sbi 0x7,1
 447 00ee 00C0      		rjmp .L26
 448               	.L25:
 269:setup.c       **** 	}
 270:setup.c       **** 	else { // WR pin
 271:setup.c       **** 		wrPin_low; // WE low
 449               		.loc 1 271 0
 450 00f0 9698      		cbi 0x12,6
 272:setup.c       **** 		asm volatile("nop");
 451               		.loc 1 272 0
 452               	/* #APP */
 453               	 ;  272 "setup.c" 1
 454 00f2 0000      		nop
 455               	 ;  0 "" 2
 273:setup.c       **** 		asm volatile("nop");
 456               		.loc 1 273 0
 457               	 ;  273 "setup.c" 1
 458 00f4 0000      		nop
 459               	 ;  0 "" 2
 274:setup.c       **** 		asm volatile("nop");
 460               		.loc 1 274 0
 461               	 ;  274 "setup.c" 1
 462 00f6 0000      		nop
 463               	 ;  0 "" 2
 275:setup.c       **** 		asm volatile("nop");
 464               		.loc 1 275 0
 465               	 ;  275 "setup.c" 1
 466 00f8 0000      		nop
 467               	 ;  0 "" 2
 276:setup.c       **** 		asm volatile("nop");
 468               		.loc 1 276 0
 469               	 ;  276 "setup.c" 1
 470 00fa 0000      		nop
 471               	 ;  0 "" 2
 277:setup.c       **** 		asm volatile("nop");
 472               		.loc 1 277 0
 473               	 ;  277 "setup.c" 1
 474 00fc 0000      		nop
 475               	 ;  0 "" 2
 278:setup.c       **** 		wrPin_high; // WE high
 476               		.loc 1 278 0
 477               	/* #NOAPP */
 478 00fe 969A      		sbi 0x12,6
 479               	.L26:
 279:setup.c       **** 	}
 280:setup.c       **** 	
 281:setup.c       **** 	// Clear data outputs and set data pins as inputs
 282:setup.c       **** 	PORT_DATA7_0 = 0;
 480               		.loc 1 282 0
 481 0100 15BA      		out 0x15,__zero_reg__
 283:setup.c       **** 	DDR_DATA7_0 = 0;
 482               		.loc 1 283 0
 483 0102 14BA      		out 0x14,__zero_reg__
 484               	/* epilogue start */
 284:setup.c       **** }
 485               		.loc 1 284 0
 486 0104 CF91      		pop r28
 487               	.LVL27:
 488 0106 0895      		ret
 489               		.cfi_endproc
 490               	.LFE22:
 492               	.global	gb_flash_write_byte
 494               	gb_flash_write_byte:
 495               	.LFB23:
 285:setup.c       **** 
 286:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 287:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 496               		.loc 1 287 0
 497               		.cfi_startproc
 498               	.LVL28:
 499 0108 1F93      		push r17
 500               	.LCFI9:
 501               		.cfi_def_cfa_offset 3
 502               		.cfi_offset 17, -2
 503 010a CF93      		push r28
 504               	.LCFI10:
 505               		.cfi_def_cfa_offset 4
 506               		.cfi_offset 28, -3
 507 010c DF93      		push r29
 508               	.LCFI11:
 509               		.cfi_def_cfa_offset 5
 510               		.cfi_offset 29, -4
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 3 */
 514               	.L__stack_usage = 3
 515 010e EC01      		movw r28,r24
 516 0110 162F      		mov r17,r22
 288:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 517               		.loc 1 288 0
 518 0112 6091 0000 		lds r22,flashWriteCycle+2
 519               	.LVL29:
 520 0116 8091 0000 		lds r24,flashWriteCycle
 521 011a 9091 0000 		lds r25,flashWriteCycle+1
 522               	.LVL30:
 523 011e 00D0      		rcall gb_flash_write_bus_cycle
 524               	.LVL31:
 289:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 525               		.loc 1 289 0
 526 0120 6091 0000 		lds r22,flashWriteCycle+6
 527 0124 8091 0000 		lds r24,flashWriteCycle+4
 528 0128 9091 0000 		lds r25,flashWriteCycle+4+1
 529 012c 00D0      		rcall gb_flash_write_bus_cycle
 530               	.LVL32:
 290:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 531               		.loc 1 290 0
 532 012e 6091 0000 		lds r22,flashWriteCycle+10
 533 0132 8091 0000 		lds r24,flashWriteCycle+8
 534 0136 9091 0000 		lds r25,flashWriteCycle+8+1
 535 013a 00D0      		rcall gb_flash_write_bus_cycle
 536               	.LVL33:
 291:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 537               		.loc 1 291 0
 538 013c 612F      		mov r22,r17
 539 013e CE01      		movw r24,r28
 540 0140 00D0      		rcall gb_flash_write_bus_cycle
 541               	.LVL34:
 542               	.LBB89:
 543               	.LBB90:
 544               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 545               		.loc 2 276 0
 546 0142 85E3      		ldi r24,lo8(53)
 547 0144 8A95      	1:	dec r24
 548 0146 01F4      		brne 1b
 549 0148 0000      		nop
 550               	.LVL35:
 551               	.LBE90:
 552               	.LBE89:
 292:setup.c       **** 	_delay_us(10); // Wait byte program time
 293:setup.c       **** 	
 294:setup.c       **** 	// Set data pins inputs
 295:setup.c       **** 	PORT_DATA7_0 = 0;
 553               		.loc 1 295 0
 554 014a 15BA      		out 0x15,__zero_reg__
 296:setup.c       **** 	DDR_DATA7_0 = 0;
 555               		.loc 1 296 0
 556 014c 14BA      		out 0x14,__zero_reg__
 297:setup.c       **** 	
 298:setup.c       **** 	// Verify data
 299:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 557               		.loc 1 299 0
 558 014e CE01      		movw r24,r28
 559 0150 00D0      		rcall gb_flash_read_byte
 560               	.LVL36:
 561               	.L28:
 300:setup.c       **** 	while (data != dataVerify) {
 562               		.loc 1 300 0
 563 0152 8117      		cp r24,r17
 564 0154 01F0      		breq .L27
 301:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 565               		.loc 1 301 0
 566 0156 CE01      		movw r24,r28
 567               	.LVL37:
 568 0158 00D0      		rcall gb_flash_read_byte
 569               	.LVL38:
 570               	.LBB91:
 571               	.LBB92:
 572               		.loc 2 276 0
 573 015a 9AE1      		ldi r25,lo8(26)
 574 015c 9A95      	1:	dec r25
 575 015e 01F4      		brne 1b
 576 0160 00C0      		rjmp .
 577               	.LVL39:
 578               	.LBE92:
 579               	.LBE91:
 302:setup.c       **** 		_delay_us(5);
 303:setup.c       **** 		if (writingTimedout == 1) {
 580               		.loc 1 303 0
 581 0162 9091 0000 		lds r25,writingTimedout
 582 0166 9130      		cpi r25,lo8(1)
 583 0168 01F4      		brne .L28
 584               	.L27:
 585               	/* epilogue start */
 304:setup.c       **** 			break;
 305:setup.c       **** 		}
 306:setup.c       **** 	}
 307:setup.c       **** }
 586               		.loc 1 307 0
 587 016a DF91      		pop r29
 588 016c CF91      		pop r28
 589               	.LVL40:
 590 016e 1F91      		pop r17
 591               	.LVL41:
 592 0170 0895      		ret
 593               		.cfi_endproc
 594               	.LFE23:
 596               	.global	gb_flash_write_byte_special
 598               	gb_flash_write_byte_special:
 599               	.LFB24:
 308:setup.c       **** 
 309:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 310:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 600               		.loc 1 310 0
 601               		.cfi_startproc
 602               	.LVL42:
 603 0172 1F93      		push r17
 604               	.LCFI12:
 605               		.cfi_def_cfa_offset 3
 606               		.cfi_offset 17, -2
 607 0174 CF93      		push r28
 608               	.LCFI13:
 609               		.cfi_def_cfa_offset 4
 610               		.cfi_offset 28, -3
 611 0176 DF93      		push r29
 612               	.LCFI14:
 613               		.cfi_def_cfa_offset 5
 614               		.cfi_offset 29, -4
 615               	/* prologue: function */
 616               	/* frame size = 0 */
 617               	/* stack size = 3 */
 618               	.L__stack_usage = 3
 619 0178 EC01      		movw r28,r24
 620 017a 162F      		mov r17,r22
 311:setup.c       **** 	// Set bank back
 312:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 621               		.loc 1 312 0
 622 017c 8091 0000 		lds r24,flashBank1CommandWrites
 623               	.LVL43:
 624 0180 8130      		cpi r24,lo8(1)
 625 0182 01F4      		brne .L33
 313:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 626               		.loc 1 313 0
 627 0184 40E0      		ldi r20,0
 628 0186 6091 0000 		lds r22,lastBankAccessed
 629               	.LVL44:
 630 018a 80E0      		ldi r24,0
 631 018c 91E2      		ldi r25,lo8(33)
 632 018e 00D0      		rcall write_8bit_data
 633               	.LVL45:
 634               	.LBB93:
 635               	.LBB94:
 636               		.loc 2 276 0
 637 0190 87EC      		ldi r24,lo8(199)
 638 0192 90E0      		ldi r25,hi8(199)
 639 0194 0197      	1:	sbiw r24,1
 640 0196 01F4      		brne 1b
 641 0198 00C0      		rjmp .
 642 019a 0000      		nop
 643               	.LVL46:
 644               	.L33:
 645               	.LBE94:
 646               	.LBE93:
 314:setup.c       **** 		_delay_us(50);
 315:setup.c       **** 	}
 316:setup.c       **** 	
 317:setup.c       **** 	// Write
 318:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 647               		.loc 1 318 0
 648 019c 6091 0000 		lds r22,flashWriteCycle+2
 649 01a0 8091 0000 		lds r24,flashWriteCycle
 650 01a4 9091 0000 		lds r25,flashWriteCycle+1
 651 01a8 00D0      		rcall gb_flash_write_bus_cycle
 652               	.LVL47:
 319:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 653               		.loc 1 319 0
 654 01aa 6091 0000 		lds r22,flashWriteCycle+6
 655 01ae 8091 0000 		lds r24,flashWriteCycle+4
 656 01b2 9091 0000 		lds r25,flashWriteCycle+4+1
 657 01b6 00D0      		rcall gb_flash_write_bus_cycle
 658               	.LVL48:
 320:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 659               		.loc 1 320 0
 660 01b8 6091 0000 		lds r22,flashWriteCycle+10
 661 01bc 8091 0000 		lds r24,flashWriteCycle+8
 662 01c0 9091 0000 		lds r25,flashWriteCycle+8+1
 663 01c4 00D0      		rcall gb_flash_write_bus_cycle
 664               	.LVL49:
 321:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 665               		.loc 1 321 0
 666 01c6 612F      		mov r22,r17
 667 01c8 CE01      		movw r24,r28
 668 01ca 00D0      		rcall gb_flash_write_bus_cycle
 669               	.LVL50:
 670               	.LBB95:
 671               	.LBB96:
 672               		.loc 2 276 0
 673 01cc 87EE      		ldi r24,lo8(999)
 674 01ce 93E0      		ldi r25,hi8(999)
 675 01d0 0197      	1:	sbiw r24,1
 676 01d2 01F4      		brne 1b
 677 01d4 00C0      		rjmp .
 678 01d6 0000      		nop
 679               	.LVL51:
 680               	.LBE96:
 681               	.LBE95:
 322:setup.c       **** 	_delay_us(250); // Wait byte program time
 323:setup.c       **** 	
 324:setup.c       **** 	// Set data pins inputs
 325:setup.c       **** 	PORT_DATA7_0 = 0;
 682               		.loc 1 325 0
 683 01d8 15BA      		out 0x15,__zero_reg__
 326:setup.c       **** 	DDR_DATA7_0 = 0;
 684               		.loc 1 326 0
 685 01da 14BA      		out 0x14,__zero_reg__
 327:setup.c       **** 	
 328:setup.c       **** 	// Pulse reset
 329:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 686               		.loc 1 329 0
 687 01dc 3A98      		cbi 0x7,2
 688               	.LVL52:
 689               	.LBB97:
 690               	.LBB98:
 691               		.loc 2 276 0
 692 01de 87EC      		ldi r24,lo8(199)
 693 01e0 90E0      		ldi r25,hi8(199)
 694 01e2 0197      	1:	sbiw r24,1
 695 01e4 01F4      		brne 1b
 696 01e6 00C0      		rjmp .
 697 01e8 0000      		nop
 698               	.LVL53:
 699               	.LBE98:
 700               	.LBE97:
 330:setup.c       **** 	_delay_us(50);
 331:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 701               		.loc 1 331 0
 702 01ea 3A9A      		sbi 0x7,2
 703               	.LVL54:
 704               	.LBB99:
 705               	.LBB100:
 706               		.loc 2 276 0
 707 01ec 87EC      		ldi r24,lo8(199)
 708 01ee 90E0      		ldi r25,hi8(199)
 709 01f0 0197      	1:	sbiw r24,1
 710 01f2 01F4      		brne 1b
 711 01f4 00C0      		rjmp .
 712 01f6 0000      		nop
 713               	.LVL55:
 714               	/* epilogue start */
 715               	.LBE100:
 716               	.LBE99:
 332:setup.c       **** 	_delay_us(50);
 333:setup.c       **** }
 717               		.loc 1 333 0
 718 01f8 DF91      		pop r29
 719 01fa CF91      		pop r28
 720               	.LVL56:
 721 01fc 1F91      		pop r17
 722               	.LVL57:
 723 01fe 0895      		ret
 724               		.cfi_endproc
 725               	.LFE24:
 727               	.global	gb_flash_write_byte_bank1_commands
 729               	gb_flash_write_byte_bank1_commands:
 730               	.LFB25:
 334:setup.c       **** 
 335:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 336:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 337:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 731               		.loc 1 337 0
 732               		.cfi_startproc
 733               	.LVL58:
 734 0200 FF92      		push r15
 735               	.LCFI15:
 736               		.cfi_def_cfa_offset 3
 737               		.cfi_offset 15, -2
 738 0202 0F93      		push r16
 739               	.LCFI16:
 740               		.cfi_def_cfa_offset 4
 741               		.cfi_offset 16, -3
 742 0204 1F93      		push r17
 743               	.LCFI17:
 744               		.cfi_def_cfa_offset 5
 745               		.cfi_offset 17, -4
 746 0206 CF93      		push r28
 747               	.LCFI18:
 748               		.cfi_def_cfa_offset 6
 749               		.cfi_offset 28, -5
 750 0208 DF93      		push r29
 751               	.LCFI19:
 752               		.cfi_def_cfa_offset 7
 753               		.cfi_offset 29, -6
 754               	/* prologue: function */
 755               	/* frame size = 0 */
 756               	/* stack size = 5 */
 757               	.L__stack_usage = 5
 758 020a EC01      		movw r28,r24
 759 020c 162F      		mov r17,r22
 338:setup.c       **** 	// Set bank 1
 339:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 760               		.loc 1 339 0
 761 020e FF24      		clr r15
 762 0210 FA94      		dec r15
 763 0212 F4BA      		out 0x14,r15
 764               	.LVL59:
 765               	.LBB101:
 766               	.LBB102:
 183:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 767               		.loc 1 183 0
 768 0214 01E2      		ldi r16,lo8(33)
 769 0216 0BBB      		out 0x1b,r16
 184:setup.c       **** }
 770               		.loc 1 184 0
 771 0218 18BA      		out 0x18,__zero_reg__
 772               	.LVL60:
 773               	.LBE102:
 774               	.LBE101:
 340:setup.c       **** 	set_16bit_address(0x2100);
 341:setup.c       **** 	PORT_DATA7_0 = 1;
 775               		.loc 1 341 0
 776 021a 81E0      		ldi r24,lo8(1)
 777               	.LVL61:
 778 021c 85BB      		out 0x15,r24
 342:setup.c       **** 	wrPin_low; // Pulse WR
 779               		.loc 1 342 0
 780 021e 9698      		cbi 0x12,6
 343:setup.c       **** 	asm volatile("nop");
 781               		.loc 1 343 0
 782               	/* #APP */
 783               	 ;  343 "setup.c" 1
 784 0220 0000      		nop
 785               	 ;  0 "" 2
 344:setup.c       **** 	asm volatile("nop");
 786               		.loc 1 344 0
 787               	 ;  344 "setup.c" 1
 788 0222 0000      		nop
 789               	 ;  0 "" 2
 345:setup.c       **** 	wrPin_high;
 790               		.loc 1 345 0
 791               	/* #NOAPP */
 792 0224 969A      		sbi 0x12,6
 346:setup.c       **** 	
 347:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 793               		.loc 1 347 0
 794 0226 6091 0000 		lds r22,flashWriteCycle+2
 795               	.LVL62:
 796 022a 8091 0000 		lds r24,flashWriteCycle
 797 022e 9091 0000 		lds r25,flashWriteCycle+1
 798 0232 00D0      		rcall gb_flash_write_bus_cycle
 799               	.LVL63:
 348:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 800               		.loc 1 348 0
 801 0234 6091 0000 		lds r22,flashWriteCycle+6
 802 0238 8091 0000 		lds r24,flashWriteCycle+4
 803 023c 9091 0000 		lds r25,flashWriteCycle+4+1
 804 0240 00D0      		rcall gb_flash_write_bus_cycle
 805               	.LVL64:
 349:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 806               		.loc 1 349 0
 807 0242 6091 0000 		lds r22,flashWriteCycle+10
 808 0246 8091 0000 		lds r24,flashWriteCycle+8
 809 024a 9091 0000 		lds r25,flashWriteCycle+8+1
 810 024e 00D0      		rcall gb_flash_write_bus_cycle
 811               	.LVL65:
 350:setup.c       **** 	
 351:setup.c       **** 	
 352:setup.c       **** 	// Set bank back
 353:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 812               		.loc 1 353 0
 813 0250 F4BA      		out 0x14,r15
 814               	.LVL66:
 815               	.LBB103:
 816               	.LBB104:
 183:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 817               		.loc 1 183 0
 818 0252 0BBB      		out 0x1b,r16
 184:setup.c       **** }
 819               		.loc 1 184 0
 820 0254 18BA      		out 0x18,__zero_reg__
 821               	.LVL67:
 822               	.LBE104:
 823               	.LBE103:
 354:setup.c       **** 	set_16bit_address(0x2100);
 355:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 824               		.loc 1 355 0
 825 0256 8091 0000 		lds r24,lastBankAccessed
 826 025a 85BB      		out 0x15,r24
 356:setup.c       **** 	wrPin_low; // Pulse WR
 827               		.loc 1 356 0
 828 025c 9698      		cbi 0x12,6
 357:setup.c       **** 	asm volatile("nop");
 829               		.loc 1 357 0
 830               	/* #APP */
 831               	 ;  357 "setup.c" 1
 832 025e 0000      		nop
 833               	 ;  0 "" 2
 358:setup.c       **** 	asm volatile("nop");
 834               		.loc 1 358 0
 835               	 ;  358 "setup.c" 1
 836 0260 0000      		nop
 837               	 ;  0 "" 2
 359:setup.c       **** 	wrPin_high;
 838               		.loc 1 359 0
 839               	/* #NOAPP */
 840 0262 969A      		sbi 0x12,6
 360:setup.c       **** 	
 361:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 841               		.loc 1 361 0
 842 0264 612F      		mov r22,r17
 843 0266 CE01      		movw r24,r28
 844 0268 00D0      		rcall gb_flash_write_bus_cycle
 845               	.LVL68:
 846               	.LBB105:
 847               	.LBB106:
 848               		.loc 2 276 0
 849 026a 85E3      		ldi r24,lo8(53)
 850 026c 8A95      	1:	dec r24
 851 026e 01F4      		brne 1b
 852 0270 0000      		nop
 853               	.LVL69:
 854               	.LBE106:
 855               	.LBE105:
 362:setup.c       **** 	_delay_us(10); // Wait byte program time
 363:setup.c       **** 	
 364:setup.c       **** 	// Set data pins inputs
 365:setup.c       **** 	PORT_DATA7_0 = 0;
 856               		.loc 1 365 0
 857 0272 15BA      		out 0x15,__zero_reg__
 366:setup.c       **** 	DDR_DATA7_0 = 0;
 858               		.loc 1 366 0
 859 0274 14BA      		out 0x14,__zero_reg__
 367:setup.c       **** 	
 368:setup.c       **** 	// Verify data
 369:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 860               		.loc 1 369 0
 861 0276 CE01      		movw r24,r28
 862 0278 00D0      		rcall gb_flash_read_byte
 863               	.LVL70:
 864               	.L35:
 370:setup.c       **** 	while (data != dataVerify) {
 865               		.loc 1 370 0
 866 027a 8117      		cp r24,r17
 867 027c 01F0      		breq .L34
 371:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 868               		.loc 1 371 0
 869 027e CE01      		movw r24,r28
 870               	.LVL71:
 871 0280 00D0      		rcall gb_flash_read_byte
 872               	.LVL72:
 873               	.LBB107:
 874               	.LBB108:
 875               		.loc 2 276 0
 876 0282 9AE1      		ldi r25,lo8(26)
 877 0284 9A95      	1:	dec r25
 878 0286 01F4      		brne 1b
 879 0288 00C0      		rjmp .
 880               	.LVL73:
 881               	.LBE108:
 882               	.LBE107:
 372:setup.c       **** 		_delay_us(5);
 373:setup.c       **** 		if (writingTimedout == 1) {
 883               		.loc 1 373 0
 884 028a 9091 0000 		lds r25,writingTimedout
 885 028e 9130      		cpi r25,lo8(1)
 886 0290 01F4      		brne .L35
 887               	.L34:
 888               	/* epilogue start */
 374:setup.c       **** 			break;
 375:setup.c       **** 		}
 376:setup.c       **** 	}
 377:setup.c       **** }
 889               		.loc 1 377 0
 890 0292 DF91      		pop r29
 891 0294 CF91      		pop r28
 892               	.LVL74:
 893 0296 1F91      		pop r17
 894               	.LVL75:
 895 0298 0F91      		pop r16
 896 029a FF90      		pop r15
 897 029c 0895      		ret
 898               		.cfi_endproc
 899               	.LFE25:
 901               	.global	start_timeout_timer
 903               	start_timeout_timer:
 904               	.LFB26:
 378:setup.c       **** 
 379:setup.c       **** // Timeout for ~500ms when flashing carts
 380:setup.c       **** void start_timeout_timer(void) {
 905               		.loc 1 380 0
 906               		.cfi_startproc
 907               	/* prologue: function */
 908               	/* frame size = 0 */
 909               	/* stack size = 0 */
 910               	.L__stack_usage = 0
 381:setup.c       **** 	writingTimedout = 0;
 911               		.loc 1 381 0
 912 029e 1092 0000 		sts writingTimedout,__zero_reg__
 382:setup.c       **** 	TCNT1 = 0;
 913               		.loc 1 382 0
 914 02a2 1DBC      		out 0x2c+1,__zero_reg__
 915 02a4 1CBC      		out 0x2c,__zero_reg__
 383:setup.c       **** 	TCCR1B |= (1<<CS11) | (1<<CS10);
 916               		.loc 1 383 0
 917 02a6 8EB5      		in r24,0x2e
 918 02a8 8360      		ori r24,lo8(3)
 919 02aa 8EBD      		out 0x2e,r24
 920 02ac 0895      		ret
 921               		.cfi_endproc
 922               	.LFE26:
 924               	.global	stop_timeout_timer
 926               	stop_timeout_timer:
 927               	.LFB27:
 384:setup.c       **** }
 385:setup.c       **** 
 386:setup.c       **** // Stop the flash timeout timer
 387:setup.c       **** void stop_timeout_timer(void) {
 928               		.loc 1 387 0
 929               		.cfi_startproc
 930               	/* prologue: function */
 931               	/* frame size = 0 */
 932               	/* stack size = 0 */
 933               	.L__stack_usage = 0
 388:setup.c       **** 	writingTimedout = 0;
 934               		.loc 1 388 0
 935 02ae 1092 0000 		sts writingTimedout,__zero_reg__
 389:setup.c       **** 	TCNT1 = 0;
 936               		.loc 1 389 0
 937 02b2 1DBC      		out 0x2c+1,__zero_reg__
 938 02b4 1CBC      		out 0x2c,__zero_reg__
 390:setup.c       **** 	TCCR1B = 0;
 939               		.loc 1 390 0
 940 02b6 1EBC      		out 0x2e,__zero_reg__
 391:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 941               		.loc 1 391 0
 942 02b8 9398      		cbi 0x12,3
 943 02ba 0895      		ret
 944               		.cfi_endproc
 945               	.LFE27:
 947               	.global	check_if_timed_out
 949               	check_if_timed_out:
 950               	.LFB28:
 392:setup.c       **** }
 393:setup.c       **** 
 394:setup.c       **** void check_if_timed_out(void) {
 951               		.loc 1 394 0
 952               		.cfi_startproc
 953               	/* prologue: function */
 954               	/* frame size = 0 */
 955               	/* stack size = 0 */
 956               	.L__stack_usage = 0
 395:setup.c       **** 	if (writingTimedout == 0) {
 957               		.loc 1 395 0
 958 02bc 8091 0000 		lds r24,writingTimedout
 959 02c0 8111      		cpse r24,__zero_reg__
 960 02c2 00C0      		rjmp .L41
 961               	.LBB111:
 962               	.LBB112:
 396:setup.c       **** 		stop_timeout_timer();		
 963               		.loc 1 396 0
 964 02c4 00D0      		rcall stop_timeout_timer
 965               	.LVL76:
 397:setup.c       **** 		USART_Transmit(SEND_ACK); // Send back acknowledgement
 966               		.loc 1 397 0
 967 02c6 81E3      		ldi r24,lo8(49)
 968 02c8 00D0      		rcall USART_Transmit
 969               	.LVL77:
 398:setup.c       **** 		PORTD &= ~(1<<ACTIVITY_LED);
 970               		.loc 1 398 0
 971 02ca 9398      		cbi 0x12,3
 972               	.L41:
 973 02cc 0895      		ret
 974               	.LBE112:
 975               	.LBE111:
 976               		.cfi_endproc
 977               	.LFE28:
 979               	.global	setup
 981               	setup:
 982               	.LFB29:
 399:setup.c       **** 	}
 400:setup.c       **** }
 401:setup.c       **** 
 402:setup.c       **** 
 403:setup.c       **** // Setup
 404:setup.c       **** void setup(void) {
 983               		.loc 1 404 0
 984               		.cfi_startproc
 985               	/* prologue: function */
 986               	/* frame size = 0 */
 987               	/* stack size = 0 */
 988               	.L__stack_usage = 0
 405:setup.c       **** 	// Turn off watchdog
 406:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 989               		.loc 1 406 0
 990 02ce 84B7      		in r24,0x34
 991 02d0 877F      		andi r24,lo8(-9)
 992 02d2 84BF      		out 0x34,r24
 407:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 993               		.loc 1 407 0
 994 02d4 88E1      		ldi r24,lo8(24)
 995 02d6 81BD      		out 0x21,r24
 408:setup.c       **** 	WDTCR = 0;
 996               		.loc 1 408 0
 997 02d8 11BC      		out 0x21,__zero_reg__
 409:setup.c       **** 	
 410:setup.c       **** 	// Reset common lines
 411:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 998               		.loc 1 411 0
 999 02da 00D0      		rcall rd_wr_csmreq_cs2_reset
 1000               	.LVL78:
 412:setup.c       **** 	
 413:setup.c       **** 	// Set outputs
 414:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN);
 1001               		.loc 1 414 0
 1002 02dc 81B3      		in r24,0x11
 1003 02de 8867      		ori r24,lo8(120)
 1004 02e0 81BB      		out 0x11,r24
 415:setup.c       **** 	DDRE |= (1<<CS2_PIN);
 1005               		.loc 1 415 0
 1006 02e2 329A      		sbi 0x6,2
 416:setup.c       **** 	
 417:setup.c       **** 	// Pull ups
 418:setup.c       **** 	PORTE |= (1<<PE0);
 1007               		.loc 1 418 0
 1008 02e4 389A      		sbi 0x7,0
 419:setup.c       **** 	PORTD |= (1<<PD7) | (1<<PD2);
 1009               		.loc 1 419 0
 1010 02e6 82B3      		in r24,0x12
 1011 02e8 8468      		ori r24,lo8(-124)
 1012 02ea 82BB      		out 0x12,r24
 420:setup.c       **** 	
 421:setup.c       **** 	// Set all pins as inputs
 422:setup.c       **** 	PORT_DATA7_0 = 0;
 1013               		.loc 1 422 0
 1014 02ec 15BA      		out 0x15,__zero_reg__
 423:setup.c       **** 	DDR_DATA7_0 = 0;
 1015               		.loc 1 423 0
 1016 02ee 14BA      		out 0x14,__zero_reg__
 424:setup.c       **** 	PORT_ADDR7_0 = 0;
 1017               		.loc 1 424 0
 1018 02f0 18BA      		out 0x18,__zero_reg__
 425:setup.c       **** 	DDR_ADDR7_0 = 0;
 1019               		.loc 1 425 0
 1020 02f2 17BA      		out 0x17,__zero_reg__
 426:setup.c       **** 	PORT_ADDR15_8 = 0;
 1021               		.loc 1 426 0
 1022 02f4 1BBA      		out 0x1b,__zero_reg__
 427:setup.c       **** 	DDR_ADDR15_8 = 0;
 1023               		.loc 1 427 0
 1024 02f6 1ABA      		out 0x1a,__zero_reg__
 428:setup.c       **** 	
 429:setup.c       **** 	// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 430:setup.c       **** 	cs2Pin_low;
 1025               		.loc 1 430 0
 1026 02f8 3A98      		cbi 0x7,2
 1027               	.LVL79:
 1028               	.LBB113:
 1029               	.LBB114:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1030               		.loc 2 187 0
 1031 02fa 2FEF      		ldi r18,lo8(159999)
 1032 02fc 80E7      		ldi r24,hi8(159999)
 1033 02fe 92E0      		ldi r25,hlo8(159999)
 1034 0300 2150      	1:	subi r18,1
 1035 0302 8040      		sbci r24,0
 1036 0304 9040      		sbci r25,0
 1037 0306 01F4      		brne 1b
 1038 0308 00C0      		rjmp .
 1039 030a 0000      		nop
 1040               	.LVL80:
 1041               	.LBE114:
 1042               	.LBE113:
 431:setup.c       **** 	_delay_ms(50);
 432:setup.c       **** 	cs2Pin_high;
 1043               		.loc 1 432 0
 1044 030c 3A9A      		sbi 0x7,2
 433:setup.c       **** 	
 434:setup.c       **** 	// Light LED
 435:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1045               		.loc 1 435 0
 1046 030e 939A      		sbi 0x12,3
 1047               	.LVL81:
 1048               	.LBB115:
 1049               	.LBB116:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1050               		.loc 2 187 0
 1051 0310 2FEF      		ldi r18,lo8(1599999)
 1052 0312 89E6      		ldi r24,hi8(1599999)
 1053 0314 98E1      		ldi r25,hlo8(1599999)
 1054 0316 2150      	1:	subi r18,1
 1055 0318 8040      		sbci r24,0
 1056 031a 9040      		sbci r25,0
 1057 031c 01F4      		brne 1b
 1058 031e 00C0      		rjmp .
 1059 0320 0000      		nop
 1060               	.LVL82:
 1061               	.LBE116:
 1062               	.LBE115:
 436:setup.c       **** 	_delay_ms(500);
 437:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1063               		.loc 1 437 0
 1064 0322 9398      		cbi 0x12,3
 438:setup.c       **** 	
 439:setup.c       **** 	// Setup USART
 440:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1065               		.loc 1 440 0
 1066 0324 19B8      		out 0x9,__zero_reg__
 441:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1067               		.loc 1 441 0
 1068 0326 539A      		sbi 0xa,3
 442:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1069               		.loc 1 442 0
 1070 0328 549A      		sbi 0xa,4
 443:setup.c       **** 	
 444:setup.c       **** 	// Timer1 setup
 445:setup.c       **** 	TIMSK |= (1<<TOIE1);
 1071               		.loc 1 445 0
 1072 032a 89B7      		in r24,0x39
 1073 032c 8068      		ori r24,lo8(-128)
 1074 032e 89BF      		out 0x39,r24
 446:setup.c       **** 	TCNT1 = 0;
 1075               		.loc 1 446 0
 1076 0330 1DBC      		out 0x2c+1,__zero_reg__
 1077 0332 1CBC      		out 0x2c,__zero_reg__
 447:setup.c       **** 	
 448:setup.c       **** 	// Turn on interrupts
 449:setup.c       **** 	sei();
 1078               		.loc 1 449 0
 1079               	/* #APP */
 1080               	 ;  449 "setup.c" 1
 1081 0334 7894      		sei
 1082               	 ;  0 "" 2
 1083               	/* #NOAPP */
 1084 0336 0895      		ret
 1085               		.cfi_endproc
 1086               	.LFE29:
 1088               		.section	.text.startup,"ax",@progbits
 1089               	.global	main
 1091               	main:
 1092               	.LFB30:
 1093               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW Mini
   3:main.c        ****  PCB version: 1.0
   4:main.c        ****  Firmware version: R18
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 20/08/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW Mini allows you to dump your Gameboy/Gameboy Colour games ROM, save the RAM, write to t
  10:main.c        ****  write to certain Gameboy flash carts. GBA carts are not supported, please check out the non-Mini v
  11:main.c        ****  
  12:main.c        ****  The ATmega8515 talks to the cartridge and interfaces with the CH340G serial to USB converter with 
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 16MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BO
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.x_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart Mini RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  */
  28:main.c        **** 
  29:main.c        **** // ATmega8515L Pin Map
  30:main.c        **** //
  31:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  32:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  33:main.c        **** // 
  34:main.c        **** // Gameboy / Gameboy Colour
  35:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** #define F_CPU 16000000 // 16 MHz
  39:main.c        **** #define PCB_VERSION 100 // Mini v1.0
  40:main.c        **** #define FIRMWARE_VERSION 18
  41:main.c        **** 
  42:main.c        **** #include <avr/io.h>
  43:main.c        **** #include <avr/wdt.h>
  44:main.c        **** #include <avr/eeprom.h>
  45:main.c        **** #include <avr/interrupt.h>
  46:main.c        **** #include <avr/sleep.h>
  47:main.c        **** #include <util/delay.h>
  48:main.c        **** #include <stdlib.h>
  49:main.c        **** #include <string.h>
  50:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  51:main.c        **** 
  52:main.c        **** 
  53:main.c        **** int main(void) {
 1094               		.loc 3 53 0
 1095               		.cfi_startproc
 1096               	/* prologue: function */
 1097               	/* frame size = 0 */
 1098               	/* stack size = 0 */
 1099               	.L__stack_usage = 0
  54:main.c        **** 	setup();
 1100               		.loc 3 54 0
 1101 0000 00D0      		rcall setup
 1102               	.LVL83:
  55:main.c        **** 	
  56:main.c        **** 	uint32_t address = 0;
  57:main.c        **** 	uint8_t resetCommonLines = 1;
 1103               		.loc 3 57 0
 1104 0002 5524      		clr r5
 1105 0004 5394      		inc r5
  56:main.c        **** 	uint8_t resetCommonLines = 1;
 1106               		.loc 3 56 0
 1107 0006 C12C      		mov r12,__zero_reg__
 1108 0008 D12C      		mov r13,__zero_reg__
 1109 000a 7601      		movw r14,r12
 1110               	.LBB117:
 1111               	.LBB118:
 1112               	.LBB119:
 1113               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 1114               		.loc 4 105 0
 1115 000c 2224      		clr r2
 1116 000e 2A94      		dec r2
 1117 0010 322C      		mov r3,r2
 1118               	.LBE119:
 1119               	.LBE118:
 1120               	.LBE117:
 1121               	.LBB122:
  58:main.c        **** 	
  59:main.c        **** 	while(1) {
  60:main.c        **** 		if (resetCommonLines == 1) {
  61:main.c        **** 			rd_wr_csmreq_cs2_reset();
  62:main.c        **** 		}
  63:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  64:main.c        **** 		
  65:main.c        **** 		
  66:main.c        **** 		// Return the cart mode in use
  67:main.c        **** 		if (receivedChar == CART_MODE) {
  68:main.c        **** 			USART_Transmit(cartMode);
  69:main.c        **** 			stop_timeout_timer();
  70:main.c        **** 		}
  71:main.c        **** 		
  72:main.c        **** 		// Change to GB mode or GBA mode if requested
  73:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  74:main.c        **** 			gb_mode();
  75:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
  76:main.c        **** 			stop_timeout_timer();
  77:main.c        **** 		}
  78:main.c        **** 		
  79:main.c        **** 		// Set address
  80:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
  81:main.c        **** 			usart_read_chars(); // Read start address
  82:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
  83:main.c        **** 		}
  84:main.c        **** 		
  85:main.c        **** 		
  86:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  87:main.c        **** 		
  88:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  89:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
  90:main.c        **** 			gb_mode();
  91:main.c        **** 			receivedChar = '1';
  92:main.c        **** 			while (receivedChar == '1') {
  93:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
  94:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
  95:main.c        **** 					USART_Transmit(read_8bit_data(address));
  96:main.c        **** 					address++;
  97:main.c        **** 				}
  98:main.c        **** 				
  99:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 100:main.c        **** 				receivedChar = USART_Receive();
 101:main.c        **** 			}
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Read and send 0x4000 bytes of data
 105:main.c        **** 		else if (receivedChar == READ_ROM_4000H) {
 106:main.c        **** 			gb_mode();
 107:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 108:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 109:main.c        **** 				USART_Transmit(read_8bit_data(address));
 110:main.c        **** 				address++;
 111:main.c        **** 			}
 112:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 116:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 117:main.c        **** 			gb_mode();
 118:main.c        **** 			
 119:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 120:main.c        **** 			usart_read_bytes(64);
 121:main.c        **** 			
 122:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 123:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 124:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 125:main.c        **** 				address++;
 126:main.c        **** 			}
 127:main.c        **** 			
 128:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 129:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 130:main.c        **** 		}
 131:main.c        **** 		
 132:main.c        **** 		// Set bank address and write a byte
 133:main.c        **** 		else if (receivedChar == SET_BANK) {
 134:main.c        **** 			gb_mode();
 135:main.c        **** 			
 136:main.c        **** 			usart_read_chars(); // Read start address
 137:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 138:main.c        **** 			
 139:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 140:main.c        **** 			if (receivedChar == 'B') {
 141:main.c        **** 				usart_read_chars(); // Read data
 142:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 143:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 144:main.c        **** 				
 145:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 146:main.c        **** 			}
 147:main.c        **** 		}
 148:main.c        **** 		
 149:main.c        **** 		
 150:main.c        **** 		// ---------- GB FLASH CARTS ----------
 151:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 152:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 153:main.c        **** 			flashWriteWePin = USART_Receive();
 154:main.c        **** 			
 155:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 156:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 157:main.c        **** 				audioPin_high;
 158:main.c        **** 			}
 159:main.c        **** 		}
 160:main.c        **** 		
 161:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 162:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 163:main.c        **** 			flashBank1CommandWrites = 1;
 164:main.c        **** 		}
 165:main.c        **** 		
 166:main.c        **** 		// Load the program method to use
 167:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 168:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 169:main.c        **** 				usart_read_chars(); // Address
 170:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 171:main.c        **** 				USART_Transmit(SEND_ACK);
 172:main.c        **** 				
 173:main.c        **** 				usart_read_chars(); // Data
 174:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 175:main.c        **** 				USART_Transmit(SEND_ACK);
 176:main.c        **** 			}
 177:main.c        **** 		}
 178:main.c        **** 		
 179:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 180:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 181:main.c        **** 			usart_read_chars(); // Read address
 182:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 183:main.c        **** 			
 184:main.c        **** 			usart_read_chars(); // Read data byte
 185:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 186:main.c        **** 			
 187:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 188:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 189:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 190:main.c        **** 			
 191:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 192:main.c        **** 		}
 193:main.c        **** 		
 194:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 195:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 196:main.c        **** 			usart_read_bytes(64);
 197:main.c        **** 			start_timeout_timer();
 198:main.c        **** 			
 199:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 200:main.c        **** 			if (flashBank1CommandWrites == 0) {
 201:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 202:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 203:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 204:main.c        **** 					}
 205:main.c        **** 					address++;
 206:main.c        **** 				}
 207:main.c        **** 			}
 208:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 209:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 210:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 211:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 212:main.c        **** 					}
 213:main.c        **** 					address++;
 214:main.c        **** 				}
 215:main.c        **** 			}
 216:main.c        **** 			
 217:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 218:main.c        **** 		}
 219:main.c        **** 		
 220:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 221:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 222:main.c        **** 			usart_read_bytes(32);
 223:main.c        **** 			start_timeout_timer();
 224:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 225:main.c        **** 			
 226:main.c        **** 			// Setup buffered write
 227:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 228:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 229:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 230:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 231:main.c        **** 			_delay_us(1);
 232:main.c        **** 			
 233:main.c        **** 			// Write data
 234:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 235:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 236:main.c        **** 				address++;
 237:main.c        **** 			}
 238:main.c        **** 			
 239:main.c        **** 			// Write buffer to flash
 240:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 241:main.c        **** 			_delay_us(200);
 242:main.c        **** 			
 243:main.c        **** 			// Verify last byte written
 244:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 245:main.c        **** 			uint8_t verifyCount = 0;
 246:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 247:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 248:main.c        **** 				_delay_us(5);
 249:main.c        **** 				verifyCount++;
 250:main.c        **** 				if (writingTimedout == 1) {
 251:main.c        **** 					break;
 252:main.c        **** 				}
 253:main.c        **** 			}
 254:main.c        **** 			
 255:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 259:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 260:main.c        **** 			usart_read_bytes(64);
 261:main.c        **** 			start_timeout_timer();
 262:main.c        **** 			
 263:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 264:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 265:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 266:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 267:main.c        **** 				}
 268:main.c        **** 				address++;
 269:main.c        **** 			}
 270:main.c        **** 			
 271:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 275:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 276:main.c        **** 			usart_read_bytes(256);
 277:main.c        **** 			start_timeout_timer();
 278:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 279:main.c        **** 			
 280:main.c        **** 			// Setup buffered write
 281:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 282:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 283:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 284:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 285:main.c        **** 			_delay_us(50);
 286:main.c        **** 			
 287:main.c        **** 			// Write data
 288:main.c        **** 			for (int x = 0; x < 256; x++) {
 289:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			
 293:main.c        **** 			// Write buffer to flash
 294:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 295:main.c        **** 			
 296:main.c        **** 			// Verify last byte written
 297:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 298:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 299:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 300:main.c        **** 				_delay_us(5);
 301:main.c        **** 				if (writingTimedout == 1) {
 302:main.c        **** 					break;
 303:main.c        **** 				}
 304:main.c        **** 			}
 305:main.c        **** 			
 306:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 307:main.c        **** 		}
 308:main.c        **** 		
 309:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 310:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 311:main.c        **** 			usart_read_bytes(128);
 312:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 313:main.c        **** 			
 314:main.c        **** 			// Enable flash chip access
 315:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 316:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 317:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 318:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 319:main.c        **** 			_delay_us(5);
 320:main.c        **** 			
 321:main.c        **** 			// Re-Enable writes to MBC registers
 322:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 323:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 324:main.c        **** 			_delay_us(5);
 325:main.c        **** 			
 326:main.c        **** 			// Bank 1 for commands
 327:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 328:main.c        **** 			_delay_us(5);
 329:main.c        **** 			
 330:main.c        **** 			
 331:main.c        **** 			// Write setup
 332:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 333:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 334:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 335:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 336:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 337:main.c        **** 			_delay_us(5);
 338:main.c        **** 			
 339:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 340:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 341:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 342:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 343:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 344:main.c        **** 			_delay_us(5);
 345:main.c        **** 			
 346:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 347:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 348:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 349:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 350:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 351:main.c        **** 			_delay_us(5);
 352:main.c        **** 			
 353:main.c        **** 			// Set bank back
 354:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 355:main.c        **** 			_delay_us(5);
 356:main.c        **** 			
 357:main.c        **** 			// Disable writes to MBC registers
 358:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 359:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 360:main.c        **** 			_delay_us(5);
 361:main.c        **** 			
 362:main.c        **** 			// Undo Wakeup
 363:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 364:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 365:main.c        **** 			_delay_us(5);
 366:main.c        **** 			
 367:main.c        **** 			
 368:main.c        **** 			// Write data
 369:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 370:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 371:main.c        **** 				_delay_us(5);
 372:main.c        **** 				address++;
 373:main.c        **** 			}
 374:main.c        **** 			
 375:main.c        **** 			// Write buffer to flash
 376:main.c        **** 			address--;
 377:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 378:main.c        **** 			address++;
 379:main.c        **** 			_delay_ms(10);
 380:main.c        **** 			
 381:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 382:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 383:main.c        **** 		}
 384:main.c        **** 		
 385:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 386:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 387:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 388:main.c        **** 			usart_read_bytes(32);
 389:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 390:main.c        **** 			
 391:main.c        **** 			// Setup buffered write
 392:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 393:main.c        **** 			
 394:main.c        **** 			// Wait until ready
 395:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 396:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 397:main.c        **** 			
 398:main.c        **** 			// Set buffer size
 399:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 400:main.c        **** 			
 401:main.c        **** 			// Write data to buffer
 402:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 403:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 404:main.c        **** 				address++;
 405:main.c        **** 			}
 406:main.c        **** 			
 407:main.c        **** 			// Write buffer to flash
 408:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 409:main.c        **** 			_delay_us(196);
 410:main.c        **** 			
 411:main.c        **** 			// Wait until ready
 412:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 413:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 414:main.c        **** 			
 415:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 416:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 417:main.c        **** 		}
 418:main.c        **** 		
 419:main.c        **** 		
 420:main.c        **** 		// ---------- General commands ----------
 421:main.c        **** 		// Set any pin as input/output
 422:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 423:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 424:main.c        **** 			char portChar = USART_Receive();
 425:main.c        **** 			usart_read_chars();
 426:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 427:main.c        **** 			
 428:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 429:main.c        **** 			if (receivedChar == SET_INPUT) {
 430:main.c        **** 				if (portChar == 'A') {
 431:main.c        **** 					DDRA &= ~(setValue);
 432:main.c        **** 				}
 433:main.c        **** 				else if (portChar == 'B') {
 434:main.c        **** 					DDRB &= ~(setValue);
 435:main.c        **** 				}
 436:main.c        **** 				else if (portChar == 'C') {
 437:main.c        **** 					DDRC &= ~(setValue);
 438:main.c        **** 				}
 439:main.c        **** 				else if (portChar == 'D') {
 440:main.c        **** 					DDRD &= ~(setValue);
 441:main.c        **** 				}
 442:main.c        **** 				else if (portChar == 'E') {
 443:main.c        **** 					DDRE &= ~(setValue);
 444:main.c        **** 				}
 445:main.c        **** 			}
 446:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 447:main.c        **** 				if (portChar == 'A') {
 448:main.c        **** 					DDRA |= (setValue);
 449:main.c        **** 				}
 450:main.c        **** 				else if (portChar == 'B') {
 451:main.c        **** 					DDRB |= (setValue);
 452:main.c        **** 				}
 453:main.c        **** 				else if (portChar == 'C') {
 454:main.c        **** 					DDRC |= (setValue);
 455:main.c        **** 				}
 456:main.c        **** 				else if (portChar == 'D') {
 457:main.c        **** 					DDRD |= (setValue);
 458:main.c        **** 				}
 459:main.c        **** 				else if (portChar == 'E') {
 460:main.c        **** 					DDRE |= (setValue);
 461:main.c        **** 				}
 462:main.c        **** 			}
 463:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 464:main.c        **** 		}
 465:main.c        **** 		
 466:main.c        **** 		// Set pin output as low
 467:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 468:main.c        **** 			char portChar = USART_Receive();			
 469:main.c        **** 			usart_read_chars();
 470:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 471:main.c        **** 			
 472:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 473:main.c        **** 			if (portChar == 'A') {
 474:main.c        **** 				PORTA &= ~(setValue);
 475:main.c        **** 			}
 476:main.c        **** 			else if (portChar == 'B') {
 477:main.c        **** 				PORTB &= ~(setValue);
 478:main.c        **** 			}
 479:main.c        **** 			else if (portChar == 'C') {
 480:main.c        **** 				PORTC &= ~(setValue);
 481:main.c        **** 			}
 482:main.c        **** 			else if (portChar == 'D') {
 483:main.c        **** 				PORTD &= ~(setValue);
 484:main.c        **** 			}
 485:main.c        **** 			else if (portChar == 'E') {
 486:main.c        **** 				PORTE &= ~(setValue);
 487:main.c        **** 			}
 488:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 489:main.c        **** 		}
 490:main.c        **** 		
 491:main.c        **** 		// Set pin output as high
 492:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 493:main.c        **** 			char portChar = USART_Receive();			
 494:main.c        **** 			usart_read_chars();
 495:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 496:main.c        **** 			
 497:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 498:main.c        **** 			if (portChar == 'A') {
 499:main.c        **** 				PORTA |= (setValue);
 500:main.c        **** 			}
 501:main.c        **** 			else if (portChar == 'B') {
 502:main.c        **** 				PORTB |= (setValue);
 503:main.c        **** 			}
 504:main.c        **** 			else if (portChar == 'C') {
 505:main.c        **** 				PORTC |= (setValue);
 506:main.c        **** 			}
 507:main.c        **** 			else if (portChar == 'D') {
 508:main.c        **** 				PORTD |= (setValue);
 509:main.c        **** 			}
 510:main.c        **** 			else if (portChar == 'E') {
 511:main.c        **** 				PORTE |= (setValue);
 512:main.c        **** 			}
 513:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 514:main.c        **** 		}
 515:main.c        **** 		
 516:main.c        **** 		// Read all pins of a PORT and return the value
 517:main.c        **** 		else if (receivedChar == READ_INPUT) {
 518:main.c        **** 			char portChar = USART_Receive();			
 519:main.c        **** 			
 520:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 521:main.c        **** 			if (portChar == 'A') {
 522:main.c        **** 				USART_Transmit(PINA);
 523:main.c        **** 			}
 524:main.c        **** 			else if (portChar == 'B') {
 525:main.c        **** 				USART_Transmit(PINB);
 526:main.c        **** 			}
 527:main.c        **** 			else if (portChar == 'C') {
 528:main.c        **** 				USART_Transmit(PINC);
 529:main.c        **** 			}
 530:main.c        **** 			else if (portChar == 'D') {
 531:main.c        **** 				USART_Transmit(PIND);
 532:main.c        **** 			}
 533:main.c        **** 			else if (portChar == 'E') {
 534:main.c        **** 				USART_Transmit(PINE);
 535:main.c        **** 			}
 536:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 537:main.c        **** 		}
 538:main.c        **** 		
 539:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 540:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 541:main.c        **** 			char commonChar = USART_Receive();
 542:main.c        **** 			if (commonChar == '1') {
 543:main.c        **** 				resetCommonLines = 1;
 1122               		.loc 3 543 0
 1123 0012 4424      		clr r4
 1124 0014 4394      		inc r4
 1125 0016 20E0      		ldi r18,lo8(receivedBuffer+128)
 1126 0018 622E      		mov r6,r18
 1127 001a 20E0      		ldi r18,hi8(receivedBuffer+128)
 1128 001c 722E      		mov r7,r18
 1129               	.LVL84:
 1130               	.L45:
 1131               	.LBE122:
  60:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1132               		.loc 3 60 0
 1133 001e 21E0      		ldi r18,lo8(1)
 1134 0020 5212      		cpse r5,r18
 1135 0022 00C0      		rjmp .L46
 1136               	.LVL85:
 1137               	.L152:
  61:main.c        **** 		}
 1138               		.loc 3 61 0
 1139 0024 00D0      		rcall rd_wr_csmreq_cs2_reset
 1140               	.LVL86:
 1141               	.L46:
  63:main.c        **** 		
 1142               		.loc 3 63 0
 1143 0026 00D0      		rcall USART_Receive
 1144               	.LVL87:
 1145 0028 8093 0000 		sts receivedChar,r24
  67:main.c        **** 			USART_Transmit(cartMode);
 1146               		.loc 3 67 0
 1147 002c 8334      		cpi r24,lo8(67)
 1148 002e 01F4      		brne .L47
  68:main.c        **** 			stop_timeout_timer();
 1149               		.loc 3 68 0
 1150 0030 8091 0000 		lds r24,cartMode
 1151 0034 00D0      		rcall USART_Transmit
 1152               	.LVL88:
 1153 0036 00C0      		rjmp .L154
 1154               	.L47:
  73:main.c        **** 			gb_mode();
 1155               		.loc 3 73 0
 1156 0038 8734      		cpi r24,lo8(71)
 1157 003a 01F4      		brne .L49
  74:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
 1158               		.loc 3 74 0
 1159 003c 00D0      		rcall gb_mode
 1160               	.LVL89:
  75:main.c        **** 			stop_timeout_timer();
 1161               		.loc 3 75 0
 1162 003e 1092 0000 		sts flashBank1CommandWrites,__zero_reg__
 1163               	.L154:
  76:main.c        **** 		}
 1164               		.loc 3 76 0
 1165 0042 00D0      		rcall stop_timeout_timer
 1166               	.LVL90:
 1167 0044 00C0      		rjmp .L45
 1168               	.L49:
  80:main.c        **** 			usart_read_chars(); // Read start address
 1169               		.loc 3 80 0
 1170 0046 8134      		cpi r24,lo8(65)
 1171 0048 01F4      		brne .L50
  81:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1172               		.loc 3 81 0
 1173 004a 00D0      		rcall usart_read_chars
 1174               	.LVL91:
  82:main.c        **** 		}
 1175               		.loc 3 82 0
 1176 004c 40E1      		ldi r20,lo8(16)
 1177 004e 50E0      		ldi r21,0
 1178 0050 60E0      		ldi r22,0
 1179 0052 70E0      		ldi r23,0
 1180 0054 80E0      		ldi r24,lo8(receivedBuffer)
 1181 0056 90E0      		ldi r25,hi8(receivedBuffer)
 1182 0058 00D0      		rcall strtol
 1183               	.LVL92:
 1184 005a 6B01      		movw r12,r22
 1185 005c 7C01      		movw r14,r24
 1186               	.LVL93:
 1187 005e 00C0      		rjmp .L45
 1188               	.L50:
  89:main.c        **** 			gb_mode();
 1189               		.loc 3 89 0
 1190 0060 8235      		cpi r24,lo8(82)
 1191 0062 01F4      		brne .L51
  90:main.c        **** 			receivedChar = '1';
 1192               		.loc 3 90 0
 1193 0064 00D0      		rcall gb_mode
 1194               	.LVL94:
  91:main.c        **** 			while (receivedChar == '1') {
 1195               		.loc 3 91 0
 1196 0066 81E3      		ldi r24,lo8(49)
 1197               	.LVL95:
 1198               	.L156:
 100:main.c        **** 			}
 1199               		.loc 3 100 0
 1200 0068 8093 0000 		sts receivedChar,r24
 1201               	.LVL96:
  92:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 1202               		.loc 3 92 0
 1203 006c 8091 0000 		lds r24,receivedChar
 1204 0070 8133      		cpi r24,lo8(49)
 1205 0072 01F4      		brne .L45
  93:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1206               		.loc 3 93 0
 1207 0074 939A      		sbi 0x12,3
 1208               	.LVL97:
 1209 0076 C0E0      		ldi r28,0
 1210 0078 D0E0      		ldi r29,0
 1211               	.LVL98:
 1212               	.L53:
 1213               	.LBB123:
  95:main.c        **** 					address++;
 1214               		.loc 3 95 0 discriminator 3
 1215 007a CE01      		movw r24,r28
 1216 007c 8C0D      		add r24,r12
 1217 007e 9D1D      		adc r25,r13
 1218 0080 00D0      		rcall read_8bit_data
 1219               	.LVL99:
 1220 0082 00D0      		rcall USART_Transmit
 1221               	.LVL100:
 1222 0084 2196      		adiw r28,1
 1223               	.LVL101:
  94:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1224               		.loc 3 94 0 discriminator 3
 1225 0086 C034      		cpi r28,64
 1226 0088 D105      		cpc r29,__zero_reg__
 1227 008a 01F4      		brne .L53
 1228 008c 80E4      		ldi r24,64
 1229 008e C80E      		add r12,r24
 1230 0090 D11C      		adc r13,__zero_reg__
 1231 0092 E11C      		adc r14,__zero_reg__
 1232 0094 F11C      		adc r15,__zero_reg__
 1233               	.LBE123:
  99:main.c        **** 				receivedChar = USART_Receive();
 1234               		.loc 3 99 0
 1235 0096 9398      		cbi 0x12,3
 100:main.c        **** 			}
 1236               		.loc 3 100 0
 1237 0098 00D0      		rcall USART_Receive
 1238               	.LVL102:
 1239 009a 00C0      		rjmp .L156
 1240               	.LVL103:
 1241               	.L51:
 105:main.c        **** 			gb_mode();
 1242               		.loc 3 105 0
 1243 009c 8135      		cpi r24,lo8(81)
 1244 009e 01F4      		brne .L55
 106:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1245               		.loc 3 106 0
 1246 00a0 00D0      		rcall gb_mode
 1247               	.LVL104:
 107:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 1248               		.loc 3 107 0
 1249 00a2 939A      		sbi 0x12,3
 1250               	.LVL105:
 1251               	.LBB124:
 108:main.c        **** 				USART_Transmit(read_8bit_data(address));
 1252               		.loc 3 108 0
 1253 00a4 C0E0      		ldi r28,0
 1254 00a6 D0E0      		ldi r29,0
 1255               	.LVL106:
 1256               	.L56:
 109:main.c        **** 				address++;
 1257               		.loc 3 109 0 discriminator 3
 1258 00a8 CE01      		movw r24,r28
 1259 00aa 8C0D      		add r24,r12
 1260 00ac 9D1D      		adc r25,r13
 1261 00ae 00D0      		rcall read_8bit_data
 1262               	.LVL107:
 1263 00b0 00D0      		rcall USART_Transmit
 1264               	.LVL108:
 108:main.c        **** 				USART_Transmit(read_8bit_data(address));
 1265               		.loc 3 108 0 discriminator 3
 1266 00b2 2196      		adiw r28,1
 1267               	.LVL109:
 1268 00b4 C115      		cp r28,__zero_reg__
 1269 00b6 90E4      		ldi r25,64
 1270 00b8 D907      		cpc r29,r25
 1271 00ba 01F4      		brne .L56
 1272 00bc E0E4      		ldi r30,64
 1273 00be DE0E      		add r13,r30
 1274 00c0 E11C      		adc r14,__zero_reg__
 1275 00c2 F11C      		adc r15,__zero_reg__
 1276 00c4 00C0      		rjmp .L118
 1277               	.LVL110:
 1278               	.L55:
 1279               	.LBE124:
 116:main.c        **** 			gb_mode();
 1280               		.loc 3 116 0
 1281 00c6 8735      		cpi r24,lo8(87)
 1282 00c8 01F4      		brne .L57
 117:main.c        **** 			
 1283               		.loc 3 117 0
 1284 00ca 00D0      		rcall gb_mode
 1285               	.LVL111:
 120:main.c        **** 			
 1286               		.loc 3 120 0
 1287 00cc 80E4      		ldi r24,lo8(64)
 1288 00ce 90E0      		ldi r25,0
 1289 00d0 00D0      		rcall usart_read_bytes
 1290               	.LVL112:
 122:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1291               		.loc 3 122 0
 1292 00d2 939A      		sbi 0x12,3
 1293               	.LVL113:
 1294 00d4 00E0      		ldi r16,lo8(receivedBuffer)
 1295 00d6 10E0      		ldi r17,hi8(receivedBuffer)
 1296 00d8 C0E0      		ldi r28,0
 1297 00da D0E0      		ldi r29,0
 1298               	.LVL114:
 1299               	.L58:
 1300               	.LBB125:
 124:main.c        **** 				address++;
 1301               		.loc 3 124 0 discriminator 3
 1302 00dc F801      		movw r30,r16
 1303 00de 6191      		ld r22,Z+
 1304 00e0 8F01      		movw r16,r30
 1305 00e2 CE01      		movw r24,r28
 1306 00e4 8C0D      		add r24,r12
 1307 00e6 9D1D      		adc r25,r13
 1308 00e8 41E0      		ldi r20,lo8(1)
 1309 00ea 00D0      		rcall write_8bit_data
 1310               	.LVL115:
 1311 00ec 2196      		adiw r28,1
 1312               	.LVL116:
 123:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1313               		.loc 3 123 0 discriminator 3
 1314 00ee C034      		cpi r28,64
 1315 00f0 D105      		cpc r29,__zero_reg__
 1316 00f2 01F4      		brne .L58
 1317 00f4 F0E4      		ldi r31,64
 1318 00f6 CF0E      		add r12,r31
 1319 00f8 D11C      		adc r13,__zero_reg__
 1320 00fa E11C      		adc r14,__zero_reg__
 1321 00fc F11C      		adc r15,__zero_reg__
 1322 00fe 00C0      		rjmp .L169
 1323               	.LVL117:
 1324               	.L57:
 1325               	.LBE125:
 133:main.c        **** 			gb_mode();
 1326               		.loc 3 133 0
 1327 0100 8234      		cpi r24,lo8(66)
 1328 0102 01F4      		brne .L59
 1329               	.LBB126:
 134:main.c        **** 			
 1330               		.loc 3 134 0
 1331 0104 00D0      		rcall gb_mode
 1332               	.LVL118:
 136:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1333               		.loc 3 136 0
 1334 0106 00D0      		rcall usart_read_chars
 1335               	.LVL119:
 137:main.c        **** 			
 1336               		.loc 3 137 0
 1337 0108 40E1      		ldi r20,lo8(16)
 1338 010a 50E0      		ldi r21,0
 1339 010c 60E0      		ldi r22,0
 1340 010e 70E0      		ldi r23,0
 1341 0110 80E0      		ldi r24,lo8(receivedBuffer)
 1342 0112 90E0      		ldi r25,hi8(receivedBuffer)
 1343 0114 00D0      		rcall strtol
 1344               	.LVL120:
 1345 0116 4B01      		movw r8,r22
 1346 0118 5C01      		movw r10,r24
 1347               	.LVL121:
 139:main.c        **** 			if (receivedChar == 'B') {
 1348               		.loc 3 139 0
 1349 011a 00D0      		rcall USART_Receive
 1350               	.LVL122:
 1351 011c 8093 0000 		sts receivedChar,r24
 140:main.c        **** 				usart_read_chars(); // Read data
 1352               		.loc 3 140 0
 1353 0120 8234      		cpi r24,lo8(66)
 1354 0122 01F0      		breq .+2
 1355 0124 00C0      		rjmp .L45
 1356               	.LBB127:
 141:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1357               		.loc 3 141 0
 1358 0126 00D0      		rcall usart_read_chars
 1359               	.LVL123:
 142:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 1360               		.loc 3 142 0
 1361 0128 80E0      		ldi r24,lo8(receivedBuffer)
 1362 012a 90E0      		ldi r25,hi8(receivedBuffer)
 1363 012c 00D0      		rcall atoi
 1364               	.LVL124:
 143:main.c        **** 				
 1365               		.loc 3 143 0
 1366 012e 8093 0000 		sts lastBankAccessed,r24
 145:main.c        **** 			}
 1367               		.loc 3 145 0
 1368 0132 40E0      		ldi r20,0
 1369 0134 682F      		mov r22,r24
 1370 0136 C401      		movw r24,r8
 1371               	.LVL125:
 1372 0138 00D0      		rcall write_8bit_data
 1373               	.LVL126:
 1374 013a 00C0      		rjmp .L45
 1375               	.LVL127:
 1376               	.L59:
 1377               	.LBE127:
 1378               	.LBE126:
 152:main.c        **** 			flashWriteWePin = USART_Receive();
 1379               		.loc 3 152 0
 1380 013c 8035      		cpi r24,lo8(80)
 1381 013e 01F4      		brne .L60
 153:main.c        **** 			
 1382               		.loc 3 153 0
 1383 0140 00D0      		rcall USART_Receive
 1384               	.LVL128:
 1385 0142 8093 0000 		sts flashWriteWePin,r24
 155:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 1386               		.loc 3 155 0
 1387 0146 8134      		cpi r24,lo8(65)
 1388 0148 01F0      		breq .+2
 1389 014a 00C0      		rjmp .L45
 156:main.c        **** 				audioPin_high;
 1390               		.loc 3 156 0
 1391 014c 319A      		sbi 0x6,1
 157:main.c        **** 			}
 1392               		.loc 3 157 0
 1393 014e 399A      		sbi 0x7,1
 1394 0150 00C0      		rjmp .L45
 1395               	.L60:
 162:main.c        **** 			flashBank1CommandWrites = 1;
 1396               		.loc 3 162 0
 1397 0152 8E34      		cpi r24,lo8(78)
 1398 0154 01F4      		brne .L61
 163:main.c        **** 		}
 1399               		.loc 3 163 0
 1400 0156 4092 0000 		sts flashBank1CommandWrites,r4
 1401 015a 00C0      		rjmp .L45
 1402               	.L61:
 167:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 1403               		.loc 3 167 0
 1404 015c 8534      		cpi r24,lo8(69)
 1405 015e 01F4      		brne .L62
 1406 0160 C0E0      		ldi r28,lo8(flashWriteCycle)
 1407 0162 D0E0      		ldi r29,hi8(flashWriteCycle)
 1408               	.L63:
 1409               	.LBB128:
 169:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 1410               		.loc 3 169 0 discriminator 3
 1411 0164 00D0      		rcall usart_read_chars
 1412               	.LVL129:
 170:main.c        **** 				USART_Transmit(SEND_ACK);
 1413               		.loc 3 170 0 discriminator 3
 1414 0166 40E1      		ldi r20,lo8(16)
 1415 0168 50E0      		ldi r21,0
 1416 016a 60E0      		ldi r22,0
 1417 016c 70E0      		ldi r23,0
 1418 016e 80E0      		ldi r24,lo8(receivedBuffer)
 1419 0170 90E0      		ldi r25,hi8(receivedBuffer)
 1420 0172 00D0      		rcall strtol
 1421               	.LVL130:
 1422 0174 7983      		std Y+1,r23
 1423 0176 6883      		st Y,r22
 171:main.c        **** 				
 1424               		.loc 3 171 0 discriminator 3
 1425 0178 81E3      		ldi r24,lo8(49)
 1426 017a 00D0      		rcall USART_Transmit
 1427               	.LVL131:
 173:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 1428               		.loc 3 173 0 discriminator 3
 1429 017c 00D0      		rcall usart_read_chars
 1430               	.LVL132:
 174:main.c        **** 				USART_Transmit(SEND_ACK);
 1431               		.loc 3 174 0 discriminator 3
 1432 017e 40E1      		ldi r20,lo8(16)
 1433 0180 50E0      		ldi r21,0
 1434 0182 60E0      		ldi r22,0
 1435 0184 70E0      		ldi r23,0
 1436 0186 80E0      		ldi r24,lo8(receivedBuffer)
 1437 0188 90E0      		ldi r25,hi8(receivedBuffer)
 1438 018a 00D0      		rcall strtol
 1439               	.LVL133:
 1440 018c 7B83      		std Y+3,r23
 1441 018e 6A83      		std Y+2,r22
 175:main.c        **** 			}
 1442               		.loc 3 175 0 discriminator 3
 1443 0190 81E3      		ldi r24,lo8(49)
 1444 0192 00D0      		rcall USART_Transmit
 1445               	.LVL134:
 1446 0194 2496      		adiw r28,4
 168:main.c        **** 				usart_read_chars(); // Address
 1447               		.loc 3 168 0 discriminator 3
 1448 0196 80E0      		ldi r24,lo8(flashWriteCycle+12)
 1449 0198 90E0      		ldi r25,hi8(flashWriteCycle+12)
 1450 019a 8C17      		cp r24,r28
 1451 019c 9D07      		cpc r25,r29
 1452 019e 01F4      		brne .L63
 1453 01a0 00C0      		rjmp .L45
 1454               	.L62:
 1455               	.LBE128:
 180:main.c        **** 			usart_read_chars(); // Read address
 1456               		.loc 3 180 0
 1457 01a2 8634      		cpi r24,lo8(70)
 1458 01a4 01F4      		brne .L64
 1459               	.LBB129:
 181:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 1460               		.loc 3 181 0
 1461 01a6 00D0      		rcall usart_read_chars
 1462               	.LVL135:
 182:main.c        **** 			
 1463               		.loc 3 182 0
 1464 01a8 40E1      		ldi r20,lo8(16)
 1465 01aa 50E0      		ldi r21,0
 1466 01ac 60E0      		ldi r22,0
 1467 01ae 70E0      		ldi r23,0
 1468 01b0 80E0      		ldi r24,lo8(receivedBuffer)
 1469 01b2 90E0      		ldi r25,hi8(receivedBuffer)
 1470 01b4 00D0      		rcall strtol
 1471               	.LVL136:
 1472 01b6 4B01      		movw r8,r22
 1473 01b8 5C01      		movw r10,r24
 1474               	.LVL137:
 184:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 1475               		.loc 3 184 0
 1476 01ba 00D0      		rcall usart_read_chars
 1477               	.LVL138:
 185:main.c        **** 			
 1478               		.loc 3 185 0
 1479 01bc 40E1      		ldi r20,lo8(16)
 1480 01be 50E0      		ldi r21,0
 1481 01c0 60E0      		ldi r22,0
 1482 01c2 70E0      		ldi r23,0
 1483 01c4 80E0      		ldi r24,lo8(receivedBuffer)
 1484 01c6 90E0      		ldi r25,hi8(receivedBuffer)
 1485 01c8 00D0      		rcall strtol
 1486               	.LVL139:
 187:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 1487               		.loc 3 187 0
 1488 01ca 939A      		sbi 0x12,3
 188:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1489               		.loc 3 188 0
 1490 01cc C401      		movw r24,r8
 1491 01ce 00D0      		rcall gb_flash_write_bus_cycle
 1492               	.LVL140:
 1493               	.L169:
 189:main.c        **** 			
 1494               		.loc 3 189 0
 1495 01d0 9398      		cbi 0x12,3
 191:main.c        **** 		}
 1496               		.loc 3 191 0
 1497 01d2 81E3      		ldi r24,lo8(49)
 1498 01d4 00C0      		rjmp .L153
 1499               	.LVL141:
 1500               	.L64:
 1501               	.LBE129:
 195:main.c        **** 			usart_read_bytes(64);
 1502               		.loc 3 195 0
 1503 01d6 8435      		cpi r24,lo8(84)
 1504 01d8 01F4      		brne .L65
 196:main.c        **** 			start_timeout_timer();
 1505               		.loc 3 196 0
 1506 01da 80E4      		ldi r24,lo8(64)
 1507 01dc 90E0      		ldi r25,0
 1508 01de 00D0      		rcall usart_read_bytes
 1509               	.LVL142:
 197:main.c        **** 			
 1510               		.loc 3 197 0
 1511 01e0 00D0      		rcall start_timeout_timer
 1512               	.LVL143:
 199:main.c        **** 			if (flashBank1CommandWrites == 0) {
 1513               		.loc 3 199 0
 1514 01e2 939A      		sbi 0x12,3
 200:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1515               		.loc 3 200 0
 1516 01e4 8091 0000 		lds r24,flashBank1CommandWrites
 1517 01e8 00E0      		ldi r16,lo8(receivedBuffer)
 1518 01ea 10E0      		ldi r17,hi8(receivedBuffer)
 1519 01ec C0E0      		ldi r28,0
 1520 01ee D0E0      		ldi r29,0
 1521 01f0 8111      		cpse r24,__zero_reg__
 1522 01f2 00C0      		rjmp .L71
 1523               	.LVL144:
 1524               	.L68:
 1525               	.LBB130:
 202:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 1526               		.loc 3 202 0
 1527 01f4 F801      		movw r30,r16
 1528 01f6 6191      		ld r22,Z+
 1529 01f8 8F01      		movw r16,r30
 1530 01fa 6F3F      		cpi r22,lo8(-1)
 1531 01fc 01F0      		breq .L67
 203:main.c        **** 					}
 1532               		.loc 3 203 0
 1533 01fe CE01      		movw r24,r28
 1534 0200 8C0D      		add r24,r12
 1535 0202 9D1D      		adc r25,r13
 1536 0204 00D0      		rcall gb_flash_write_byte
 1537               	.LVL145:
 1538               	.L67:
 1539 0206 2196      		adiw r28,1
 1540               	.LVL146:
 201:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1541               		.loc 3 201 0 discriminator 2
 1542 0208 C034      		cpi r28,64
 1543 020a D105      		cpc r29,__zero_reg__
 1544 020c 01F4      		brne .L68
 1545 020e 00C0      		rjmp .L157
 1546               	.LVL147:
 1547               	.L70:
 1548 0210 2196      		adiw r28,1
 1549               	.LVL148:
 1550               	.LBE130:
 1551               	.LBB131:
 209:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1552               		.loc 3 209 0 discriminator 2
 1553 0212 C034      		cpi r28,64
 1554 0214 D105      		cpc r29,__zero_reg__
 1555 0216 01F4      		brne .+2
 1556 0218 00C0      		rjmp .L157
 1557               	.LVL149:
 1558               	.L71:
 210:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 1559               		.loc 3 210 0
 1560 021a F801      		movw r30,r16
 1561 021c 6191      		ld r22,Z+
 1562 021e 8F01      		movw r16,r30
 1563 0220 6F3F      		cpi r22,lo8(-1)
 1564 0222 01F0      		breq .L70
 211:main.c        **** 					}
 1565               		.loc 3 211 0
 1566 0224 CE01      		movw r24,r28
 1567 0226 8C0D      		add r24,r12
 1568 0228 9D1D      		adc r25,r13
 1569 022a 00D0      		rcall gb_flash_write_byte_bank1_commands
 1570               	.LVL150:
 1571 022c 00C0      		rjmp .L70
 1572               	.LVL151:
 1573               	.L65:
 1574               	.LBE131:
 221:main.c        **** 			usart_read_bytes(32);
 1575               		.loc 3 221 0
 1576 022e 8935      		cpi r24,lo8(89)
 1577 0230 01F0      		breq .+2
 1578 0232 00C0      		rjmp .L72
 1579               	.LBB132:
 222:main.c        **** 			start_timeout_timer();
 1580               		.loc 3 222 0
 1581 0234 80E2      		ldi r24,lo8(32)
 1582 0236 90E0      		ldi r25,0
 1583 0238 00D0      		rcall usart_read_bytes
 1584               	.LVL152:
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1585               		.loc 3 223 0
 1586 023a 00D0      		rcall start_timeout_timer
 1587               	.LVL153:
 224:main.c        **** 			
 1588               		.loc 3 224 0
 1589 023c 939A      		sbi 0x12,3
 227:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 1590               		.loc 3 227 0
 1591 023e 6AEA      		ldi r22,lo8(-86)
 1592 0240 8AEA      		ldi r24,lo8(-86)
 1593 0242 9AE0      		ldi r25,lo8(10)
 1594 0244 00D0      		rcall gb_flash_write_bus_cycle
 1595               	.LVL154:
 228:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 1596               		.loc 3 228 0
 1597 0246 65E5      		ldi r22,lo8(85)
 1598 0248 85E5      		ldi r24,lo8(85)
 1599 024a 95E0      		ldi r25,lo8(5)
 1600 024c 00D0      		rcall gb_flash_write_bus_cycle
 1601               	.LVL155:
 229:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 1602               		.loc 3 229 0
 1603 024e 5601      		movw r10,r12
 1604 0250 65E2      		ldi r22,lo8(37)
 1605 0252 C601      		movw r24,r12
 1606 0254 00D0      		rcall gb_flash_write_bus_cycle
 1607               	.LVL156:
 230:main.c        **** 			_delay_us(1);
 1608               		.loc 3 230 0
 1609 0256 6FE1      		ldi r22,lo8(31)
 1610 0258 C601      		movw r24,r12
 1611 025a 00D0      		rcall gb_flash_write_bus_cycle
 1612               	.LVL157:
 1613               	.LBB133:
 1614               	.LBB134:
 1615               		.loc 2 276 0
 1616 025c 25E0      		ldi r18,lo8(5)
 1617 025e 2A95      	1:	dec r18
 1618 0260 01F4      		brne 1b
 1619 0262 0000      		nop
 1620               	.LVL158:
 1621 0264 00E0      		ldi r16,lo8(receivedBuffer)
 1622 0266 10E0      		ldi r17,hi8(receivedBuffer)
 1623 0268 C0E0      		ldi r28,0
 1624 026a D0E0      		ldi r29,0
 1625               	.LVL159:
 1626               	.L73:
 1627               	.LBE134:
 1628               	.LBE133:
 1629               	.LBB135:
 235:main.c        **** 				address++;
 1630               		.loc 3 235 0 discriminator 3
 1631 026c F801      		movw r30,r16
 1632 026e 6191      		ld r22,Z+
 1633 0270 8F01      		movw r16,r30
 1634 0272 C501      		movw r24,r10
 1635 0274 8C0F      		add r24,r28
 1636 0276 9D1F      		adc r25,r29
 1637 0278 00D0      		rcall gb_flash_write_bus_cycle
 1638               	.LVL160:
 1639 027a 2196      		adiw r28,1
 1640               	.LVL161:
 234:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1641               		.loc 3 234 0 discriminator 3
 1642 027c C032      		cpi r28,32
 1643 027e D105      		cpc r29,__zero_reg__
 1644 0280 01F4      		brne .L73
 1645 0282 F0E2      		ldi r31,32
 1646 0284 CF0E      		add r12,r31
 1647 0286 D11C      		adc r13,__zero_reg__
 1648 0288 E11C      		adc r14,__zero_reg__
 1649 028a F11C      		adc r15,__zero_reg__
 1650               	.LBE135:
 240:main.c        **** 			_delay_us(200);
 1651               		.loc 3 240 0
 1652 028c C601      		movw r24,r12
 1653 028e 8097      		sbiw r24,32
 1654 0290 69E2      		ldi r22,lo8(41)
 1655 0292 00D0      		rcall gb_flash_write_bus_cycle
 1656               	.LVL162:
 1657               	.LBB136:
 1658               	.LBB137:
 1659               		.loc 2 276 0
 1660 0294 8FE1      		ldi r24,lo8(799)
 1661 0296 93E0      		ldi r25,hi8(799)
 1662 0298 0197      	1:	sbiw r24,1
 1663 029a 01F4      		brne 1b
 1664 029c 00C0      		rjmp .
 1665 029e 0000      		nop
 1666               	.LVL163:
 1667               	.LBE137:
 1668               	.LBE136:
 244:main.c        **** 			uint8_t verifyCount = 0;
 1669               		.loc 3 244 0
 1670 02a0 E601      		movw r28,r12
 1671               	.LVL164:
 1672 02a2 2197      		sbiw r28,1
 1673 02a4 CE01      		movw r24,r28
 1674 02a6 00D0      		rcall gb_flash_read_byte
 1675               	.LVL165:
 1676               	.L74:
 246:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1677               		.loc 3 246 0
 1678 02a8 9091 0000 		lds r25,receivedBuffer+31
 1679 02ac 8917      		cp r24,r25
 1680 02ae 01F4      		brne .+2
 1681 02b0 00C0      		rjmp .L84
 247:main.c        **** 				_delay_us(5);
 1682               		.loc 3 247 0
 1683 02b2 CE01      		movw r24,r28
 1684               	.LVL166:
 1685 02b4 00D0      		rcall gb_flash_read_byte
 1686               	.LVL167:
 1687               	.LBB138:
 1688               	.LBB139:
 1689               		.loc 2 276 0
 1690 02b6 9AE1      		ldi r25,lo8(26)
 1691 02b8 9A95      	1:	dec r25
 1692 02ba 01F4      		brne 1b
 1693 02bc 00C0      		rjmp .
 1694               	.LVL168:
 1695               	.LBE139:
 1696               	.LBE138:
 250:main.c        **** 					break;
 1697               		.loc 3 250 0
 1698 02be 9091 0000 		lds r25,writingTimedout
 1699 02c2 9130      		cpi r25,lo8(1)
 1700 02c4 01F4      		brne .L74
 1701 02c6 00C0      		rjmp .L84
 1702               	.LVL169:
 1703               	.L72:
 1704               	.LBE132:
 259:main.c        **** 			usart_read_bytes(64);
 1705               		.loc 3 259 0
 1706 02c8 8A34      		cpi r24,lo8(74)
 1707 02ca 01F4      		brne .L77
 260:main.c        **** 			start_timeout_timer();
 1708               		.loc 3 260 0
 1709 02cc 80E4      		ldi r24,lo8(64)
 1710 02ce 90E0      		ldi r25,0
 1711 02d0 00D0      		rcall usart_read_bytes
 1712               	.LVL170:
 261:main.c        **** 			
 1713               		.loc 3 261 0
 1714 02d2 00D0      		rcall start_timeout_timer
 1715               	.LVL171:
 263:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1716               		.loc 3 263 0
 1717 02d4 939A      		sbi 0x12,3
 1718               	.LVL172:
 1719 02d6 00E0      		ldi r16,lo8(receivedBuffer)
 1720 02d8 10E0      		ldi r17,hi8(receivedBuffer)
 1721 02da C0E0      		ldi r28,0
 1722 02dc D0E0      		ldi r29,0
 1723               	.LVL173:
 1724               	.L79:
 1725               	.LBB140:
 265:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 1726               		.loc 3 265 0
 1727 02de F801      		movw r30,r16
 1728 02e0 6191      		ld r22,Z+
 1729 02e2 8F01      		movw r16,r30
 1730 02e4 6F3F      		cpi r22,lo8(-1)
 1731 02e6 01F0      		breq .L78
 266:main.c        **** 				}
 1732               		.loc 3 266 0
 1733 02e8 CE01      		movw r24,r28
 1734 02ea 8C0D      		add r24,r12
 1735 02ec 9D1D      		adc r25,r13
 1736 02ee 00D0      		rcall gb_flash_write_byte_special
 1737               	.LVL174:
 1738               	.L78:
 1739 02f0 2196      		adiw r28,1
 1740               	.LVL175:
 264:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 1741               		.loc 3 264 0 discriminator 2
 1742 02f2 C034      		cpi r28,64
 1743 02f4 D105      		cpc r29,__zero_reg__
 1744 02f6 01F4      		brne .L79
 1745               	.LVL176:
 1746               	.L157:
 1747 02f8 F0E4      		ldi r31,64
 1748 02fa CF0E      		add r12,r31
 1749 02fc D11C      		adc r13,__zero_reg__
 1750 02fe E11C      		adc r14,__zero_reg__
 1751 0300 F11C      		adc r15,__zero_reg__
 1752 0302 00C0      		rjmp .L84
 1753               	.LVL177:
 1754               	.L77:
 1755               	.LBE140:
 275:main.c        **** 			usart_read_bytes(256);
 1756               		.loc 3 275 0
 1757 0304 8835      		cpi r24,lo8(88)
 1758 0306 01F0      		breq .+2
 1759 0308 00C0      		rjmp .L80
 1760               	.LBB141:
 276:main.c        **** 			start_timeout_timer();
 1761               		.loc 3 276 0
 1762 030a 80E0      		ldi r24,0
 1763 030c 91E0      		ldi r25,lo8(1)
 1764 030e 00D0      		rcall usart_read_bytes
 1765               	.LVL178:
 277:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1766               		.loc 3 277 0
 1767 0310 00D0      		rcall start_timeout_timer
 1768               	.LVL179:
 278:main.c        **** 			
 1769               		.loc 3 278 0
 1770 0312 939A      		sbi 0x12,3
 281:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 1771               		.loc 3 281 0
 1772 0314 69EA      		ldi r22,lo8(-87)
 1773 0316 8AEA      		ldi r24,lo8(-86)
 1774 0318 9AE0      		ldi r25,lo8(10)
 1775 031a 00D0      		rcall gb_flash_write_bus_cycle
 1776               	.LVL180:
 282:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 1777               		.loc 3 282 0
 1778 031c 66E5      		ldi r22,lo8(86)
 1779 031e 85E5      		ldi r24,lo8(85)
 1780 0320 95E0      		ldi r25,lo8(5)
 1781 0322 00D0      		rcall gb_flash_write_bus_cycle
 1782               	.LVL181:
 283:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 1783               		.loc 3 283 0
 1784 0324 5601      		movw r10,r12
 1785 0326 66E2      		ldi r22,lo8(38)
 1786 0328 C601      		movw r24,r12
 1787 032a 00D0      		rcall gb_flash_write_bus_cycle
 1788               	.LVL182:
 284:main.c        **** 			_delay_us(50);
 1789               		.loc 3 284 0
 1790 032c 6FEF      		ldi r22,lo8(-1)
 1791 032e C601      		movw r24,r12
 1792 0330 00D0      		rcall gb_flash_write_bus_cycle
 1793               	.LVL183:
 1794               	.LBB142:
 1795               	.LBB143:
 1796               		.loc 2 276 0
 1797 0332 87EC      		ldi r24,lo8(199)
 1798 0334 90E0      		ldi r25,hi8(199)
 1799 0336 0197      	1:	sbiw r24,1
 1800 0338 01F4      		brne 1b
 1801 033a 00C0      		rjmp .
 1802 033c 0000      		nop
 1803               	.LVL184:
 1804 033e 00E0      		ldi r16,lo8(receivedBuffer)
 1805 0340 10E0      		ldi r17,hi8(receivedBuffer)
 1806               	.LBE143:
 1807               	.LBE142:
 1808               	.LBB144:
 288:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1809               		.loc 3 288 0
 1810 0342 C0E0      		ldi r28,0
 1811 0344 D0E0      		ldi r29,0
 1812               	.LVL185:
 1813               	.L81:
 289:main.c        **** 				address++;
 1814               		.loc 3 289 0 discriminator 3
 1815 0346 F801      		movw r30,r16
 1816 0348 6191      		ld r22,Z+
 1817 034a 8F01      		movw r16,r30
 1818 034c CE01      		movw r24,r28
 1819 034e 8A0D      		add r24,r10
 1820 0350 9B1D      		adc r25,r11
 1821 0352 00D0      		rcall gb_flash_write_bus_cycle
 1822               	.LVL186:
 288:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1823               		.loc 3 288 0 discriminator 3
 1824 0354 2196      		adiw r28,1
 1825               	.LVL187:
 1826 0356 C115      		cp r28,__zero_reg__
 1827 0358 F1E0      		ldi r31,1
 1828 035a DF07      		cpc r29,r31
 1829 035c 01F4      		brne .L81
 1830 035e 2FEF      		ldi r18,-1
 1831 0360 D21A      		sub r13,r18
 1832 0362 E20A      		sbc r14,r18
 1833 0364 F20A      		sbc r15,r18
 1834               	.LBE144:
 294:main.c        **** 			
 1835               		.loc 3 294 0
 1836 0366 C601      		movw r24,r12
 1837 0368 9A95      		dec r25
 1838 036a 6AE2      		ldi r22,lo8(42)
 1839 036c 00D0      		rcall gb_flash_write_bus_cycle
 1840               	.LVL188:
 297:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 1841               		.loc 3 297 0
 1842 036e E601      		movw r28,r12
 1843               	.LVL189:
 1844 0370 2197      		sbiw r28,1
 1845 0372 CE01      		movw r24,r28
 1846 0374 00D0      		rcall gb_flash_read_byte
 1847               	.LVL190:
 1848               	.L82:
 298:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1849               		.loc 3 298 0
 1850 0376 9091 0000 		lds r25,receivedBuffer+255
 1851 037a 8917      		cp r24,r25
 1852 037c 01F0      		breq .L84
 299:main.c        **** 				_delay_us(5);
 1853               		.loc 3 299 0
 1854 037e CE01      		movw r24,r28
 1855               	.LVL191:
 1856 0380 00D0      		rcall gb_flash_read_byte
 1857               	.LVL192:
 1858               	.LBB145:
 1859               	.LBB146:
 1860               		.loc 2 276 0
 1861 0382 9AE1      		ldi r25,lo8(26)
 1862 0384 9A95      	1:	dec r25
 1863 0386 01F4      		brne 1b
 1864 0388 00C0      		rjmp .
 1865               	.LVL193:
 1866               	.LBE146:
 1867               	.LBE145:
 301:main.c        **** 					break;
 1868               		.loc 3 301 0
 1869 038a 9091 0000 		lds r25,writingTimedout
 1870 038e 9130      		cpi r25,lo8(1)
 1871 0390 01F4      		brne .L82
 1872               	.LVL194:
 1873               	.L84:
 306:main.c        **** 		}
 1874               		.loc 3 306 0
 1875 0392 00D0      		rcall check_if_timed_out
 1876               	.LVL195:
 1877               	.LBE141:
 1878 0394 00C0      		rjmp .L45
 1879               	.LVL196:
 1880               	.L80:
 310:main.c        **** 			usart_read_bytes(128);
 1881               		.loc 3 310 0
 1882 0396 8A35      		cpi r24,lo8(90)
 1883 0398 01F0      		breq .+2
 1884 039a 00C0      		rjmp .L85
 311:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1885               		.loc 3 311 0
 1886 039c 80E8      		ldi r24,lo8(-128)
 1887 039e 90E0      		ldi r25,0
 1888 03a0 00D0      		rcall usart_read_bytes
 1889               	.LVL197:
 312:main.c        **** 			
 1890               		.loc 3 312 0
 1891 03a2 939A      		sbi 0x12,3
 315:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 1892               		.loc 3 315 0
 1893 03a4 69E0      		ldi r22,lo8(9)
 1894 03a6 80E2      		ldi r24,lo8(32)
 1895 03a8 91E0      		ldi r25,lo8(1)
 1896 03aa 00D0      		rcall gb_flash_write_bus_cycle
 1897               	.LVL198:
 316:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 1898               		.loc 3 316 0
 1899 03ac 6AEA      		ldi r22,lo8(-86)
 1900 03ae 81E2      		ldi r24,lo8(33)
 1901 03b0 91E0      		ldi r25,lo8(1)
 1902 03b2 00D0      		rcall gb_flash_write_bus_cycle
 1903               	.LVL199:
 317:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1904               		.loc 3 317 0
 1905 03b4 65E5      		ldi r22,lo8(85)
 1906 03b6 82E2      		ldi r24,lo8(34)
 1907 03b8 91E0      		ldi r25,lo8(1)
 1908 03ba 00D0      		rcall gb_flash_write_bus_cycle
 1909               	.LVL200:
 318:main.c        **** 			_delay_us(5);
 1910               		.loc 3 318 0
 1911 03bc 65EA      		ldi r22,lo8(-91)
 1912 03be 8FE3      		ldi r24,lo8(63)
 1913 03c0 91E0      		ldi r25,lo8(1)
 1914 03c2 00D0      		rcall gb_flash_write_bus_cycle
 1915               	.LVL201:
 1916               	.LBB147:
 1917               	.LBB148:
 1918               		.loc 2 276 0
 1919 03c4 EAE1      		ldi r30,lo8(26)
 1920 03c6 EA95      	1:	dec r30
 1921 03c8 01F4      		brne 1b
 1922 03ca 00C0      		rjmp .
 1923               	.LVL202:
 1924               	.LBE148:
 1925               	.LBE147:
 322:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1926               		.loc 3 322 0
 1927 03cc 61E1      		ldi r22,lo8(17)
 1928 03ce 80E2      		ldi r24,lo8(32)
 1929 03d0 91E0      		ldi r25,lo8(1)
 1930 03d2 00D0      		rcall gb_flash_write_bus_cycle
 1931               	.LVL203:
 323:main.c        **** 			_delay_us(5);
 1932               		.loc 3 323 0
 1933 03d4 65EA      		ldi r22,lo8(-91)
 1934 03d6 8FE3      		ldi r24,lo8(63)
 1935 03d8 91E0      		ldi r25,lo8(1)
 1936 03da 00D0      		rcall gb_flash_write_bus_cycle
 1937               	.LVL204:
 1938               	.LBB149:
 1939               	.LBB150:
 1940               		.loc 2 276 0
 1941 03dc FAE1      		ldi r31,lo8(26)
 1942 03de FA95      	1:	dec r31
 1943 03e0 01F4      		brne 1b
 1944 03e2 00C0      		rjmp .
 1945               	.LVL205:
 1946               	.LBE150:
 1947               	.LBE149:
 327:main.c        **** 			_delay_us(5);
 1948               		.loc 3 327 0
 1949 03e4 61E0      		ldi r22,lo8(1)
 1950 03e6 80E0      		ldi r24,0
 1951 03e8 91E2      		ldi r25,lo8(33)
 1952 03ea 00D0      		rcall gb_flash_write_bus_cycle
 1953               	.LVL206:
 1954               	.LBB151:
 1955               	.LBB152:
 1956               		.loc 2 276 0
 1957 03ec 2AE1      		ldi r18,lo8(26)
 1958 03ee 2A95      	1:	dec r18
 1959 03f0 01F4      		brne 1b
 1960 03f2 00C0      		rjmp .
 1961               	.LVL207:
 1962               	.LBE152:
 1963               	.LBE151:
 332:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1964               		.loc 3 332 0
 1965 03f4 6FE0      		ldi r22,lo8(15)
 1966 03f6 80E2      		ldi r24,lo8(32)
 1967 03f8 91E0      		ldi r25,lo8(1)
 1968 03fa 00D0      		rcall gb_flash_write_bus_cycle
 1969               	.LVL208:
 333:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1970               		.loc 3 333 0
 1971 03fc 65E5      		ldi r22,lo8(85)
 1972 03fe 85E2      		ldi r24,lo8(37)
 1973 0400 91E0      		ldi r25,lo8(1)
 1974 0402 00D0      		rcall gb_flash_write_bus_cycle
 1975               	.LVL209:
 334:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 1976               		.loc 3 334 0
 1977 0404 65E5      		ldi r22,lo8(85)
 1978 0406 86E2      		ldi r24,lo8(38)
 1979 0408 91E0      		ldi r25,lo8(1)
 1980 040a 00D0      		rcall gb_flash_write_bus_cycle
 1981               	.LVL210:
 335:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1982               		.loc 3 335 0
 1983 040c 6AEA      		ldi r22,lo8(-86)
 1984 040e 87E2      		ldi r24,lo8(39)
 1985 0410 91E0      		ldi r25,lo8(1)
 1986 0412 00D0      		rcall gb_flash_write_bus_cycle
 1987               	.LVL211:
 336:main.c        **** 			_delay_us(5);
 1988               		.loc 3 336 0
 1989 0414 65EA      		ldi r22,lo8(-91)
 1990 0416 8FE3      		ldi r24,lo8(63)
 1991 0418 91E0      		ldi r25,lo8(1)
 1992 041a 00D0      		rcall gb_flash_write_bus_cycle
 1993               	.LVL212:
 1994               	.LBB153:
 1995               	.LBB154:
 1996               		.loc 2 276 0
 1997 041c 8AE1      		ldi r24,lo8(26)
 1998 041e 8A95      	1:	dec r24
 1999 0420 01F4      		brne 1b
 2000 0422 00C0      		rjmp .
 2001               	.LVL213:
 2002               	.LBE154:
 2003               	.LBE153:
 339:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 2004               		.loc 3 339 0
 2005 0424 6FE0      		ldi r22,lo8(15)
 2006 0426 80E2      		ldi r24,lo8(32)
 2007 0428 91E0      		ldi r25,lo8(1)
 2008 042a 00D0      		rcall gb_flash_write_bus_cycle
 2009               	.LVL214:
 340:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 2010               		.loc 3 340 0
 2011 042c 6AE2      		ldi r22,lo8(42)
 2012 042e 85E2      		ldi r24,lo8(37)
 2013 0430 91E0      		ldi r25,lo8(1)
 2014 0432 00D0      		rcall gb_flash_write_bus_cycle
 2015               	.LVL215:
 341:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 2016               		.loc 3 341 0
 2017 0434 6AEA      		ldi r22,lo8(-86)
 2018 0436 86E2      		ldi r24,lo8(38)
 2019 0438 91E0      		ldi r25,lo8(1)
 2020 043a 00D0      		rcall gb_flash_write_bus_cycle
 2021               	.LVL216:
 342:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 2022               		.loc 3 342 0
 2023 043c 65E5      		ldi r22,lo8(85)
 2024 043e 87E2      		ldi r24,lo8(39)
 2025 0440 91E0      		ldi r25,lo8(1)
 2026 0442 00D0      		rcall gb_flash_write_bus_cycle
 2027               	.LVL217:
 343:main.c        **** 			_delay_us(5);
 2028               		.loc 3 343 0
 2029 0444 65EA      		ldi r22,lo8(-91)
 2030 0446 8FE3      		ldi r24,lo8(63)
 2031 0448 91E0      		ldi r25,lo8(1)
 2032 044a 00D0      		rcall gb_flash_write_bus_cycle
 2033               	.LVL218:
 2034               	.LBB155:
 2035               	.LBB156:
 2036               		.loc 2 276 0
 2037 044c 9AE1      		ldi r25,lo8(26)
 2038 044e 9A95      	1:	dec r25
 2039 0450 01F4      		brne 1b
 2040 0452 00C0      		rjmp .
 2041               	.LVL219:
 2042               	.LBE156:
 2043               	.LBE155:
 346:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 2044               		.loc 3 346 0
 2045 0454 6FE0      		ldi r22,lo8(15)
 2046 0456 80E2      		ldi r24,lo8(32)
 2047 0458 91E0      		ldi r25,lo8(1)
 2048 045a 00D0      		rcall gb_flash_write_bus_cycle
 2049               	.LVL220:
 347:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 2050               		.loc 3 347 0
 2051 045c 65E5      		ldi r22,lo8(85)
 2052 045e 85E2      		ldi r24,lo8(37)
 2053 0460 91E0      		ldi r25,lo8(1)
 2054 0462 00D0      		rcall gb_flash_write_bus_cycle
 2055               	.LVL221:
 348:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 2056               		.loc 3 348 0
 2057 0464 65E5      		ldi r22,lo8(85)
 2058 0466 86E2      		ldi r24,lo8(38)
 2059 0468 91E0      		ldi r25,lo8(1)
 2060 046a 00D0      		rcall gb_flash_write_bus_cycle
 2061               	.LVL222:
 349:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 2062               		.loc 3 349 0
 2063 046c 60EA      		ldi r22,lo8(-96)
 2064 046e 87E2      		ldi r24,lo8(39)
 2065 0470 91E0      		ldi r25,lo8(1)
 2066 0472 00D0      		rcall gb_flash_write_bus_cycle
 2067               	.LVL223:
 350:main.c        **** 			_delay_us(5);
 2068               		.loc 3 350 0
 2069 0474 65EA      		ldi r22,lo8(-91)
 2070 0476 8FE3      		ldi r24,lo8(63)
 2071 0478 91E0      		ldi r25,lo8(1)
 2072 047a 00D0      		rcall gb_flash_write_bus_cycle
 2073               	.LVL224:
 2074               	.LBB157:
 2075               	.LBB158:
 2076               		.loc 2 276 0
 2077 047c EAE1      		ldi r30,lo8(26)
 2078 047e EA95      	1:	dec r30
 2079 0480 01F4      		brne 1b
 2080 0482 00C0      		rjmp .
 2081               	.LVL225:
 2082               	.LBE158:
 2083               	.LBE157:
 354:main.c        **** 			_delay_us(5);
 2084               		.loc 3 354 0
 2085 0484 40E0      		ldi r20,0
 2086 0486 6091 0000 		lds r22,lastBankAccessed
 2087 048a 80E0      		ldi r24,0
 2088 048c 91E2      		ldi r25,lo8(33)
 2089 048e 00D0      		rcall write_8bit_data
 2090               	.LVL226:
 2091               	.LBB159:
 2092               	.LBB160:
 2093               		.loc 2 276 0
 2094 0490 FAE1      		ldi r31,lo8(26)
 2095 0492 FA95      	1:	dec r31
 2096 0494 01F4      		brne 1b
 2097 0496 00C0      		rjmp .
 2098               	.LVL227:
 2099               	.LBE160:
 2100               	.LBE159:
 358:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 2101               		.loc 3 358 0
 2102 0498 60E1      		ldi r22,lo8(16)
 2103 049a 80E2      		ldi r24,lo8(32)
 2104 049c 91E0      		ldi r25,lo8(1)
 2105 049e 00D0      		rcall gb_flash_write_bus_cycle
 2106               	.LVL228:
 359:main.c        **** 			_delay_us(5);
 2107               		.loc 3 359 0
 2108 04a0 65EA      		ldi r22,lo8(-91)
 2109 04a2 8FE3      		ldi r24,lo8(63)
 2110 04a4 91E0      		ldi r25,lo8(1)
 2111 04a6 00D0      		rcall gb_flash_write_bus_cycle
 2112               	.LVL229:
 2113               	.LBB161:
 2114               	.LBB162:
 2115               		.loc 2 276 0
 2116 04a8 2AE1      		ldi r18,lo8(26)
 2117 04aa 2A95      	1:	dec r18
 2118 04ac 01F4      		brne 1b
 2119 04ae 00C0      		rjmp .
 2120               	.LVL230:
 2121               	.LBE162:
 2122               	.LBE161:
 363:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 2123               		.loc 3 363 0
 2124 04b0 68E0      		ldi r22,lo8(8)
 2125 04b2 80E2      		ldi r24,lo8(32)
 2126 04b4 91E0      		ldi r25,lo8(1)
 2127 04b6 00D0      		rcall gb_flash_write_bus_cycle
 2128               	.LVL231:
 364:main.c        **** 			_delay_us(5);
 2129               		.loc 3 364 0
 2130 04b8 65EA      		ldi r22,lo8(-91)
 2131 04ba 8FE3      		ldi r24,lo8(63)
 2132 04bc 91E0      		ldi r25,lo8(1)
 2133 04be 00D0      		rcall gb_flash_write_bus_cycle
 2134               	.LVL232:
 2135               	.LBB163:
 2136               	.LBB164:
 2137               		.loc 2 276 0
 2138 04c0 8AE1      		ldi r24,lo8(26)
 2139 04c2 8A95      	1:	dec r24
 2140 04c4 01F4      		brne 1b
 2141 04c6 00C0      		rjmp .
 2142               	.LVL233:
 2143 04c8 C0E0      		ldi r28,lo8(receivedBuffer)
 2144 04ca D0E0      		ldi r29,hi8(receivedBuffer)
 2145               	.L86:
 2146               	.LBE164:
 2147               	.LBE163:
 2148               	.LBB165:
 369:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2149               		.loc 3 369 0 discriminator 1
 2150 04cc 6C16      		cp r6,r28
 2151 04ce 7D06      		cpc r7,r29
 2152 04d0 01F0      		breq .L170
 370:main.c        **** 				_delay_us(5);
 2153               		.loc 3 370 0 discriminator 3
 2154 04d2 6991      		ld r22,Y+
 2155 04d4 C601      		movw r24,r12
 2156 04d6 00D0      		rcall gb_flash_write_bus_cycle
 2157               	.LVL234:
 2158               	.LBB166:
 2159               	.LBB167:
 2160               		.loc 2 276 0 discriminator 3
 2161 04d8 9AE1      		ldi r25,lo8(26)
 2162 04da 9A95      	1:	dec r25
 2163 04dc 01F4      		brne 1b
 2164 04de 00C0      		rjmp .
 2165               	.LVL235:
 2166               	.LBE167:
 2167               	.LBE166:
 372:main.c        **** 			}
 2168               		.loc 3 372 0 discriminator 3
 2169 04e0 EFEF      		ldi r30,-1
 2170 04e2 CE1A      		sub r12,r30
 2171 04e4 DE0A      		sbc r13,r30
 2172 04e6 EE0A      		sbc r14,r30
 2173 04e8 FE0A      		sbc r15,r30
 2174               	.LVL236:
 2175 04ea 00C0      		rjmp .L86
 2176               	.L170:
 2177               	.LVL237:
 2178               	.LBE165:
 377:main.c        **** 			address++;
 2179               		.loc 3 377 0
 2180 04ec 6FEF      		ldi r22,lo8(-1)
 2181 04ee D701      		movw r26,r14
 2182 04f0 C601      		movw r24,r12
 2183 04f2 0197      		sbiw r24,1
 2184 04f4 A109      		sbc r26,__zero_reg__
 2185 04f6 B109      		sbc r27,__zero_reg__
 2186               	.LVL238:
 2187 04f8 00D0      		rcall gb_flash_write_bus_cycle
 2188               	.LVL239:
 2189               	.LBB168:
 2190               	.LBB169:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2191               		.loc 2 187 0
 2192 04fa 8FE3      		ldi r24,lo8(-25537)
 2193 04fc 9CE9      		ldi r25,hi8(-25537)
 2194 04fe 0197      	1:	sbiw r24,1
 2195 0500 01F4      		brne 1b
 2196 0502 00C0      		rjmp .
 2197 0504 0000      		nop
 2198               	.LVL240:
 2199 0506 00C0      		rjmp .L158
 2200               	.LVL241:
 2201               	.L85:
 2202               	.LBE169:
 2203               	.LBE168:
 387:main.c        **** 			usart_read_bytes(32);
 2204               		.loc 3 387 0
 2205 0508 8937      		cpi r24,lo8(121)
 2206 050a 01F4      		brne .L88
 388:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2207               		.loc 3 388 0
 2208 050c 80E2      		ldi r24,lo8(32)
 2209 050e 90E0      		ldi r25,0
 2210 0510 00D0      		rcall usart_read_bytes
 2211               	.LVL242:
 389:main.c        **** 			
 2212               		.loc 3 389 0
 2213 0512 939A      		sbi 0x12,3
 392:main.c        **** 			
 2214               		.loc 3 392 0
 2215 0514 8601      		movw r16,r12
 2216 0516 68EE      		ldi r22,lo8(-24)
 2217 0518 C601      		movw r24,r12
 2218 051a 00D0      		rcall gb_flash_write_bus_cycle
 2219               	.LVL243:
 2220               	.L89:
 396:main.c        **** 			
 2221               		.loc 3 396 0 discriminator 1
 2222 051c C801      		movw r24,r16
 2223 051e 00D0      		rcall gb_flash_read_byte
 2224               	.LVL244:
 2225 0520 8038      		cpi r24,lo8(-128)
 2226 0522 01F4      		brne .L89
 399:main.c        **** 			
 2227               		.loc 3 399 0
 2228 0524 6FE1      		ldi r22,lo8(31)
 2229 0526 C801      		movw r24,r16
 2230 0528 00D0      		rcall gb_flash_write_bus_cycle
 2231               	.LVL245:
 2232 052a 80E0      		ldi r24,lo8(receivedBuffer)
 2233 052c A82E      		mov r10,r24
 2234 052e 80E0      		ldi r24,hi8(receivedBuffer)
 2235 0530 B82E      		mov r11,r24
 2236 0532 C0E0      		ldi r28,0
 2237 0534 D0E0      		ldi r29,0
 2238               	.LVL246:
 2239               	.L90:
 2240               	.LBB170:
 403:main.c        **** 				address++;
 2241               		.loc 3 403 0 discriminator 3
 2242 0536 F501      		movw r30,r10
 2243 0538 6191      		ld r22,Z+
 2244 053a 5F01      		movw r10,r30
 2245 053c CE01      		movw r24,r28
 2246 053e 800F      		add r24,r16
 2247 0540 911F      		adc r25,r17
 2248 0542 00D0      		rcall gb_flash_write_bus_cycle
 2249               	.LVL247:
 2250 0544 2196      		adiw r28,1
 2251               	.LVL248:
 402:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2252               		.loc 3 402 0 discriminator 3
 2253 0546 C032      		cpi r28,32
 2254 0548 D105      		cpc r29,__zero_reg__
 2255 054a 01F4      		brne .L90
 2256 054c F0E2      		ldi r31,32
 2257 054e CF0E      		add r12,r31
 2258 0550 D11C      		adc r13,__zero_reg__
 2259 0552 E11C      		adc r14,__zero_reg__
 2260 0554 F11C      		adc r15,__zero_reg__
 2261               	.LBE170:
 408:main.c        **** 			_delay_us(196);
 2262               		.loc 3 408 0
 2263 0556 E601      		movw r28,r12
 2264               	.LVL249:
 2265 0558 A097      		sbiw r28,32
 2266 055a 60ED      		ldi r22,lo8(-48)
 2267 055c CE01      		movw r24,r28
 2268 055e 00D0      		rcall gb_flash_write_bus_cycle
 2269               	.LVL250:
 2270               	.LBB171:
 2271               	.LBB172:
 2272               		.loc 2 276 0
 2273 0560 8FE0      		ldi r24,lo8(783)
 2274 0562 93E0      		ldi r25,hi8(783)
 2275 0564 0197      	1:	sbiw r24,1
 2276 0566 01F4      		brne 1b
 2277 0568 00C0      		rjmp .
 2278 056a 0000      		nop
 2279               	.L91:
 2280               	.LBE172:
 2281               	.LBE171:
 413:main.c        **** 			
 2282               		.loc 3 413 0 discriminator 1
 2283 056c CE01      		movw r24,r28
 2284 056e 00D0      		rcall gb_flash_read_byte
 2285               	.LVL251:
 2286 0570 8038      		cpi r24,lo8(-128)
 2287 0572 01F4      		brne .L91
 2288               	.LVL252:
 2289               	.L158:
 415:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2290               		.loc 3 415 0
 2291 0574 81E3      		ldi r24,lo8(49)
 2292 0576 00C0      		rjmp .L155
 2293               	.LVL253:
 2294               	.L88:
 423:main.c        **** 			char portChar = USART_Receive();
 2295               		.loc 3 423 0
 2296 0578 8934      		cpi r24,lo8(73)
 2297 057a 01F0      		breq .L92
 423:main.c        **** 			char portChar = USART_Receive();
 2298               		.loc 3 423 0 is_stmt 0 discriminator 1
 2299 057c 8F34      		cpi r24,lo8(79)
 2300 057e 01F0      		breq .+2
 2301 0580 00C0      		rjmp .L93
 2302               	.L92:
 2303               	.LBB173:
 424:main.c        **** 			usart_read_chars();
 2304               		.loc 3 424 0 is_stmt 1
 2305 0582 00D0      		rcall USART_Receive
 2306               	.LVL254:
 2307 0584 C82F      		mov r28,r24
 2308               	.LVL255:
 425:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2309               		.loc 3 425 0
 2310 0586 00D0      		rcall usart_read_chars
 2311               	.LVL256:
 426:main.c        **** 			
 2312               		.loc 3 426 0
 2313 0588 40E1      		ldi r20,lo8(16)
 2314 058a 50E0      		ldi r21,0
 2315 058c 60E0      		ldi r22,0
 2316 058e 70E0      		ldi r23,0
 2317 0590 80E0      		ldi r24,lo8(receivedBuffer)
 2318 0592 90E0      		ldi r25,hi8(receivedBuffer)
 2319 0594 00D0      		rcall strtol
 2320               	.LVL257:
 428:main.c        **** 			if (receivedChar == SET_INPUT) {
 2321               		.loc 3 428 0
 2322 0596 939A      		sbi 0x12,3
 429:main.c        **** 				if (portChar == 'A') {
 2323               		.loc 3 429 0
 2324 0598 8091 0000 		lds r24,receivedChar
 2325 059c 8934      		cpi r24,lo8(73)
 2326 059e 01F4      		brne .L94
 430:main.c        **** 					DDRA &= ~(setValue);
 2327               		.loc 3 430 0
 2328 05a0 C134      		cpi r28,lo8(65)
 2329 05a2 01F4      		brne .L95
 431:main.c        **** 				}
 2330               		.loc 3 431 0
 2331 05a4 8AB3      		in r24,0x1a
 2332 05a6 6095      		com r22
 2333               	.LVL258:
 2334 05a8 6823      		and r22,r24
 2335               	.LVL259:
 2336 05aa 00C0      		rjmp .L160
 2337               	.LVL260:
 2338               	.L95:
 433:main.c        **** 					DDRB &= ~(setValue);
 2339               		.loc 3 433 0
 2340 05ac C234      		cpi r28,lo8(66)
 2341 05ae 01F4      		brne .L97
 434:main.c        **** 				}
 2342               		.loc 3 434 0
 2343 05b0 87B3      		in r24,0x17
 2344 05b2 6095      		com r22
 2345               	.LVL261:
 2346 05b4 6823      		and r22,r24
 2347               	.LVL262:
 2348 05b6 00C0      		rjmp .L161
 2349               	.LVL263:
 2350               	.L97:
 436:main.c        **** 					DDRC &= ~(setValue);
 2351               		.loc 3 436 0
 2352 05b8 C334      		cpi r28,lo8(67)
 2353 05ba 01F4      		brne .L98
 437:main.c        **** 				}
 2354               		.loc 3 437 0
 2355 05bc 84B3      		in r24,0x14
 2356 05be 6095      		com r22
 2357               	.LVL264:
 2358 05c0 6823      		and r22,r24
 2359               	.LVL265:
 2360 05c2 00C0      		rjmp .L166
 2361               	.LVL266:
 2362               	.L98:
 439:main.c        **** 					DDRD &= ~(setValue);
 2363               		.loc 3 439 0
 2364 05c4 C434      		cpi r28,lo8(68)
 2365 05c6 01F4      		brne .L99
 440:main.c        **** 				}
 2366               		.loc 3 440 0
 2367 05c8 81B3      		in r24,0x11
 2368 05ca 6095      		com r22
 2369               	.LVL267:
 2370 05cc 6823      		and r22,r24
 2371               	.LVL268:
 2372 05ce 00C0      		rjmp .L167
 2373               	.LVL269:
 2374               	.L99:
 442:main.c        **** 					DDRE &= ~(setValue);
 2375               		.loc 3 442 0
 2376 05d0 C534      		cpi r28,lo8(69)
 2377 05d2 01F0      		breq .+2
 2378 05d4 00C0      		rjmp .L118
 443:main.c        **** 				}
 2379               		.loc 3 443 0
 2380 05d6 86B1      		in r24,0x6
 2381 05d8 6095      		com r22
 2382               	.LVL270:
 2383 05da 6823      		and r22,r24
 2384               	.LVL271:
 2385 05dc 00C0      		rjmp .L168
 2386               	.LVL272:
 2387               	.L94:
 446:main.c        **** 				if (portChar == 'A') {
 2388               		.loc 3 446 0
 2389 05de 8F34      		cpi r24,lo8(79)
 2390 05e0 01F0      		breq .+2
 2391 05e2 00C0      		rjmp .L118
 447:main.c        **** 					DDRA |= (setValue);
 2392               		.loc 3 447 0
 2393 05e4 C134      		cpi r28,lo8(65)
 2394 05e6 01F4      		brne .L100
 448:main.c        **** 				}
 2395               		.loc 3 448 0
 2396 05e8 8AB3      		in r24,0x1a
 2397 05ea 682B      		or r22,r24
 2398               	.LVL273:
 2399               	.L160:
 2400 05ec 6ABB      		out 0x1a,r22
 2401 05ee 00C0      		rjmp .L118
 2402               	.LVL274:
 2403               	.L100:
 450:main.c        **** 					DDRB |= (setValue);
 2404               		.loc 3 450 0
 2405 05f0 C234      		cpi r28,lo8(66)
 2406 05f2 01F4      		brne .L101
 451:main.c        **** 				}
 2407               		.loc 3 451 0
 2408 05f4 87B3      		in r24,0x17
 2409 05f6 682B      		or r22,r24
 2410               	.LVL275:
 2411               	.L161:
 2412 05f8 67BB      		out 0x17,r22
 2413 05fa 00C0      		rjmp .L118
 2414               	.LVL276:
 2415               	.L101:
 453:main.c        **** 					DDRC |= (setValue);
 2416               		.loc 3 453 0
 2417 05fc C334      		cpi r28,lo8(67)
 2418 05fe 01F4      		brne .L102
 454:main.c        **** 				}
 2419               		.loc 3 454 0
 2420 0600 84B3      		in r24,0x14
 2421 0602 682B      		or r22,r24
 2422               	.LVL277:
 2423               	.L166:
 2424 0604 64BB      		out 0x14,r22
 2425 0606 00C0      		rjmp .L118
 2426               	.LVL278:
 2427               	.L102:
 456:main.c        **** 					DDRD |= (setValue);
 2428               		.loc 3 456 0
 2429 0608 C434      		cpi r28,lo8(68)
 2430 060a 01F4      		brne .L103
 457:main.c        **** 				}
 2431               		.loc 3 457 0
 2432 060c 81B3      		in r24,0x11
 2433 060e 682B      		or r22,r24
 2434               	.LVL279:
 2435               	.L167:
 2436 0610 61BB      		out 0x11,r22
 2437 0612 00C0      		rjmp .L118
 2438               	.LVL280:
 2439               	.L103:
 459:main.c        **** 					DDRE |= (setValue);
 2440               		.loc 3 459 0
 2441 0614 C534      		cpi r28,lo8(69)
 2442 0616 01F0      		breq .+2
 2443 0618 00C0      		rjmp .L118
 460:main.c        **** 				}
 2444               		.loc 3 460 0
 2445 061a 86B1      		in r24,0x6
 2446 061c 682B      		or r22,r24
 2447               	.LVL281:
 2448               	.L168:
 2449 061e 66B9      		out 0x6,r22
 2450 0620 00C0      		rjmp .L118
 2451               	.LVL282:
 2452               	.L93:
 2453               	.LBE173:
 467:main.c        **** 			char portChar = USART_Receive();			
 2454               		.loc 3 467 0
 2455 0622 8C34      		cpi r24,lo8(76)
 2456 0624 01F4      		brne .L104
 2457               	.LBB174:
 468:main.c        **** 			usart_read_chars();
 2458               		.loc 3 468 0
 2459 0626 00D0      		rcall USART_Receive
 2460               	.LVL283:
 2461 0628 C82F      		mov r28,r24
 2462               	.LVL284:
 469:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2463               		.loc 3 469 0
 2464 062a 00D0      		rcall usart_read_chars
 2465               	.LVL285:
 470:main.c        **** 			
 2466               		.loc 3 470 0
 2467 062c 40E1      		ldi r20,lo8(16)
 2468 062e 50E0      		ldi r21,0
 2469 0630 60E0      		ldi r22,0
 2470 0632 70E0      		ldi r23,0
 2471 0634 80E0      		ldi r24,lo8(receivedBuffer)
 2472 0636 90E0      		ldi r25,hi8(receivedBuffer)
 2473 0638 00D0      		rcall strtol
 2474               	.LVL286:
 472:main.c        **** 			if (portChar == 'A') {
 2475               		.loc 3 472 0
 2476 063a 939A      		sbi 0x12,3
 473:main.c        **** 				PORTA &= ~(setValue);
 2477               		.loc 3 473 0
 2478 063c C134      		cpi r28,lo8(65)
 2479 063e 01F4      		brne .L105
 474:main.c        **** 			}
 2480               		.loc 3 474 0
 2481 0640 8BB3      		in r24,0x1b
 2482 0642 6095      		com r22
 2483               	.LVL287:
 2484 0644 6823      		and r22,r24
 2485               	.LVL288:
 2486 0646 00C0      		rjmp .L165
 2487               	.LVL289:
 2488               	.L105:
 476:main.c        **** 				PORTB &= ~(setValue);
 2489               		.loc 3 476 0
 2490 0648 C234      		cpi r28,lo8(66)
 2491 064a 01F4      		brne .L107
 477:main.c        **** 			}
 2492               		.loc 3 477 0
 2493 064c 88B3      		in r24,0x18
 2494 064e 6095      		com r22
 2495               	.LVL290:
 2496 0650 6823      		and r22,r24
 2497               	.LVL291:
 2498 0652 00C0      		rjmp .L164
 2499               	.LVL292:
 2500               	.L107:
 479:main.c        **** 				PORTC &= ~(setValue);
 2501               		.loc 3 479 0
 2502 0654 C334      		cpi r28,lo8(67)
 2503 0656 01F4      		brne .L108
 480:main.c        **** 			}
 2504               		.loc 3 480 0
 2505 0658 85B3      		in r24,0x15
 2506 065a 6095      		com r22
 2507               	.LVL293:
 2508 065c 6823      		and r22,r24
 2509               	.LVL294:
 2510 065e 00C0      		rjmp .L163
 2511               	.LVL295:
 2512               	.L108:
 482:main.c        **** 				PORTD &= ~(setValue);
 2513               		.loc 3 482 0
 2514 0660 C434      		cpi r28,lo8(68)
 2515 0662 01F4      		brne .L109
 483:main.c        **** 			}
 2516               		.loc 3 483 0
 2517 0664 82B3      		in r24,0x12
 2518 0666 6095      		com r22
 2519               	.LVL296:
 2520 0668 6823      		and r22,r24
 2521               	.LVL297:
 2522 066a 00C0      		rjmp .L162
 2523               	.LVL298:
 2524               	.L109:
 485:main.c        **** 				PORTE &= ~(setValue);
 2525               		.loc 3 485 0
 2526 066c C534      		cpi r28,lo8(69)
 2527 066e 01F0      		breq .+2
 2528 0670 00C0      		rjmp .L118
 486:main.c        **** 			}
 2529               		.loc 3 486 0
 2530 0672 87B1      		in r24,0x7
 2531 0674 6095      		com r22
 2532               	.LVL299:
 2533 0676 6823      		and r22,r24
 2534               	.LVL300:
 2535 0678 00C0      		rjmp .L159
 2536               	.LVL301:
 2537               	.L104:
 2538               	.LBE174:
 492:main.c        **** 			char portChar = USART_Receive();			
 2539               		.loc 3 492 0
 2540 067a 8834      		cpi r24,lo8(72)
 2541 067c 01F4      		brne .L110
 2542               	.LBB175:
 493:main.c        **** 			usart_read_chars();
 2543               		.loc 3 493 0
 2544 067e 00D0      		rcall USART_Receive
 2545               	.LVL302:
 2546 0680 C82F      		mov r28,r24
 2547               	.LVL303:
 494:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2548               		.loc 3 494 0
 2549 0682 00D0      		rcall usart_read_chars
 2550               	.LVL304:
 495:main.c        **** 			
 2551               		.loc 3 495 0
 2552 0684 40E1      		ldi r20,lo8(16)
 2553 0686 50E0      		ldi r21,0
 2554 0688 60E0      		ldi r22,0
 2555 068a 70E0      		ldi r23,0
 2556 068c 80E0      		ldi r24,lo8(receivedBuffer)
 2557 068e 90E0      		ldi r25,hi8(receivedBuffer)
 2558 0690 00D0      		rcall strtol
 2559               	.LVL305:
 497:main.c        **** 			if (portChar == 'A') {
 2560               		.loc 3 497 0
 2561 0692 939A      		sbi 0x12,3
 498:main.c        **** 				PORTA |= (setValue);
 2562               		.loc 3 498 0
 2563 0694 C134      		cpi r28,lo8(65)
 2564 0696 01F4      		brne .L111
 499:main.c        **** 			}
 2565               		.loc 3 499 0
 2566 0698 8BB3      		in r24,0x1b
 2567 069a 682B      		or r22,r24
 2568               	.LVL306:
 2569               	.L165:
 2570 069c 6BBB      		out 0x1b,r22
 2571 069e 00C0      		rjmp .L118
 2572               	.LVL307:
 2573               	.L111:
 501:main.c        **** 				PORTB |= (setValue);
 2574               		.loc 3 501 0
 2575 06a0 C234      		cpi r28,lo8(66)
 2576 06a2 01F4      		brne .L113
 502:main.c        **** 			}
 2577               		.loc 3 502 0
 2578 06a4 88B3      		in r24,0x18
 2579 06a6 682B      		or r22,r24
 2580               	.LVL308:
 2581               	.L164:
 2582 06a8 68BB      		out 0x18,r22
 2583 06aa 00C0      		rjmp .L118
 2584               	.LVL309:
 2585               	.L113:
 504:main.c        **** 				PORTC |= (setValue);
 2586               		.loc 3 504 0
 2587 06ac C334      		cpi r28,lo8(67)
 2588 06ae 01F4      		brne .L114
 505:main.c        **** 			}
 2589               		.loc 3 505 0
 2590 06b0 85B3      		in r24,0x15
 2591 06b2 682B      		or r22,r24
 2592               	.LVL310:
 2593               	.L163:
 2594 06b4 65BB      		out 0x15,r22
 2595 06b6 00C0      		rjmp .L118
 2596               	.LVL311:
 2597               	.L114:
 507:main.c        **** 				PORTD |= (setValue);
 2598               		.loc 3 507 0
 2599 06b8 C434      		cpi r28,lo8(68)
 2600 06ba 01F4      		brne .L115
 508:main.c        **** 			}
 2601               		.loc 3 508 0
 2602 06bc 82B3      		in r24,0x12
 2603 06be 682B      		or r22,r24
 2604               	.LVL312:
 2605               	.L162:
 2606 06c0 62BB      		out 0x12,r22
 2607 06c2 00C0      		rjmp .L118
 2608               	.LVL313:
 2609               	.L115:
 510:main.c        **** 				PORTE |= (setValue);
 2610               		.loc 3 510 0
 2611 06c4 C534      		cpi r28,lo8(69)
 2612 06c6 01F4      		brne .L118
 511:main.c        **** 			}
 2613               		.loc 3 511 0
 2614 06c8 87B1      		in r24,0x7
 2615 06ca 682B      		or r22,r24
 2616               	.LVL314:
 2617               	.L159:
 2618 06cc 67B9      		out 0x7,r22
 2619 06ce 00C0      		rjmp .L118
 2620               	.L110:
 2621               	.LBE175:
 517:main.c        **** 			char portChar = USART_Receive();			
 2622               		.loc 3 517 0
 2623 06d0 8434      		cpi r24,lo8(68)
 2624 06d2 01F4      		brne .L116
 2625               	.LBB176:
 518:main.c        **** 			
 2626               		.loc 3 518 0
 2627 06d4 00D0      		rcall USART_Receive
 2628               	.LVL315:
 520:main.c        **** 			if (portChar == 'A') {
 2629               		.loc 3 520 0
 2630 06d6 939A      		sbi 0x12,3
 521:main.c        **** 				USART_Transmit(PINA);
 2631               		.loc 3 521 0
 2632 06d8 8134      		cpi r24,lo8(65)
 2633 06da 01F4      		brne .L117
 522:main.c        **** 			}
 2634               		.loc 3 522 0
 2635 06dc 89B3      		in r24,0x19
 2636               	.LVL316:
 2637 06de 00C0      		rjmp .L155
 2638               	.LVL317:
 2639               	.L117:
 524:main.c        **** 				USART_Transmit(PINB);
 2640               		.loc 3 524 0
 2641 06e0 8234      		cpi r24,lo8(66)
 2642 06e2 01F4      		brne .L119
 525:main.c        **** 			}
 2643               		.loc 3 525 0
 2644 06e4 86B3      		in r24,0x16
 2645               	.LVL318:
 2646 06e6 00C0      		rjmp .L155
 2647               	.LVL319:
 2648               	.L119:
 527:main.c        **** 				USART_Transmit(PINC);
 2649               		.loc 3 527 0
 2650 06e8 8334      		cpi r24,lo8(67)
 2651 06ea 01F4      		brne .L120
 528:main.c        **** 			}
 2652               		.loc 3 528 0
 2653 06ec 83B3      		in r24,0x13
 2654               	.LVL320:
 2655 06ee 00C0      		rjmp .L155
 2656               	.LVL321:
 2657               	.L120:
 530:main.c        **** 				USART_Transmit(PIND);
 2658               		.loc 3 530 0
 2659 06f0 8434      		cpi r24,lo8(68)
 2660 06f2 01F4      		brne .L121
 531:main.c        **** 			}
 2661               		.loc 3 531 0
 2662 06f4 80B3      		in r24,0x10
 2663               	.LVL322:
 2664 06f6 00C0      		rjmp .L155
 2665               	.LVL323:
 2666               	.L121:
 533:main.c        **** 				USART_Transmit(PINE);
 2667               		.loc 3 533 0
 2668 06f8 8534      		cpi r24,lo8(69)
 2669 06fa 01F4      		brne .L118
 534:main.c        **** 			}
 2670               		.loc 3 534 0
 2671 06fc 85B1      		in r24,0x5
 2672               	.LVL324:
 2673               	.L155:
 2674 06fe 00D0      		rcall USART_Transmit
 2675               	.LVL325:
 2676               	.L118:
 536:main.c        **** 		}
 2677               		.loc 3 536 0
 2678 0700 9398      		cbi 0x12,3
 2679               	.LBE176:
 2680 0702 00C0      		rjmp .L45
 2681               	.LVL326:
 2682               	.L116:
 540:main.c        **** 			char commonChar = USART_Receive();
 2683               		.loc 3 540 0
 2684 0704 8D34      		cpi r24,lo8(77)
 2685 0706 01F4      		brne .L122
 2686               	.LBB177:
 541:main.c        **** 			if (commonChar == '1') {
 2687               		.loc 3 541 0
 2688 0708 00D0      		rcall USART_Receive
 2689               	.LVL327:
 542:main.c        **** 				resetCommonLines = 1;
 2690               		.loc 3 542 0
 2691 070a 8133      		cpi r24,lo8(49)
 2692 070c 01F4      		brne .L171
 2693               		.loc 3 543 0
 2694 070e 5524      		clr r5
 2695 0710 5394      		inc r5
 2696 0712 00C0      		rjmp .L152
 2697               	.L171:
 544:main.c        **** 			}
 545:main.c        **** 			else if (commonChar == '0') {
 2698               		.loc 3 545 0
 2699 0714 8033      		cpi r24,lo8(48)
 2700 0716 01F0      		breq .+2
 2701 0718 00C0      		rjmp .L45
 546:main.c        **** 				resetCommonLines = 0;
 2702               		.loc 3 546 0
 2703 071a 512C      		mov r5,__zero_reg__
 2704 071c 00C0      		rjmp .L46
 2705               	.LVL328:
 2706               	.L122:
 2707               	.LBE177:
 547:main.c        **** 			}
 548:main.c        **** 		}
 549:main.c        **** 		
 550:main.c        **** 		// Send back the PCB version number
 551:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2708               		.loc 3 551 0
 2709 071e 8836      		cpi r24,lo8(104)
 2710 0720 01F4      		brne .L123
 552:main.c        **** 			USART_Transmit(PCB_VERSION);
 2711               		.loc 3 552 0
 2712 0722 84E6      		ldi r24,lo8(100)
 2713 0724 00C0      		rjmp .L153
 2714               	.L123:
 553:main.c        **** 		}
 554:main.c        **** 		
 555:main.c        **** 		// Send back the firmware version number
 556:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2715               		.loc 3 556 0
 2716 0726 8635      		cpi r24,lo8(86)
 2717 0728 01F4      		brne .L124
 557:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2718               		.loc 3 557 0
 2719 072a 82E1      		ldi r24,lo8(18)
 2720               	.LVL329:
 2721               	.L153:
 2722 072c 00D0      		rcall USART_Transmit
 2723               	.LVL330:
 2724 072e 00C0      		rjmp .L45
 2725               	.LVL331:
 2726               	.L124:
 558:main.c        **** 		}
 559:main.c        **** 		
 560:main.c        **** 		// Reset the AVR if it matches the number
 561:main.c        **** 		else if (receivedChar == RESET_AVR) {
 2727               		.loc 3 561 0
 2728 0730 8A32      		cpi r24,lo8(42)
 2729 0732 01F0      		breq .+2
 2730 0734 00C0      		rjmp .L45
 2731               	.LBB178:
 562:main.c        **** 			usart_read_chars();
 2732               		.loc 3 562 0
 2733 0736 00D0      		rcall usart_read_chars
 2734               	.LVL332:
 563:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 2735               		.loc 3 563 0
 2736 0738 40E1      		ldi r20,lo8(16)
 2737 073a 50E0      		ldi r21,0
 2738 073c 60E0      		ldi r22,0
 2739 073e 70E0      		ldi r23,0
 2740 0740 80E0      		ldi r24,lo8(receivedBuffer)
 2741 0742 90E0      		ldi r25,hi8(receivedBuffer)
 2742 0744 00D0      		rcall strtol
 2743               	.LVL333:
 564:main.c        **** 			if (resetValue == RESET_VALUE) {
 2744               		.loc 3 564 0
 2745 0746 613E      		cpi r22,-31
 2746 0748 754E      		sbci r23,-27
 2747 074a 8740      		sbci r24,7
 2748 074c 9105      		cpc r25,__zero_reg__
 2749 074e 01F0      		breq .+2
 2750 0750 00C0      		rjmp .L45
 565:main.c        **** 				// Clear watchdog flag
 566:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 2751               		.loc 3 566 0
 2752 0752 84B7      		in r24,0x34
 2753 0754 877F      		andi r24,lo8(-9)
 2754 0756 84BF      		out 0x34,r24
 567:main.c        **** 				
 568:main.c        **** 				// Start timed sequence
 569:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 2755               		.loc 3 569 0
 2756 0758 F8E1      		ldi r31,lo8(24)
 2757 075a F1BD      		out 0x21,r31
 570:main.c        **** 				
 571:main.c        **** 				// Reset in 250 ms
 572:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 2758               		.loc 3 572 0
 2759 075c 2CE0      		ldi r18,lo8(12)
 2760 075e 21BD      		out 0x21,r18
 2761               	.LVL334:
 2762               	.LBB121:
 2763               	.LBB120:
 2764               		.loc 4 105 0
 2765 0760 C101      		movw r24,r2
 2766               	/* #APP */
 2767               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 2768 0762 0197      		1: sbiw r24,1
 2769 0764 01F4      		brne 1b
 2770               	 ;  0 "" 2
 2771               	.LVL335:
 2772               	/* #NOAPP */
 2773 0766 00C0      		rjmp .L45
 2774               	.LBE120:
 2775               	.LBE121:
 2776               	.LBE178:
 2777               		.cfi_endproc
 2778               	.LFE30:
 2780               	.global	cartMode
 2781               		.data
 2784               	cartMode:
 2785 0000 01        		.byte	1
 2786               	.global	writingTimedout
 2787               		.section .bss
 2790               	writingTimedout:
 2791 0000 00        		.zero	1
 2792               	.global	lastBankAccessed
 2795               	lastBankAccessed:
 2796 0001 00        		.zero	1
 2797               	.global	flashBank1CommandWrites
 2800               	flashBank1CommandWrites:
 2801 0002 00        		.zero	1
 2802               		.comm	flashWriteCycle,12,1
 2803               		.comm	flashWriteWePin,1,1
 2804               		.comm	receivedChar,1,1
 2805               		.comm	receivedBuffer,256,1
 2806               		.text
 2807               	.Letext0:
 2808               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2809               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:274    .text:00000086 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:343    .text:000000b4 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:391    .text:000000ca gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:494    .text:00000108 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:2790   .bss:00000000 writingTimedout
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:598    .text:00000172 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:2800   .bss:00000002 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:2795   .bss:00000001 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:729    .text:00000200 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:903    .text:0000029e start_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:926    .text:000002ae stop_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:949    .text:000002bc check_if_timed_out
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:981    .text:000002ce setup
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:1091   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccVtNsgi.s:2784   .data:00000000 cartMode

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
