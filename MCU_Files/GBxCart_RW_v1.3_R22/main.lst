   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R22
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 24/10/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define READ_ROM_4000H 'Q'
 109:setup.c       **** #define WRITE_RAM 'W'
 110:setup.c       **** #define SET_BANK 'B'
 111:setup.c       **** #define GB_CART_MODE 'G'
 112:setup.c       **** 
 113:setup.c       **** // GBA commands
 114:setup.c       **** #define GBA_READ_ROM 'r'
 115:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 116:setup.c       **** #define GBA_READ_ROM_8000H 'Z'
 117:setup.c       **** #define GBA_READ_SRAM 'm'
 118:setup.c       **** #define GBA_WRITE_SRAM 'w'
 119:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 120:setup.c       **** #define GBA_CART_MODE 'g'
 121:setup.c       **** 
 122:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 123:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 124:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 125:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 126:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 127:setup.c       **** 
 128:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 129:setup.c       **** #define GBA_READ_EEPROM 'e'
 130:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 131:setup.c       **** 
 132:setup.c       **** // Flash Cart commands
 133:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 134:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 135:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 136:setup.c       **** 
 137:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 141:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 142:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 143:setup.c       **** 
 144:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 145:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 146:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_256BYTE 'U'
 147:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 148:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 149:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 150:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'z'
 151:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
 152:setup.c       **** 
 153:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 154:setup.c       **** 
 155:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 156:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 157:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 158:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 159:setup.c       **** #define GBA_FLASH_WRITE_BUFFERED_256BYTE 'c'
 160:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 161:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 162:setup.c       **** #define GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE 'v'
 163:setup.c       **** #define GBA_FLASH_WRITE_SHARP_64BYTE 'x'
 164:setup.c       **** 
 165:setup.c       **** #define D0D1_NOT_SWAPPED 0
 166:setup.c       **** #define D0D1_SWAPPED 1
 167:setup.c       **** 
 168:setup.c       **** // General commands
 169:setup.c       **** #define SEND_ACK '1'
 170:setup.c       **** #define CART_MODE 'C'
 171:setup.c       **** #define SET_INPUT 'I'
 172:setup.c       **** #define SET_OUTPUT 'O'
 173:setup.c       **** #define SET_OUTPUT_LOW 'L'
 174:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 175:setup.c       **** #define READ_INPUT 'D'
 176:setup.c       **** #define RESET_COMMON_LINES 'M'
 177:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 178:setup.c       **** #define READ_PCB_VERSION 'h'
 179:setup.c       **** #define FAST_READ_CHECK '+'
 180:setup.c       **** #define VOLTAGE_3_3V '3'
 181:setup.c       **** #define VOLTAGE_5V '5'
 182:setup.c       **** 
 183:setup.c       **** #define RESET_AVR '*'
 184:setup.c       **** #define RESET_VALUE 0x7E5E1
 185:setup.c       **** 
 186:setup.c       **** 
 187:setup.c       **** char receivedBuffer[256];
 188:setup.c       **** char receivedChar;
 189:setup.c       **** uint8_t eepromBuffer[8];
 190:setup.c       **** uint8_t flashChipIdBuffer[2];
 191:setup.c       **** 
 192:setup.c       **** char flashWriteWePin;
 193:setup.c       **** uint16_t flashWriteCycle[3][2];
 194:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 195:setup.c       **** uint8_t lastBankAccessed = 0;
 196:setup.c       **** volatile uint8_t writingTimedout = 0;
 197:setup.c       **** 
 198:setup.c       **** uint8_t cartMode = GBA_MODE;
 199:setup.c       **** 
 200:setup.c       **** // Receive USART data
 201:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 201 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 202:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 202 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 203:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 203 0
  26 0004 8CB1      		in r24,0xc
 204:setup.c       **** }
  27               		.loc 1 204 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 205:setup.c       **** 
 206:setup.c       **** // Transmit USART data
 207:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 207 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 208:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 208 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 209:setup.c       **** 	UDR = data;
  47               		.loc 1 209 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 210:setup.c       **** }
 211:setup.c       **** 
 212:setup.c       **** // Read 1-256 bytes from the USART 
 213:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 213 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB165:
 214:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 214 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 214 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 215:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 215 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE165:
 216:setup.c       **** 	}
 217:setup.c       **** }
 106               		.loc 1 217 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 218:setup.c       **** 
 219:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 220:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 220 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 221:setup.c       **** 	int x = 0;
 222:setup.c       **** 	while (1) {
 223:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 223 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 224:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 224 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 225:setup.c       **** 			break;
 226:setup.c       **** 		}
 227:setup.c       **** 		x++;
 228:setup.c       **** 	}
 229:setup.c       **** }
 148               		.loc 1 229 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 230:setup.c       **** 
 231:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 232:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 232 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 233:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 233 0
 167 0050 3A9A      		sbi 0x7,2
 234:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 234 0
 169 0052 949A      		sbi 0x12,4
 235:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 235 0
 171 0054 959A      		sbi 0x12,5
 236:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 236 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 237:setup.c       **** }
 238:setup.c       **** 
 239:setup.c       **** 
 240:setup.c       **** 
 241:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 242:setup.c       **** 
 243:setup.c       **** // Set Gameboy mode
 244:setup.c       **** void gb_mode(void) {
 182               		.loc 1 244 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 245:setup.c       **** 	// Set inputs
 246:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 246 0
 189 005a 15BA      		out 0x15,__zero_reg__
 247:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 247 0
 191 005c 14BA      		out 0x14,__zero_reg__
 248:setup.c       **** 	
 249:setup.c       **** 	// Set outputs
 250:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 250 0
 193 005e 18BA      		out 0x18,__zero_reg__
 251:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 251 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 252:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 252 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 253:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 253 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 254:setup.c       **** }
 255:setup.c       **** 
 256:setup.c       **** // Set the 16 bit address on A15-0
 257:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 257 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 258:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 258 0
 217 006a 9BBB      		out 0x1b,r25
 259:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 259 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 260:setup.c       **** }
 261:setup.c       **** 
 262:setup.c       **** // Set the address and read a byte from the 8 bit data line
 263:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 263 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 264:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 264 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 265:setup.c       **** 	
 266:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 266 0
 239 0072 9498      		cbi 0x12,4
 267:setup.c       **** 	rdPin_low;
 240               		.loc 1 267 0
 241 0074 9598      		cbi 0x12,5
 268:setup.c       **** 	
 269:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 269 0
 243               	/* #APP */
 244               	 ;  269 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 270:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 270 0
 248               	 ;  270 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 271:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 271 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 272:setup.c       **** 	
 273:setup.c       **** 	rdPin_high;
 255               		.loc 1 273 0
 256 007c 959A      		sbi 0x12,5
 274:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 274 0
 258 007e 949A      		sbi 0x12,4
 275:setup.c       **** 	
 276:setup.c       **** 	return data;
 277:setup.c       **** }
 259               		.loc 1 277 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 278:setup.c       **** 
 279:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 280:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 280 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 281:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 281 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 282:setup.c       **** 	
 283:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 283 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 284:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 284 0
 292 0090 D5BB      		out 0x15,r29
 285:setup.c       **** 	
 286:setup.c       **** 	// Pulse WR and mREQ if the type matches
 287:setup.c       **** 	wrPin_low;
 293               		.loc 1 287 0
 294 0092 9698      		cbi 0x12,6
 288:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 288 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 289:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 289 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 290:setup.c       **** 	}
 291:setup.c       **** 	
 292:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 292 0
 302               	/* #APP */
 303               	 ;  292 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 293:setup.c       **** 	
 294:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 294 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 295:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 295 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 296:setup.c       **** 	}
 297:setup.c       **** 	wrPin_high;
 313               		.loc 1 297 0
 314 00a2 969A      		sbi 0x12,6
 298:setup.c       **** 	
 299:setup.c       **** 	// Clear data outputs and set data pins as inputs
 300:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 300 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 301:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 301 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 302:setup.c       **** }
 320               		.loc 1 302 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 303:setup.c       **** 
 304:setup.c       **** 
 305:setup.c       **** 
 306:setup.c       **** // ****** Gameboy Advance functions ****** 
 307:setup.c       **** 
 308:setup.c       **** // Set GBA mode
 309:setup.c       **** void gba_mode(void) {
 333               		.loc 1 309 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 310:setup.c       **** 	// Set outputs for reading ROM addresses as default
 311:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 311 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 312:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 312 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 313:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 313 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 314:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 314 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 315:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 315 0
 349 00b8 8ABB      		out 0x1a,r24
 316:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 316 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 317:setup.c       **** }
 318:setup.c       **** 
 319:setup.c       **** // Set the 24 bit address on A23-0
 320:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 320 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 321:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 321 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 322:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 322 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 323:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 323 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 324:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 324 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 325:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 325 0
 385 00cc 2ABB      		out 0x1a,r18
 326:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 326 0
 387 00ce 27BB      		out 0x17,r18
 327:setup.c       **** 	
 328:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 328 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 329:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 329 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 330:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 330 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 331:setup.c       **** }
 402               		.loc 1 331 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 332:setup.c       **** 
 333:setup.c       **** 
 334:setup.c       **** 
 335:setup.c       **** // ---------- ROM/SRAM ----------
 336:setup.c       **** 
 337:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 338:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 338 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 339:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 339 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 340:setup.c       **** 	
 341:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 341 0
 424 00ec 9498      		cbi 0x12,4
 342:setup.c       **** 	
 343:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 343 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 344:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 344 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 345:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 345 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 346:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 346 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 347:setup.c       **** 	
 348:setup.c       **** 	rdPin_low;
 433               		.loc 1 348 0
 434 00f6 9598      		cbi 0x12,5
 349:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 349 0
 436               	/* #APP */
 437               	 ;  349 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 350:setup.c       **** 	
 351:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 351 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 352:setup.c       **** 	
 353:setup.c       **** 	rdPin_high;
 445               		.loc 1 353 0
 446 00fe 959A      		sbi 0x12,5
 354:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 354 0
 448 0100 949A      		sbi 0x12,4
 355:setup.c       **** 	
 356:setup.c       **** 	return data;
 449               		.loc 1 356 0
 450 0102 90E0      		ldi r25,0
 357:setup.c       **** }
 451               		.loc 1 357 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 358:setup.c       **** 
 359:setup.c       **** // Set the address and read a byte from the 8 bit data line
 360:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 360 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 361:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 361 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 362:setup.c       **** 	
 363:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 471               		.loc 1 363 0
 472 010a 3A98      		cbi 0x7,2
 364:setup.c       **** 	rdPin_low;
 473               		.loc 1 364 0
 474 010c 9598      		cbi 0x12,5
 365:setup.c       **** 	
 366:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 366 0
 476               	/* #APP */
 477               	 ;  366 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 367:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 367 0
 481               	 ;  367 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 368:setup.c       **** 	
 369:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 369 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 370:setup.c       **** 	
 371:setup.c       **** 	rdPin_high;
 488               		.loc 1 371 0
 489 0114 959A      		sbi 0x12,5
 372:setup.c       **** 	cs2Pin_high;
 490               		.loc 1 372 0
 491 0116 3A9A      		sbi 0x7,2
 373:setup.c       **** 	
 374:setup.c       **** 	return data;
 375:setup.c       **** }
 492               		.loc 1 375 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 376:setup.c       **** 
 377:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 378:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 378 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 379:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 379 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 380:setup.c       **** 	
 381:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 381 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 382:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 382 0
 520 0124 C5BB      		out 0x15,r28
 383:setup.c       **** 	
 384:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 521               		.loc 1 384 0
 522 0126 3A98      		cbi 0x7,2
 385:setup.c       **** 	wrPin_low; // Pulse WR
 523               		.loc 1 385 0
 524 0128 9698      		cbi 0x12,6
 386:setup.c       **** 	
 387:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 387 0
 526               	/* #APP */
 527               	 ;  387 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 388:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 388 0
 531               	 ;  388 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 389:setup.c       **** 	
 390:setup.c       **** 	wrPin_high;
 534               		.loc 1 390 0
 535               	/* #NOAPP */
 536 012e 969A      		sbi 0x12,6
 391:setup.c       **** 	cs2Pin_high;
 537               		.loc 1 391 0
 538 0130 3A9A      		sbi 0x7,2
 392:setup.c       **** 	
 393:setup.c       **** 	// Clear data outputs and set data pins as inputs
 394:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 394 0
 540 0132 15BA      		out 0x15,__zero_reg__
 395:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 395 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 396:setup.c       **** }
 544               		.loc 1 396 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 397:setup.c       **** 
 398:setup.c       **** 
 399:setup.c       **** 
 400:setup.c       **** // ---------- EEPROM ----------
 401:setup.c       **** 
 402:setup.c       **** // Set address/data all high (includes AD0/A23)
 403:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 403 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 404:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 404 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 405:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 405 0
 565 013e 8ABB      		out 0x1a,r24
 406:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 406 0
 567 0140 84BB      		out 0x14,r24
 407:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 407 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 408:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 408 0
 572 0146 8BBB      		out 0x1b,r24
 409:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 409 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 410:setup.c       **** }
 411:setup.c       **** 
 412:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 413:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 413 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 414:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 414 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 415:setup.c       **** 	
 416:setup.c       **** 	int8_t x = 0;
 417:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 417 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 418:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 418 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 419:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 419 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 420:setup.c       **** 		}
 421:setup.c       **** 		else {
 422:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 423:setup.c       **** 		}
 424:setup.c       **** 		x = 15;
 603               		.loc 1 424 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 425:setup.c       **** 	}
 426:setup.c       **** 	else {
 427:setup.c       **** 		if (command == EEPROM_READ) {
 428:setup.c       **** 			address |= (1<<7) | (1<<6);
 429:setup.c       **** 		}
 430:setup.c       **** 		else {
 431:setup.c       **** 			address |= (1<<7);
 432:setup.c       **** 		}
 433:setup.c       **** 		x = 7;
 434:setup.c       **** 	}
 435:setup.c       **** 	
 436:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 437:setup.c       **** 	while (x >= 0) {
 438:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 438 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 422:setup.c       **** 		}
 613               		.loc 1 422 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 427:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 427 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 428:setup.c       **** 		}
 621               		.loc 1 428 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 431:setup.c       **** 		}
 626               		.loc 1 431 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 433:setup.c       **** 	}
 630               		.loc 1 433 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 439:setup.c       **** 			ad0Pin_high;
 440:setup.c       **** 		}
 441:setup.c       **** 		else {
 442:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 442 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 443:setup.c       **** 		}
 444:setup.c       **** 		
 445:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 445 0
 639 0174 9698      		cbi 0x12,6
 446:setup.c       **** 		asm ("nop");
 640               		.loc 1 446 0
 641               	/* #APP */
 642               	 ;  446 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 447:setup.c       **** 		asm ("nop");
 645               		.loc 1 447 0
 646               	 ;  447 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 448:setup.c       **** 		wrPin_high; 
 649               		.loc 1 448 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 449:setup.c       **** 		asm ("nop");
 652               		.loc 1 449 0
 653               	/* #APP */
 654               	 ;  449 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 450:setup.c       **** 		asm ("nop");
 657               		.loc 1 450 0
 658               	 ;  450 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 437:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 437 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 438:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 438 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 439:setup.c       **** 		}
 682               		.loc 1 439 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 451:setup.c       **** 		
 452:setup.c       **** 		x--;
 453:setup.c       **** 	}
 454:setup.c       **** 	
 455:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 456:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 456 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 457:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 457 0
 690 01a4 C098      		cbi 0x18,0
 458:setup.c       **** 		asm ("nop");
 691               		.loc 1 458 0
 692               	/* #APP */
 693               	 ;  458 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 459:setup.c       **** 		wrPin_low;
 696               		.loc 1 459 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 460:setup.c       **** 		asm ("nop");
 699               		.loc 1 460 0
 700               	/* #APP */
 701               	 ;  460 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 461:setup.c       **** 		asm ("nop");
 704               		.loc 1 461 0
 705               	 ;  461 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 462:setup.c       **** 		
 463:setup.c       **** 		wrPin_high;
 708               		.loc 1 463 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 464:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 464 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 465:setup.c       **** 	}
 466:setup.c       **** }
 467:setup.c       **** 
 468:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 469:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 469 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 470:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 470 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 471:setup.c       **** 	
 472:setup.c       **** 	// Set AD0 pin as input
 473:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 473 0
 734 01b8 C098      		cbi 0x18,0
 474:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 474 0
 736 01ba B898      		cbi 0x17,0
 475:setup.c       **** 	
 476:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 476 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB166:
 477:setup.c       **** 	
 478:setup.c       **** 	// Ignore first 4 bits
 479:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 480:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 480 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 481:setup.c       **** 		asm ("nop");
 746               		.loc 1 481 0 discriminator 3
 747               	/* #APP */
 748               	 ;  481 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 482:setup.c       **** 		asm ("nop");
 751               		.loc 1 482 0 discriminator 3
 752               	 ;  482 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 483:setup.c       **** 		rdPin_high; 
 755               		.loc 1 483 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 484:setup.c       **** 		asm ("nop");
 758               		.loc 1 484 0 discriminator 3
 759               	/* #APP */
 760               	 ;  484 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 485:setup.c       **** 		asm ("nop");
 763               		.loc 1 485 0 discriminator 3
 764               	 ;  485 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 479:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 479 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE166:
 776               	.LBB167:
 777               	.LBB168:
 778               	.LBB169:
 486:setup.c       **** 	}
 487:setup.c       **** 	
 488:setup.c       **** 	// Read out 64 bits
 489:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 490:setup.c       **** 		uint8_t data = 0;
 491:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 492:setup.c       **** 			rdPin_low; // CLK
 493:setup.c       **** 			asm ("nop");
 494:setup.c       **** 			asm ("nop");
 495:setup.c       **** 			rdPin_high;
 496:setup.c       **** 			
 497:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 498:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 498 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE169:
 785               	.LBE168:
 786               	.LBE167:
 476:setup.c       **** 	
 787               		.loc 1 476 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB172:
 794               	.LBB171:
 795               	.LBB170:
 492:setup.c       **** 			asm ("nop");
 796               		.loc 1 492 0
 797 01de 9598      		cbi 0x12,5
 493:setup.c       **** 			asm ("nop");
 798               		.loc 1 493 0
 799               	/* #APP */
 800               	 ;  493 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 494:setup.c       **** 			rdPin_high;
 803               		.loc 1 494 0
 804               	 ;  494 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 495:setup.c       **** 			
 807               		.loc 1 495 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 497:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 497 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 498 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE170:
 499:setup.c       **** 			}
 500:setup.c       **** 		}
 501:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 501 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE171:
 489:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 489 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE172:
 502:setup.c       **** 	}
 503:setup.c       **** 	
 504:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 504 0
 841 0206 949A      		sbi 0x12,4
 505:setup.c       **** 	
 506:setup.c       **** 	// Set AD0 pin as output
 507:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 507 0
 843 0208 C09A      		sbi 0x18,0
 508:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 508 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 509:setup.c       **** }
 510:setup.c       **** 
 511:setup.c       **** // Write 8 bytes to the EEPROM address
 512:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 512 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 513:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 513 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 512:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 512 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB173:
 876               	.LBB174:
 514:setup.c       **** 	
 515:setup.c       **** 	// Write 64 bits
 516:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 517:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 518:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 518 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 519:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 519 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 520:setup.c       **** 			}
 521:setup.c       **** 			else {
 522:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 522 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 523:setup.c       **** 			}
 524:setup.c       **** 			
 525:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 525 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 526:setup.c       **** 			asm ("nop");
 899               		.loc 1 526 0 discriminator 2
 900               	/* #APP */
 901               	 ;  526 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 527:setup.c       **** 			asm ("nop");
 904               		.loc 1 527 0 discriminator 2
 905               	 ;  527 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 528:setup.c       **** 			wrPin_high; 
 908               		.loc 1 528 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 529:setup.c       **** 			asm ("nop");
 911               		.loc 1 529 0 discriminator 2
 912               	/* #APP */
 913               	 ;  529 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 530:setup.c       **** 			asm ("nop");
 916               		.loc 1 530 0 discriminator 2
 917               	 ;  530 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE174:
 516:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 516 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE173:
 531:setup.c       **** 		}
 532:setup.c       **** 	}
 533:setup.c       **** 	
 534:setup.c       **** 	// Last bit low
 535:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 535 0
 935 0250 C098      		cbi 0x18,0
 536:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 536 0
 937 0252 9698      		cbi 0x12,6
 537:setup.c       **** 	asm ("nop");
 938               		.loc 1 537 0
 939               	/* #APP */
 940               	 ;  537 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 538:setup.c       **** 	asm ("nop");
 943               		.loc 1 538 0
 944               	 ;  538 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 539:setup.c       **** 	wrPin_high; 
 947               		.loc 1 539 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 540:setup.c       **** 	asm ("nop");
 950               		.loc 1 540 0
 951               	/* #APP */
 952               	 ;  540 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 541:setup.c       **** 	asm ("nop");
 955               		.loc 1 541 0
 956               	 ;  541 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 542:setup.c       **** 	
 543:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 543 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 544:setup.c       **** }
 545:setup.c       **** 
 546:setup.c       **** 
 547:setup.c       **** 
 548:setup.c       **** // ---------- FLASH ----------
 549:setup.c       **** 
 550:setup.c       **** // Set the address and data for the write byte cycle to the flash
 551:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 551 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 552:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 552 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 553:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 553 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 554:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 554 0
 989 026c C5BB      		out 0x15,r28
 555:setup.c       **** 	
 556:setup.c       **** 	cs2Pin_low;
 990               		.loc 1 556 0
 991 026e 3A98      		cbi 0x7,2
 557:setup.c       **** 	wrPin_low;
 992               		.loc 1 557 0
 993 0270 9698      		cbi 0x12,6
 558:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 558 0
 995               	/* #APP */
 996               	 ;  558 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 559:setup.c       **** 	cs2Pin_high;
 999               		.loc 1 559 0
 1000               	/* #NOAPP */
 1001 0274 3A9A      		sbi 0x7,2
 560:setup.c       **** 	wrPin_high;
 1002               		.loc 1 560 0
 1003 0276 969A      		sbi 0x12,6
 1004               	/* epilogue start */
 561:setup.c       **** }
 1005               		.loc 1 561 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 562:setup.c       **** 
 563:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 564:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 564 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 565:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 565 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 566:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 566 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 567:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 567 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB175:
 1049               	.LBB176:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE176:
 1060               	.LBE175:
 568:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 569:setup.c       **** 	
 570:setup.c       **** 	// Set data as inputs
 571:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 571 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 572:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 572 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 573:setup.c       **** 	
 574:setup.c       **** 	// Read and transmit the 2 bytes
 575:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 575 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 576:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 576 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 577:setup.c       **** 	
 578:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 578 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 579:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 579 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 580:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 580 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB177:
 1098               	.LBB178:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE178:
 1109               	.LBE177:
 581:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 582:setup.c       **** }
 1110               		.loc 1 582 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 583:setup.c       **** 
 584:setup.c       **** // Switch banks on the Flash
 585:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 585 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 586:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 586 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 587:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 587 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 588:setup.c       **** 	
 589:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 589 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 590:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 590 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 591:setup.c       **** }
 1157               		.loc 1 591 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 590:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 590 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 592:setup.c       **** 
 593:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 594:setup.c       **** // Takes 25ms after last command to erase sector
 595:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 595 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 596:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 596 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 597:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 597 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 598:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 598 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 599:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 599 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 600:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 600 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 601:setup.c       **** 	
 602:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 602 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB179:
 1222               	.LBB180:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE180:
 1233               	.LBE179:
 603:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 604:setup.c       **** }
 1234               		.loc 1 604 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 605:setup.c       **** 
 606:setup.c       **** // Write a single byte to the Flash address
 607:setup.c       **** // Takes 20us to program Flash
 608:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 608 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 609:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 609 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 610:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 610 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 611:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 611 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 612:setup.c       **** 	
 613:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 613 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB181:
 1292               	.LBB182:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE182:
 1301               	.LBE181:
 614:setup.c       **** 	_delay_us(20); // Wait byte program time
 615:setup.c       **** }
 1302               		.loc 1 615 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 616:setup.c       **** 
 617:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 618:setup.c       **** // Takes 20ms for write cycle
 619:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 619 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 620:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 620 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 621:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 621 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 622:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 622 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB183:
 623:setup.c       **** 	
 624:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 625:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 626:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 626 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 626 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 625:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 625 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE183:
 1400               	.LBB184:
 1401               	.LBB185:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE185:
 1412               	.LBE184:
 627:setup.c       **** 	}
 628:setup.c       **** 	_delay_ms(20); // Wait sector program time
 629:setup.c       **** }
 1413               		.loc 1 629 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 630:setup.c       **** 
 631:setup.c       **** 
 632:setup.c       **** 
 633:setup.c       **** // ---------- GB FLASH CARTS ----------
 634:setup.c       **** 
 635:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 636:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 636 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 637:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 637 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 638:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 638 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 639:setup.c       **** 	
 640:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 640 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 641:setup.c       **** 	
 642:setup.c       **** 	rdPin_low;
 1443               		.loc 1 642 0
 1444 03fe 9598      		cbi 0x12,5
 643:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 643 0
 1446               	/* #APP */
 1447               	 ;  643 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 644:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 644 0
 1451               	 ;  644 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 645:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 645 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 646:setup.c       **** 	rdPin_high;
 1458               		.loc 1 646 0
 1459 0406 959A      		sbi 0x12,5
 647:setup.c       **** 	
 648:setup.c       **** 	return data;
 649:setup.c       **** }
 1460               		.loc 1 649 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_read_byte_fast
 1467               	gb_flash_read_byte_fast:
 1468               	.LFB37:
 650:setup.c       **** 
 651:setup.c       **** // No setting address or outputs, assuming already set
 652:setup.c       **** uint8_t gb_flash_read_byte_fast(void) {
 1469               		.loc 1 652 0
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 653:setup.c       **** 	rdPin_low;
 1475               		.loc 1 653 0
 1476 040a 9598      		cbi 0x12,5
 654:setup.c       **** 	asm volatile("nop"); // Delay a little
 1477               		.loc 1 654 0
 1478               	/* #APP */
 1479               	 ;  654 "setup.c" 1
 1480 040c 0000      		nop
 1481               	 ;  0 "" 2
 655:setup.c       **** 	asm volatile("nop");
 1482               		.loc 1 655 0
 1483               	 ;  655 "setup.c" 1
 1484 040e 0000      		nop
 1485               	 ;  0 "" 2
 656:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1486               		.loc 1 656 0
 1487               	/* #NOAPP */
 1488 0410 83B3      		in r24,0x13
 1489               	.LVL116:
 657:setup.c       **** 	rdPin_high;
 1490               		.loc 1 657 0
 1491 0412 959A      		sbi 0x12,5
 658:setup.c       **** 	
 659:setup.c       **** 	return data;
 660:setup.c       **** }
 1492               		.loc 1 660 0
 1493 0414 0895      		ret
 1494               		.cfi_endproc
 1495               	.LFE37:
 1497               	.global	gb_flash_write_bus_cycle
 1499               	gb_flash_write_bus_cycle:
 1500               	.LFB38:
 661:setup.c       **** 
 662:setup.c       **** // Set the address and data for the write byte cycle to the flash
 663:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1501               		.loc 1 663 0
 1502               		.cfi_startproc
 1503               	.LVL117:
 1504 0416 CF93      		push r28
 1505               	.LCFI25:
 1506               		.cfi_def_cfa_offset 3
 1507               		.cfi_offset 28, -2
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 1 */
 1511               	.L__stack_usage = 1
 1512 0418 C62F      		mov r28,r22
 664:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1513               		.loc 1 664 0
 1514 041a 2FEF      		ldi r18,lo8(-1)
 1515 041c 24BB      		out 0x14,r18
 665:setup.c       **** 	set_16bit_address(address);
 1516               		.loc 1 665 0
 1517 041e 00D0      		rcall set_16bit_address
 1518               	.LVL118:
 666:setup.c       **** 	PORT_DATA7_0 = data;
 1519               		.loc 1 666 0
 1520 0420 C5BB      		out 0x15,r28
 667:setup.c       **** 	
 668:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1521               		.loc 1 668 0
 1522 0422 8091 0000 		lds r24,flashWriteWePin
 1523 0426 8134      		cpi r24,lo8(65)
 1524 0428 01F4      		brne .L71
 669:setup.c       **** 		audioPin_low; // WE low
 1525               		.loc 1 669 0
 1526 042a 3998      		cbi 0x7,1
 670:setup.c       **** 		asm volatile("nop");
 1527               		.loc 1 670 0
 1528               	/* #APP */
 1529               	 ;  670 "setup.c" 1
 1530 042c 0000      		nop
 1531               	 ;  0 "" 2
 671:setup.c       **** 		asm volatile("nop");
 1532               		.loc 1 671 0
 1533               	 ;  671 "setup.c" 1
 1534 042e 0000      		nop
 1535               	 ;  0 "" 2
 672:setup.c       **** 		asm volatile("nop");
 1536               		.loc 1 672 0
 1537               	 ;  672 "setup.c" 1
 1538 0430 0000      		nop
 1539               	 ;  0 "" 2
 673:setup.c       **** 		audioPin_high; // WE high
 1540               		.loc 1 673 0
 1541               	/* #NOAPP */
 1542 0432 399A      		sbi 0x7,1
 1543 0434 00C0      		rjmp .L72
 1544               	.L71:
 674:setup.c       **** 	}
 675:setup.c       **** 	else { // WR pin
 676:setup.c       **** 		wrPin_low; // WE low
 1545               		.loc 1 676 0
 1546 0436 9698      		cbi 0x12,6
 677:setup.c       **** 		asm volatile("nop");
 1547               		.loc 1 677 0
 1548               	/* #APP */
 1549               	 ;  677 "setup.c" 1
 1550 0438 0000      		nop
 1551               	 ;  0 "" 2
 678:setup.c       **** 		asm volatile("nop");
 1552               		.loc 1 678 0
 1553               	 ;  678 "setup.c" 1
 1554 043a 0000      		nop
 1555               	 ;  0 "" 2
 679:setup.c       **** 		asm volatile("nop");
 1556               		.loc 1 679 0
 1557               	 ;  679 "setup.c" 1
 1558 043c 0000      		nop
 1559               	 ;  0 "" 2
 680:setup.c       **** 		wrPin_high; // WE high
 1560               		.loc 1 680 0
 1561               	/* #NOAPP */
 1562 043e 969A      		sbi 0x12,6
 1563               	.L72:
 681:setup.c       **** 	}
 682:setup.c       **** 	
 683:setup.c       **** 	// Clear data outputs and set data pins as inputs
 684:setup.c       **** 	PORT_DATA7_0 = 0;
 1564               		.loc 1 684 0
 1565 0440 15BA      		out 0x15,__zero_reg__
 685:setup.c       **** 	DDR_DATA7_0 = 0;
 1566               		.loc 1 685 0
 1567 0442 14BA      		out 0x14,__zero_reg__
 1568               	/* epilogue start */
 686:setup.c       **** }
 1569               		.loc 1 686 0
 1570 0444 CF91      		pop r28
 1571               	.LVL119:
 1572 0446 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE38:
 1576               	.global	gb_flash_write_bus_cycle_fast
 1578               	gb_flash_write_bus_cycle_fast:
 1579               	.LFB39:
 687:setup.c       **** 
 688:setup.c       **** void gb_flash_write_bus_cycle_fast(uint16_t address, uint8_t data) {
 1580               		.loc 1 688 0
 1581               		.cfi_startproc
 1582               	.LVL120:
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1585               	/* stack size = 0 */
 1586               	.L__stack_usage = 0
 689:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 1587               		.loc 1 689 0
 1588 0448 9BBB      		out 0x1b,r25
 690:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1589               		.loc 1 690 0
 1590 044a 88BB      		out 0x18,r24
 691:setup.c       **** 	PORT_DATA7_0 = data;
 1591               		.loc 1 691 0
 1592 044c 65BB      		out 0x15,r22
 692:setup.c       **** 	
 693:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1593               		.loc 1 693 0
 1594 044e 8091 0000 		lds r24,flashWriteWePin
 1595               	.LVL121:
 1596 0452 8134      		cpi r24,lo8(65)
 1597 0454 01F4      		brne .L74
 1598               	.LVL122:
 1599               	.LBB188:
 1600               	.LBB189:
 694:setup.c       **** 		audioPin_low; // WE low
 1601               		.loc 1 694 0
 1602 0456 3998      		cbi 0x7,1
 695:setup.c       **** 		asm volatile("nop");
 1603               		.loc 1 695 0
 1604               	/* #APP */
 1605               	 ;  695 "setup.c" 1
 1606 0458 0000      		nop
 1607               	 ;  0 "" 2
 696:setup.c       **** 		asm volatile("nop");
 1608               		.loc 1 696 0
 1609               	 ;  696 "setup.c" 1
 1610 045a 0000      		nop
 1611               	 ;  0 "" 2
 697:setup.c       **** 		asm volatile("nop");
 1612               		.loc 1 697 0
 1613               	 ;  697 "setup.c" 1
 1614 045c 0000      		nop
 1615               	 ;  0 "" 2
 698:setup.c       **** 		audioPin_high; // WE high
 1616               		.loc 1 698 0
 1617               	/* #NOAPP */
 1618 045e 399A      		sbi 0x7,1
 1619 0460 0895      		ret
 1620               	.LVL123:
 1621               	.L74:
 1622               	.LBE189:
 1623               	.LBE188:
 699:setup.c       **** 	}
 700:setup.c       **** 	else { // WR pin
 701:setup.c       **** 		wrPin_low; // WE low
 1624               		.loc 1 701 0
 1625 0462 9698      		cbi 0x12,6
 702:setup.c       **** 		asm volatile("nop");
 1626               		.loc 1 702 0
 1627               	/* #APP */
 1628               	 ;  702 "setup.c" 1
 1629 0464 0000      		nop
 1630               	 ;  0 "" 2
 703:setup.c       **** 		asm volatile("nop");
 1631               		.loc 1 703 0
 1632               	 ;  703 "setup.c" 1
 1633 0466 0000      		nop
 1634               	 ;  0 "" 2
 704:setup.c       **** 		asm volatile("nop");
 1635               		.loc 1 704 0
 1636               	 ;  704 "setup.c" 1
 1637 0468 0000      		nop
 1638               	 ;  0 "" 2
 705:setup.c       **** 		wrPin_high; // WE high
 1639               		.loc 1 705 0
 1640               	/* #NOAPP */
 1641 046a 969A      		sbi 0x12,6
 1642 046c 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE39:
 1646               	.global	gb_flash_write_byte
 1648               	gb_flash_write_byte:
 1649               	.LFB40:
 706:setup.c       **** 	}
 707:setup.c       **** }
 708:setup.c       **** 
 709:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 710:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1650               		.loc 1 710 0
 1651               		.cfi_startproc
 1652               	.LVL124:
 1653 046e 0F93      		push r16
 1654               	.LCFI26:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 0470 1F93      		push r17
 1658               	.LCFI27:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661 0472 CF93      		push r28
 1662               	.LCFI28:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 28, -4
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 3 */
 1668               	.L__stack_usage = 3
 1669 0474 8C01      		movw r16,r24
 1670 0476 C62F      		mov r28,r22
 711:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1671               		.loc 1 711 0
 1672 0478 8FEF      		ldi r24,lo8(-1)
 1673               	.LVL125:
 1674 047a 84BB      		out 0x14,r24
 712:setup.c       **** 	
 713:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1675               		.loc 1 713 0
 1676 047c 6091 0000 		lds r22,flashWriteCycle+2
 1677               	.LVL126:
 1678 0480 8091 0000 		lds r24,flashWriteCycle
 1679 0484 9091 0000 		lds r25,flashWriteCycle+1
 1680 0488 00D0      		rcall gb_flash_write_bus_cycle_fast
 1681               	.LVL127:
 714:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1682               		.loc 1 714 0
 1683 048a 6091 0000 		lds r22,flashWriteCycle+6
 1684 048e 8091 0000 		lds r24,flashWriteCycle+4
 1685 0492 9091 0000 		lds r25,flashWriteCycle+4+1
 1686 0496 00D0      		rcall gb_flash_write_bus_cycle_fast
 1687               	.LVL128:
 715:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1688               		.loc 1 715 0
 1689 0498 6091 0000 		lds r22,flashWriteCycle+10
 1690 049c 8091 0000 		lds r24,flashWriteCycle+8
 1691 04a0 9091 0000 		lds r25,flashWriteCycle+8+1
 1692 04a4 00D0      		rcall gb_flash_write_bus_cycle_fast
 1693               	.LVL129:
 716:setup.c       **** 	gb_flash_write_bus_cycle_fast(address, data);
 1694               		.loc 1 716 0
 1695 04a6 6C2F      		mov r22,r28
 1696 04a8 C801      		movw r24,r16
 1697 04aa 00D0      		rcall gb_flash_write_bus_cycle_fast
 1698               	.LVL130:
 1699               	.LBB190:
 1700               	.LBB191:
 1701               		.loc 2 276 0
 1702 04ac 8DE0      		ldi r24,lo8(13)
 1703 04ae 8A95      	1:	dec r24
 1704 04b0 01F4      		brne 1b
 1705 04b2 0000      		nop
 1706               	.LVL131:
 1707               	.LBE191:
 1708               	.LBE190:
 717:setup.c       **** 	_delay_us(5); // Wait byte program time
 718:setup.c       **** 	
 719:setup.c       **** 	// Set data pins inputs
 720:setup.c       **** 	PORT_DATA7_0 = 0;
 1709               		.loc 1 720 0
 1710 04b4 15BA      		out 0x15,__zero_reg__
 721:setup.c       **** 	DDR_DATA7_0 = 0;
 1711               		.loc 1 721 0
 1712 04b6 14BA      		out 0x14,__zero_reg__
 722:setup.c       **** 	
 723:setup.c       **** 	// Verify data
 724:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte_fast();
 1713               		.loc 1 724 0
 1714 04b8 00D0      		rcall gb_flash_read_byte_fast
 1715               	.LVL132:
 1716               	.L77:
 725:setup.c       **** 	while (data != dataVerify) {
 1717               		.loc 1 725 0
 1718 04ba 8C17      		cp r24,r28
 1719 04bc 01F0      		breq .L76
 726:setup.c       **** 		dataVerify = gb_flash_read_byte_fast();
 1720               		.loc 1 726 0
 1721 04be 00D0      		rcall gb_flash_read_byte_fast
 1722               	.LVL133:
 1723               	.LBB192:
 1724               	.LBB193:
 1725               		.loc 2 276 0
 1726 04c0 92E0      		ldi r25,lo8(2)
 1727 04c2 9A95      	1:	dec r25
 1728 04c4 01F4      		brne 1b
 1729 04c6 00C0      		rjmp .
 1730               	.LVL134:
 1731               	.LBE193:
 1732               	.LBE192:
 727:setup.c       **** 		_delay_us(1);
 728:setup.c       **** 		if (writingTimedout == 1) {
 1733               		.loc 1 728 0
 1734 04c8 9091 0000 		lds r25,writingTimedout
 1735 04cc 9130      		cpi r25,lo8(1)
 1736 04ce 01F4      		brne .L77
 1737               	.L76:
 1738               	/* epilogue start */
 729:setup.c       **** 			break;
 730:setup.c       **** 		}
 731:setup.c       **** 	}
 732:setup.c       **** }
 1739               		.loc 1 732 0
 1740 04d0 CF91      		pop r28
 1741               	.LVL135:
 1742 04d2 1F91      		pop r17
 1743 04d4 0F91      		pop r16
 1744               	.LVL136:
 1745 04d6 0895      		ret
 1746               		.cfi_endproc
 1747               	.LFE40:
 1749               	.global	gb_flash_write_byte_special
 1751               	gb_flash_write_byte_special:
 1752               	.LFB41:
 733:setup.c       **** 
 734:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 735:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1753               		.loc 1 735 0
 1754               		.cfi_startproc
 1755               	.LVL137:
 1756 04d8 1F93      		push r17
 1757               	.LCFI29:
 1758               		.cfi_def_cfa_offset 3
 1759               		.cfi_offset 17, -2
 1760 04da CF93      		push r28
 1761               	.LCFI30:
 1762               		.cfi_def_cfa_offset 4
 1763               		.cfi_offset 28, -3
 1764 04dc DF93      		push r29
 1765               	.LCFI31:
 1766               		.cfi_def_cfa_offset 5
 1767               		.cfi_offset 29, -4
 1768               	/* prologue: function */
 1769               	/* frame size = 0 */
 1770               	/* stack size = 3 */
 1771               	.L__stack_usage = 3
 1772 04de EC01      		movw r28,r24
 1773 04e0 162F      		mov r17,r22
 736:setup.c       **** 	// Set bank back
 737:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1774               		.loc 1 737 0
 1775 04e2 8091 0000 		lds r24,flashBank1CommandWrites
 1776               	.LVL138:
 1777 04e6 8130      		cpi r24,lo8(1)
 1778 04e8 01F4      		brne .L82
 738:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1779               		.loc 1 738 0
 1780 04ea 40E0      		ldi r20,0
 1781 04ec 6091 0000 		lds r22,lastBankAccessed
 1782               	.LVL139:
 1783 04f0 80E0      		ldi r24,0
 1784 04f2 91E2      		ldi r25,lo8(33)
 1785 04f4 00D0      		rcall write_8bit_data
 1786               	.LVL140:
 1787               	.LBB194:
 1788               	.LBB195:
 1789               		.loc 2 276 0
 1790 04f6 85E8      		ldi r24,lo8(-123)
 1791 04f8 8A95      	1:	dec r24
 1792 04fa 01F4      		brne 1b
 1793 04fc 0000      		nop
 1794               	.LVL141:
 1795               	.L82:
 1796               	.LBE195:
 1797               	.LBE194:
 739:setup.c       **** 		_delay_us(50);
 740:setup.c       **** 	}
 741:setup.c       **** 	
 742:setup.c       **** 	// Write
 743:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1798               		.loc 1 743 0
 1799 04fe 6091 0000 		lds r22,flashWriteCycle+2
 1800 0502 8091 0000 		lds r24,flashWriteCycle
 1801 0506 9091 0000 		lds r25,flashWriteCycle+1
 1802 050a 00D0      		rcall gb_flash_write_bus_cycle
 1803               	.LVL142:
 744:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1804               		.loc 1 744 0
 1805 050c 6091 0000 		lds r22,flashWriteCycle+6
 1806 0510 8091 0000 		lds r24,flashWriteCycle+4
 1807 0514 9091 0000 		lds r25,flashWriteCycle+4+1
 1808 0518 00D0      		rcall gb_flash_write_bus_cycle
 1809               	.LVL143:
 745:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1810               		.loc 1 745 0
 1811 051a 6091 0000 		lds r22,flashWriteCycle+10
 1812 051e 8091 0000 		lds r24,flashWriteCycle+8
 1813 0522 9091 0000 		lds r25,flashWriteCycle+8+1
 1814 0526 00D0      		rcall gb_flash_write_bus_cycle
 1815               	.LVL144:
 746:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1816               		.loc 1 746 0
 1817 0528 612F      		mov r22,r17
 1818 052a CE01      		movw r24,r28
 1819 052c 00D0      		rcall gb_flash_write_bus_cycle
 1820               	.LVL145:
 1821               	.LBB196:
 1822               	.LBB197:
 1823               		.loc 2 276 0
 1824 052e 83EF      		ldi r24,lo8(499)
 1825 0530 91E0      		ldi r25,hi8(499)
 1826 0532 0197      	1:	sbiw r24,1
 1827 0534 01F4      		brne 1b
 1828 0536 00C0      		rjmp .
 1829 0538 0000      		nop
 1830               	.LVL146:
 1831               	.LBE197:
 1832               	.LBE196:
 747:setup.c       **** 	_delay_us(250); // Wait byte program time
 748:setup.c       **** 	
 749:setup.c       **** 	// Set data pins inputs
 750:setup.c       **** 	PORT_DATA7_0 = 0;
 1833               		.loc 1 750 0
 1834 053a 15BA      		out 0x15,__zero_reg__
 751:setup.c       **** 	DDR_DATA7_0 = 0;
 1835               		.loc 1 751 0
 1836 053c 14BA      		out 0x14,__zero_reg__
 752:setup.c       **** 	
 753:setup.c       **** 	// Pulse reset
 754:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1837               		.loc 1 754 0
 1838 053e 3A98      		cbi 0x7,2
 1839               	.LVL147:
 1840               	.LBB198:
 1841               	.LBB199:
 1842               		.loc 2 276 0
 1843 0540 95E8      		ldi r25,lo8(-123)
 1844 0542 9A95      	1:	dec r25
 1845 0544 01F4      		brne 1b
 1846 0546 0000      		nop
 1847               	.LVL148:
 1848               	.LBE199:
 1849               	.LBE198:
 755:setup.c       **** 	_delay_us(50);
 756:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1850               		.loc 1 756 0
 1851 0548 3A9A      		sbi 0x7,2
 1852               	.LVL149:
 1853               	.LBB200:
 1854               	.LBB201:
 1855               		.loc 2 276 0
 1856 054a 85E8      		ldi r24,lo8(-123)
 1857 054c 8A95      	1:	dec r24
 1858 054e 01F4      		brne 1b
 1859 0550 0000      		nop
 1860               	.LVL150:
 1861               	/* epilogue start */
 1862               	.LBE201:
 1863               	.LBE200:
 757:setup.c       **** 	_delay_us(50);
 758:setup.c       **** }
 1864               		.loc 1 758 0
 1865 0552 DF91      		pop r29
 1866 0554 CF91      		pop r28
 1867               	.LVL151:
 1868 0556 1F91      		pop r17
 1869               	.LVL152:
 1870 0558 0895      		ret
 1871               		.cfi_endproc
 1872               	.LFE41:
 1874               	.global	gb_flash_write_byte_bank1_commands
 1876               	gb_flash_write_byte_bank1_commands:
 1877               	.LFB42:
 759:setup.c       **** 
 760:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 761:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 762:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1878               		.loc 1 762 0
 1879               		.cfi_startproc
 1880               	.LVL153:
 1881 055a FF92      		push r15
 1882               	.LCFI32:
 1883               		.cfi_def_cfa_offset 3
 1884               		.cfi_offset 15, -2
 1885 055c 0F93      		push r16
 1886               	.LCFI33:
 1887               		.cfi_def_cfa_offset 4
 1888               		.cfi_offset 16, -3
 1889 055e 1F93      		push r17
 1890               	.LCFI34:
 1891               		.cfi_def_cfa_offset 5
 1892               		.cfi_offset 17, -4
 1893 0560 CF93      		push r28
 1894               	.LCFI35:
 1895               		.cfi_def_cfa_offset 6
 1896               		.cfi_offset 28, -5
 1897 0562 DF93      		push r29
 1898               	.LCFI36:
 1899               		.cfi_def_cfa_offset 7
 1900               		.cfi_offset 29, -6
 1901               	/* prologue: function */
 1902               	/* frame size = 0 */
 1903               	/* stack size = 5 */
 1904               	.L__stack_usage = 5
 1905 0564 EC01      		movw r28,r24
 1906 0566 162F      		mov r17,r22
 763:setup.c       **** 	// Set bank 1
 764:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1907               		.loc 1 764 0
 1908 0568 FF24      		clr r15
 1909 056a FA94      		dec r15
 1910 056c F4BA      		out 0x14,r15
 1911               	.LVL154:
 1912               	.LBB202:
 1913               	.LBB203:
 258:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1914               		.loc 1 258 0
 1915 056e 01E2      		ldi r16,lo8(33)
 1916 0570 0BBB      		out 0x1b,r16
 259:setup.c       **** }
 1917               		.loc 1 259 0
 1918 0572 18BA      		out 0x18,__zero_reg__
 1919               	.LVL155:
 1920               	.LBE203:
 1921               	.LBE202:
 765:setup.c       **** 	set_16bit_address(0x2100);
 766:setup.c       **** 	PORT_DATA7_0 = 1;
 1922               		.loc 1 766 0
 1923 0574 81E0      		ldi r24,lo8(1)
 1924               	.LVL156:
 1925 0576 85BB      		out 0x15,r24
 767:setup.c       **** 	wrPin_low; // Pulse WR
 1926               		.loc 1 767 0
 1927 0578 9698      		cbi 0x12,6
 768:setup.c       **** 	asm volatile("nop");
 1928               		.loc 1 768 0
 1929               	/* #APP */
 1930               	 ;  768 "setup.c" 1
 1931 057a 0000      		nop
 1932               	 ;  0 "" 2
 769:setup.c       **** 	wrPin_high;
 1933               		.loc 1 769 0
 1934               	/* #NOAPP */
 1935 057c 969A      		sbi 0x12,6
 770:setup.c       **** 	
 771:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1936               		.loc 1 771 0
 1937 057e 6091 0000 		lds r22,flashWriteCycle+2
 1938               	.LVL157:
 1939 0582 8091 0000 		lds r24,flashWriteCycle
 1940 0586 9091 0000 		lds r25,flashWriteCycle+1
 1941 058a 00D0      		rcall gb_flash_write_bus_cycle
 1942               	.LVL158:
 772:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1943               		.loc 1 772 0
 1944 058c 6091 0000 		lds r22,flashWriteCycle+6
 1945 0590 8091 0000 		lds r24,flashWriteCycle+4
 1946 0594 9091 0000 		lds r25,flashWriteCycle+4+1
 1947 0598 00D0      		rcall gb_flash_write_bus_cycle
 1948               	.LVL159:
 773:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1949               		.loc 1 773 0
 1950 059a 6091 0000 		lds r22,flashWriteCycle+10
 1951 059e 8091 0000 		lds r24,flashWriteCycle+8
 1952 05a2 9091 0000 		lds r25,flashWriteCycle+8+1
 1953 05a6 00D0      		rcall gb_flash_write_bus_cycle
 1954               	.LVL160:
 774:setup.c       **** 	
 775:setup.c       **** 	
 776:setup.c       **** 	// Set bank back
 777:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1955               		.loc 1 777 0
 1956 05a8 F4BA      		out 0x14,r15
 1957               	.LVL161:
 1958               	.LBB204:
 1959               	.LBB205:
 258:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1960               		.loc 1 258 0
 1961 05aa 0BBB      		out 0x1b,r16
 259:setup.c       **** }
 1962               		.loc 1 259 0
 1963 05ac 18BA      		out 0x18,__zero_reg__
 1964               	.LVL162:
 1965               	.LBE205:
 1966               	.LBE204:
 778:setup.c       **** 	set_16bit_address(0x2100);
 779:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1967               		.loc 1 779 0
 1968 05ae 8091 0000 		lds r24,lastBankAccessed
 1969 05b2 85BB      		out 0x15,r24
 780:setup.c       **** 	wrPin_low; // Pulse WR
 1970               		.loc 1 780 0
 1971 05b4 9698      		cbi 0x12,6
 781:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 781 0
 1973               	/* #APP */
 1974               	 ;  781 "setup.c" 1
 1975 05b6 0000      		nop
 1976               	 ;  0 "" 2
 782:setup.c       **** 	wrPin_high;
 1977               		.loc 1 782 0
 1978               	/* #NOAPP */
 1979 05b8 969A      		sbi 0x12,6
 783:setup.c       **** 	
 784:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1980               		.loc 1 784 0
 1981 05ba 612F      		mov r22,r17
 1982 05bc CE01      		movw r24,r28
 1983 05be 00D0      		rcall gb_flash_write_bus_cycle
 1984               	.LVL163:
 1985               	.LBB206:
 1986               	.LBB207:
 1987               		.loc 2 276 0
 1988 05c0 8AE1      		ldi r24,lo8(26)
 1989 05c2 8A95      	1:	dec r24
 1990 05c4 01F4      		brne 1b
 1991 05c6 00C0      		rjmp .
 1992               	.LVL164:
 1993               	.LBE207:
 1994               	.LBE206:
 785:setup.c       **** 	_delay_us(10); // Wait byte program time
 786:setup.c       **** 	
 787:setup.c       **** 	// Set data pins inputs
 788:setup.c       **** 	PORT_DATA7_0 = 0;
 1995               		.loc 1 788 0
 1996 05c8 15BA      		out 0x15,__zero_reg__
 789:setup.c       **** 	DDR_DATA7_0 = 0;
 1997               		.loc 1 789 0
 1998 05ca 14BA      		out 0x14,__zero_reg__
 790:setup.c       **** 	
 791:setup.c       **** 	// Verify data
 792:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1999               		.loc 1 792 0
 2000 05cc CE01      		movw r24,r28
 2001 05ce 00D0      		rcall gb_flash_read_byte
 2002               	.LVL165:
 2003               	.L84:
 793:setup.c       **** 	while (data != dataVerify) {
 2004               		.loc 1 793 0
 2005 05d0 8117      		cp r24,r17
 2006 05d2 01F0      		breq .L83
 794:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2007               		.loc 1 794 0
 2008 05d4 CE01      		movw r24,r28
 2009               	.LVL166:
 2010 05d6 00D0      		rcall gb_flash_read_byte
 2011               	.LVL167:
 2012               	.LBB208:
 2013               	.LBB209:
 2014               		.loc 2 276 0
 2015 05d8 9DE0      		ldi r25,lo8(13)
 2016 05da 9A95      	1:	dec r25
 2017 05dc 01F4      		brne 1b
 2018 05de 0000      		nop
 2019               	.LVL168:
 2020               	.LBE209:
 2021               	.LBE208:
 795:setup.c       **** 		_delay_us(5);
 796:setup.c       **** 		if (writingTimedout == 1) {
 2022               		.loc 1 796 0
 2023 05e0 9091 0000 		lds r25,writingTimedout
 2024 05e4 9130      		cpi r25,lo8(1)
 2025 05e6 01F4      		brne .L84
 2026               	.L83:
 2027               	/* epilogue start */
 797:setup.c       **** 			break;
 798:setup.c       **** 		}
 799:setup.c       **** 	}
 800:setup.c       **** }
 2028               		.loc 1 800 0
 2029 05e8 DF91      		pop r29
 2030 05ea CF91      		pop r28
 2031               	.LVL169:
 2032 05ec 1F91      		pop r17
 2033               	.LVL170:
 2034 05ee 0F91      		pop r16
 2035 05f0 FF90      		pop r15
 2036 05f2 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE42:
 2040               	.global	gba_flash_write_bus_cycle
 2042               	gba_flash_write_bus_cycle:
 2043               	.LFB43:
 801:setup.c       **** 
 802:setup.c       **** 
 803:setup.c       **** 
 804:setup.c       **** // ---------- GBA FLASH CARTS ----------
 805:setup.c       **** 
 806:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 807:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2044               		.loc 1 807 0
 2045               		.cfi_startproc
 2046               	.LVL171:
 2047 05f4 0F93      		push r16
 2048               	.LCFI37:
 2049               		.cfi_def_cfa_offset 3
 2050               		.cfi_offset 16, -2
 2051 05f6 1F93      		push r17
 2052               	.LCFI38:
 2053               		.cfi_def_cfa_offset 4
 2054               		.cfi_offset 17, -3
 2055               	/* prologue: function */
 2056               	/* frame size = 0 */
 2057               	/* stack size = 2 */
 2058               	.L__stack_usage = 2
 808:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 2059               		.loc 1 808 0
 2060 05f8 8C01      		movw r16,r24
 2061 05fa 2227      		clr r18
 2062 05fc 3327      		clr r19
 2063 05fe 05BB      		out 0x15,r16
 809:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 2064               		.loc 1 809 0
 2065 0600 072F      		mov r16,r23
 2066 0602 182F      		mov r17,r24
 2067 0604 292F      		mov r18,r25
 2068 0606 3327      		clr r19
 2069 0608 0BBB      		out 0x1b,r16
 810:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 2070               		.loc 1 810 0
 2071 060a 68BB      		out 0x18,r22
 811:setup.c       **** 	
 812:setup.c       **** 	cs_mreqPin_low;
 2072               		.loc 1 812 0
 2073 060c 9498      		cbi 0x12,4
 813:setup.c       **** 	
 814:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2074               		.loc 1 814 0
 2075 060e 5BBB      		out 0x1b,r21
 815:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2076               		.loc 1 815 0
 2077 0610 48BB      		out 0x18,r20
 816:setup.c       **** 	
 817:setup.c       **** 	wrPin_low;
 2078               		.loc 1 817 0
 2079 0612 9698      		cbi 0x12,6
 818:setup.c       **** 	asm volatile("nop");
 2080               		.loc 1 818 0
 2081               	/* #APP */
 2082               	 ;  818 "setup.c" 1
 2083 0614 0000      		nop
 2084               	 ;  0 "" 2
 819:setup.c       **** 	asm volatile("nop");
 2085               		.loc 1 819 0
 2086               	 ;  819 "setup.c" 1
 2087 0616 0000      		nop
 2088               	 ;  0 "" 2
 820:setup.c       **** 	asm volatile("nop");
 2089               		.loc 1 820 0
 2090               	 ;  820 "setup.c" 1
 2091 0618 0000      		nop
 2092               	 ;  0 "" 2
 821:setup.c       **** 	wrPin_high;
 2093               		.loc 1 821 0
 2094               	/* #NOAPP */
 2095 061a 969A      		sbi 0x12,6
 822:setup.c       **** 	cs_mreqPin_high;
 2096               		.loc 1 822 0
 2097 061c 949A      		sbi 0x12,4
 2098               	/* epilogue start */
 823:setup.c       **** }
 2099               		.loc 1 823 0
 2100 061e 1F91      		pop r17
 2101 0620 0F91      		pop r16
 2102 0622 0895      		ret
 2103               		.cfi_endproc
 2104               	.LFE43:
 2106               	.global	gba_flash_write_cycle_start_swapped
 2108               	gba_flash_write_cycle_start_swapped:
 2109               	.LFB44:
 824:setup.c       **** 
 825:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 826:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2110               		.loc 1 826 0
 2111               		.cfi_startproc
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 0 */
 2115               	.L__stack_usage = 0
 827:setup.c       **** 	// Set outputs
 828:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2116               		.loc 1 828 0
 2117 0624 8FEF      		ldi r24,lo8(-1)
 2118 0626 84BB      		out 0x14,r24
 829:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2119               		.loc 1 829 0
 2120 0628 8ABB      		out 0x1a,r24
 830:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2121               		.loc 1 830 0
 2122 062a 87BB      		out 0x17,r24
 831:setup.c       **** 	
 832:setup.c       **** 	// 0x555, 0xA9
 833:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2123               		.loc 1 833 0
 2124 062c 15BA      		out 0x15,__zero_reg__
 834:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2125               		.loc 1 834 0
 2126 062e 95E0      		ldi r25,lo8(5)
 2127 0630 9BBB      		out 0x1b,r25
 835:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2128               		.loc 1 835 0
 2129 0632 85E5      		ldi r24,lo8(85)
 2130 0634 88BB      		out 0x18,r24
 836:setup.c       **** 	cs_mreqPin_low;
 2131               		.loc 1 836 0
 2132 0636 9498      		cbi 0x12,4
 837:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2133               		.loc 1 837 0
 2134 0638 1BBA      		out 0x1b,__zero_reg__
 838:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2135               		.loc 1 838 0
 2136 063a 29EA      		ldi r18,lo8(-87)
 2137 063c 28BB      		out 0x18,r18
 839:setup.c       **** 	wrPin_low;
 2138               		.loc 1 839 0
 2139 063e 9698      		cbi 0x12,6
 840:setup.c       **** 	asm volatile("nop");
 2140               		.loc 1 840 0
 2141               	/* #APP */
 2142               	 ;  840 "setup.c" 1
 2143 0640 0000      		nop
 2144               	 ;  0 "" 2
 841:setup.c       **** 	asm volatile("nop");
 2145               		.loc 1 841 0
 2146               	 ;  841 "setup.c" 1
 2147 0642 0000      		nop
 2148               	 ;  0 "" 2
 842:setup.c       **** 	asm volatile("nop");
 2149               		.loc 1 842 0
 2150               	 ;  842 "setup.c" 1
 2151 0644 0000      		nop
 2152               	 ;  0 "" 2
 843:setup.c       **** 	wrPin_high;
 2153               		.loc 1 843 0
 2154               	/* #NOAPP */
 2155 0646 969A      		sbi 0x12,6
 844:setup.c       **** 	cs_mreqPin_high;
 2156               		.loc 1 844 0
 2157 0648 949A      		sbi 0x12,4
 845:setup.c       **** 	
 846:setup.c       **** 	// 0x2AA, 0x56
 847:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2158               		.loc 1 847 0
 2159 064a 15BA      		out 0x15,__zero_reg__
 848:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2160               		.loc 1 848 0
 2161 064c 22E0      		ldi r18,lo8(2)
 2162 064e 2BBB      		out 0x1b,r18
 849:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2163               		.loc 1 849 0
 2164 0650 2AEA      		ldi r18,lo8(-86)
 2165 0652 28BB      		out 0x18,r18
 850:setup.c       **** 	cs_mreqPin_low;
 2166               		.loc 1 850 0
 2167 0654 9498      		cbi 0x12,4
 851:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2168               		.loc 1 851 0
 2169 0656 1BBA      		out 0x1b,__zero_reg__
 852:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2170               		.loc 1 852 0
 2171 0658 26E5      		ldi r18,lo8(86)
 2172 065a 28BB      		out 0x18,r18
 853:setup.c       **** 	wrPin_low;
 2173               		.loc 1 853 0
 2174 065c 9698      		cbi 0x12,6
 854:setup.c       **** 	asm volatile("nop");
 2175               		.loc 1 854 0
 2176               	/* #APP */
 2177               	 ;  854 "setup.c" 1
 2178 065e 0000      		nop
 2179               	 ;  0 "" 2
 855:setup.c       **** 	asm volatile("nop");
 2180               		.loc 1 855 0
 2181               	 ;  855 "setup.c" 1
 2182 0660 0000      		nop
 2183               	 ;  0 "" 2
 856:setup.c       **** 	asm volatile("nop");
 2184               		.loc 1 856 0
 2185               	 ;  856 "setup.c" 1
 2186 0662 0000      		nop
 2187               	 ;  0 "" 2
 857:setup.c       **** 	wrPin_high;
 2188               		.loc 1 857 0
 2189               	/* #NOAPP */
 2190 0664 969A      		sbi 0x12,6
 858:setup.c       **** 	cs_mreqPin_high;
 2191               		.loc 1 858 0
 2192 0666 949A      		sbi 0x12,4
 859:setup.c       **** 	
 860:setup.c       **** 	// 0x555, 0xA0;
 861:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2193               		.loc 1 861 0
 2194 0668 15BA      		out 0x15,__zero_reg__
 862:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2195               		.loc 1 862 0
 2196 066a 9BBB      		out 0x1b,r25
 863:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2197               		.loc 1 863 0
 2198 066c 88BB      		out 0x18,r24
 864:setup.c       **** 	cs_mreqPin_low;
 2199               		.loc 1 864 0
 2200 066e 9498      		cbi 0x12,4
 865:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2201               		.loc 1 865 0
 2202 0670 1BBA      		out 0x1b,__zero_reg__
 866:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2203               		.loc 1 866 0
 2204 0672 80EA      		ldi r24,lo8(-96)
 2205 0674 88BB      		out 0x18,r24
 867:setup.c       **** 	wrPin_low;
 2206               		.loc 1 867 0
 2207 0676 9698      		cbi 0x12,6
 868:setup.c       **** 	asm volatile("nop");
 2208               		.loc 1 868 0
 2209               	/* #APP */
 2210               	 ;  868 "setup.c" 1
 2211 0678 0000      		nop
 2212               	 ;  0 "" 2
 869:setup.c       **** 	asm volatile("nop");
 2213               		.loc 1 869 0
 2214               	 ;  869 "setup.c" 1
 2215 067a 0000      		nop
 2216               	 ;  0 "" 2
 870:setup.c       **** 	asm volatile("nop");
 2217               		.loc 1 870 0
 2218               	 ;  870 "setup.c" 1
 2219 067c 0000      		nop
 2220               	 ;  0 "" 2
 871:setup.c       **** 	wrPin_high;
 2221               		.loc 1 871 0
 2222               	/* #NOAPP */
 2223 067e 969A      		sbi 0x12,6
 872:setup.c       **** 	cs_mreqPin_high;
 2224               		.loc 1 872 0
 2225 0680 949A      		sbi 0x12,4
 2226 0682 0895      		ret
 2227               		.cfi_endproc
 2228               	.LFE44:
 2230               	.global	gba_flash_write_cycle_start
 2232               	gba_flash_write_cycle_start:
 2233               	.LFB45:
 873:setup.c       **** }
 874:setup.c       **** 
 875:setup.c       **** 
 876:setup.c       **** // Send the first 3 write cycles to the flash
 877:setup.c       **** void gba_flash_write_cycle_start(void) {
 2234               		.loc 1 877 0
 2235               		.cfi_startproc
 2236               	/* prologue: function */
 2237               	/* frame size = 0 */
 2238               	/* stack size = 0 */
 2239               	.L__stack_usage = 0
 878:setup.c       **** 	// Set outputs
 879:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2240               		.loc 1 879 0
 2241 0684 8FEF      		ldi r24,lo8(-1)
 2242 0686 84BB      		out 0x14,r24
 880:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2243               		.loc 1 880 0
 2244 0688 8ABB      		out 0x1a,r24
 881:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2245               		.loc 1 881 0
 2246 068a 87BB      		out 0x17,r24
 882:setup.c       **** 	
 883:setup.c       **** 	// 0x555, 0xAA
 884:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2247               		.loc 1 884 0
 2248 068c 15BA      		out 0x15,__zero_reg__
 885:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2249               		.loc 1 885 0
 2250 068e 95E0      		ldi r25,lo8(5)
 2251 0690 9BBB      		out 0x1b,r25
 886:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2252               		.loc 1 886 0
 2253 0692 85E5      		ldi r24,lo8(85)
 2254 0694 88BB      		out 0x18,r24
 887:setup.c       **** 	cs_mreqPin_low;
 2255               		.loc 1 887 0
 2256 0696 9498      		cbi 0x12,4
 888:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2257               		.loc 1 888 0
 2258 0698 1BBA      		out 0x1b,__zero_reg__
 889:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2259               		.loc 1 889 0
 2260 069a 2AEA      		ldi r18,lo8(-86)
 2261 069c 28BB      		out 0x18,r18
 890:setup.c       **** 	wrPin_low;
 2262               		.loc 1 890 0
 2263 069e 9698      		cbi 0x12,6
 891:setup.c       **** 	asm volatile("nop");
 2264               		.loc 1 891 0
 2265               	/* #APP */
 2266               	 ;  891 "setup.c" 1
 2267 06a0 0000      		nop
 2268               	 ;  0 "" 2
 892:setup.c       **** 	asm volatile("nop");
 2269               		.loc 1 892 0
 2270               	 ;  892 "setup.c" 1
 2271 06a2 0000      		nop
 2272               	 ;  0 "" 2
 893:setup.c       **** 	asm volatile("nop");
 2273               		.loc 1 893 0
 2274               	 ;  893 "setup.c" 1
 2275 06a4 0000      		nop
 2276               	 ;  0 "" 2
 894:setup.c       **** 	wrPin_high;
 2277               		.loc 1 894 0
 2278               	/* #NOAPP */
 2279 06a6 969A      		sbi 0x12,6
 895:setup.c       **** 	cs_mreqPin_high;
 2280               		.loc 1 895 0
 2281 06a8 949A      		sbi 0x12,4
 896:setup.c       **** 	
 897:setup.c       **** 	// 0x2AA, 0x55
 898:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2282               		.loc 1 898 0
 2283 06aa 15BA      		out 0x15,__zero_reg__
 899:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2284               		.loc 1 899 0
 2285 06ac 32E0      		ldi r19,lo8(2)
 2286 06ae 3BBB      		out 0x1b,r19
 900:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2287               		.loc 1 900 0
 2288 06b0 28BB      		out 0x18,r18
 901:setup.c       **** 	cs_mreqPin_low;
 2289               		.loc 1 901 0
 2290 06b2 9498      		cbi 0x12,4
 902:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2291               		.loc 1 902 0
 2292 06b4 1BBA      		out 0x1b,__zero_reg__
 903:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2293               		.loc 1 903 0
 2294 06b6 88BB      		out 0x18,r24
 904:setup.c       **** 	wrPin_low;
 2295               		.loc 1 904 0
 2296 06b8 9698      		cbi 0x12,6
 905:setup.c       **** 	asm volatile("nop");
 2297               		.loc 1 905 0
 2298               	/* #APP */
 2299               	 ;  905 "setup.c" 1
 2300 06ba 0000      		nop
 2301               	 ;  0 "" 2
 906:setup.c       **** 	asm volatile("nop");
 2302               		.loc 1 906 0
 2303               	 ;  906 "setup.c" 1
 2304 06bc 0000      		nop
 2305               	 ;  0 "" 2
 907:setup.c       **** 	asm volatile("nop");
 2306               		.loc 1 907 0
 2307               	 ;  907 "setup.c" 1
 2308 06be 0000      		nop
 2309               	 ;  0 "" 2
 908:setup.c       **** 	wrPin_high;
 2310               		.loc 1 908 0
 2311               	/* #NOAPP */
 2312 06c0 969A      		sbi 0x12,6
 909:setup.c       **** 	cs_mreqPin_high;
 2313               		.loc 1 909 0
 2314 06c2 949A      		sbi 0x12,4
 910:setup.c       **** 	
 911:setup.c       **** 	// 0x555, 0xA0;
 912:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2315               		.loc 1 912 0
 2316 06c4 15BA      		out 0x15,__zero_reg__
 913:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2317               		.loc 1 913 0
 2318 06c6 9BBB      		out 0x1b,r25
 914:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2319               		.loc 1 914 0
 2320 06c8 88BB      		out 0x18,r24
 915:setup.c       **** 	cs_mreqPin_low;
 2321               		.loc 1 915 0
 2322 06ca 9498      		cbi 0x12,4
 916:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2323               		.loc 1 916 0
 2324 06cc 1BBA      		out 0x1b,__zero_reg__
 917:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2325               		.loc 1 917 0
 2326 06ce 80EA      		ldi r24,lo8(-96)
 2327 06d0 88BB      		out 0x18,r24
 918:setup.c       **** 	wrPin_low;
 2328               		.loc 1 918 0
 2329 06d2 9698      		cbi 0x12,6
 919:setup.c       **** 	asm volatile("nop");
 2330               		.loc 1 919 0
 2331               	/* #APP */
 2332               	 ;  919 "setup.c" 1
 2333 06d4 0000      		nop
 2334               	 ;  0 "" 2
 920:setup.c       **** 	asm volatile("nop");
 2335               		.loc 1 920 0
 2336               	 ;  920 "setup.c" 1
 2337 06d6 0000      		nop
 2338               	 ;  0 "" 2
 921:setup.c       **** 	asm volatile("nop");
 2339               		.loc 1 921 0
 2340               	 ;  921 "setup.c" 1
 2341 06d8 0000      		nop
 2342               	 ;  0 "" 2
 922:setup.c       **** 	wrPin_high;
 2343               		.loc 1 922 0
 2344               	/* #NOAPP */
 2345 06da 969A      		sbi 0x12,6
 923:setup.c       **** 	cs_mreqPin_high;
 2346               		.loc 1 923 0
 2347 06dc 949A      		sbi 0x12,4
 2348 06de 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE45:
 2352               	.global	gba_flash_write_byte
 2354               	gba_flash_write_byte:
 2355               	.LFB46:
 924:setup.c       **** }	
 925:setup.c       **** 
 926:setup.c       **** 
 927:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 928:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 929:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2356               		.loc 1 929 0
 2357               		.cfi_startproc
 2358               	.LVL172:
 2359 06e0 CF92      		push r12
 2360               	.LCFI39:
 2361               		.cfi_def_cfa_offset 3
 2362               		.cfi_offset 12, -2
 2363 06e2 DF92      		push r13
 2364               	.LCFI40:
 2365               		.cfi_def_cfa_offset 4
 2366               		.cfi_offset 13, -3
 2367 06e4 EF92      		push r14
 2368               	.LCFI41:
 2369               		.cfi_def_cfa_offset 5
 2370               		.cfi_offset 14, -4
 2371 06e6 FF92      		push r15
 2372               	.LCFI42:
 2373               		.cfi_def_cfa_offset 6
 2374               		.cfi_offset 15, -5
 2375 06e8 CF93      		push r28
 2376               	.LCFI43:
 2377               		.cfi_def_cfa_offset 7
 2378               		.cfi_offset 28, -6
 2379 06ea DF93      		push r29
 2380               	.LCFI44:
 2381               		.cfi_def_cfa_offset 8
 2382               		.cfi_offset 29, -7
 2383               	/* prologue: function */
 2384               	/* frame size = 0 */
 2385               	/* stack size = 6 */
 2386               	.L__stack_usage = 6
 2387 06ec 6B01      		movw r12,r22
 2388 06ee 7C01      		movw r14,r24
 2389 06f0 EA01      		movw r28,r20
 930:setup.c       **** 	if (isD0D1Swapped == 0) {
 2390               		.loc 1 930 0
 2391 06f2 2111      		cpse r18,__zero_reg__
 2392 06f4 00C0      		rjmp .L92
 931:setup.c       **** 		gba_flash_write_cycle_start();
 2393               		.loc 1 931 0
 2394 06f6 00D0      		rcall gba_flash_write_cycle_start
 2395               	.LVL173:
 2396 06f8 00C0      		rjmp .L93
 2397               	.LVL174:
 2398               	.L92:
 932:setup.c       **** 	}
 933:setup.c       **** 	else {
 934:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2399               		.loc 1 934 0
 2400 06fa 00D0      		rcall gba_flash_write_cycle_start_swapped
 2401               	.LVL175:
 2402               	.L93:
 935:setup.c       **** 	}
 936:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2403               		.loc 1 936 0
 2404 06fc AE01      		movw r20,r28
 2405 06fe C701      		movw r24,r14
 2406 0700 B601      		movw r22,r12
 2407 0702 00D0      		rcall gba_flash_write_bus_cycle
 2408               	.LVL176:
 2409               	.LBB210:
 2410               	.LBB211:
 2411               		.loc 2 276 0
 2412 0704 25E0      		ldi r18,lo8(5)
 2413 0706 2A95      	1:	dec r18
 2414 0708 01F4      		brne 1b
 2415 070a 0000      		nop
 2416               	.LVL177:
 2417               	.LBE211:
 2418               	.LBE210:
 937:setup.c       **** 	_delay_us(2); // Wait byte program time
 938:setup.c       **** 	
 939:setup.c       **** 	// Verify data
 940:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2419               		.loc 1 940 0
 2420 070c C701      		movw r24,r14
 2421 070e B601      		movw r22,r12
 2422 0710 00D0      		rcall gba_read_16bit_data
 2423               	.LVL178:
 2424               	.L94:
 941:setup.c       **** 	while (data != dataVerify) {
 2425               		.loc 1 941 0
 2426 0712 8C17      		cp r24,r28
 2427 0714 9D07      		cpc r25,r29
 2428 0716 01F0      		breq .L91
 942:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2429               		.loc 1 942 0
 2430 0718 C701      		movw r24,r14
 2431 071a B601      		movw r22,r12
 2432 071c 00D0      		rcall gba_read_16bit_data
 2433               	.LVL179:
 2434               	.LBB212:
 2435               	.LBB213:
 2436               		.loc 2 276 0
 2437 071e 25E0      		ldi r18,lo8(5)
 2438 0720 2A95      	1:	dec r18
 2439 0722 01F4      		brne 1b
 2440 0724 0000      		nop
 2441               	.LVL180:
 2442               	.LBE213:
 2443               	.LBE212:
 943:setup.c       **** 		_delay_us(2);
 944:setup.c       **** 		if (writingTimedout == 1) {
 2444               		.loc 1 944 0
 2445 0726 2091 0000 		lds r18,writingTimedout
 2446 072a 2130      		cpi r18,lo8(1)
 2447 072c 01F4      		brne .L94
 2448               	.L91:
 2449               	/* epilogue start */
 945:setup.c       **** 			break;
 946:setup.c       **** 		}
 947:setup.c       **** 	}
 948:setup.c       **** }
 2450               		.loc 1 948 0
 2451 072e DF91      		pop r29
 2452 0730 CF91      		pop r28
 2453               	.LVL181:
 2454 0732 FF90      		pop r15
 2455 0734 EF90      		pop r14
 2456 0736 DF90      		pop r13
 2457 0738 CF90      		pop r12
 2458               	.LVL182:
 2459 073a 0895      		ret
 2460               		.cfi_endproc
 2461               	.LFE46:
 2463               	.global	start_timeout_timer
 2465               	start_timeout_timer:
 2466               	.LFB47:
 949:setup.c       **** 
 950:setup.c       **** // Timeout for ~500ms when flashing carts
 951:setup.c       **** void start_timeout_timer(void) {
 2467               		.loc 1 951 0
 2468               		.cfi_startproc
 2469               	/* prologue: function */
 2470               	/* frame size = 0 */
 2471               	/* stack size = 0 */
 2472               	.L__stack_usage = 0
 952:setup.c       **** 	writingTimedout = 0;
 2473               		.loc 1 952 0
 2474 073c 1092 0000 		sts writingTimedout,__zero_reg__
 953:setup.c       **** 	TCNT1 = 0;
 2475               		.loc 1 953 0
 2476 0740 1DBC      		out 0x2c+1,__zero_reg__
 2477 0742 1CBC      		out 0x2c,__zero_reg__
 954:setup.c       **** 	TCCR1B |= (1<<CS11) | (1<<CS10);
 2478               		.loc 1 954 0
 2479 0744 8EB5      		in r24,0x2e
 2480 0746 8360      		ori r24,lo8(3)
 2481 0748 8EBD      		out 0x2e,r24
 2482 074a 0895      		ret
 2483               		.cfi_endproc
 2484               	.LFE47:
 2486               	.global	stop_timeout_timer
 2488               	stop_timeout_timer:
 2489               	.LFB48:
 955:setup.c       **** }
 956:setup.c       **** 
 957:setup.c       **** // Stop the flash timeout timer
 958:setup.c       **** void stop_timeout_timer(void) {
 2490               		.loc 1 958 0
 2491               		.cfi_startproc
 2492               	/* prologue: function */
 2493               	/* frame size = 0 */
 2494               	/* stack size = 0 */
 2495               	.L__stack_usage = 0
 959:setup.c       **** 	writingTimedout = 0;
 2496               		.loc 1 959 0
 2497 074c 1092 0000 		sts writingTimedout,__zero_reg__
 960:setup.c       **** 	TCNT1 = 0;
 2498               		.loc 1 960 0
 2499 0750 1DBC      		out 0x2c+1,__zero_reg__
 2500 0752 1CBC      		out 0x2c,__zero_reg__
 961:setup.c       **** 	TCCR1B = 0;
 2501               		.loc 1 961 0
 2502 0754 1EBC      		out 0x2e,__zero_reg__
 962:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2503               		.loc 1 962 0
 2504 0756 9398      		cbi 0x12,3
 2505 0758 0895      		ret
 2506               		.cfi_endproc
 2507               	.LFE48:
 2509               	.global	check_if_timed_out
 2511               	check_if_timed_out:
 2512               	.LFB49:
 963:setup.c       **** }
 964:setup.c       **** 
 965:setup.c       **** // If we didn't time out, stop the timeout timer and send back an ACK
 966:setup.c       **** void check_if_timed_out(void) {
 2513               		.loc 1 966 0
 2514               		.cfi_startproc
 2515               	/* prologue: function */
 2516               	/* frame size = 0 */
 2517               	/* stack size = 0 */
 2518               	.L__stack_usage = 0
 967:setup.c       **** 	if (writingTimedout == 0) {
 2519               		.loc 1 967 0
 2520 075a 8091 0000 		lds r24,writingTimedout
 2521 075e 8111      		cpse r24,__zero_reg__
 2522 0760 00C0      		rjmp .L100
 2523               	.LBB216:
 2524               	.LBB217:
 968:setup.c       **** 		stop_timeout_timer();		
 2525               		.loc 1 968 0
 2526 0762 00D0      		rcall stop_timeout_timer
 2527               	.LVL183:
 969:setup.c       **** 		USART_Transmit(SEND_ACK); // Send back acknowledgement
 2528               		.loc 1 969 0
 2529 0764 81E3      		ldi r24,lo8(49)
 2530 0766 00D0      		rcall USART_Transmit
 2531               	.LVL184:
 970:setup.c       **** 		PORTD &= ~(1<<ACTIVITY_LED);
 2532               		.loc 1 970 0
 2533 0768 9398      		cbi 0x12,3
 2534               	.L100:
 2535 076a 0895      		ret
 2536               	.LBE217:
 2537               	.LBE216:
 2538               		.cfi_endproc
 2539               	.LFE49:
 2541               	.global	setup
 2543               	setup:
 2544               	.LFB50:
 971:setup.c       **** 	}
 972:setup.c       **** }
 973:setup.c       **** 
 974:setup.c       **** 
 975:setup.c       **** // Setup
 976:setup.c       **** void setup(void) {
 2545               		.loc 1 976 0
 2546               		.cfi_startproc
 2547               	/* prologue: function */
 2548               	/* frame size = 0 */
 2549               	/* stack size = 0 */
 2550               	.L__stack_usage = 0
 977:setup.c       **** 	// Turn off watchdog
 978:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2551               		.loc 1 978 0
 2552 076c 84B7      		in r24,0x34
 2553 076e 877F      		andi r24,lo8(-9)
 2554 0770 84BF      		out 0x34,r24
 979:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2555               		.loc 1 979 0
 2556 0772 88E1      		ldi r24,lo8(24)
 2557 0774 81BD      		out 0x21,r24
 980:setup.c       **** 	WDTCR = 0;
 2558               		.loc 1 980 0
 2559 0776 11BC      		out 0x21,__zero_reg__
 981:setup.c       **** 	
 982:setup.c       **** 	// Reset common lines
 983:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2560               		.loc 1 983 0
 2561 0778 00D0      		rcall rd_wr_csmreq_cs2_reset
 2562               	.LVL185:
 984:setup.c       **** 	
 985:setup.c       **** 	// Set outputs
 986:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2563               		.loc 1 986 0
 2564 077a 81B3      		in r24,0x11
 2565 077c 8C6F      		ori r24,lo8(-4)
 2566 077e 81BB      		out 0x11,r24
 987:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2567               		.loc 1 987 0
 2568 0780 86B1      		in r24,0x6
 2569 0782 8560      		ori r24,lo8(5)
 2570 0784 86B9      		out 0x6,r24
 988:setup.c       **** 	
 989:setup.c       **** 	// Set all pins as inputs
 990:setup.c       **** 	PORT_DATA7_0 = 0;
 2571               		.loc 1 990 0
 2572 0786 15BA      		out 0x15,__zero_reg__
 991:setup.c       **** 	DDR_DATA7_0 = 0;
 2573               		.loc 1 991 0
 2574 0788 14BA      		out 0x14,__zero_reg__
 992:setup.c       **** 	PORT_ADDR7_0 = 0;
 2575               		.loc 1 992 0
 2576 078a 18BA      		out 0x18,__zero_reg__
 993:setup.c       **** 	DDR_ADDR7_0 = 0;
 2577               		.loc 1 993 0
 2578 078c 17BA      		out 0x17,__zero_reg__
 994:setup.c       **** 	PORT_ADDR15_8 = 0;
 2579               		.loc 1 994 0
 2580 078e 1BBA      		out 0x1b,__zero_reg__
 995:setup.c       **** 	DDR_ADDR15_8 = 0;
 2581               		.loc 1 995 0
 2582 0790 1ABA      		out 0x1a,__zero_reg__
 996:setup.c       **** 	
 997:setup.c       **** 	// Light up 3.3V or 5V
 998:setup.c       **** 	if (cartMode == GB_MODE) {
 2583               		.loc 1 998 0
 2584 0792 8091 0000 		lds r24,cartMode
 2585 0796 8130      		cpi r24,lo8(1)
 2586 0798 01F4      		brne .L103
 999:setup.c       **** 		PORTD |= (1<<LED_5V);
 2587               		.loc 1 999 0
 2588 079a 979A      		sbi 0x12,7
1000:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2589               		.loc 1 1000 0
 2590 079c 3898      		cbi 0x7,0
 2591 079e 00C0      		rjmp .L104
 2592               	.L103:
1001:setup.c       **** 	}
1002:setup.c       **** 	else {
1003:setup.c       **** 		PORTE |= (1<<LED_3V);
 2593               		.loc 1 1003 0
 2594 07a0 389A      		sbi 0x7,0
1004:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2595               		.loc 1 1004 0
 2596 07a2 9798      		cbi 0x12,7
 2597               	.L104:
1005:setup.c       **** 	}
1006:setup.c       **** 	
1007:setup.c       **** 	// Light LED
1008:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2598               		.loc 1 1008 0
 2599 07a4 939A      		sbi 0x12,3
 2600               	.LVL186:
 2601               	.LBB218:
 2602               	.LBB219:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2603               		.loc 2 187 0
 2604 07a6 2FEF      		ldi r18,lo8(799999)
 2605 07a8 84E3      		ldi r24,hi8(799999)
 2606 07aa 9CE0      		ldi r25,hlo8(799999)
 2607 07ac 2150      	1:	subi r18,1
 2608 07ae 8040      		sbci r24,0
 2609 07b0 9040      		sbci r25,0
 2610 07b2 01F4      		brne 1b
 2611 07b4 00C0      		rjmp .
 2612 07b6 0000      		nop
 2613               	.LVL187:
 2614               	.LBE219:
 2615               	.LBE218:
1009:setup.c       **** 	_delay_ms(500);
1010:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2616               		.loc 1 1010 0
 2617 07b8 9398      		cbi 0x12,3
1011:setup.c       **** 	
1012:setup.c       **** 	// Setup USART
1013:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2618               		.loc 1 1013 0
 2619 07ba 19B8      		out 0x9,__zero_reg__
1014:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2620               		.loc 1 1014 0
 2621 07bc 599A      		sbi 0xb,1
1015:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2622               		.loc 1 1015 0
 2623 07be 539A      		sbi 0xa,3
1016:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2624               		.loc 1 1016 0
 2625 07c0 549A      		sbi 0xa,4
1017:setup.c       **** 	
1018:setup.c       **** 	// Timer1 setup
1019:setup.c       **** 	TIMSK |= (1<<TOIE1);
 2626               		.loc 1 1019 0
 2627 07c2 89B7      		in r24,0x39
 2628 07c4 8068      		ori r24,lo8(-128)
 2629 07c6 89BF      		out 0x39,r24
1020:setup.c       **** 	TCNT1 = 0;
 2630               		.loc 1 1020 0
 2631 07c8 1DBC      		out 0x2c+1,__zero_reg__
 2632 07ca 1CBC      		out 0x2c,__zero_reg__
1021:setup.c       **** 	
1022:setup.c       **** 	// Turn on interrupts
1023:setup.c       **** 	sei();
 2633               		.loc 1 1023 0
 2634               	/* #APP */
 2635               	 ;  1023 "setup.c" 1
 2636 07cc 7894      		sei
 2637               	 ;  0 "" 2
 2638               	/* #NOAPP */
 2639 07ce 0895      		ret
 2640               		.cfi_endproc
 2641               	.LFE50:
 2643               		.section	.text.startup,"ax",@progbits
 2644               	.global	main
 2646               	main:
 2647               	.LFB51:
 2648               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R22
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 24/10/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.x_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.x_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  */
  28:main.c        **** 
  29:main.c        **** // ATmega8515L Pin Map
  30:main.c        **** //
  31:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  32:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  33:main.c        **** // 
  34:main.c        **** // Gameboy / Gameboy Colour
  35:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  36:main.c        **** // 
  37:main.c        **** // Gameboy Advance
  38:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  39:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  40:main.c        **** 
  41:main.c        **** #define F_CPU 8000000 // 8 MHz
  42:main.c        **** #define PCB_VERSION 4
  43:main.c        **** #define FIRMWARE_VERSION 22
  44:main.c        **** 
  45:main.c        **** #include <avr/io.h>
  46:main.c        **** #include <avr/wdt.h>
  47:main.c        **** #include <avr/eeprom.h>
  48:main.c        **** #include <avr/interrupt.h>
  49:main.c        **** #include <avr/sleep.h>
  50:main.c        **** #include <util/delay.h>
  51:main.c        **** #include <stdlib.h>
  52:main.c        **** #include <string.h>
  53:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  54:main.c        **** 
  55:main.c        **** 
  56:main.c        **** int main(void) {
 2649               		.loc 3 56 0
 2650               		.cfi_startproc
 2651 0000 CF93      		push r28
 2652               	.LCFI45:
 2653               		.cfi_def_cfa_offset 3
 2654               		.cfi_offset 28, -2
 2655 0002 DF93      		push r29
 2656               	.LCFI46:
 2657               		.cfi_def_cfa_offset 4
 2658               		.cfi_offset 29, -3
 2659 0004 CDB7      		in r28,__SP_L__
 2660 0006 DEB7      		in r29,__SP_H__
 2661               	.LCFI47:
 2662               		.cfi_def_cfa_register 28
 2663 0008 A797      		sbiw r28,39
 2664               	.LCFI48:
 2665               		.cfi_def_cfa_offset 43
 2666 000a 0FB6      		in __tmp_reg__,__SREG__
 2667 000c F894      		cli
 2668 000e DEBF      		out __SP_H__,r29
 2669 0010 0FBE      		out __SREG__,__tmp_reg__
 2670 0012 CDBF      		out __SP_L__,r28
 2671               	/* prologue: function */
 2672               	/* frame size = 39 */
 2673               	/* stack size = 41 */
 2674               	.L__stack_usage = 41
  57:main.c        **** 	setup();
 2675               		.loc 3 57 0
 2676 0014 00D0      		rcall setup
 2677               	.LVL188:
  58:main.c        **** 	
  59:main.c        **** 	uint32_t address = 0;
  60:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  61:main.c        **** 	uint8_t resetCommonLines = 1;
 2678               		.loc 3 61 0
 2679 0016 21E0      		ldi r18,lo8(1)
 2680 0018 2DA3      		std Y+37,r18
  60:main.c        **** 	uint8_t resetCommonLines = 1;
 2681               		.loc 3 60 0
 2682 001a 6624      		clr r6
 2683 001c 6394      		inc r6
  59:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2684               		.loc 3 59 0
 2685 001e C12C      		mov r12,__zero_reg__
 2686 0020 D12C      		mov r13,__zero_reg__
 2687 0022 7601      		movw r14,r12
 2688               	.LBB220:
 2689               	.LBB221:
 2690               	.LBB222:
  62:main.c        **** 	
  63:main.c        **** 	while(1) {
  64:main.c        **** 		if (resetCommonLines == 1) {
  65:main.c        **** 			rd_wr_csmreq_cs2_reset();
  66:main.c        **** 		}
  67:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  68:main.c        **** 		
  69:main.c        **** 		// Return the cart mode in use
  70:main.c        **** 		if (receivedChar == CART_MODE) {
  71:main.c        **** 			USART_Transmit(cartMode);
  72:main.c        **** 		}
  73:main.c        **** 		
  74:main.c        **** 		// Change to GB mode or GBA mode if requested
  75:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  76:main.c        **** 			gb_mode();
  77:main.c        **** 			stop_timeout_timer();
  78:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
  79:main.c        **** 		}
  80:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
  81:main.c        **** 			gba_mode();
  82:main.c        **** 			stop_timeout_timer();
  83:main.c        **** 		}
  84:main.c        **** 		
  85:main.c        **** 		// Switch voltage if requested
  86:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
  87:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
  88:main.c        **** 			cartMode = GBA_MODE;
  89:main.c        **** 			PORTE |= (1<<LED_3V);
  90:main.c        **** 			PORTD &= ~(1<<LED_5V);
  91:main.c        **** 			stop_timeout_timer();
  92:main.c        **** 		}
  93:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
  94:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
  95:main.c        **** 			cartMode = GB_MODE;
  96:main.c        **** 			PORTD |= (1<<LED_5V);
  97:main.c        **** 			PORTE &= ~(1<<LED_3V);
  98:main.c        **** 			stop_timeout_timer();
  99:main.c        **** 		}
 100:main.c        **** 		
 101:main.c        **** 		
 102:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 106:main.c        **** 			usart_read_chars(); // Read start address
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 111:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 112:main.c        **** 			gb_mode();
 113:main.c        **** 			receivedChar = '1';
 114:main.c        **** 			while (receivedChar == '1') {
 115:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 116:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 117:main.c        **** 					USART_Transmit(read_8bit_data(address));
 118:main.c        **** 					address++;
 119:main.c        **** 				}
 120:main.c        **** 				
 121:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 122:main.c        **** 				receivedChar = USART_Receive();
 123:main.c        **** 			}
 124:main.c        **** 		}
 125:main.c        **** 		
 126:main.c        **** 		// Read and send 0x4000 bytes of data
 127:main.c        **** 		else if (receivedChar == READ_ROM_4000H) {
 128:main.c        **** 			gb_mode();
 129:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 130:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 131:main.c        **** 				USART_Transmit(read_8bit_data(address));
 132:main.c        **** 				address++;
 133:main.c        **** 			}
 134:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 135:main.c        **** 		}
 136:main.c        **** 		
 137:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 138:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 139:main.c        **** 			gb_mode();
 140:main.c        **** 			
 141:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 142:main.c        **** 			usart_read_bytes(64);
 143:main.c        **** 			
 144:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 145:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 146:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 147:main.c        **** 				address++;
 148:main.c        **** 			}
 149:main.c        **** 			
 150:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 151:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 152:main.c        **** 		}
 153:main.c        **** 		
 154:main.c        **** 		// Set bank address and write a byte
 155:main.c        **** 		else if (receivedChar == SET_BANK) {
 156:main.c        **** 			gb_mode();
 157:main.c        **** 			
 158:main.c        **** 			usart_read_chars(); // Read start address
 159:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 160:main.c        **** 			
 161:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 162:main.c        **** 			if (receivedChar == 'B') {
 163:main.c        **** 				usart_read_chars(); // Read data
 164:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 165:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 166:main.c        **** 				
 167:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 168:main.c        **** 			}
 169:main.c        **** 		}
 170:main.c        **** 		
 171:main.c        **** 		
 172:main.c        **** 		// ****** Gameboy Advance ******
 173:main.c        **** 		
 174:main.c        **** 		// ---------- ROM ----------
 175:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 176:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 177:main.c        **** 			gba_mode();
 178:main.c        **** 			
 179:main.c        **** 			uint8_t readEnd = 32;
 180:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 181:main.c        **** 				readEnd = 128;
 182:main.c        **** 			}
 183:main.c        **** 			
 184:main.c        **** 			receivedChar = '1';
 185:main.c        **** 			while (receivedChar == '1') {
 186:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 187:main.c        **** 				
 188:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 189:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 190:main.c        **** 					
 191:main.c        **** 					// Low byte & High byte
 192:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 193:main.c        **** 					USART_Transmit(dataRead >> 8);
 194:main.c        **** 					
 195:main.c        **** 					address++;
 196:main.c        **** 				}
 197:main.c        **** 				
 198:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 199:main.c        **** 				receivedChar = USART_Receive();
 200:main.c        **** 			}
 201:main.c        **** 		}
 202:main.c        **** 		
 203:main.c        **** 		// Read and send 0x10000 bytes of data
 204:main.c        **** 		else if (receivedChar == GBA_READ_ROM_8000H) {
 205:main.c        **** 			gba_mode();
 206:main.c        **** 			
 207:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 208:main.c        **** 			gba_set_24bit_address(address);
 209:main.c        **** 			cs_mreqPin_low;
 210:main.c        **** 			
 211:main.c        **** 			GBA_PORT_ROM_ADDR15_8 = 0;
 212:main.c        **** 			GBA_PORT_ROM_ADDR7_0 = 0;
 213:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0;
 214:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0;
 215:main.c        **** 			
 216:main.c        **** 			for (uint16_t x = 0; x < 0x8000; x++) {
 217:main.c        **** 				rdPin_low;
 218:main.c        **** 				asm volatile("nop");
 219:main.c        **** 				
 220:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA7_0);
 221:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA15_8);
 222:main.c        **** 				rdPin_high;
 223:main.c        **** 			}
 224:main.c        **** 			address += 0x8000;
 225:main.c        **** 			
 226:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 227:main.c        **** 		}
 228:main.c        **** 		
 229:main.c        **** 		// ---------- SRAM ----------
 230:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 231:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 232:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 233:main.c        **** 			
 234:main.c        **** 			receivedChar = '1';
 235:main.c        **** 			while (receivedChar == '1') {
 236:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 237:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 238:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 239:main.c        **** 					address++;
 240:main.c        **** 				}
 241:main.c        **** 				
 242:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 243:main.c        **** 				receivedChar = USART_Receive();
 244:main.c        **** 			}
 245:main.c        **** 			
 246:main.c        **** 			gba_mode(); // Set back
 247:main.c        **** 		}
 248:main.c        **** 		
 249:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 250:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 251:main.c        **** 			gb_mode();
 252:main.c        **** 			
 253:main.c        **** 			usart_read_bytes(64);
 254:main.c        **** 			
 255:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 256:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 257:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 258:main.c        **** 				address++;
 259:main.c        **** 			}
 260:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 261:main.c        **** 			
 262:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 263:main.c        **** 			gba_mode(); // Set back
 264:main.c        **** 		}
 265:main.c        **** 		
 266:main.c        **** 		// Write 1 byte to SRAM address
 267:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 268:main.c        **** 			gb_mode();
 269:main.c        **** 			
 270:main.c        **** 			uint8_t data = USART_Receive();
 271:main.c        **** 			gba_write_ram_8bit_data(address, data);
 272:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 273:main.c        **** 			
 274:main.c        **** 			gba_mode(); // Set back
 275:main.c        **** 		}
 276:main.c        **** 		
 277:main.c        **** 		
 278:main.c        **** 		// ---------- FLASH ----------
 279:main.c        **** 		// Read the Flash Manufacturer and Device ID
 280:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 281:main.c        **** 			gb_mode();
 282:main.c        **** 			
 283:main.c        **** 			flash_read_chip_id();
 284:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 285:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 286:main.c        **** 			
 287:main.c        **** 			gba_mode(); // Set back
 288:main.c        **** 		}
 289:main.c        **** 		
 290:main.c        **** 		// Change bank
 291:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 292:main.c        **** 			usart_read_chars(); // Read data
 293:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 294:main.c        **** 			
 295:main.c        **** 			gb_mode();
 296:main.c        **** 			flash_switch_bank(bank);
 297:main.c        **** 			
 298:main.c        **** 			gba_mode(); // Set back
 299:main.c        **** 		}
 300:main.c        **** 		
 301:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 302:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 303:main.c        **** 			gb_mode();
 304:main.c        **** 			
 305:main.c        **** 			usart_read_chars(); // Read sector
 306:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 307:main.c        **** 			
 308:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 309:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 310:main.c        **** 			
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 315:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 316:main.c        **** 			gb_mode();
 317:main.c        **** 			
 318:main.c        **** 			usart_read_bytes(64);
 319:main.c        **** 			
 320:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 321:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 322:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 323:main.c        **** 				address++;
 324:main.c        **** 			}
 325:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 326:main.c        **** 			
 327:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 328:main.c        **** 			gba_mode(); // Set back
 329:main.c        **** 		}
 330:main.c        **** 		
 331:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 332:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 333:main.c        **** 			gb_mode();
 334:main.c        **** 			
 335:main.c        **** 			usart_read_bytes(128);
 336:main.c        **** 			
 337:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 338:main.c        **** 			flash_write_sector(address); // Address used as sector number
 339:main.c        **** 			address++;
 340:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 341:main.c        **** 			
 342:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 343:main.c        **** 			gba_mode(); // Set back
 344:main.c        **** 		}
 345:main.c        **** 		
 346:main.c        **** 		
 347:main.c        **** 		// ---------- EEPROM ----------
 348:main.c        **** 		// Set EEPROM size
 349:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 350:main.c        **** 			usart_read_chars(); // Read size
 351:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 352:main.c        **** 		}
 353:main.c        **** 		
 354:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 355:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 356:main.c        **** 			gba_eeprom_mode();
 357:main.c        **** 			
 358:main.c        **** 			receivedChar = '1';
 359:main.c        **** 			while (receivedChar == '1') {
 360:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 361:main.c        **** 				gba_eeprom_read(address, eepromSize);
 362:main.c        **** 				
 363:main.c        **** 				// Send back the 8 bytes of data
 364:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 365:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 366:main.c        **** 				}
 367:main.c        **** 				address++; // Increment to next 8 bytes
 368:main.c        **** 				
 369:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 370:main.c        **** 				receivedChar = USART_Receive();
 371:main.c        **** 			}
 372:main.c        **** 			
 373:main.c        **** 			gba_mode(); // Set back
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 377:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 378:main.c        **** 			gba_eeprom_mode();
 379:main.c        **** 			
 380:main.c        **** 			// Read 8 bytes from USART and place in buffer
 381:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 382:main.c        **** 				eepromBuffer[x] = USART_Receive();
 383:main.c        **** 			}
 384:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 385:main.c        **** 			
 386:main.c        **** 			gba_eeprom_write(address, eepromSize);
 387:main.c        **** 			address++;
 388:main.c        **** 			
 389:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 390:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 391:main.c        **** 			
 392:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 393:main.c        **** 			gba_mode(); // Set back
 394:main.c        **** 		}
 395:main.c        **** 		
 396:main.c        **** 		
 397:main.c        **** 		// ---------- GB FLASH CARTS ----------
 398:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 399:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 400:main.c        **** 			flashWriteWePin = USART_Receive();
 401:main.c        **** 			
 402:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 403:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 404:main.c        **** 				audioPin_high;
 405:main.c        **** 			}
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 409:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 410:main.c        **** 			flashBank1CommandWrites = 1;
 411:main.c        **** 		}
 412:main.c        **** 		
 413:main.c        **** 		// Load the program method to use
 414:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 415:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 416:main.c        **** 				usart_read_chars(); // Address
 417:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 418:main.c        **** 				USART_Transmit(SEND_ACK);
 419:main.c        **** 				
 420:main.c        **** 				usart_read_chars(); // Data
 421:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 422:main.c        **** 				USART_Transmit(SEND_ACK);
 423:main.c        **** 			}
 424:main.c        **** 		}
 425:main.c        **** 		
 426:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 427:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 428:main.c        **** 			usart_read_chars(); // Read address
 429:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 430:main.c        **** 			
 431:main.c        **** 			usart_read_chars(); // Read data byte
 432:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 433:main.c        **** 			
 434:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 435:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 436:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 437:main.c        **** 			
 438:main.c        **** 			USART_Transmit(SEND_ACK);
 439:main.c        **** 		}
 440:main.c        **** 		
 441:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 442:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 443:main.c        **** 			usart_read_bytes(64);
 444:main.c        **** 			start_timeout_timer();
 445:main.c        **** 			
 446:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 447:main.c        **** 			if (flashBank1CommandWrites == 0) {
 448:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 449:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 450:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 451:main.c        **** 					}
 452:main.c        **** 					address++;
 453:main.c        **** 				}
 454:main.c        **** 			}
 455:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 456:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 457:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 458:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 459:main.c        **** 					}
 460:main.c        **** 					address++;
 461:main.c        **** 				}
 462:main.c        **** 			}
 463:main.c        **** 			
 464:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 469:main.c        **** 			usart_read_bytes(32);
 470:main.c        **** 			start_timeout_timer();
 471:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 472:main.c        **** 			
 473:main.c        **** 			// Setup buffered write
 474:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 475:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 477:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 478:main.c        **** 			_delay_us(1);
 479:main.c        **** 			
 480:main.c        **** 			// Write data
 481:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 482:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 483:main.c        **** 				address++;
 484:main.c        **** 			}
 485:main.c        **** 			
 486:main.c        **** 			// Write buffer to flash
 487:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 488:main.c        **** 			_delay_us(200);
 489:main.c        **** 			
 490:main.c        **** 			// Verify last byte written
 491:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 492:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 493:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 494:main.c        **** 				_delay_us(5);
 495:main.c        **** 				if (writingTimedout == 1) {
 496:main.c        **** 					break;
 497:main.c        **** 				}
 498:main.c        **** 			}
 499:main.c        **** 			
 500:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 501:main.c        **** 		}
 502:main.c        **** 		
 503:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 504:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_256BYTE) {
 505:main.c        **** 			usart_read_bytes(256);
 506:main.c        **** 			start_timeout_timer();
 507:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 508:main.c        **** 			
 509:main.c        **** 			int16_t byteCounter = 0;
 510:main.c        **** 			for (uint8_t b = 0; b < 8; b++) {
 511:main.c        **** 				// Store to local buffer
 512:main.c        **** 				uint8_t localBuffer[32];
 513:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 514:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 515:main.c        **** 					byteCounter++;
 516:main.c        **** 				}
 517:main.c        **** 				
 518:main.c        **** 				// Setup buffered write
 519:main.c        **** 				gb_flash_write_bus_cycle(0xAAA, 0xAA);
 520:main.c        **** 				gb_flash_write_bus_cycle(0x555, 0x55);
 521:main.c        **** 				gb_flash_write_bus_cycle(address, 0x25);
 522:main.c        **** 				gb_flash_write_bus_cycle(address, 0x1F); // Length
 523:main.c        **** 				_delay_us(1);
 524:main.c        **** 				
 525:main.c        **** 				// Write data
 526:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 527:main.c        **** 					gb_flash_write_bus_cycle(address, localBuffer[x]);
 528:main.c        **** 					address++;
 529:main.c        **** 				}
 530:main.c        **** 				
 531:main.c        **** 				// Write buffer to flash
 532:main.c        **** 				gb_flash_write_bus_cycle(address-32, 0x29);
 533:main.c        **** 				_delay_us(200);
 534:main.c        **** 				
 535:main.c        **** 				// Verify last byte written
 536:main.c        **** 				uint8_t dataVerify = gb_flash_read_byte(address-1);
 537:main.c        **** 				while (dataVerify != localBuffer[31]) {
 538:main.c        **** 					dataVerify = gb_flash_read_byte(address-1);
 539:main.c        **** 					_delay_us(5);
 540:main.c        **** 					if (writingTimedout == 1) {
 541:main.c        **** 						break;
 542:main.c        **** 					}
 543:main.c        **** 				}
 544:main.c        **** 				if (writingTimedout == 1) {
 545:main.c        **** 					break;
 546:main.c        **** 				}
 547:main.c        **** 			}
 548:main.c        **** 			
 549:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 550:main.c        **** 		}
 551:main.c        **** 		
 552:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 553:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 554:main.c        **** 			usart_read_bytes(64);
 555:main.c        **** 			start_timeout_timer();
 556:main.c        **** 			
 557:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 558:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 559:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 560:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 561:main.c        **** 				}
 562:main.c        **** 				address++;
 563:main.c        **** 			}
 564:main.c        **** 			
 565:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 566:main.c        **** 		}
 567:main.c        **** 		
 568:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 569:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 570:main.c        **** 			usart_read_bytes(256);
 571:main.c        **** 			start_timeout_timer();
 572:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 573:main.c        **** 			
 574:main.c        **** 			// Setup buffered write
 575:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 576:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 577:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 578:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 579:main.c        **** 			_delay_us(50);
 580:main.c        **** 			
 581:main.c        **** 			// Write data
 582:main.c        **** 			for (int x = 0; x < 256; x++) {
 583:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 584:main.c        **** 				address++;
 585:main.c        **** 			}
 586:main.c        **** 			
 587:main.c        **** 			// Write buffer to flash
 588:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 589:main.c        **** 			
 590:main.c        **** 			// Verify last byte written
 591:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 592:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 593:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 594:main.c        **** 				_delay_us(5);
 595:main.c        **** 				if (writingTimedout == 1) {
 596:main.c        **** 					break;
 597:main.c        **** 				}
 598:main.c        **** 			}
 599:main.c        **** 			
 600:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 601:main.c        **** 		}
 602:main.c        **** 		
 603:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 604:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 605:main.c        **** 			usart_read_bytes(128);
 606:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 607:main.c        **** 			
 608:main.c        **** 			// Enable flash chip access
 609:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 610:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 611:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 612:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 613:main.c        **** 			_delay_us(5);
 614:main.c        **** 			
 615:main.c        **** 			// Re-Enable writes to MBC registers
 616:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 617:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 618:main.c        **** 			_delay_us(5);
 619:main.c        **** 			
 620:main.c        **** 			// Bank 1 for commands
 621:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 622:main.c        **** 			_delay_us(5);
 623:main.c        **** 			
 624:main.c        **** 			
 625:main.c        **** 			// Write setup
 626:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 627:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 628:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 629:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 630:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 631:main.c        **** 			_delay_us(5);
 632:main.c        **** 			
 633:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 634:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 635:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 636:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 637:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 638:main.c        **** 			_delay_us(5);
 639:main.c        **** 			
 640:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 641:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 642:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 643:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 644:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 645:main.c        **** 			_delay_us(5);
 646:main.c        **** 			
 647:main.c        **** 			// Set bank back
 648:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 649:main.c        **** 			_delay_us(5);
 650:main.c        **** 			
 651:main.c        **** 			// Disable writes to MBC registers
 652:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 653:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 654:main.c        **** 			_delay_us(5);
 655:main.c        **** 			
 656:main.c        **** 			// Undo Wakeup
 657:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 658:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 659:main.c        **** 			_delay_us(5);
 660:main.c        **** 			
 661:main.c        **** 			
 662:main.c        **** 			// Write data
 663:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 664:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 665:main.c        **** 				_delay_us(5);
 666:main.c        **** 				address++;
 667:main.c        **** 			}
 668:main.c        **** 			
 669:main.c        **** 			// Write buffer to flash
 670:main.c        **** 			address--;
 671:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 672:main.c        **** 			address++;
 673:main.c        **** 			_delay_ms(10);
 674:main.c        **** 			
 675:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 676:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 677:main.c        **** 		}
 678:main.c        **** 		
 679:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 680:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 681:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 682:main.c        **** 			usart_read_bytes(32);
 683:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 684:main.c        **** 			
 685:main.c        **** 			// Setup buffered write
 686:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 687:main.c        **** 			
 688:main.c        **** 			// Wait until ready
 689:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 690:main.c        **** 			start_timeout_timer();
 691:main.c        **** 			while (gb_flash_read_byte(address) != 0x80) {
 692:main.c        **** 				if (writingTimedout == 1) {
 693:main.c        **** 					break;
 694:main.c        **** 				}
 695:main.c        **** 			}
 696:main.c        **** 			
 697:main.c        **** 			if (writingTimedout == 0) {
 698:main.c        **** 				start_timeout_timer();
 699:main.c        **** 				
 700:main.c        **** 				// Set buffer size
 701:main.c        **** 				gb_flash_write_bus_cycle(address, 0x1F);
 702:main.c        **** 				
 703:main.c        **** 				// Write data to buffer
 704:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 705:main.c        **** 					gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 706:main.c        **** 					address++;
 707:main.c        **** 				}
 708:main.c        **** 				
 709:main.c        **** 				// Write buffer to flash
 710:main.c        **** 				gb_flash_write_bus_cycle(address-32, 0xD0);
 711:main.c        **** 				_delay_us(196);
 712:main.c        **** 				
 713:main.c        **** 				// Wait until ready
 714:main.c        **** 				//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 715:main.c        **** 				while (gb_flash_read_byte(address-32) != 0x80) {
 716:main.c        **** 					if (writingTimedout == 1) {
 717:main.c        **** 						break;
 718:main.c        **** 					}
 719:main.c        **** 				}
 720:main.c        **** 				
 721:main.c        **** 				check_if_timed_out(); // Send ACK if successful write
 722:main.c        **** 			}
 723:main.c        **** 		}
 724:main.c        **** 		
 725:main.c        **** 		
 726:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 727:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 728:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 729:main.c        **** 			usart_read_chars(); // Read address
 730:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 731:main.c        **** 			
 732:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 733:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 734:main.c        **** 				usart_read_chars(); // Read data
 735:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 736:main.c        **** 				
 737:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 738:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 739:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 740:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 741:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 742:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 743:main.c        **** 				
 744:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 745:main.c        **** 			}
 746:main.c        **** 		}
 747:main.c        **** 		
 748:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 749:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 750:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 751:main.c        **** 			
 752:main.c        **** 			int readLength = 64;
 753:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 754:main.c        **** 				readLength = 256;
 755:main.c        **** 			}
 756:main.c        **** 			usart_read_bytes(readLength);
 757:main.c        **** 			start_timeout_timer();
 758:main.c        **** 			
 759:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 760:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 761:main.c        **** 				if (combinedBytes != 0xFFFF) {
 762:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 763:main.c        **** 				}
 764:main.c        **** 				address++;
 765:main.c        **** 			}
 766:main.c        **** 			
 767:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 768:main.c        **** 		}
 769:main.c        **** 		
 770:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 771:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 772:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 773:main.c        **** 			
 774:main.c        **** 			int readLength = 256;
 775:main.c        **** 			usart_read_bytes(readLength);
 776:main.c        **** 			start_timeout_timer();
 777:main.c        **** 			
 778:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 779:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 780:main.c        **** 				if (combinedBytes != 0xFFFF) {
 781:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 782:main.c        **** 				}
 783:main.c        **** 				address++;
 784:main.c        **** 			}
 785:main.c        **** 			
 786:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 787:main.c        **** 		}
 788:main.c        **** 		
 789:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 790:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BUFFERED_256BYTE) {
 791:main.c        **** 			usart_read_bytes(256);
 792:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 793:main.c        **** 			
 794:main.c        **** 			// Setup buffered write
 795:main.c        **** 			int16_t byteCounter = 0;
 796:main.c        **** 			for (uint8_t b = 0; b < 8; b++) {
 797:main.c        **** 				start_timeout_timer();
 798:main.c        **** 				
 799:main.c        **** 				// Set address lines as outputs
 800:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 801:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 802:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 803:main.c        **** 				
 804:main.c        **** 				// Store to local buffer
 805:main.c        **** 				uint8_t localBuffer[32];
 806:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 807:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 808:main.c        **** 					byteCounter++;
 809:main.c        **** 				}
 810:main.c        **** 				
 811:main.c        **** 				gba_flash_write_bus_cycle(0x555, 0xAA);
 812:main.c        **** 				gba_flash_write_bus_cycle(0x2AA, 0x55);
 813:main.c        **** 				gba_flash_write_bus_cycle(address, 0x25);
 814:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // Length
 815:main.c        **** 				_delay_us(1);
 816:main.c        **** 				
 817:main.c        **** 				// Set address
 818:main.c        **** 				GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 819:main.c        **** 				GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 820:main.c        **** 				GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 821:main.c        **** 				cs_mreqPin_low;
 822:main.c        **** 				
 823:main.c        **** 				// Write data
 824:main.c        **** 				for (uint8_t x = 0; x < 32; x += 2) {
 825:main.c        **** 					GBA_PORT_ROM_DATA15_8 = localBuffer[x+1];
 826:main.c        **** 					GBA_PORT_ROM_DATA7_0 = localBuffer[x];
 827:main.c        **** 					
 828:main.c        **** 					wrPin_low;
 829:main.c        **** 					asm volatile("nop");
 830:main.c        **** 					asm volatile("nop");
 831:main.c        **** 					asm volatile("nop");
 832:main.c        **** 					wrPin_high;
 833:main.c        **** 					
 834:main.c        **** 					// Increment address
 835:main.c        **** 					rdPin_low;
 836:main.c        **** 					asm volatile("nop");
 837:main.c        **** 					rdPin_high;
 838:main.c        **** 					address++;
 839:main.c        **** 				}
 840:main.c        **** 				cs_mreqPin_high;
 841:main.c        **** 				
 842:main.c        **** 				// Write buffer to flash
 843:main.c        **** 				gba_flash_write_bus_cycle(address-15, 0x29);
 844:main.c        **** 				_delay_us(200);
 845:main.c        **** 				
 846:main.c        **** 				// Verify last byte written
 847:main.c        **** 				uint16_t combinedBytes = (uint16_t) localBuffer[31] << 8 | (uint16_t) localBuffer[30];
 848:main.c        **** 				uint16_t dataVerify = gba_read_16bit_data(address-1);
 849:main.c        **** 				while (dataVerify != combinedBytes) {
 850:main.c        **** 					dataVerify = gba_read_16bit_data(address-1);
 851:main.c        **** 					_delay_us(1);
 852:main.c        **** 					if (writingTimedout == 1) {
 853:main.c        **** 						break;
 854:main.c        **** 					}
 855:main.c        **** 				}
 856:main.c        **** 				if (writingTimedout == 1) {
 857:main.c        **** 					break;
 858:main.c        **** 				}
 859:main.c        **** 			}
 860:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 861:main.c        **** 		}
 862:main.c        **** 		
 863:main.c        **** 		// Intel flash command based chips
 864:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 865:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 866:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 867:main.c        **** 			usart_read_bytes(64);
 868:main.c        **** 			start_timeout_timer();
 869:main.c        **** 			
 870:main.c        **** 			// Set address lines as outputs
 871:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 872:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 873:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 874:main.c        **** 			
 875:main.c        **** 			// Unlock
 876:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 877:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 878:main.c        **** 			
 879:main.c        **** 			// Buffered write command
 880:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 881:main.c        **** 			_delay_us(50);
 882:main.c        **** 			
 883:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 884:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 885:main.c        **** 			while (dataVerify != 0x0080) {
 886:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 887:main.c        **** 				_delay_us(50);
 888:main.c        **** 				if (writingTimedout == 1) {
 889:main.c        **** 					break;
 890:main.c        **** 				}
 891:main.c        **** 			}
 892:main.c        **** 			
 893:main.c        **** 			
 894:main.c        **** 			// Set address lines as outputs
 895:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 896:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 897:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 898:main.c        **** 			
 899:main.c        **** 			// Set length
 900:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 901:main.c        **** 			
 902:main.c        **** 			// Write data
 903:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 904:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 905:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 906:main.c        **** 				address++;
 907:main.c        **** 			}
 908:main.c        **** 			
 909:main.c        **** 			// Write buffer to flash
 910:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 911:main.c        **** 			_delay_us(440);
 912:main.c        **** 			
 913:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 914:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 915:main.c        **** 			while (dataVerify != 0x0080) {
 916:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 917:main.c        **** 				_delay_us(50);
 918:main.c        **** 				if (writingTimedout == 1) {
 919:main.c        **** 					break;
 920:main.c        **** 				}
 921:main.c        **** 			}
 922:main.c        **** 			
 923:main.c        **** 			
 924:main.c        **** 			// Set address lines as outputs
 925:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 926:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 927:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 928:main.c        **** 			
 929:main.c        **** 			// Back to reading mode
 930:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 931:main.c        **** 			
 932:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 933:main.c        **** 		}
 934:main.c        **** 		
 935:main.c        **** 		// Intel word programming
 936:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 937:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 938:main.c        **** 			usart_read_bytes(64);
 939:main.c        **** 			start_timeout_timer();
 940:main.c        **** 			
 941:main.c        **** 			// Write data
 942:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 943:main.c        **** 				// Set address lines as outputs
 944:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 945:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 946:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 947:main.c        **** 				
 948:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 949:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 950:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 951:main.c        **** 				
 952:main.c        **** 				// Verify status ok
 953:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 954:main.c        **** 				while ((status & 0x80) == 0) {
 955:main.c        **** 					status = gba_read_16bit_data(address);
 956:main.c        **** 					_delay_us(2);
 957:main.c        **** 					if (writingTimedout == 1) {
 958:main.c        **** 						break;
 959:main.c        **** 					}
 960:main.c        **** 				}
 961:main.c        **** 				address++;
 962:main.c        **** 			}
 963:main.c        **** 			
 964:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 965:main.c        **** 		}
 966:main.c        **** 		
 967:main.c        **** 		// Intel flash command based chips, two chips interleaved (Flash2Advance 256M cart)
 968:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 969:main.c        **** 		// Thanks to lesserkuma for adding support
 970:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE) {
 971:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 972:main.c        **** 			usart_read_bytes(256);
 973:main.c        **** 			start_timeout_timer();
 974:main.c        **** 			
 975:main.c        **** 			// Loop four times, transferring 256 bytes over USB at once is faster than doing four transfers
 976:main.c        **** 			for (int c = 0; c < 4; c++) {
 977:main.c        **** 				// Set address lines as outputs
 978:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 979:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 980:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 981:main.c        **** 				
 982:main.c        **** 				// Setup buffered write
 983:main.c        **** 				gba_flash_write_bus_cycle(address, 0xE8);
 984:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 985:main.c        **** 				
 986:main.c        **** 				// Wait until both chips are ready
 987:main.c        **** 				while (gba_read_16bit_data(address) != 0x80) {
 988:main.c        **** 					if (writingTimedout == 1) {
 989:main.c        **** 						break;
 990:main.c        **** 					}
 991:main.c        **** 				}
 992:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80) {
 993:main.c        **** 					if (writingTimedout == 1) {
 994:main.c        **** 						break;
 995:main.c        **** 					}
 996:main.c        **** 				}
 997:main.c        **** 				
 998:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 999:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
1000:main.c        **** 				
1001:main.c        **** 				if (writingTimedout == 0) {
1002:main.c        **** 					start_timeout_timer();
1003:main.c        **** 					
1004:main.c        **** 					// Set address lines as outputs
1005:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
1006:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
1007:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
1008:main.c        **** 					
1009:main.c        **** 					// Set length (number of words+1 to write)
1010:main.c        **** 					gba_flash_write_bus_cycle(address, 0x0F); // 16 words
1011:main.c        **** 					gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
1012:main.c        **** 					
1013:main.c        **** 					// Write data (32 words total)
1014:main.c        **** 					uint16_t combinedBytes;
1015:main.c        **** 					for (int x = 0; x < 64; x += 2) {
1016:main.c        **** 						combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
1017:main.c        **** 						gba_flash_write_bus_cycle(address, combinedBytes);
1018:main.c        **** 						address++;
1019:main.c        **** 					}
1020:main.c        **** 					
1021:main.c        **** 					// Write buffer to flash
1022:main.c        **** 					gba_flash_write_bus_cycle(address-32, 0xD0);
1023:main.c        **** 					gba_flash_write_bus_cycle(address-32+1, 0xD0);
1024:main.c        **** 					
1025:main.c        **** 					// Wait until ready
1026:main.c        **** 					while (gba_read_16bit_data(address) != 0x80) {
1027:main.c        **** 						if (writingTimedout == 1) {
1028:main.c        **** 							break;
1029:main.c        **** 						}
1030:main.c        **** 					}
1031:main.c        **** 					while (gba_read_16bit_data(address+1) != 0x80) {
1032:main.c        **** 						if (writingTimedout == 1) {
1033:main.c        **** 							break;
1034:main.c        **** 						}
1035:main.c        **** 					}
1036:main.c        **** 				}
1037:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
1038:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
1039:main.c        **** 			}
1040:main.c        **** 			
1041:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
1042:main.c        **** 		}
1043:main.c        **** 
1044:main.c        **** 		// Sharp LH28F320BJE programming (Thanks to lesserkuma for adding support)
1045:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_SHARP_64BYTE) {
1046:main.c        **** 			uint16_t status = 0;
1047:main.c        **** 			
1048:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1049:main.c        **** 			usart_read_bytes(64);
1050:main.c        **** 			start_timeout_timer();
1051:main.c        **** 			
1052:main.c        **** 			// Write data
1053:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
1054:main.c        **** 				// Wait until ready
1055:main.c        **** 				while ((status & 0x80) != 0x80) {
1056:main.c        **** 					// Set address lines as outputs
1057:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2691               		.loc 3 1057 0
 2692 0024 7724      		clr r7
 2693 0026 7A94      		dec r7
 2694 0028 CE01      		movw r24,r28
 2695 002a 8196      		adiw r24,33
 2696 002c 9AA3      		std Y+34,r25
 2697 002e 89A3      		std Y+33,r24
 2698               	.LVL189:
 2699               	.L106:
 2700               	.LBE222:
 2701               	.LBE221:
 2702               	.LBE220:
  64:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2703               		.loc 3 64 0
 2704 0030 EDA1      		ldd r30,Y+37
 2705 0032 E130      		cpi r30,lo8(1)
 2706 0034 01F4      		brne .L107
 2707               	.LVL190:
 2708               	.L341:
  65:main.c        **** 		}
 2709               		.loc 3 65 0
 2710 0036 00D0      		rcall rd_wr_csmreq_cs2_reset
 2711               	.LVL191:
 2712               	.L107:
  67:main.c        **** 		
 2713               		.loc 3 67 0
 2714 0038 00D0      		rcall USART_Receive
 2715               	.LVL192:
 2716 003a 8093 0000 		sts receivedChar,r24
  70:main.c        **** 			USART_Transmit(cartMode);
 2717               		.loc 3 70 0
 2718 003e 8334      		cpi r24,lo8(67)
 2719 0040 01F4      		brne .L108
  71:main.c        **** 		}
 2720               		.loc 3 71 0
 2721 0042 8091 0000 		lds r24,cartMode
 2722 0046 00C0      		rjmp .L347
 2723               	.L108:
  75:main.c        **** 			gb_mode();
 2724               		.loc 3 75 0
 2725 0048 8734      		cpi r24,lo8(71)
 2726 004a 01F4      		brne .L110
  76:main.c        **** 			stop_timeout_timer();
 2727               		.loc 3 76 0
 2728 004c 00D0      		rcall gb_mode
 2729               	.LVL193:
  77:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
 2730               		.loc 3 77 0
 2731 004e 00D0      		rcall stop_timeout_timer
 2732               	.LVL194:
  78:main.c        **** 		}
 2733               		.loc 3 78 0
 2734 0050 1092 0000 		sts flashBank1CommandWrites,__zero_reg__
 2735 0054 00C0      		rjmp .L106
 2736               	.L110:
  80:main.c        **** 			gba_mode();
 2737               		.loc 3 80 0
 2738 0056 8736      		cpi r24,lo8(103)
 2739 0058 01F4      		brne .L111
  81:main.c        **** 			stop_timeout_timer();
 2740               		.loc 3 81 0
 2741 005a 00D0      		rcall gba_mode
 2742               	.LVL195:
 2743 005c 00C0      		rjmp .L348
 2744               	.L111:
  86:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2745               		.loc 3 86 0
 2746 005e 8333      		cpi r24,lo8(51)
 2747 0060 01F4      		brne .L112
  87:main.c        **** 			cartMode = GBA_MODE;
 2748               		.loc 3 87 0
 2749 0062 9298      		cbi 0x12,2
  88:main.c        **** 			PORTE |= (1<<LED_3V);
 2750               		.loc 3 88 0
 2751 0064 82E0      		ldi r24,lo8(2)
 2752 0066 8093 0000 		sts cartMode,r24
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2753               		.loc 3 89 0
 2754 006a 389A      		sbi 0x7,0
  90:main.c        **** 			stop_timeout_timer();
 2755               		.loc 3 90 0
 2756 006c 9798      		cbi 0x12,7
 2757               	.L348:
  91:main.c        **** 		}
 2758               		.loc 3 91 0
 2759 006e 00D0      		rcall stop_timeout_timer
 2760               	.LVL196:
 2761 0070 00C0      		rjmp .L106
 2762               	.L112:
  93:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2763               		.loc 3 93 0
 2764 0072 8533      		cpi r24,lo8(53)
 2765 0074 01F4      		brne .L113
  94:main.c        **** 			cartMode = GB_MODE;
 2766               		.loc 3 94 0
 2767 0076 929A      		sbi 0x12,2
  95:main.c        **** 			PORTD |= (1<<LED_5V);
 2768               		.loc 3 95 0
 2769 0078 81E0      		ldi r24,lo8(1)
 2770 007a 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2771               		.loc 3 96 0
 2772 007e 979A      		sbi 0x12,7
  97:main.c        **** 			stop_timeout_timer();
 2773               		.loc 3 97 0
 2774 0080 3898      		cbi 0x7,0
 2775 0082 00C0      		rjmp .L348
 2776               	.L113:
 105:main.c        **** 			usart_read_chars(); // Read start address
 2777               		.loc 3 105 0
 2778 0084 8134      		cpi r24,lo8(65)
 2779 0086 01F4      		brne .L114
 106:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2780               		.loc 3 106 0
 2781 0088 00D0      		rcall usart_read_chars
 2782               	.LVL197:
 107:main.c        **** 		}
 2783               		.loc 3 107 0
 2784 008a 40E1      		ldi r20,lo8(16)
 2785 008c 50E0      		ldi r21,0
 2786 008e 60E0      		ldi r22,0
 2787 0090 70E0      		ldi r23,0
 2788 0092 80E0      		ldi r24,lo8(receivedBuffer)
 2789 0094 90E0      		ldi r25,hi8(receivedBuffer)
 2790 0096 00D0      		rcall strtol
 2791               	.LVL198:
 2792 0098 6B01      		movw r12,r22
 2793 009a 7C01      		movw r14,r24
 2794               	.LVL199:
 2795 009c 00C0      		rjmp .L106
 2796               	.L114:
 111:main.c        **** 			gb_mode();
 2797               		.loc 3 111 0
 2798 009e 8235      		cpi r24,lo8(82)
 2799 00a0 01F4      		brne .L115
 112:main.c        **** 			receivedChar = '1';
 2800               		.loc 3 112 0
 2801 00a2 00D0      		rcall gb_mode
 2802               	.LVL200:
 113:main.c        **** 			while (receivedChar == '1') {
 2803               		.loc 3 113 0
 2804 00a4 81E3      		ldi r24,lo8(49)
 2805               	.LVL201:
 2806               	.L354:
 122:main.c        **** 			}
 2807               		.loc 3 122 0
 2808 00a6 8093 0000 		sts receivedChar,r24
 2809               	.LVL202:
 114:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2810               		.loc 3 114 0
 2811 00aa 8091 0000 		lds r24,receivedChar
 2812 00ae 8133      		cpi r24,lo8(49)
 2813 00b0 01F0      		breq .+2
 2814 00b2 00C0      		rjmp .L106
 115:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2815               		.loc 3 115 0
 2816 00b4 939A      		sbi 0x12,3
 2817               	.LVL203:
 2818 00b6 00E0      		ldi r16,0
 2819 00b8 10E0      		ldi r17,0
 2820               	.LVL204:
 2821               	.L117:
 2822               	.LBB227:
 117:main.c        **** 					address++;
 2823               		.loc 3 117 0 discriminator 3
 2824 00ba C801      		movw r24,r16
 2825 00bc 8C0D      		add r24,r12
 2826 00be 9D1D      		adc r25,r13
 2827 00c0 00D0      		rcall read_8bit_data
 2828               	.LVL205:
 2829 00c2 00D0      		rcall USART_Transmit
 2830               	.LVL206:
 2831 00c4 0F5F      		subi r16,-1
 2832 00c6 1F4F      		sbci r17,-1
 2833               	.LVL207:
 116:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2834               		.loc 3 116 0 discriminator 3
 2835 00c8 0034      		cpi r16,64
 2836 00ca 1105      		cpc r17,__zero_reg__
 2837 00cc 01F4      		brne .L117
 2838 00ce F0E4      		ldi r31,64
 2839 00d0 CF0E      		add r12,r31
 2840 00d2 D11C      		adc r13,__zero_reg__
 2841 00d4 E11C      		adc r14,__zero_reg__
 2842 00d6 F11C      		adc r15,__zero_reg__
 2843               	.LBE227:
 121:main.c        **** 				receivedChar = USART_Receive();
 2844               		.loc 3 121 0
 2845 00d8 9398      		cbi 0x12,3
 122:main.c        **** 			}
 2846               		.loc 3 122 0
 2847 00da 00D0      		rcall USART_Receive
 2848               	.LVL208:
 2849 00dc 00C0      		rjmp .L354
 2850               	.LVL209:
 2851               	.L115:
 127:main.c        **** 			gb_mode();
 2852               		.loc 3 127 0
 2853 00de 8135      		cpi r24,lo8(81)
 2854 00e0 01F4      		brne .L119
 128:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2855               		.loc 3 128 0
 2856 00e2 00D0      		rcall gb_mode
 2857               	.LVL210:
 129:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2858               		.loc 3 129 0
 2859 00e4 939A      		sbi 0x12,3
 2860               	.LVL211:
 2861               	.LBB228:
 130:main.c        **** 				USART_Transmit(read_8bit_data(address));
 2862               		.loc 3 130 0
 2863 00e6 00E0      		ldi r16,0
 2864 00e8 10E0      		ldi r17,0
 2865               	.LVL212:
 2866               	.L120:
 131:main.c        **** 				address++;
 2867               		.loc 3 131 0 discriminator 3
 2868 00ea C801      		movw r24,r16
 2869 00ec 8C0D      		add r24,r12
 2870 00ee 9D1D      		adc r25,r13
 2871 00f0 00D0      		rcall read_8bit_data
 2872               	.LVL213:
 2873 00f2 00D0      		rcall USART_Transmit
 2874               	.LVL214:
 130:main.c        **** 				USART_Transmit(read_8bit_data(address));
 2875               		.loc 3 130 0 discriminator 3
 2876 00f4 0F5F      		subi r16,-1
 2877 00f6 1F4F      		sbci r17,-1
 2878               	.LVL215:
 2879 00f8 0115      		cp r16,__zero_reg__
 2880 00fa 20E4      		ldi r18,64
 2881 00fc 1207      		cpc r17,r18
 2882 00fe 01F4      		brne .L120
 2883 0100 80E4      		ldi r24,64
 2884 0102 D80E      		add r13,r24
 2885 0104 E11C      		adc r14,__zero_reg__
 2886 0106 F11C      		adc r15,__zero_reg__
 2887 0108 00C0      		rjmp .L349
 2888               	.LVL216:
 2889               	.L119:
 2890               	.LBE228:
 138:main.c        **** 			gb_mode();
 2891               		.loc 3 138 0
 2892 010a 8735      		cpi r24,lo8(87)
 2893 010c 01F4      		brne .L121
 139:main.c        **** 			
 2894               		.loc 3 139 0
 2895 010e 00D0      		rcall gb_mode
 2896               	.LVL217:
 142:main.c        **** 			
 2897               		.loc 3 142 0
 2898 0110 80E4      		ldi r24,lo8(64)
 2899 0112 90E0      		ldi r25,0
 2900 0114 00D0      		rcall usart_read_bytes
 2901               	.LVL218:
 144:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2902               		.loc 3 144 0
 2903 0116 939A      		sbi 0x12,3
 2904               	.LVL219:
 2905 0118 F0E0      		ldi r31,lo8(receivedBuffer)
 2906 011a AF2E      		mov r10,r31
 2907 011c F0E0      		ldi r31,hi8(receivedBuffer)
 2908 011e BF2E      		mov r11,r31
 2909 0120 00E0      		ldi r16,0
 2910 0122 10E0      		ldi r17,0
 2911               	.LVL220:
 2912               	.L122:
 2913               	.LBB229:
 146:main.c        **** 				address++;
 2914               		.loc 3 146 0 discriminator 3
 2915 0124 F501      		movw r30,r10
 2916 0126 6191      		ld r22,Z+
 2917 0128 5F01      		movw r10,r30
 2918 012a C801      		movw r24,r16
 2919 012c 8C0D      		add r24,r12
 2920 012e 9D1D      		adc r25,r13
 2921 0130 41E0      		ldi r20,lo8(1)
 2922 0132 00D0      		rcall write_8bit_data
 2923               	.LVL221:
 2924 0134 0F5F      		subi r16,-1
 2925 0136 1F4F      		sbci r17,-1
 2926               	.LVL222:
 145:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2927               		.loc 3 145 0 discriminator 3
 2928 0138 0034      		cpi r16,64
 2929 013a 1105      		cpc r17,__zero_reg__
 2930 013c 01F4      		brne .L122
 2931 013e F0E4      		ldi r31,64
 2932 0140 CF0E      		add r12,r31
 2933 0142 D11C      		adc r13,__zero_reg__
 2934 0144 E11C      		adc r14,__zero_reg__
 2935 0146 F11C      		adc r15,__zero_reg__
 2936 0148 00C0      		rjmp .L360
 2937               	.LVL223:
 2938               	.L121:
 2939               	.LBE229:
 155:main.c        **** 			gb_mode();
 2940               		.loc 3 155 0
 2941 014a 8234      		cpi r24,lo8(66)
 2942 014c 01F4      		brne .L123
 2943               	.LBB230:
 156:main.c        **** 			
 2944               		.loc 3 156 0
 2945 014e 00D0      		rcall gb_mode
 2946               	.LVL224:
 158:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2947               		.loc 3 158 0
 2948 0150 00D0      		rcall usart_read_chars
 2949               	.LVL225:
 159:main.c        **** 			
 2950               		.loc 3 159 0
 2951 0152 40E1      		ldi r20,lo8(16)
 2952 0154 50E0      		ldi r21,0
 2953 0156 60E0      		ldi r22,0
 2954 0158 70E0      		ldi r23,0
 2955 015a 80E0      		ldi r24,lo8(receivedBuffer)
 2956 015c 90E0      		ldi r25,hi8(receivedBuffer)
 2957 015e 00D0      		rcall strtol
 2958               	.LVL226:
 2959 0160 4B01      		movw r8,r22
 2960 0162 5C01      		movw r10,r24
 2961               	.LVL227:
 161:main.c        **** 			if (receivedChar == 'B') {
 2962               		.loc 3 161 0
 2963 0164 00D0      		rcall USART_Receive
 2964               	.LVL228:
 2965 0166 8093 0000 		sts receivedChar,r24
 162:main.c        **** 				usart_read_chars(); // Read data
 2966               		.loc 3 162 0
 2967 016a 8234      		cpi r24,lo8(66)
 2968 016c 01F0      		breq .+2
 2969 016e 00C0      		rjmp .L106
 2970               	.LBB231:
 163:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2971               		.loc 3 163 0
 2972 0170 00D0      		rcall usart_read_chars
 2973               	.LVL229:
 164:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2974               		.loc 3 164 0
 2975 0172 80E0      		ldi r24,lo8(receivedBuffer)
 2976 0174 90E0      		ldi r25,hi8(receivedBuffer)
 2977 0176 00D0      		rcall atoi
 2978               	.LVL230:
 165:main.c        **** 				
 2979               		.loc 3 165 0
 2980 0178 8093 0000 		sts lastBankAccessed,r24
 167:main.c        **** 			}
 2981               		.loc 3 167 0
 2982 017c 40E0      		ldi r20,0
 2983 017e 682F      		mov r22,r24
 2984 0180 C401      		movw r24,r8
 2985               	.LVL231:
 2986 0182 00D0      		rcall write_8bit_data
 2987               	.LVL232:
 2988 0184 00C0      		rjmp .L106
 2989               	.LVL233:
 2990               	.L123:
 2991               	.LBE231:
 2992               	.LBE230:
 176:main.c        **** 			gba_mode();
 2993               		.loc 3 176 0
 2994 0186 8237      		cpi r24,lo8(114)
 2995 0188 01F0      		breq .L124
 176:main.c        **** 			gba_mode();
 2996               		.loc 3 176 0 is_stmt 0 discriminator 1
 2997 018a 8A36      		cpi r24,lo8(106)
 2998 018c 01F4      		brne .L125
 2999               	.L124:
 3000               	.LBB232:
 177:main.c        **** 			
 3001               		.loc 3 177 0 is_stmt 1
 3002 018e 00D0      		rcall gba_mode
 3003               	.LVL234:
 180:main.c        **** 				readEnd = 128;
 3004               		.loc 3 180 0
 3005 0190 8091 0000 		lds r24,receivedChar
 3006 0194 8A36      		cpi r24,lo8(106)
 3007 0196 01F0      		breq .L256
 179:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 3008               		.loc 3 179 0
 3009 0198 10E2      		ldi r17,lo8(32)
 3010 019a 00C0      		rjmp .L126
 3011               	.L256:
 181:main.c        **** 			}
 3012               		.loc 3 181 0
 3013 019c 10E8      		ldi r17,lo8(-128)
 3014               	.L126:
 3015               	.LVL235:
 184:main.c        **** 			while (receivedChar == '1') {
 3016               		.loc 3 184 0
 3017 019e 81E3      		ldi r24,lo8(49)
 3018 01a0 8093 0000 		sts receivedChar,r24
 3019 01a4 8824      		clr r8
 3020 01a6 8A94      		dec r8
 3021 01a8 810E      		add r8,r17
 3022 01aa 912C      		mov r9,__zero_reg__
 3023 01ac A12C      		mov r10,__zero_reg__
 3024 01ae B12C      		mov r11,__zero_reg__
 3025 01b0 2FEF      		ldi r18,-1
 3026 01b2 821A      		sub r8,r18
 3027 01b4 920A      		sbc r9,r18
 3028 01b6 A20A      		sbc r10,r18
 3029 01b8 B20A      		sbc r11,r18
 3030               	.LVL236:
 3031               	.L127:
 185:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3032               		.loc 3 185 0
 3033 01ba 8091 0000 		lds r24,receivedChar
 3034 01be 8133      		cpi r24,lo8(49)
 3035 01c0 01F0      		breq .+2
 3036 01c2 00C0      		rjmp .L106
 186:main.c        **** 				
 3037               		.loc 3 186 0
 3038 01c4 939A      		sbi 0x12,3
 3039               	.LVL237:
 3040 01c6 1601      		movw r2,r12
 3041 01c8 2701      		movw r4,r14
 3042               	.LVL238:
 3043               	.L128:
 3044               	.LBB233:
 3045               	.LBB234:
 189:main.c        **** 					
 3046               		.loc 3 189 0 discriminator 3
 3047 01ca C201      		movw r24,r4
 3048 01cc B101      		movw r22,r2
 3049 01ce 00D0      		rcall gba_read_16bit_data
 3050               	.LVL239:
 3051 01d0 092F      		mov r16,r25
 3052               	.LVL240:
 192:main.c        **** 					USART_Transmit(dataRead >> 8);
 3053               		.loc 3 192 0 discriminator 3
 3054 01d2 00D0      		rcall USART_Transmit
 3055               	.LVL241:
 193:main.c        **** 					
 3056               		.loc 3 193 0 discriminator 3
 3057 01d4 802F      		mov r24,r16
 3058 01d6 00D0      		rcall USART_Transmit
 3059               	.LVL242:
 195:main.c        **** 				}
 3060               		.loc 3 195 0 discriminator 3
 3061 01d8 8FEF      		ldi r24,-1
 3062 01da 281A      		sub r2,r24
 3063 01dc 380A      		sbc r3,r24
 3064 01de 480A      		sbc r4,r24
 3065 01e0 580A      		sbc r5,r24
 3066               	.LVL243:
 3067               	.LBE234:
 188:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 3068               		.loc 3 188 0 discriminator 3
 3069 01e2 822D      		mov r24,r2
 3070 01e4 8C19      		sub r24,r12
 3071 01e6 8117      		cp r24,r17
 3072 01e8 00F0      		brlo .L128
 3073 01ea C80C      		add r12,r8
 3074 01ec D91C      		adc r13,r9
 3075 01ee EA1C      		adc r14,r10
 3076 01f0 FB1C      		adc r15,r11
 3077               	.LVL244:
 3078               	.LBE233:
 198:main.c        **** 				receivedChar = USART_Receive();
 3079               		.loc 3 198 0
 3080 01f2 9398      		cbi 0x12,3
 199:main.c        **** 			}
 3081               		.loc 3 199 0
 3082 01f4 00D0      		rcall USART_Receive
 3083               	.LVL245:
 3084 01f6 8093 0000 		sts receivedChar,r24
 3085 01fa 00C0      		rjmp .L127
 3086               	.LVL246:
 3087               	.L125:
 3088               	.LBE232:
 204:main.c        **** 			gba_mode();
 3089               		.loc 3 204 0
 3090 01fc 8A35      		cpi r24,lo8(90)
 3091 01fe 01F4      		brne .L130
 205:main.c        **** 			
 3092               		.loc 3 205 0
 3093 0200 00D0      		rcall gba_mode
 3094               	.LVL247:
 207:main.c        **** 			gba_set_24bit_address(address);
 3095               		.loc 3 207 0
 3096 0202 939A      		sbi 0x12,3
 208:main.c        **** 			cs_mreqPin_low;
 3097               		.loc 3 208 0
 3098 0204 C701      		movw r24,r14
 3099 0206 B601      		movw r22,r12
 3100 0208 00D0      		rcall gba_set_24bit_address
 3101               	.LVL248:
 209:main.c        **** 			
 3102               		.loc 3 209 0
 3103 020a 9498      		cbi 0x12,4
 211:main.c        **** 			GBA_PORT_ROM_ADDR7_0 = 0;
 3104               		.loc 3 211 0
 3105 020c 1BBA      		out 0x1b,__zero_reg__
 212:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0;
 3106               		.loc 3 212 0
 3107 020e 18BA      		out 0x18,__zero_reg__
 213:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0;
 3108               		.loc 3 213 0
 3109 0210 1ABA      		out 0x1a,__zero_reg__
 214:main.c        **** 			
 3110               		.loc 3 214 0
 3111 0212 17BA      		out 0x17,__zero_reg__
 3112               	.LVL249:
 3113               	.LBB235:
 216:main.c        **** 				rdPin_low;
 3114               		.loc 3 216 0
 3115 0214 00E0      		ldi r16,0
 3116 0216 10E0      		ldi r17,0
 3117               	.LVL250:
 3118               	.L131:
 216:main.c        **** 				rdPin_low;
 3119               		.loc 3 216 0 is_stmt 0 discriminator 1
 3120 0218 17FD      		sbrc r17,7
 3121 021a 00C0      		rjmp .L361
 217:main.c        **** 				asm volatile("nop");
 3122               		.loc 3 217 0 is_stmt 1 discriminator 3
 3123 021c 9598      		cbi 0x12,5
 218:main.c        **** 				
 3124               		.loc 3 218 0 discriminator 3
 3125               	/* #APP */
 3126               	 ;  218 "main.c" 1
 3127 021e 0000      		nop
 3128               	 ;  0 "" 2
 220:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA15_8);
 3129               		.loc 3 220 0 discriminator 3
 3130               	/* #NOAPP */
 3131 0220 86B3      		in r24,0x16
 3132 0222 00D0      		rcall USART_Transmit
 3133               	.LVL251:
 221:main.c        **** 				rdPin_high;
 3134               		.loc 3 221 0 discriminator 3
 3135 0224 89B3      		in r24,0x19
 3136 0226 00D0      		rcall USART_Transmit
 3137               	.LVL252:
 222:main.c        **** 			}
 3138               		.loc 3 222 0 discriminator 3
 3139 0228 959A      		sbi 0x12,5
 216:main.c        **** 				rdPin_low;
 3140               		.loc 3 216 0 discriminator 3
 3141 022a 0F5F      		subi r16,-1
 3142 022c 1F4F      		sbci r17,-1
 3143               	.LVL253:
 3144 022e 00C0      		rjmp .L131
 3145               	.L361:
 3146               	.LBE235:
 224:main.c        **** 			
 3147               		.loc 3 224 0
 3148 0230 90E8      		ldi r25,-128
 3149 0232 D90E      		add r13,r25
 3150 0234 E11C      		adc r14,__zero_reg__
 3151 0236 F11C      		adc r15,__zero_reg__
 3152               	.LVL254:
 3153               	.L349:
 226:main.c        **** 		}
 3154               		.loc 3 226 0
 3155 0238 9398      		cbi 0x12,3
 3156 023a 00C0      		rjmp .L106
 3157               	.L130:
 231:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 3158               		.loc 3 231 0
 3159 023c 8D36      		cpi r24,lo8(109)
 3160 023e 01F4      		brne .L133
 232:main.c        **** 			
 3161               		.loc 3 232 0
 3162 0240 00D0      		rcall gb_mode
 3163               	.LVL255:
 234:main.c        **** 			while (receivedChar == '1') {
 3164               		.loc 3 234 0
 3165 0242 81E3      		ldi r24,lo8(49)
 3166               	.LVL256:
 3167               	.L355:
 243:main.c        **** 			}
 3168               		.loc 3 243 0
 3169 0244 8093 0000 		sts receivedChar,r24
 3170               	.LVL257:
 235:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3171               		.loc 3 235 0
 3172 0248 8091 0000 		lds r24,receivedChar
 3173 024c 8133      		cpi r24,lo8(49)
 3174 024e 01F4      		brne .L351
 236:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3175               		.loc 3 236 0
 3176 0250 939A      		sbi 0x12,3
 3177               	.LVL258:
 3178 0252 00E0      		ldi r16,0
 3179 0254 10E0      		ldi r17,0
 3180               	.LVL259:
 3181               	.L135:
 3182               	.LBB236:
 238:main.c        **** 					address++;
 3183               		.loc 3 238 0 discriminator 3
 3184 0256 C801      		movw r24,r16
 3185 0258 8C0D      		add r24,r12
 3186 025a 9D1D      		adc r25,r13
 3187 025c 00D0      		rcall gba_read_ram_8bit_data
 3188               	.LVL260:
 3189 025e 00D0      		rcall USART_Transmit
 3190               	.LVL261:
 3191 0260 0F5F      		subi r16,-1
 3192 0262 1F4F      		sbci r17,-1
 3193               	.LVL262:
 237:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 3194               		.loc 3 237 0 discriminator 3
 3195 0264 0034      		cpi r16,64
 3196 0266 1105      		cpc r17,__zero_reg__
 3197 0268 01F4      		brne .L135
 3198 026a E0E4      		ldi r30,64
 3199 026c CE0E      		add r12,r30
 3200 026e D11C      		adc r13,__zero_reg__
 3201 0270 E11C      		adc r14,__zero_reg__
 3202 0272 F11C      		adc r15,__zero_reg__
 3203               	.LBE236:
 242:main.c        **** 				receivedChar = USART_Receive();
 3204               		.loc 3 242 0
 3205 0274 9398      		cbi 0x12,3
 243:main.c        **** 			}
 3206               		.loc 3 243 0
 3207 0276 00D0      		rcall USART_Receive
 3208               	.LVL263:
 3209 0278 00C0      		rjmp .L355
 3210               	.LVL264:
 3211               	.L133:
 250:main.c        **** 			gb_mode();
 3212               		.loc 3 250 0
 3213 027a 8737      		cpi r24,lo8(119)
 3214 027c 01F4      		brne .L137
 251:main.c        **** 			
 3215               		.loc 3 251 0
 3216 027e 00D0      		rcall gb_mode
 3217               	.LVL265:
 253:main.c        **** 			
 3218               		.loc 3 253 0
 3219 0280 80E4      		ldi r24,lo8(64)
 3220 0282 90E0      		ldi r25,0
 3221 0284 00D0      		rcall usart_read_bytes
 3222               	.LVL266:
 255:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3223               		.loc 3 255 0
 3224 0286 939A      		sbi 0x12,3
 3225               	.LVL267:
 3226 0288 E0E0      		ldi r30,lo8(receivedBuffer)
 3227 028a AE2E      		mov r10,r30
 3228 028c E0E0      		ldi r30,hi8(receivedBuffer)
 3229 028e BE2E      		mov r11,r30
 3230 0290 00E0      		ldi r16,0
 3231 0292 10E0      		ldi r17,0
 3232               	.LVL268:
 3233               	.L138:
 3234               	.LBB237:
 257:main.c        **** 				address++;
 3235               		.loc 3 257 0 discriminator 3
 3236 0294 F501      		movw r30,r10
 3237 0296 6191      		ld r22,Z+
 3238 0298 5F01      		movw r10,r30
 3239 029a C801      		movw r24,r16
 3240 029c 8C0D      		add r24,r12
 3241 029e 9D1D      		adc r25,r13
 3242 02a0 00D0      		rcall gba_write_ram_8bit_data
 3243               	.LVL269:
 3244 02a2 0F5F      		subi r16,-1
 3245 02a4 1F4F      		sbci r17,-1
 3246               	.LVL270:
 256:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 3247               		.loc 3 256 0 discriminator 3
 3248 02a6 0034      		cpi r16,64
 3249 02a8 1105      		cpc r17,__zero_reg__
 3250 02aa 01F4      		brne .L138
 3251               	.LVL271:
 3252               	.L352:
 3253 02ac F0E4      		ldi r31,64
 3254 02ae CF0E      		add r12,r31
 3255 02b0 D11C      		adc r13,__zero_reg__
 3256 02b2 E11C      		adc r14,__zero_reg__
 3257 02b4 F11C      		adc r15,__zero_reg__
 3258               	.L353:
 3259               	.LBE237:
 260:main.c        **** 			
 3260               		.loc 3 260 0
 3261 02b6 81E3      		ldi r24,lo8(49)
 3262 02b8 00D0      		rcall USART_Transmit
 3263               	.LVL272:
 262:main.c        **** 			gba_mode(); // Set back
 3264               		.loc 3 262 0
 3265 02ba 9398      		cbi 0x12,3
 3266               	.L351:
 263:main.c        **** 		}
 3267               		.loc 3 263 0
 3268 02bc 00D0      		rcall gba_mode
 3269               	.LVL273:
 3270 02be 00C0      		rjmp .L106
 3271               	.LVL274:
 3272               	.L137:
 267:main.c        **** 			gb_mode();
 3273               		.loc 3 267 0
 3274 02c0 8F36      		cpi r24,lo8(111)
 3275 02c2 01F4      		brne .L139
 3276               	.LBB238:
 268:main.c        **** 			
 3277               		.loc 3 268 0
 3278 02c4 00D0      		rcall gb_mode
 3279               	.LVL275:
 270:main.c        **** 			gba_write_ram_8bit_data(address, data);
 3280               		.loc 3 270 0
 3281 02c6 00D0      		rcall USART_Receive
 3282               	.LVL276:
 271:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3283               		.loc 3 271 0
 3284 02c8 682F      		mov r22,r24
 3285 02ca C601      		movw r24,r12
 3286               	.LVL277:
 3287 02cc 00D0      		rcall gba_write_ram_8bit_data
 3288               	.LVL278:
 3289 02ce 00C0      		rjmp .L357
 3290               	.L139:
 3291               	.LBE238:
 280:main.c        **** 			gb_mode();
 3292               		.loc 3 280 0
 3293 02d0 8936      		cpi r24,lo8(105)
 3294 02d2 01F4      		brne .L140
 281:main.c        **** 			
 3295               		.loc 3 281 0
 3296 02d4 00D0      		rcall gb_mode
 3297               	.LVL279:
 283:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 3298               		.loc 3 283 0
 3299 02d6 00D0      		rcall flash_read_chip_id
 3300               	.LVL280:
 284:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 3301               		.loc 3 284 0
 3302 02d8 8091 0000 		lds r24,flashChipIdBuffer
 3303 02dc 00D0      		rcall USART_Transmit
 3304               	.LVL281:
 285:main.c        **** 			
 3305               		.loc 3 285 0
 3306 02de 8091 0000 		lds r24,flashChipIdBuffer+1
 3307               	.L356:
 3308 02e2 00D0      		rcall USART_Transmit
 3309               	.LVL282:
 3310 02e4 00C0      		rjmp .L351
 3311               	.L140:
 291:main.c        **** 			usart_read_chars(); // Read data
 3312               		.loc 3 291 0
 3313 02e6 8B36      		cpi r24,lo8(107)
 3314 02e8 01F4      		brne .L141
 3315               	.LBB239:
 292:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3316               		.loc 3 292 0
 3317 02ea 00D0      		rcall usart_read_chars
 3318               	.LVL283:
 293:main.c        **** 			
 3319               		.loc 3 293 0
 3320 02ec 80E0      		ldi r24,lo8(receivedBuffer)
 3321 02ee 90E0      		ldi r25,hi8(receivedBuffer)
 3322 02f0 00D0      		rcall atoi
 3323               	.LVL284:
 3324 02f2 182F      		mov r17,r24
 3325               	.LVL285:
 295:main.c        **** 			flash_switch_bank(bank);
 3326               		.loc 3 295 0
 3327 02f4 00D0      		rcall gb_mode
 3328               	.LVL286:
 296:main.c        **** 			
 3329               		.loc 3 296 0
 3330 02f6 812F      		mov r24,r17
 3331 02f8 00D0      		rcall flash_switch_bank
 3332               	.LVL287:
 3333 02fa 00C0      		rjmp .L351
 3334               	.LVL288:
 3335               	.L141:
 3336               	.LBE239:
 302:main.c        **** 			gb_mode();
 3337               		.loc 3 302 0
 3338 02fc 8337      		cpi r24,lo8(115)
 3339 02fe 01F4      		brne .L142
 3340               	.LBB240:
 303:main.c        **** 			
 3341               		.loc 3 303 0
 3342 0300 00D0      		rcall gb_mode
 3343               	.LVL289:
 305:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3344               		.loc 3 305 0
 3345 0302 00D0      		rcall usart_read_chars
 3346               	.LVL290:
 306:main.c        **** 			
 3347               		.loc 3 306 0
 3348 0304 40E1      		ldi r20,lo8(16)
 3349 0306 50E0      		ldi r21,0
 3350 0308 60E0      		ldi r22,0
 3351 030a 70E0      		ldi r23,0
 3352 030c 80E0      		ldi r24,lo8(receivedBuffer)
 3353 030e 90E0      		ldi r25,hi8(receivedBuffer)
 3354 0310 00D0      		rcall strtol
 3355               	.LVL291:
 3356 0312 862F      		mov r24,r22
 3357               	.LVL292:
 308:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3358               		.loc 3 308 0
 3359 0314 00D0      		rcall flash_erase_4k_sector
 3360               	.LVL293:
 3361               	.L357:
 309:main.c        **** 			
 3362               		.loc 3 309 0
 3363 0316 81E3      		ldi r24,lo8(49)
 3364 0318 00C0      		rjmp .L356
 3365               	.L142:
 3366               	.LBE240:
 315:main.c        **** 			gb_mode();
 3367               		.loc 3 315 0
 3368 031a 8236      		cpi r24,lo8(98)
 3369 031c 01F4      		brne .L143
 316:main.c        **** 			
 3370               		.loc 3 316 0
 3371 031e 00D0      		rcall gb_mode
 3372               	.LVL294:
 318:main.c        **** 			
 3373               		.loc 3 318 0
 3374 0320 80E4      		ldi r24,lo8(64)
 3375 0322 90E0      		ldi r25,0
 3376 0324 00D0      		rcall usart_read_bytes
 3377               	.LVL295:
 320:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3378               		.loc 3 320 0
 3379 0326 939A      		sbi 0x12,3
 3380               	.LVL296:
 3381 0328 70E0      		ldi r23,lo8(receivedBuffer)
 3382 032a A72E      		mov r10,r23
 3383 032c 70E0      		ldi r23,hi8(receivedBuffer)
 3384 032e B72E      		mov r11,r23
 3385 0330 00E0      		ldi r16,0
 3386 0332 10E0      		ldi r17,0
 3387               	.LVL297:
 3388               	.L144:
 3389               	.LBB241:
 322:main.c        **** 				address++;
 3390               		.loc 3 322 0 discriminator 3
 3391 0334 F501      		movw r30,r10
 3392 0336 6191      		ld r22,Z+
 3393 0338 5F01      		movw r10,r30
 3394 033a C801      		movw r24,r16
 3395 033c 8C0D      		add r24,r12
 3396 033e 9D1D      		adc r25,r13
 3397 0340 00D0      		rcall flash_write_byte
 3398               	.LVL298:
 3399 0342 0F5F      		subi r16,-1
 3400 0344 1F4F      		sbci r17,-1
 3401               	.LVL299:
 321:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3402               		.loc 3 321 0 discriminator 3
 3403 0346 0034      		cpi r16,64
 3404 0348 1105      		cpc r17,__zero_reg__
 3405 034a 01F4      		brne .L144
 3406 034c 00C0      		rjmp .L352
 3407               	.LVL300:
 3408               	.L143:
 3409               	.LBE241:
 332:main.c        **** 			gb_mode();
 3410               		.loc 3 332 0
 3411 034e 8136      		cpi r24,lo8(97)
 3412 0350 01F4      		brne .L145
 333:main.c        **** 			
 3413               		.loc 3 333 0
 3414 0352 00D0      		rcall gb_mode
 3415               	.LVL301:
 335:main.c        **** 			
 3416               		.loc 3 335 0
 3417 0354 80E8      		ldi r24,lo8(-128)
 3418 0356 90E0      		ldi r25,0
 3419 0358 00D0      		rcall usart_read_bytes
 3420               	.LVL302:
 337:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3421               		.loc 3 337 0
 3422 035a 939A      		sbi 0x12,3
 338:main.c        **** 			address++;
 3423               		.loc 3 338 0
 3424 035c C601      		movw r24,r12
 3425 035e 00D0      		rcall flash_write_sector
 3426               	.LVL303:
 339:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3427               		.loc 3 339 0
 3428 0360 2FEF      		ldi r18,-1
 3429 0362 C21A      		sub r12,r18
 3430 0364 D20A      		sbc r13,r18
 3431 0366 E20A      		sbc r14,r18
 3432 0368 F20A      		sbc r15,r18
 3433               	.LVL304:
 3434 036a 00C0      		rjmp .L353
 3435               	.L145:
 349:main.c        **** 			usart_read_chars(); // Read size
 3436               		.loc 3 349 0
 3437 036c 8335      		cpi r24,lo8(83)
 3438 036e 01F4      		brne .L146
 350:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3439               		.loc 3 350 0
 3440 0370 00D0      		rcall usart_read_chars
 3441               	.LVL305:
 351:main.c        **** 		}
 3442               		.loc 3 351 0
 3443 0372 40E1      		ldi r20,lo8(16)
 3444 0374 50E0      		ldi r21,0
 3445 0376 60E0      		ldi r22,0
 3446 0378 70E0      		ldi r23,0
 3447 037a 80E0      		ldi r24,lo8(receivedBuffer)
 3448 037c 90E0      		ldi r25,hi8(receivedBuffer)
 3449 037e 00D0      		rcall strtol
 3450               	.LVL306:
 3451 0380 662E      		mov r6,r22
 3452               	.LVL307:
 3453 0382 00C0      		rjmp .L106
 3454               	.L146:
 355:main.c        **** 			gba_eeprom_mode();
 3455               		.loc 3 355 0
 3456 0384 8536      		cpi r24,lo8(101)
 3457 0386 01F4      		brne .L147
 356:main.c        **** 			
 3458               		.loc 3 356 0
 3459 0388 00D0      		rcall gba_eeprom_mode
 3460               	.LVL308:
 358:main.c        **** 			while (receivedChar == '1') {
 3461               		.loc 3 358 0
 3462 038a 81E3      		ldi r24,lo8(49)
 3463               	.L358:
 370:main.c        **** 			}
 3464               		.loc 3 370 0
 3465 038c 8093 0000 		sts receivedChar,r24
 359:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3466               		.loc 3 359 0
 3467 0390 8091 0000 		lds r24,receivedChar
 3468 0394 8133      		cpi r24,lo8(49)
 3469 0396 01F0      		breq .+2
 3470 0398 00C0      		rjmp .L351
 360:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3471               		.loc 3 360 0
 3472 039a 939A      		sbi 0x12,3
 361:main.c        **** 				
 3473               		.loc 3 361 0
 3474 039c 662D      		mov r22,r6
 3475 039e C601      		movw r24,r12
 3476 03a0 00D0      		rcall gba_eeprom_read
 3477               	.LVL309:
 3478 03a2 00E0      		ldi r16,lo8(eepromBuffer)
 3479 03a4 10E0      		ldi r17,hi8(eepromBuffer)
 3480               	.LVL310:
 3481               	.L149:
 3482               	.LBB242:
 365:main.c        **** 				}
 3483               		.loc 3 365 0 discriminator 3
 3484 03a6 F801      		movw r30,r16
 3485 03a8 8191      		ld r24,Z+
 3486 03aa 8F01      		movw r16,r30
 3487               	.LVL311:
 3488 03ac 00D0      		rcall USART_Transmit
 3489               	.LVL312:
 364:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3490               		.loc 3 364 0 discriminator 3
 3491 03ae 80E0      		ldi r24,lo8(eepromBuffer+8)
 3492 03b0 90E0      		ldi r25,hi8(eepromBuffer+8)
 3493 03b2 8017      		cp r24,r16
 3494 03b4 9107      		cpc r25,r17
 3495 03b6 01F4      		brne .L149
 3496               	.LBE242:
 367:main.c        **** 				
 3497               		.loc 3 367 0
 3498 03b8 9FEF      		ldi r25,-1
 3499 03ba C91A      		sub r12,r25
 3500 03bc D90A      		sbc r13,r25
 3501 03be E90A      		sbc r14,r25
 3502 03c0 F90A      		sbc r15,r25
 3503               	.LVL313:
 369:main.c        **** 				receivedChar = USART_Receive();
 3504               		.loc 3 369 0
 3505 03c2 9398      		cbi 0x12,3
 370:main.c        **** 			}
 3506               		.loc 3 370 0
 3507 03c4 00D0      		rcall USART_Receive
 3508               	.LVL314:
 3509 03c6 00C0      		rjmp .L358
 3510               	.LVL315:
 3511               	.L147:
 377:main.c        **** 			gba_eeprom_mode();
 3512               		.loc 3 377 0
 3513 03c8 8037      		cpi r24,lo8(112)
 3514 03ca 01F4      		brne .L151
 378:main.c        **** 			
 3515               		.loc 3 378 0
 3516 03cc 00D0      		rcall gba_eeprom_mode
 3517               	.LVL316:
 3518 03ce 00E0      		ldi r16,lo8(eepromBuffer)
 3519 03d0 10E0      		ldi r17,hi8(eepromBuffer)
 3520               	.LVL317:
 3521               	.L152:
 3522               	.LBB243:
 382:main.c        **** 			}
 3523               		.loc 3 382 0 discriminator 3
 3524 03d2 00D0      		rcall USART_Receive
 3525               	.LVL318:
 3526 03d4 F801      		movw r30,r16
 3527 03d6 8193      		st Z+,r24
 3528 03d8 8F01      		movw r16,r30
 3529               	.LVL319:
 381:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3530               		.loc 3 381 0 discriminator 3
 3531 03da 80E0      		ldi r24,lo8(eepromBuffer+8)
 3532 03dc 90E0      		ldi r25,hi8(eepromBuffer+8)
 3533 03de 8E17      		cp r24,r30
 3534 03e0 9F07      		cpc r25,r31
 3535 03e2 01F4      		brne .L152
 3536               	.LBE243:
 384:main.c        **** 			
 3537               		.loc 3 384 0
 3538 03e4 939A      		sbi 0x12,3
 386:main.c        **** 			address++;
 3539               		.loc 3 386 0
 3540 03e6 662D      		mov r22,r6
 3541 03e8 C601      		movw r24,r12
 3542 03ea 00D0      		rcall gba_eeprom_write
 3543               	.LVL320:
 387:main.c        **** 			
 3544               		.loc 3 387 0
 3545 03ec 9FEF      		ldi r25,-1
 3546 03ee C91A      		sub r12,r25
 3547 03f0 D90A      		sbc r13,r25
 3548 03f2 E90A      		sbc r14,r25
 3549 03f4 F90A      		sbc r15,r25
 3550               	.LVL321:
 3551               	.LBB244:
 3552               	.LBB245:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3553               		.loc 2 187 0
 3554 03f6 EFE7      		ldi r30,lo8(15999)
 3555 03f8 FEE3      		ldi r31,hi8(15999)
 3556 03fa 3197      	1:	sbiw r30,1
 3557 03fc 01F4      		brne 1b
 3558 03fe 00C0      		rjmp .
 3559 0400 0000      		nop
 3560               	.LVL322:
 3561 0402 00C0      		rjmp .L353
 3562               	.LVL323:
 3563               	.L151:
 3564               	.LBE245:
 3565               	.LBE244:
 399:main.c        **** 			flashWriteWePin = USART_Receive();
 3566               		.loc 3 399 0
 3567 0404 8035      		cpi r24,lo8(80)
 3568 0406 01F4      		brne .L153
 400:main.c        **** 			
 3569               		.loc 3 400 0
 3570 0408 00D0      		rcall USART_Receive
 3571               	.LVL324:
 3572 040a 8093 0000 		sts flashWriteWePin,r24
 402:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3573               		.loc 3 402 0
 3574 040e 8134      		cpi r24,lo8(65)
 3575 0410 01F0      		breq .+2
 3576 0412 00C0      		rjmp .L106
 403:main.c        **** 				audioPin_high;
 3577               		.loc 3 403 0
 3578 0414 319A      		sbi 0x6,1
 404:main.c        **** 			}
 3579               		.loc 3 404 0
 3580 0416 399A      		sbi 0x7,1
 3581 0418 00C0      		rjmp .L106
 3582               	.L153:
 409:main.c        **** 			flashBank1CommandWrites = 1;
 3583               		.loc 3 409 0
 3584 041a 8E34      		cpi r24,lo8(78)
 3585 041c 01F4      		brne .L154
 410:main.c        **** 		}
 3586               		.loc 3 410 0
 3587 041e 81E0      		ldi r24,lo8(1)
 3588 0420 8093 0000 		sts flashBank1CommandWrites,r24
 3589 0424 00C0      		rjmp .L106
 3590               	.L154:
 414:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3591               		.loc 3 414 0
 3592 0426 8534      		cpi r24,lo8(69)
 3593 0428 01F4      		brne .L155
 3594 042a 00E0      		ldi r16,lo8(flashWriteCycle)
 3595 042c 10E0      		ldi r17,hi8(flashWriteCycle)
 3596               	.L156:
 3597               	.LBB246:
 416:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3598               		.loc 3 416 0 discriminator 3
 3599 042e 00D0      		rcall usart_read_chars
 3600               	.LVL325:
 417:main.c        **** 				USART_Transmit(SEND_ACK);
 3601               		.loc 3 417 0 discriminator 3
 3602 0430 40E1      		ldi r20,lo8(16)
 3603 0432 50E0      		ldi r21,0
 3604 0434 60E0      		ldi r22,0
 3605 0436 70E0      		ldi r23,0
 3606 0438 80E0      		ldi r24,lo8(receivedBuffer)
 3607 043a 90E0      		ldi r25,hi8(receivedBuffer)
 3608 043c 00D0      		rcall strtol
 3609               	.LVL326:
 3610 043e F801      		movw r30,r16
 3611 0440 7183      		std Z+1,r23
 3612 0442 6083      		st Z,r22
 418:main.c        **** 				
 3613               		.loc 3 418 0 discriminator 3
 3614 0444 81E3      		ldi r24,lo8(49)
 3615 0446 00D0      		rcall USART_Transmit
 3616               	.LVL327:
 420:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3617               		.loc 3 420 0 discriminator 3
 3618 0448 00D0      		rcall usart_read_chars
 3619               	.LVL328:
 421:main.c        **** 				USART_Transmit(SEND_ACK);
 3620               		.loc 3 421 0 discriminator 3
 3621 044a 40E1      		ldi r20,lo8(16)
 3622 044c 50E0      		ldi r21,0
 3623 044e 60E0      		ldi r22,0
 3624 0450 70E0      		ldi r23,0
 3625 0452 80E0      		ldi r24,lo8(receivedBuffer)
 3626 0454 90E0      		ldi r25,hi8(receivedBuffer)
 3627 0456 00D0      		rcall strtol
 3628               	.LVL329:
 3629 0458 F801      		movw r30,r16
 3630 045a 7383      		std Z+3,r23
 3631 045c 6283      		std Z+2,r22
 422:main.c        **** 			}
 3632               		.loc 3 422 0 discriminator 3
 3633 045e 81E3      		ldi r24,lo8(49)
 3634 0460 00D0      		rcall USART_Transmit
 3635               	.LVL330:
 3636 0462 0C5F      		subi r16,-4
 3637 0464 1F4F      		sbci r17,-1
 415:main.c        **** 				usart_read_chars(); // Address
 3638               		.loc 3 415 0 discriminator 3
 3639 0466 80E0      		ldi r24,lo8(flashWriteCycle+12)
 3640 0468 90E0      		ldi r25,hi8(flashWriteCycle+12)
 3641 046a 8017      		cp r24,r16
 3642 046c 9107      		cpc r25,r17
 3643 046e 01F4      		brne .L156
 3644 0470 00C0      		rjmp .L106
 3645               	.L155:
 3646               	.LBE246:
 427:main.c        **** 			usart_read_chars(); // Read address
 3647               		.loc 3 427 0
 3648 0472 8634      		cpi r24,lo8(70)
 3649 0474 01F4      		brne .L157
 3650               	.LBB247:
 428:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3651               		.loc 3 428 0
 3652 0476 00D0      		rcall usart_read_chars
 3653               	.LVL331:
 429:main.c        **** 			
 3654               		.loc 3 429 0
 3655 0478 40E1      		ldi r20,lo8(16)
 3656 047a 50E0      		ldi r21,0
 3657 047c 60E0      		ldi r22,0
 3658 047e 70E0      		ldi r23,0
 3659 0480 80E0      		ldi r24,lo8(receivedBuffer)
 3660 0482 90E0      		ldi r25,hi8(receivedBuffer)
 3661 0484 00D0      		rcall strtol
 3662               	.LVL332:
 3663 0486 4B01      		movw r8,r22
 3664 0488 5C01      		movw r10,r24
 3665               	.LVL333:
 431:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3666               		.loc 3 431 0
 3667 048a 00D0      		rcall usart_read_chars
 3668               	.LVL334:
 432:main.c        **** 			
 3669               		.loc 3 432 0
 3670 048c 40E1      		ldi r20,lo8(16)
 3671 048e 50E0      		ldi r21,0
 3672 0490 60E0      		ldi r22,0
 3673 0492 70E0      		ldi r23,0
 3674 0494 80E0      		ldi r24,lo8(receivedBuffer)
 3675 0496 90E0      		ldi r25,hi8(receivedBuffer)
 3676 0498 00D0      		rcall strtol
 3677               	.LVL335:
 434:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3678               		.loc 3 434 0
 3679 049a 939A      		sbi 0x12,3
 435:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3680               		.loc 3 435 0
 3681 049c C401      		movw r24,r8
 3682 049e 00D0      		rcall gb_flash_write_bus_cycle
 3683               	.LVL336:
 3684 04a0 00C0      		rjmp .L360
 3685               	.LVL337:
 3686               	.L157:
 3687               	.LBE247:
 442:main.c        **** 			usart_read_bytes(64);
 3688               		.loc 3 442 0
 3689 04a2 8435      		cpi r24,lo8(84)
 3690 04a4 01F4      		brne .L158
 443:main.c        **** 			start_timeout_timer();
 3691               		.loc 3 443 0
 3692 04a6 80E4      		ldi r24,lo8(64)
 3693 04a8 90E0      		ldi r25,0
 3694 04aa 00D0      		rcall usart_read_bytes
 3695               	.LVL338:
 444:main.c        **** 			
 3696               		.loc 3 444 0
 3697 04ac 00D0      		rcall start_timeout_timer
 3698               	.LVL339:
 446:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3699               		.loc 3 446 0
 3700 04ae 939A      		sbi 0x12,3
 447:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3701               		.loc 3 447 0
 3702 04b0 8091 0000 		lds r24,flashBank1CommandWrites
 3703 04b4 60E0      		ldi r22,lo8(receivedBuffer)
 3704 04b6 A62E      		mov r10,r22
 3705 04b8 60E0      		ldi r22,hi8(receivedBuffer)
 3706 04ba B62E      		mov r11,r22
 3707 04bc 00E0      		ldi r16,0
 3708 04be 10E0      		ldi r17,0
 3709 04c0 8111      		cpse r24,__zero_reg__
 3710 04c2 00C0      		rjmp .L164
 3711               	.LVL340:
 3712               	.L161:
 3713               	.LBB248:
 449:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3714               		.loc 3 449 0
 3715 04c4 F501      		movw r30,r10
 3716 04c6 6191      		ld r22,Z+
 3717 04c8 5F01      		movw r10,r30
 3718 04ca 6F3F      		cpi r22,lo8(-1)
 3719 04cc 01F0      		breq .L160
 450:main.c        **** 					}
 3720               		.loc 3 450 0
 3721 04ce C801      		movw r24,r16
 3722 04d0 8C0D      		add r24,r12
 3723 04d2 9D1D      		adc r25,r13
 3724 04d4 00D0      		rcall gb_flash_write_byte
 3725               	.LVL341:
 3726               	.L160:
 3727 04d6 0F5F      		subi r16,-1
 3728 04d8 1F4F      		sbci r17,-1
 3729               	.LVL342:
 448:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3730               		.loc 3 448 0 discriminator 2
 3731 04da 0034      		cpi r16,64
 3732 04dc 1105      		cpc r17,__zero_reg__
 3733 04de 01F4      		brne .L161
 3734 04e0 20E4      		ldi r18,64
 3735 04e2 C20E      		add r12,r18
 3736 04e4 D11C      		adc r13,__zero_reg__
 3737 04e6 E11C      		adc r14,__zero_reg__
 3738 04e8 F11C      		adc r15,__zero_reg__
 3739               	.LVL343:
 3740 04ea 00C0      		rjmp .L350
 3741               	.LVL344:
 3742               	.L163:
 3743 04ec 0F5F      		subi r16,-1
 3744 04ee 1F4F      		sbci r17,-1
 3745               	.LVL345:
 3746               	.LBE248:
 3747               	.LBB249:
 456:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3748               		.loc 3 456 0 discriminator 2
 3749 04f0 0034      		cpi r16,64
 3750 04f2 1105      		cpc r17,__zero_reg__
 3751 04f4 01F4      		brne .+2
 3752 04f6 00C0      		rjmp .L359
 3753               	.LVL346:
 3754               	.L164:
 457:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3755               		.loc 3 457 0
 3756 04f8 F501      		movw r30,r10
 3757 04fa 6191      		ld r22,Z+
 3758 04fc 5F01      		movw r10,r30
 3759 04fe 6F3F      		cpi r22,lo8(-1)
 3760 0500 01F0      		breq .L163
 458:main.c        **** 					}
 3761               		.loc 3 458 0
 3762 0502 C801      		movw r24,r16
 3763 0504 8C0D      		add r24,r12
 3764 0506 9D1D      		adc r25,r13
 3765 0508 00D0      		rcall gb_flash_write_byte_bank1_commands
 3766               	.LVL347:
 3767 050a 00C0      		rjmp .L163
 3768               	.LVL348:
 3769               	.L158:
 3770               	.LBE249:
 468:main.c        **** 			usart_read_bytes(32);
 3771               		.loc 3 468 0
 3772 050c 8935      		cpi r24,lo8(89)
 3773 050e 01F0      		breq .+2
 3774 0510 00C0      		rjmp .L166
 3775               	.LBB250:
 469:main.c        **** 			start_timeout_timer();
 3776               		.loc 3 469 0
 3777 0512 80E2      		ldi r24,lo8(32)
 3778 0514 90E0      		ldi r25,0
 3779 0516 00D0      		rcall usart_read_bytes
 3780               	.LVL349:
 470:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3781               		.loc 3 470 0
 3782 0518 00D0      		rcall start_timeout_timer
 3783               	.LVL350:
 471:main.c        **** 			
 3784               		.loc 3 471 0
 3785 051a 939A      		sbi 0x12,3
 474:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3786               		.loc 3 474 0
 3787 051c 6AEA      		ldi r22,lo8(-86)
 3788 051e 8AEA      		ldi r24,lo8(-86)
 3789 0520 9AE0      		ldi r25,lo8(10)
 3790 0522 00D0      		rcall gb_flash_write_bus_cycle
 3791               	.LVL351:
 475:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3792               		.loc 3 475 0
 3793 0524 65E5      		ldi r22,lo8(85)
 3794 0526 85E5      		ldi r24,lo8(85)
 3795 0528 95E0      		ldi r25,lo8(5)
 3796 052a 00D0      		rcall gb_flash_write_bus_cycle
 3797               	.LVL352:
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3798               		.loc 3 476 0
 3799 052c 5601      		movw r10,r12
 3800 052e 65E2      		ldi r22,lo8(37)
 3801 0530 C601      		movw r24,r12
 3802 0532 00D0      		rcall gb_flash_write_bus_cycle
 3803               	.LVL353:
 477:main.c        **** 			_delay_us(1);
 3804               		.loc 3 477 0
 3805 0534 6FE1      		ldi r22,lo8(31)
 3806 0536 C601      		movw r24,r12
 3807 0538 00D0      		rcall gb_flash_write_bus_cycle
 3808               	.LVL354:
 3809               	.LBB251:
 3810               	.LBB252:
 3811               		.loc 2 276 0
 3812 053a 82E0      		ldi r24,lo8(2)
 3813 053c 8A95      	1:	dec r24
 3814 053e 01F4      		brne 1b
 3815 0540 00C0      		rjmp .
 3816               	.LVL355:
 3817 0542 00E0      		ldi r16,lo8(receivedBuffer)
 3818 0544 10E0      		ldi r17,hi8(receivedBuffer)
 3819 0546 812C      		mov r8,__zero_reg__
 3820 0548 912C      		mov r9,__zero_reg__
 3821               	.LVL356:
 3822               	.L167:
 3823               	.LBE252:
 3824               	.LBE251:
 3825               	.LBB254:
 482:main.c        **** 				address++;
 3826               		.loc 3 482 0 discriminator 3
 3827 054a F801      		movw r30,r16
 3828 054c 6191      		ld r22,Z+
 3829 054e 8F01      		movw r16,r30
 3830 0550 C501      		movw r24,r10
 3831 0552 880D      		add r24,r8
 3832 0554 991D      		adc r25,r9
 3833 0556 00D0      		rcall gb_flash_write_bus_cycle
 3834               	.LVL357:
 3835 0558 FFEF      		ldi r31,-1
 3836 055a 8F1A      		sub r8,r31
 3837 055c 9F0A      		sbc r9,r31
 3838               	.LVL358:
 481:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3839               		.loc 3 481 0 discriminator 3
 3840 055e 20E2      		ldi r18,32
 3841 0560 8216      		cp r8,r18
 3842 0562 9104      		cpc r9,__zero_reg__
 3843 0564 01F4      		brne .L167
 3844 0566 80E2      		ldi r24,32
 3845 0568 C80E      		add r12,r24
 3846 056a D11C      		adc r13,__zero_reg__
 3847 056c E11C      		adc r14,__zero_reg__
 3848 056e F11C      		adc r15,__zero_reg__
 3849               	.LBE254:
 487:main.c        **** 			_delay_us(200);
 3850               		.loc 3 487 0
 3851 0570 C601      		movw r24,r12
 3852 0572 8097      		sbiw r24,32
 3853 0574 69E2      		ldi r22,lo8(41)
 3854 0576 00D0      		rcall gb_flash_write_bus_cycle
 3855               	.LVL359:
 3856               	.LBB255:
 3857               	.LBB256:
 3858               		.loc 2 276 0
 3859 0578 EFE8      		ldi r30,lo8(399)
 3860 057a F1E0      		ldi r31,hi8(399)
 3861 057c 3197      	1:	sbiw r30,1
 3862 057e 01F4      		brne 1b
 3863 0580 00C0      		rjmp .
 3864 0582 0000      		nop
 3865               	.LVL360:
 3866               	.LBE256:
 3867               	.LBE255:
 491:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3868               		.loc 3 491 0
 3869 0584 8601      		movw r16,r12
 3870 0586 0150      		subi r16,1
 3871 0588 1109      		sbc r17,__zero_reg__
 3872 058a C801      		movw r24,r16
 3873 058c 00D0      		rcall gb_flash_read_byte
 3874               	.LVL361:
 3875               	.L168:
 492:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3876               		.loc 3 492 0
 3877 058e 9091 0000 		lds r25,receivedBuffer+31
 3878 0592 8917      		cp r24,r25
 3879 0594 01F4      		brne .+2
 3880 0596 00C0      		rjmp .L350
 493:main.c        **** 				_delay_us(5);
 3881               		.loc 3 493 0
 3882 0598 C801      		movw r24,r16
 3883               	.LVL362:
 3884 059a 00D0      		rcall gb_flash_read_byte
 3885               	.LVL363:
 3886               	.LBB257:
 3887               	.LBB258:
 3888               		.loc 2 276 0
 3889 059c FDE0      		ldi r31,lo8(13)
 3890 059e FA95      	1:	dec r31
 3891 05a0 01F4      		brne 1b
 3892 05a2 0000      		nop
 3893               	.LVL364:
 3894               	.LBE258:
 3895               	.LBE257:
 495:main.c        **** 					break;
 3896               		.loc 3 495 0
 3897 05a4 9091 0000 		lds r25,writingTimedout
 3898 05a8 9130      		cpi r25,lo8(1)
 3899 05aa 01F4      		brne .L168
 3900 05ac 00C0      		rjmp .L350
 3901               	.LVL365:
 3902               	.L166:
 3903               	.LBE250:
 504:main.c        **** 			usart_read_bytes(256);
 3904               		.loc 3 504 0
 3905 05ae 8535      		cpi r24,lo8(85)
 3906 05b0 01F0      		breq .+2
 3907 05b2 00C0      		rjmp .L171
 3908               	.LBB260:
 505:main.c        **** 			start_timeout_timer();
 3909               		.loc 3 505 0
 3910 05b4 80E0      		ldi r24,0
 3911 05b6 91E0      		ldi r25,lo8(1)
 3912 05b8 00D0      		rcall usart_read_bytes
 3913               	.LVL366:
 506:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3914               		.loc 3 506 0
 3915 05ba 00D0      		rcall start_timeout_timer
 3916               	.LVL367:
 507:main.c        **** 			
 3917               		.loc 3 507 0
 3918 05bc 939A      		sbi 0x12,3
 3919               	.LVL368:
 3920 05be 40E0      		ldi r20,lo8(receivedBuffer)
 3921 05c0 842E      		mov r8,r20
 3922 05c2 40E0      		ldi r20,hi8(receivedBuffer)
 3923 05c4 942E      		mov r9,r20
 3924 05c6 58E0      		ldi r21,lo8(8)
 3925 05c8 352E      		mov r3,r21
 3926               	.LVL369:
 3927               	.L172:
 3928 05ca CE01      		movw r24,r28
 3929 05cc 0196      		adiw r24,1
 3930 05ce 2C01      		movw r4,r24
 3931               	.LBE260:
 3932               	.LBB271:
 3933               	.LBB259:
 3934               	.LBB253:
 3935               		.loc 2 276 0
 3936 05d0 FC01      		movw r30,r24
 3937 05d2 D401      		movw r26,r8
 3938               	.LVL370:
 3939               	.L173:
 3940               	.LBE253:
 3941               	.LBE259:
 3942               	.LBE271:
 3943               	.LBB272:
 3944               	.LBB261:
 3945               	.LBB262:
 3946               	.LBB263:
 514:main.c        **** 					byteCounter++;
 3947               		.loc 3 514 0 discriminator 3
 3948 05d4 8D91      		ld r24,X+
 3949               	.LVL371:
 3950 05d6 8193      		st Z+,r24
 3951               	.LVL372:
 513:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 3952               		.loc 3 513 0 discriminator 3
 3953 05d8 89A1      		ldd r24,Y+33
 3954 05da 9AA1      		ldd r25,Y+34
 3955 05dc 8E17      		cp r24,r30
 3956 05de 9F07      		cpc r25,r31
 3957 05e0 01F4      		brne .L173
 3958               	.LBE263:
 519:main.c        **** 				gb_flash_write_bus_cycle(0x555, 0x55);
 3959               		.loc 3 519 0
 3960 05e2 6AEA      		ldi r22,lo8(-86)
 3961 05e4 8AEA      		ldi r24,lo8(-86)
 3962 05e6 9AE0      		ldi r25,lo8(10)
 3963 05e8 00D0      		rcall gb_flash_write_bus_cycle
 3964               	.LVL373:
 520:main.c        **** 				gb_flash_write_bus_cycle(address, 0x25);
 3965               		.loc 3 520 0
 3966 05ea 65E5      		ldi r22,lo8(85)
 3967 05ec 85E5      		ldi r24,lo8(85)
 3968 05ee 95E0      		ldi r25,lo8(5)
 3969 05f0 00D0      		rcall gb_flash_write_bus_cycle
 3970               	.LVL374:
 521:main.c        **** 				gb_flash_write_bus_cycle(address, 0x1F); // Length
 3971               		.loc 3 521 0
 3972 05f2 5601      		movw r10,r12
 3973 05f4 65E2      		ldi r22,lo8(37)
 3974 05f6 C601      		movw r24,r12
 3975 05f8 00D0      		rcall gb_flash_write_bus_cycle
 3976               	.LVL375:
 522:main.c        **** 				_delay_us(1);
 3977               		.loc 3 522 0
 3978 05fa 6FE1      		ldi r22,lo8(31)
 3979 05fc C601      		movw r24,r12
 3980 05fe 00D0      		rcall gb_flash_write_bus_cycle
 3981               	.LVL376:
 3982               	.LBB264:
 3983               	.LBB265:
 3984               		.loc 2 276 0
 3985 0600 92E0      		ldi r25,lo8(2)
 3986 0602 9A95      	1:	dec r25
 3987 0604 01F4      		brne 1b
 3988 0606 00C0      		rjmp .
 3989               	.LVL377:
 3990 0608 00E0      		ldi r16,0
 3991 060a 10E0      		ldi r17,0
 3992               	.LVL378:
 3993               	.L174:
 3994               	.LBE265:
 3995               	.LBE264:
 3996               	.LBB266:
 527:main.c        **** 					address++;
 3997               		.loc 3 527 0 discriminator 3
 3998 060c F201      		movw r30,r4
 3999 060e 6191      		ld r22,Z+
 4000 0610 2F01      		movw r4,r30
 4001 0612 C501      		movw r24,r10
 4002 0614 800F      		add r24,r16
 4003 0616 911F      		adc r25,r17
 4004 0618 00D0      		rcall gb_flash_write_bus_cycle
 4005               	.LVL379:
 4006 061a 0F5F      		subi r16,-1
 4007 061c 1F4F      		sbci r17,-1
 4008               	.LVL380:
 526:main.c        **** 					gb_flash_write_bus_cycle(address, localBuffer[x]);
 4009               		.loc 3 526 0 discriminator 3
 4010 061e 0032      		cpi r16,32
 4011 0620 1105      		cpc r17,__zero_reg__
 4012 0622 01F4      		brne .L174
 4013 0624 F0E2      		ldi r31,32
 4014 0626 CF0E      		add r12,r31
 4015 0628 D11C      		adc r13,__zero_reg__
 4016 062a E11C      		adc r14,__zero_reg__
 4017 062c F11C      		adc r15,__zero_reg__
 4018               	.LBE266:
 532:main.c        **** 				_delay_us(200);
 4019               		.loc 3 532 0
 4020 062e C601      		movw r24,r12
 4021 0630 8097      		sbiw r24,32
 4022 0632 69E2      		ldi r22,lo8(41)
 4023 0634 00D0      		rcall gb_flash_write_bus_cycle
 4024               	.LVL381:
 4025               	.LBB267:
 4026               	.LBB268:
 4027               		.loc 2 276 0
 4028 0636 8FE8      		ldi r24,lo8(399)
 4029 0638 91E0      		ldi r25,hi8(399)
 4030 063a 0197      	1:	sbiw r24,1
 4031 063c 01F4      		brne 1b
 4032 063e 00C0      		rjmp .
 4033 0640 0000      		nop
 4034               	.LVL382:
 4035 0642 8601      		movw r16,r12
 4036               	.LVL383:
 4037 0644 0150      		subi r16,1
 4038 0646 1109      		sbc r17,__zero_reg__
 4039               	.LBE268:
 4040               	.LBE267:
 536:main.c        **** 				while (dataVerify != localBuffer[31]) {
 4041               		.loc 3 536 0
 4042 0648 C801      		movw r24,r16
 4043 064a 00D0      		rcall gb_flash_read_byte
 4044               	.LVL384:
 4045               	.L175:
 537:main.c        **** 					dataVerify = gb_flash_read_byte(address-1);
 4046               		.loc 3 537 0
 4047 064c 98A1      		ldd r25,Y+32
 4048 064e 8917      		cp r24,r25
 4049 0650 01F0      		breq .L179
 538:main.c        **** 					_delay_us(5);
 4050               		.loc 3 538 0
 4051 0652 C801      		movw r24,r16
 4052               	.LVL385:
 4053 0654 00D0      		rcall gb_flash_read_byte
 4054               	.LVL386:
 4055               	.LBB269:
 4056               	.LBB270:
 4057               		.loc 2 276 0
 4058 0656 9DE0      		ldi r25,lo8(13)
 4059 0658 9A95      	1:	dec r25
 4060 065a 01F4      		brne 1b
 4061 065c 0000      		nop
 4062               	.LVL387:
 4063               	.LBE270:
 4064               	.LBE269:
 540:main.c        **** 						break;
 4065               		.loc 3 540 0
 4066 065e 9091 0000 		lds r25,writingTimedout
 4067 0662 9130      		cpi r25,lo8(1)
 4068 0664 01F4      		brne .L175
 4069               	.L179:
 544:main.c        **** 					break;
 4070               		.loc 3 544 0
 4071 0666 8091 0000 		lds r24,writingTimedout
 4072               	.LVL388:
 4073 066a 8130      		cpi r24,lo8(1)
 4074 066c 01F4      		brne .+2
 4075 066e 00C0      		rjmp .L350
 4076               	.LVL389:
 4077 0670 3A94      		dec r3
 4078               	.LVL390:
 4079 0672 E0E2      		ldi r30,32
 4080 0674 8E0E      		add r8,r30
 4081 0676 911C      		adc r9,__zero_reg__
 4082               	.LVL391:
 4083               	.LBE262:
 510:main.c        **** 				// Store to local buffer
 4084               		.loc 3 510 0
 4085 0678 3110      		cpse r3,__zero_reg__
 4086 067a 00C0      		rjmp .L172
 4087 067c 00C0      		rjmp .L350
 4088               	.LVL392:
 4089               	.L171:
 4090               	.LBE261:
 4091               	.LBE272:
 553:main.c        **** 			usart_read_bytes(64);
 4092               		.loc 3 553 0
 4093 067e 8A34      		cpi r24,lo8(74)
 4094 0680 01F4      		brne .L181
 554:main.c        **** 			start_timeout_timer();
 4095               		.loc 3 554 0
 4096 0682 80E4      		ldi r24,lo8(64)
 4097 0684 90E0      		ldi r25,0
 4098 0686 00D0      		rcall usart_read_bytes
 4099               	.LVL393:
 555:main.c        **** 			
 4100               		.loc 3 555 0
 4101 0688 00D0      		rcall start_timeout_timer
 4102               	.LVL394:
 557:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 4103               		.loc 3 557 0
 4104 068a 939A      		sbi 0x12,3
 4105               	.LVL395:
 4106 068c 30E0      		ldi r19,lo8(receivedBuffer)
 4107 068e A32E      		mov r10,r19
 4108 0690 30E0      		ldi r19,hi8(receivedBuffer)
 4109 0692 B32E      		mov r11,r19
 4110 0694 00E0      		ldi r16,0
 4111 0696 10E0      		ldi r17,0
 4112               	.LVL396:
 4113               	.L183:
 4114               	.LBB273:
 559:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 4115               		.loc 3 559 0
 4116 0698 F501      		movw r30,r10
 4117 069a 6191      		ld r22,Z+
 4118 069c 5F01      		movw r10,r30
 4119 069e 6F3F      		cpi r22,lo8(-1)
 4120 06a0 01F0      		breq .L182
 560:main.c        **** 				}
 4121               		.loc 3 560 0
 4122 06a2 C801      		movw r24,r16
 4123 06a4 8C0D      		add r24,r12
 4124 06a6 9D1D      		adc r25,r13
 4125 06a8 00D0      		rcall gb_flash_write_byte_special
 4126               	.LVL397:
 4127               	.L182:
 4128 06aa 0F5F      		subi r16,-1
 4129 06ac 1F4F      		sbci r17,-1
 4130               	.LVL398:
 558:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 4131               		.loc 3 558 0 discriminator 2
 4132 06ae 0034      		cpi r16,64
 4133 06b0 1105      		cpc r17,__zero_reg__
 4134 06b2 01F4      		brne .L183
 4135               	.LVL399:
 4136               	.L359:
 4137 06b4 F0E4      		ldi r31,64
 4138 06b6 CF0E      		add r12,r31
 4139 06b8 D11C      		adc r13,__zero_reg__
 4140 06ba E11C      		adc r14,__zero_reg__
 4141 06bc F11C      		adc r15,__zero_reg__
 4142 06be 00C0      		rjmp .L350
 4143               	.LVL400:
 4144               	.L181:
 4145               	.LBE273:
 569:main.c        **** 			usart_read_bytes(256);
 4146               		.loc 3 569 0
 4147 06c0 8835      		cpi r24,lo8(88)
 4148 06c2 01F0      		breq .+2
 4149 06c4 00C0      		rjmp .L184
 4150               	.LBB274:
 570:main.c        **** 			start_timeout_timer();
 4151               		.loc 3 570 0
 4152 06c6 80E0      		ldi r24,0
 4153 06c8 91E0      		ldi r25,lo8(1)
 4154 06ca 00D0      		rcall usart_read_bytes
 4155               	.LVL401:
 571:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4156               		.loc 3 571 0
 4157 06cc 00D0      		rcall start_timeout_timer
 4158               	.LVL402:
 572:main.c        **** 			
 4159               		.loc 3 572 0
 4160 06ce 939A      		sbi 0x12,3
 575:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 4161               		.loc 3 575 0
 4162 06d0 69EA      		ldi r22,lo8(-87)
 4163 06d2 8AEA      		ldi r24,lo8(-86)
 4164 06d4 9AE0      		ldi r25,lo8(10)
 4165 06d6 00D0      		rcall gb_flash_write_bus_cycle
 4166               	.LVL403:
 576:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 4167               		.loc 3 576 0
 4168 06d8 66E5      		ldi r22,lo8(86)
 4169 06da 85E5      		ldi r24,lo8(85)
 4170 06dc 95E0      		ldi r25,lo8(5)
 4171 06de 00D0      		rcall gb_flash_write_bus_cycle
 4172               	.LVL404:
 577:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 4173               		.loc 3 577 0
 4174 06e0 5601      		movw r10,r12
 4175 06e2 66E2      		ldi r22,lo8(38)
 4176 06e4 C601      		movw r24,r12
 4177 06e6 00D0      		rcall gb_flash_write_bus_cycle
 4178               	.LVL405:
 578:main.c        **** 			_delay_us(50);
 4179               		.loc 3 578 0
 4180 06e8 6FEF      		ldi r22,lo8(-1)
 4181 06ea C601      		movw r24,r12
 4182 06ec 00D0      		rcall gb_flash_write_bus_cycle
 4183               	.LVL406:
 4184               	.LBB275:
 4185               	.LBB276:
 4186               		.loc 2 276 0
 4187 06ee 25E8      		ldi r18,lo8(-123)
 4188 06f0 2A95      	1:	dec r18
 4189 06f2 01F4      		brne 1b
 4190 06f4 0000      		nop
 4191               	.LVL407:
 4192 06f6 00E0      		ldi r16,lo8(receivedBuffer)
 4193 06f8 10E0      		ldi r17,hi8(receivedBuffer)
 4194               	.LBE276:
 4195               	.LBE275:
 4196               	.LBB277:
 582:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4197               		.loc 3 582 0
 4198 06fa 812C      		mov r8,__zero_reg__
 4199 06fc 912C      		mov r9,__zero_reg__
 4200               	.LVL408:
 4201               	.L185:
 583:main.c        **** 				address++;
 4202               		.loc 3 583 0 discriminator 3
 4203 06fe F801      		movw r30,r16
 4204 0700 6191      		ld r22,Z+
 4205 0702 8F01      		movw r16,r30
 4206 0704 C401      		movw r24,r8
 4207 0706 8A0D      		add r24,r10
 4208 0708 9B1D      		adc r25,r11
 4209 070a 00D0      		rcall gb_flash_write_bus_cycle
 4210               	.LVL409:
 582:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4211               		.loc 3 582 0 discriminator 3
 4212 070c FFEF      		ldi r31,-1
 4213 070e 8F1A      		sub r8,r31
 4214 0710 9F0A      		sbc r9,r31
 4215               	.LVL410:
 4216 0712 8114      		cp r8,__zero_reg__
 4217 0714 21E0      		ldi r18,1
 4218 0716 9206      		cpc r9,r18
 4219 0718 01F4      		brne .L185
 4220 071a 8FEF      		ldi r24,-1
 4221 071c D81A      		sub r13,r24
 4222 071e E80A      		sbc r14,r24
 4223 0720 F80A      		sbc r15,r24
 4224               	.LBE277:
 588:main.c        **** 			
 4225               		.loc 3 588 0
 4226 0722 C601      		movw r24,r12
 4227 0724 9A95      		dec r25
 4228 0726 6AE2      		ldi r22,lo8(42)
 4229 0728 00D0      		rcall gb_flash_write_bus_cycle
 4230               	.LVL411:
 591:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 4231               		.loc 3 591 0
 4232 072a 8601      		movw r16,r12
 4233 072c 0150      		subi r16,1
 4234 072e 1109      		sbc r17,__zero_reg__
 4235 0730 C801      		movw r24,r16
 4236 0732 00D0      		rcall gb_flash_read_byte
 4237               	.LVL412:
 4238               	.L186:
 592:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 4239               		.loc 3 592 0
 4240 0734 9091 0000 		lds r25,receivedBuffer+255
 4241 0738 8917      		cp r24,r25
 4242 073a 01F4      		brne .+2
 4243 073c 00C0      		rjmp .L350
 593:main.c        **** 				_delay_us(5);
 4244               		.loc 3 593 0
 4245 073e C801      		movw r24,r16
 4246               	.LVL413:
 4247 0740 00D0      		rcall gb_flash_read_byte
 4248               	.LVL414:
 4249               	.LBB278:
 4250               	.LBB279:
 4251               		.loc 2 276 0
 4252 0742 9DE0      		ldi r25,lo8(13)
 4253 0744 9A95      	1:	dec r25
 4254 0746 01F4      		brne 1b
 4255 0748 0000      		nop
 4256               	.LVL415:
 4257               	.LBE279:
 4258               	.LBE278:
 595:main.c        **** 					break;
 4259               		.loc 3 595 0
 4260 074a 9091 0000 		lds r25,writingTimedout
 4261 074e 9130      		cpi r25,lo8(1)
 4262 0750 01F4      		brne .L186
 4263 0752 00C0      		rjmp .L350
 4264               	.LVL416:
 4265               	.L184:
 4266               	.LBE274:
 604:main.c        **** 			usart_read_bytes(128);
 4267               		.loc 3 604 0
 4268 0754 8A37      		cpi r24,lo8(122)
 4269 0756 01F0      		breq .+2
 4270 0758 00C0      		rjmp .L189
 605:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4271               		.loc 3 605 0
 4272 075a 80E8      		ldi r24,lo8(-128)
 4273 075c 90E0      		ldi r25,0
 4274 075e 00D0      		rcall usart_read_bytes
 4275               	.LVL417:
 606:main.c        **** 			
 4276               		.loc 3 606 0
 4277 0760 939A      		sbi 0x12,3
 609:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 4278               		.loc 3 609 0
 4279 0762 69E0      		ldi r22,lo8(9)
 4280 0764 80E2      		ldi r24,lo8(32)
 4281 0766 91E0      		ldi r25,lo8(1)
 4282 0768 00D0      		rcall gb_flash_write_bus_cycle
 4283               	.LVL418:
 610:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 4284               		.loc 3 610 0
 4285 076a 6AEA      		ldi r22,lo8(-86)
 4286 076c 81E2      		ldi r24,lo8(33)
 4287 076e 91E0      		ldi r25,lo8(1)
 4288 0770 00D0      		rcall gb_flash_write_bus_cycle
 4289               	.LVL419:
 611:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4290               		.loc 3 611 0
 4291 0772 65E5      		ldi r22,lo8(85)
 4292 0774 82E2      		ldi r24,lo8(34)
 4293 0776 91E0      		ldi r25,lo8(1)
 4294 0778 00D0      		rcall gb_flash_write_bus_cycle
 4295               	.LVL420:
 612:main.c        **** 			_delay_us(5);
 4296               		.loc 3 612 0
 4297 077a 65EA      		ldi r22,lo8(-91)
 4298 077c 8FE3      		ldi r24,lo8(63)
 4299 077e 91E0      		ldi r25,lo8(1)
 4300 0780 00D0      		rcall gb_flash_write_bus_cycle
 4301               	.LVL421:
 4302               	.LBB280:
 4303               	.LBB281:
 4304               		.loc 2 276 0
 4305 0782 EDE0      		ldi r30,lo8(13)
 4306 0784 EA95      	1:	dec r30
 4307 0786 01F4      		brne 1b
 4308 0788 0000      		nop
 4309               	.LVL422:
 4310               	.LBE281:
 4311               	.LBE280:
 616:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4312               		.loc 3 616 0
 4313 078a 61E1      		ldi r22,lo8(17)
 4314 078c 80E2      		ldi r24,lo8(32)
 4315 078e 91E0      		ldi r25,lo8(1)
 4316 0790 00D0      		rcall gb_flash_write_bus_cycle
 4317               	.LVL423:
 617:main.c        **** 			_delay_us(5);
 4318               		.loc 3 617 0
 4319 0792 65EA      		ldi r22,lo8(-91)
 4320 0794 8FE3      		ldi r24,lo8(63)
 4321 0796 91E0      		ldi r25,lo8(1)
 4322 0798 00D0      		rcall gb_flash_write_bus_cycle
 4323               	.LVL424:
 4324               	.LBB282:
 4325               	.LBB283:
 4326               		.loc 2 276 0
 4327 079a FDE0      		ldi r31,lo8(13)
 4328 079c FA95      	1:	dec r31
 4329 079e 01F4      		brne 1b
 4330 07a0 0000      		nop
 4331               	.LVL425:
 4332               	.LBE283:
 4333               	.LBE282:
 621:main.c        **** 			_delay_us(5);
 4334               		.loc 3 621 0
 4335 07a2 61E0      		ldi r22,lo8(1)
 4336 07a4 80E0      		ldi r24,0
 4337 07a6 91E2      		ldi r25,lo8(33)
 4338 07a8 00D0      		rcall gb_flash_write_bus_cycle
 4339               	.LVL426:
 4340               	.LBB284:
 4341               	.LBB285:
 4342               		.loc 2 276 0
 4343 07aa 2DE0      		ldi r18,lo8(13)
 4344 07ac 2A95      	1:	dec r18
 4345 07ae 01F4      		brne 1b
 4346 07b0 0000      		nop
 4347               	.LVL427:
 4348               	.LBE285:
 4349               	.LBE284:
 626:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 4350               		.loc 3 626 0
 4351 07b2 6FE0      		ldi r22,lo8(15)
 4352 07b4 80E2      		ldi r24,lo8(32)
 4353 07b6 91E0      		ldi r25,lo8(1)
 4354 07b8 00D0      		rcall gb_flash_write_bus_cycle
 4355               	.LVL428:
 627:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 4356               		.loc 3 627 0
 4357 07ba 65E5      		ldi r22,lo8(85)
 4358 07bc 85E2      		ldi r24,lo8(37)
 4359 07be 91E0      		ldi r25,lo8(1)
 4360 07c0 00D0      		rcall gb_flash_write_bus_cycle
 4361               	.LVL429:
 628:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 4362               		.loc 3 628 0
 4363 07c2 65E5      		ldi r22,lo8(85)
 4364 07c4 86E2      		ldi r24,lo8(38)
 4365 07c6 91E0      		ldi r25,lo8(1)
 4366 07c8 00D0      		rcall gb_flash_write_bus_cycle
 4367               	.LVL430:
 629:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4368               		.loc 3 629 0
 4369 07ca 6AEA      		ldi r22,lo8(-86)
 4370 07cc 87E2      		ldi r24,lo8(39)
 4371 07ce 91E0      		ldi r25,lo8(1)
 4372 07d0 00D0      		rcall gb_flash_write_bus_cycle
 4373               	.LVL431:
 630:main.c        **** 			_delay_us(5);
 4374               		.loc 3 630 0
 4375 07d2 65EA      		ldi r22,lo8(-91)
 4376 07d4 8FE3      		ldi r24,lo8(63)
 4377 07d6 91E0      		ldi r25,lo8(1)
 4378 07d8 00D0      		rcall gb_flash_write_bus_cycle
 4379               	.LVL432:
 4380               	.LBB286:
 4381               	.LBB287:
 4382               		.loc 2 276 0
 4383 07da 8DE0      		ldi r24,lo8(13)
 4384 07dc 8A95      	1:	dec r24
 4385 07de 01F4      		brne 1b
 4386 07e0 0000      		nop
 4387               	.LVL433:
 4388               	.LBE287:
 4389               	.LBE286:
 633:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 4390               		.loc 3 633 0
 4391 07e2 6FE0      		ldi r22,lo8(15)
 4392 07e4 80E2      		ldi r24,lo8(32)
 4393 07e6 91E0      		ldi r25,lo8(1)
 4394 07e8 00D0      		rcall gb_flash_write_bus_cycle
 4395               	.LVL434:
 634:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 4396               		.loc 3 634 0
 4397 07ea 6AE2      		ldi r22,lo8(42)
 4398 07ec 85E2      		ldi r24,lo8(37)
 4399 07ee 91E0      		ldi r25,lo8(1)
 4400 07f0 00D0      		rcall gb_flash_write_bus_cycle
 4401               	.LVL435:
 635:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 4402               		.loc 3 635 0
 4403 07f2 6AEA      		ldi r22,lo8(-86)
 4404 07f4 86E2      		ldi r24,lo8(38)
 4405 07f6 91E0      		ldi r25,lo8(1)
 4406 07f8 00D0      		rcall gb_flash_write_bus_cycle
 4407               	.LVL436:
 636:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4408               		.loc 3 636 0
 4409 07fa 65E5      		ldi r22,lo8(85)
 4410 07fc 87E2      		ldi r24,lo8(39)
 4411 07fe 91E0      		ldi r25,lo8(1)
 4412 0800 00D0      		rcall gb_flash_write_bus_cycle
 4413               	.LVL437:
 637:main.c        **** 			_delay_us(5);
 4414               		.loc 3 637 0
 4415 0802 65EA      		ldi r22,lo8(-91)
 4416 0804 8FE3      		ldi r24,lo8(63)
 4417 0806 91E0      		ldi r25,lo8(1)
 4418 0808 00D0      		rcall gb_flash_write_bus_cycle
 4419               	.LVL438:
 4420               	.LBB288:
 4421               	.LBB289:
 4422               		.loc 2 276 0
 4423 080a 9DE0      		ldi r25,lo8(13)
 4424 080c 9A95      	1:	dec r25
 4425 080e 01F4      		brne 1b
 4426 0810 0000      		nop
 4427               	.LVL439:
 4428               	.LBE289:
 4429               	.LBE288:
 640:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 4430               		.loc 3 640 0
 4431 0812 6FE0      		ldi r22,lo8(15)
 4432 0814 80E2      		ldi r24,lo8(32)
 4433 0816 91E0      		ldi r25,lo8(1)
 4434 0818 00D0      		rcall gb_flash_write_bus_cycle
 4435               	.LVL440:
 641:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 4436               		.loc 3 641 0
 4437 081a 65E5      		ldi r22,lo8(85)
 4438 081c 85E2      		ldi r24,lo8(37)
 4439 081e 91E0      		ldi r25,lo8(1)
 4440 0820 00D0      		rcall gb_flash_write_bus_cycle
 4441               	.LVL441:
 642:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 4442               		.loc 3 642 0
 4443 0822 65E5      		ldi r22,lo8(85)
 4444 0824 86E2      		ldi r24,lo8(38)
 4445 0826 91E0      		ldi r25,lo8(1)
 4446 0828 00D0      		rcall gb_flash_write_bus_cycle
 4447               	.LVL442:
 643:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4448               		.loc 3 643 0
 4449 082a 60EA      		ldi r22,lo8(-96)
 4450 082c 87E2      		ldi r24,lo8(39)
 4451 082e 91E0      		ldi r25,lo8(1)
 4452 0830 00D0      		rcall gb_flash_write_bus_cycle
 4453               	.LVL443:
 644:main.c        **** 			_delay_us(5);
 4454               		.loc 3 644 0
 4455 0832 65EA      		ldi r22,lo8(-91)
 4456 0834 8FE3      		ldi r24,lo8(63)
 4457 0836 91E0      		ldi r25,lo8(1)
 4458 0838 00D0      		rcall gb_flash_write_bus_cycle
 4459               	.LVL444:
 4460               	.LBB290:
 4461               	.LBB291:
 4462               		.loc 2 276 0
 4463 083a EDE0      		ldi r30,lo8(13)
 4464 083c EA95      	1:	dec r30
 4465 083e 01F4      		brne 1b
 4466 0840 0000      		nop
 4467               	.LVL445:
 4468               	.LBE291:
 4469               	.LBE290:
 648:main.c        **** 			_delay_us(5);
 4470               		.loc 3 648 0
 4471 0842 40E0      		ldi r20,0
 4472 0844 6091 0000 		lds r22,lastBankAccessed
 4473 0848 80E0      		ldi r24,0
 4474 084a 91E2      		ldi r25,lo8(33)
 4475 084c 00D0      		rcall write_8bit_data
 4476               	.LVL446:
 4477               	.LBB292:
 4478               	.LBB293:
 4479               		.loc 2 276 0
 4480 084e FDE0      		ldi r31,lo8(13)
 4481 0850 FA95      	1:	dec r31
 4482 0852 01F4      		brne 1b
 4483 0854 0000      		nop
 4484               	.LVL447:
 4485               	.LBE293:
 4486               	.LBE292:
 652:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4487               		.loc 3 652 0
 4488 0856 60E1      		ldi r22,lo8(16)
 4489 0858 80E2      		ldi r24,lo8(32)
 4490 085a 91E0      		ldi r25,lo8(1)
 4491 085c 00D0      		rcall gb_flash_write_bus_cycle
 4492               	.LVL448:
 653:main.c        **** 			_delay_us(5);
 4493               		.loc 3 653 0
 4494 085e 65EA      		ldi r22,lo8(-91)
 4495 0860 8FE3      		ldi r24,lo8(63)
 4496 0862 91E0      		ldi r25,lo8(1)
 4497 0864 00D0      		rcall gb_flash_write_bus_cycle
 4498               	.LVL449:
 4499               	.LBB294:
 4500               	.LBB295:
 4501               		.loc 2 276 0
 4502 0866 2DE0      		ldi r18,lo8(13)
 4503 0868 2A95      	1:	dec r18
 4504 086a 01F4      		brne 1b
 4505 086c 0000      		nop
 4506               	.LVL450:
 4507               	.LBE295:
 4508               	.LBE294:
 657:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4509               		.loc 3 657 0
 4510 086e 68E0      		ldi r22,lo8(8)
 4511 0870 80E2      		ldi r24,lo8(32)
 4512 0872 91E0      		ldi r25,lo8(1)
 4513 0874 00D0      		rcall gb_flash_write_bus_cycle
 4514               	.LVL451:
 658:main.c        **** 			_delay_us(5);
 4515               		.loc 3 658 0
 4516 0876 65EA      		ldi r22,lo8(-91)
 4517 0878 8FE3      		ldi r24,lo8(63)
 4518 087a 91E0      		ldi r25,lo8(1)
 4519 087c 00D0      		rcall gb_flash_write_bus_cycle
 4520               	.LVL452:
 4521               	.LBB296:
 4522               	.LBB297:
 4523               		.loc 2 276 0
 4524 087e 8DE0      		ldi r24,lo8(13)
 4525 0880 8A95      	1:	dec r24
 4526 0882 01F4      		brne 1b
 4527 0884 0000      		nop
 4528               	.LVL453:
 4529 0886 00E0      		ldi r16,lo8(receivedBuffer)
 4530 0888 10E0      		ldi r17,hi8(receivedBuffer)
 4531               	.L190:
 4532               	.LBE297:
 4533               	.LBE296:
 4534               	.LBB298:
 663:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4535               		.loc 3 663 0 discriminator 1
 4536 088a 80E0      		ldi r24,lo8(receivedBuffer+128)
 4537 088c 90E0      		ldi r25,hi8(receivedBuffer+128)
 4538 088e 8017      		cp r24,r16
 4539 0890 9107      		cpc r25,r17
 4540 0892 01F0      		breq .L362
 664:main.c        **** 				_delay_us(5);
 4541               		.loc 3 664 0 discriminator 3
 4542 0894 F801      		movw r30,r16
 4543 0896 6191      		ld r22,Z+
 4544 0898 8F01      		movw r16,r30
 4545 089a C601      		movw r24,r12
 4546 089c 00D0      		rcall gb_flash_write_bus_cycle
 4547               	.LVL454:
 4548               	.LBB299:
 4549               	.LBB300:
 4550               		.loc 2 276 0 discriminator 3
 4551 089e FDE0      		ldi r31,lo8(13)
 4552 08a0 FA95      	1:	dec r31
 4553 08a2 01F4      		brne 1b
 4554 08a4 0000      		nop
 4555               	.LVL455:
 4556               	.LBE300:
 4557               	.LBE299:
 666:main.c        **** 			}
 4558               		.loc 3 666 0 discriminator 3
 4559 08a6 2FEF      		ldi r18,-1
 4560 08a8 C21A      		sub r12,r18
 4561 08aa D20A      		sbc r13,r18
 4562 08ac E20A      		sbc r14,r18
 4563 08ae F20A      		sbc r15,r18
 4564               	.LVL456:
 4565 08b0 00C0      		rjmp .L190
 4566               	.L362:
 4567               	.LVL457:
 4568               	.LBE298:
 671:main.c        **** 			address++;
 4569               		.loc 3 671 0
 4570 08b2 6FEF      		ldi r22,lo8(-1)
 4571 08b4 D701      		movw r26,r14
 4572 08b6 C601      		movw r24,r12
 4573 08b8 0197      		sbiw r24,1
 4574 08ba A109      		sbc r26,__zero_reg__
 4575 08bc B109      		sbc r27,__zero_reg__
 4576               	.LVL458:
 4577 08be 00D0      		rcall gb_flash_write_bus_cycle
 4578               	.LVL459:
 4579               	.LBB301:
 4580               	.LBB302:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4581               		.loc 2 187 0
 4582 08c0 EFE1      		ldi r30,lo8(19999)
 4583 08c2 FEE4      		ldi r31,hi8(19999)
 4584 08c4 3197      	1:	sbiw r30,1
 4585 08c6 01F4      		brne 1b
 4586 08c8 00C0      		rjmp .
 4587 08ca 0000      		nop
 4588               	.LVL460:
 4589               	.LBE302:
 4590               	.LBE301:
 675:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4591               		.loc 3 675 0
 4592 08cc 81E3      		ldi r24,lo8(49)
 4593 08ce 00D0      		rcall USART_Transmit
 4594               	.LVL461:
 4595 08d0 00C0      		rjmp .L349
 4596               	.LVL462:
 4597               	.L189:
 681:main.c        **** 			usart_read_bytes(32);
 4598               		.loc 3 681 0
 4599 08d2 8937      		cpi r24,lo8(121)
 4600 08d4 01F0      		breq .+2
 4601 08d6 00C0      		rjmp .L192
 682:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4602               		.loc 3 682 0
 4603 08d8 80E2      		ldi r24,lo8(32)
 4604 08da 90E0      		ldi r25,0
 4605 08dc 00D0      		rcall usart_read_bytes
 4606               	.LVL463:
 683:main.c        **** 			
 4607               		.loc 3 683 0
 4608 08de 939A      		sbi 0x12,3
 686:main.c        **** 			
 4609               		.loc 3 686 0
 4610 08e0 8601      		movw r16,r12
 4611 08e2 68EE      		ldi r22,lo8(-24)
 4612 08e4 C601      		movw r24,r12
 4613 08e6 00D0      		rcall gb_flash_write_bus_cycle
 4614               	.LVL464:
 690:main.c        **** 			while (gb_flash_read_byte(address) != 0x80) {
 4615               		.loc 3 690 0
 4616 08e8 00D0      		rcall start_timeout_timer
 4617               	.LVL465:
 4618               	.L193:
 691:main.c        **** 				if (writingTimedout == 1) {
 4619               		.loc 3 691 0
 4620 08ea C801      		movw r24,r16
 4621 08ec 00D0      		rcall gb_flash_read_byte
 4622               	.LVL466:
 4623 08ee 8038      		cpi r24,lo8(-128)
 4624 08f0 01F0      		breq .L194
 692:main.c        **** 					break;
 4625               		.loc 3 692 0
 4626 08f2 8091 0000 		lds r24,writingTimedout
 4627 08f6 8130      		cpi r24,lo8(1)
 4628 08f8 01F4      		brne .L193
 4629               	.L194:
 697:main.c        **** 				start_timeout_timer();
 4630               		.loc 3 697 0
 4631 08fa 8091 0000 		lds r24,writingTimedout
 4632 08fe 8111      		cpse r24,__zero_reg__
 4633 0900 00C0      		rjmp .L106
 698:main.c        **** 				
 4634               		.loc 3 698 0
 4635 0902 00D0      		rcall start_timeout_timer
 4636               	.LVL467:
 701:main.c        **** 				
 4637               		.loc 3 701 0
 4638 0904 6FE1      		ldi r22,lo8(31)
 4639 0906 C801      		movw r24,r16
 4640 0908 00D0      		rcall gb_flash_write_bus_cycle
 4641               	.LVL468:
 4642 090a 20E0      		ldi r18,lo8(receivedBuffer)
 4643 090c A22E      		mov r10,r18
 4644 090e 20E0      		ldi r18,hi8(receivedBuffer)
 4645 0910 B22E      		mov r11,r18
 4646 0912 812C      		mov r8,__zero_reg__
 4647 0914 912C      		mov r9,__zero_reg__
 4648               	.LVL469:
 4649               	.L196:
 4650               	.LBB303:
 705:main.c        **** 					address++;
 4651               		.loc 3 705 0 discriminator 3
 4652 0916 F501      		movw r30,r10
 4653 0918 6191      		ld r22,Z+
 4654 091a 5F01      		movw r10,r30
 4655 091c C401      		movw r24,r8
 4656 091e 800F      		add r24,r16
 4657 0920 911F      		adc r25,r17
 4658 0922 00D0      		rcall gb_flash_write_bus_cycle
 4659               	.LVL470:
 4660 0924 FFEF      		ldi r31,-1
 4661 0926 8F1A      		sub r8,r31
 4662 0928 9F0A      		sbc r9,r31
 4663               	.LVL471:
 704:main.c        **** 					gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4664               		.loc 3 704 0 discriminator 3
 4665 092a 20E2      		ldi r18,32
 4666 092c 8216      		cp r8,r18
 4667 092e 9104      		cpc r9,__zero_reg__
 4668 0930 01F4      		brne .L196
 4669 0932 80E2      		ldi r24,32
 4670 0934 C80E      		add r12,r24
 4671 0936 D11C      		adc r13,__zero_reg__
 4672 0938 E11C      		adc r14,__zero_reg__
 4673 093a F11C      		adc r15,__zero_reg__
 4674               	.LBE303:
 710:main.c        **** 				_delay_us(196);
 4675               		.loc 3 710 0
 4676 093c 8601      		movw r16,r12
 4677 093e 0052      		subi r16,32
 4678 0940 1109      		sbc r17,__zero_reg__
 4679 0942 60ED      		ldi r22,lo8(-48)
 4680 0944 C801      		movw r24,r16
 4681 0946 00D0      		rcall gb_flash_write_bus_cycle
 4682               	.LVL472:
 4683               	.LBB304:
 4684               	.LBB305:
 4685               		.loc 2 276 0
 4686 0948 E7E8      		ldi r30,lo8(391)
 4687 094a F1E0      		ldi r31,hi8(391)
 4688 094c 3197      	1:	sbiw r30,1
 4689 094e 01F4      		brne 1b
 4690 0950 00C0      		rjmp .
 4691 0952 0000      		nop
 4692               	.L197:
 4693               	.LBE305:
 4694               	.LBE304:
 715:main.c        **** 					if (writingTimedout == 1) {
 4695               		.loc 3 715 0
 4696 0954 C801      		movw r24,r16
 4697 0956 00D0      		rcall gb_flash_read_byte
 4698               	.LVL473:
 4699 0958 8038      		cpi r24,lo8(-128)
 4700 095a 01F4      		brne .+2
 4701 095c 00C0      		rjmp .L350
 716:main.c        **** 						break;
 4702               		.loc 3 716 0
 4703 095e 8091 0000 		lds r24,writingTimedout
 4704 0962 8130      		cpi r24,lo8(1)
 4705 0964 01F4      		brne .L197
 4706 0966 00C0      		rjmp .L350
 4707               	.LVL474:
 4708               	.L192:
 728:main.c        **** 			usart_read_chars(); // Read address
 4709               		.loc 3 728 0
 4710 0968 8E36      		cpi r24,lo8(110)
 4711 096a 01F4      		brne .L200
 4712               	.LBB306:
 729:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4713               		.loc 3 729 0
 4714 096c 00D0      		rcall usart_read_chars
 4715               	.LVL475:
 730:main.c        **** 			
 4716               		.loc 3 730 0
 4717 096e 40E1      		ldi r20,lo8(16)
 4718 0970 50E0      		ldi r21,0
 4719 0972 60E0      		ldi r22,0
 4720 0974 70E0      		ldi r23,0
 4721 0976 80E0      		ldi r24,lo8(receivedBuffer)
 4722 0978 90E0      		ldi r25,hi8(receivedBuffer)
 4723 097a 00D0      		rcall strtol
 4724               	.LVL476:
 4725 097c 4B01      		movw r8,r22
 4726 097e 5C01      		movw r10,r24
 4727               	.LVL477:
 732:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4728               		.loc 3 732 0
 4729 0980 00D0      		rcall USART_Receive
 4730               	.LVL478:
 4731 0982 8093 0000 		sts receivedChar,r24
 733:main.c        **** 				usart_read_chars(); // Read data
 4732               		.loc 3 733 0
 4733 0986 8E36      		cpi r24,lo8(110)
 4734 0988 01F0      		breq .+2
 4735 098a 00C0      		rjmp .L106
 4736               	.LBB307:
 734:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4737               		.loc 3 734 0
 4738 098c 00D0      		rcall usart_read_chars
 4739               	.LVL479:
 735:main.c        **** 				
 4740               		.loc 3 735 0
 4741 098e 40E1      		ldi r20,lo8(16)
 4742 0990 50E0      		ldi r21,0
 4743 0992 60E0      		ldi r22,0
 4744 0994 70E0      		ldi r23,0
 4745 0996 80E0      		ldi r24,lo8(receivedBuffer)
 4746 0998 90E0      		ldi r25,hi8(receivedBuffer)
 4747 099a 00D0      		rcall strtol
 4748               	.LVL480:
 737:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4749               		.loc 3 737 0
 4750 099c 939A      		sbi 0x12,3
 738:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4751               		.loc 3 738 0
 4752 099e 74BA      		out 0x14,r7
 739:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4753               		.loc 3 739 0
 4754 09a0 7ABA      		out 0x1a,r7
 740:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4755               		.loc 3 740 0
 4756 09a2 77BA      		out 0x17,r7
 741:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4757               		.loc 3 741 0
 4758 09a4 AB01      		movw r20,r22
 4759 09a6 C501      		movw r24,r10
 4760 09a8 B401      		movw r22,r8
 4761               	.LVL481:
 4762 09aa 00D0      		rcall gba_flash_write_bus_cycle
 4763               	.LVL482:
 4764               	.L360:
 742:main.c        **** 				
 4765               		.loc 3 742 0
 4766 09ac 9398      		cbi 0x12,3
 744:main.c        **** 			}
 4767               		.loc 3 744 0
 4768 09ae 81E3      		ldi r24,lo8(49)
 4769 09b0 00C0      		rjmp .L347
 4770               	.LVL483:
 4771               	.L200:
 4772               	.LBE307:
 4773               	.LBE306:
 749:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4774               		.loc 3 749 0
 4775 09b2 8137      		cpi r24,lo8(113)
 4776 09b4 01F0      		breq .L201
 749:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4777               		.loc 3 749 0 is_stmt 0 discriminator 1
 4778 09b6 8437      		cpi r24,lo8(116)
 4779 09b8 01F4      		brne .L202
 4780               	.L201:
 4781               	.LBB308:
 750:main.c        **** 			
 4782               		.loc 3 750 0 is_stmt 1
 4783 09ba 939A      		sbi 0x12,3
 4784               	.LVL484:
 753:main.c        **** 				readLength = 256;
 4785               		.loc 3 753 0
 4786 09bc 8091 0000 		lds r24,receivedChar
 4787 09c0 8437      		cpi r24,lo8(116)
 4788 09c2 01F0      		breq .L257
 752:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4789               		.loc 3 752 0
 4790 09c4 00E4      		ldi r16,lo8(64)
 4791 09c6 10E0      		ldi r17,0
 4792 09c8 00C0      		rjmp .L203
 4793               	.L257:
 754:main.c        **** 			}
 4794               		.loc 3 754 0
 4795 09ca 00E0      		ldi r16,0
 4796 09cc 11E0      		ldi r17,lo8(1)
 4797               	.L203:
 4798               	.LVL485:
 756:main.c        **** 			start_timeout_timer();
 4799               		.loc 3 756 0
 4800 09ce C801      		movw r24,r16
 4801 09d0 00D0      		rcall usart_read_bytes
 4802               	.LVL486:
 757:main.c        **** 			
 4803               		.loc 3 757 0
 4804 09d2 00D0      		rcall start_timeout_timer
 4805               	.LVL487:
 4806 09d4 90E0      		ldi r25,lo8(receivedBuffer)
 4807 09d6 A92E      		mov r10,r25
 4808 09d8 90E0      		ldi r25,hi8(receivedBuffer)
 4809 09da B92E      		mov r11,r25
 4810 09dc 1601      		movw r2,r12
 4811 09de 2701      		movw r4,r14
 4812               	.LVL488:
 4813               	.L205:
 4814               	.LBB309:
 4815               	.LBB310:
 760:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4816               		.loc 3 760 0
 4817 09e0 F501      		movw r30,r10
 4818 09e2 4181      		ldd r20,Z+1
 4819 09e4 50E0      		ldi r21,0
 4820 09e6 542F      		mov r21,r20
 4821 09e8 4427      		clr r20
 4822 09ea 8081      		ld r24,Z
 4823 09ec 482B      		or r20,r24
 4824               	.LVL489:
 761:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4825               		.loc 3 761 0
 4826 09ee 4F3F      		cpi r20,-1
 4827 09f0 FFEF      		ldi r31,-1
 4828 09f2 5F07      		cpc r21,r31
 4829 09f4 01F0      		breq .L204
 762:main.c        **** 				}
 4830               		.loc 3 762 0
 4831 09f6 21E0      		ldi r18,lo8(1)
 4832 09f8 C201      		movw r24,r4
 4833 09fa B101      		movw r22,r2
 4834 09fc 00D0      		rcall gba_flash_write_byte
 4835               	.LVL490:
 4836               	.L204:
 764:main.c        **** 			}
 4837               		.loc 3 764 0 discriminator 2
 4838 09fe 2FEF      		ldi r18,-1
 4839 0a00 221A      		sub r2,r18
 4840 0a02 320A      		sbc r3,r18
 4841 0a04 420A      		sbc r4,r18
 4842 0a06 520A      		sbc r5,r18
 4843               	.LVL491:
 4844 0a08 82E0      		ldi r24,2
 4845 0a0a A80E      		add r10,r24
 4846 0a0c B11C      		adc r11,__zero_reg__
 4847               	.LVL492:
 4848               	.LBE310:
 759:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4849               		.loc 3 759 0 discriminator 2
 4850 0a0e C501      		movw r24,r10
 4851 0a10 8050      		subi r24,lo8(receivedBuffer)
 4852 0a12 9040      		sbci r25,hi8(receivedBuffer)
 4853 0a14 8017      		cp r24,r16
 4854 0a16 9107      		cpc r25,r17
 4855 0a18 04F0      		brlt .L205
 4856 0a1a 9FEF      		ldi r25,-1
 4857 0a1c C91A      		sub r12,r25
 4858 0a1e D90A      		sbc r13,r25
 4859 0a20 E90A      		sbc r14,r25
 4860 0a22 F90A      		sbc r15,r25
 4861 0a24 0150      		subi r16,1
 4862 0a26 1109      		sbc r17,__zero_reg__
 4863               	.LVL493:
 4864 0a28 1695      		lsr r17
 4865 0a2a 0795      		ror r16
 4866               	.LVL494:
 4867 0a2c C00E      		add r12,r16
 4868 0a2e D11E      		adc r13,r17
 4869 0a30 E11C      		adc r14,__zero_reg__
 4870 0a32 F11C      		adc r15,__zero_reg__
 4871 0a34 00C0      		rjmp .L350
 4872               	.LVL495:
 4873               	.L202:
 4874               	.LBE309:
 4875               	.LBE308:
 771:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4876               		.loc 3 771 0
 4877 0a36 8636      		cpi r24,lo8(102)
 4878 0a38 01F4      		brne .L206
 4879               	.LBB311:
 772:main.c        **** 			
 4880               		.loc 3 772 0
 4881 0a3a 939A      		sbi 0x12,3
 4882               	.LVL496:
 775:main.c        **** 			start_timeout_timer();
 4883               		.loc 3 775 0
 4884 0a3c 80E0      		ldi r24,0
 4885 0a3e 91E0      		ldi r25,lo8(1)
 4886 0a40 00D0      		rcall usart_read_bytes
 4887               	.LVL497:
 776:main.c        **** 			
 4888               		.loc 3 776 0
 4889 0a42 00D0      		rcall start_timeout_timer
 4890               	.LVL498:
 4891 0a44 00E0      		ldi r16,lo8(receivedBuffer)
 4892 0a46 10E0      		ldi r17,hi8(receivedBuffer)
 4893 0a48 4601      		movw r8,r12
 4894 0a4a 5701      		movw r10,r14
 4895               	.LVL499:
 4896               	.L208:
 4897               	.LBB312:
 4898               	.LBB313:
 779:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4899               		.loc 3 779 0
 4900 0a4c F801      		movw r30,r16
 4901 0a4e 4181      		ldd r20,Z+1
 4902 0a50 50E0      		ldi r21,0
 4903 0a52 542F      		mov r21,r20
 4904 0a54 4427      		clr r20
 4905 0a56 8081      		ld r24,Z
 4906 0a58 482B      		or r20,r24
 4907               	.LVL500:
 780:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4908               		.loc 3 780 0
 4909 0a5a 4F3F      		cpi r20,-1
 4910 0a5c FFEF      		ldi r31,-1
 4911 0a5e 5F07      		cpc r21,r31
 4912 0a60 01F0      		breq .L207
 781:main.c        **** 				}
 4913               		.loc 3 781 0
 4914 0a62 20E0      		ldi r18,0
 4915 0a64 C501      		movw r24,r10
 4916 0a66 B401      		movw r22,r8
 4917 0a68 00D0      		rcall gba_flash_write_byte
 4918               	.LVL501:
 4919               	.L207:
 783:main.c        **** 			}
 4920               		.loc 3 783 0 discriminator 2
 4921 0a6a 2FEF      		ldi r18,-1
 4922 0a6c 821A      		sub r8,r18
 4923 0a6e 920A      		sbc r9,r18
 4924 0a70 A20A      		sbc r10,r18
 4925 0a72 B20A      		sbc r11,r18
 4926               	.LVL502:
 4927 0a74 0E5F      		subi r16,-2
 4928 0a76 1F4F      		sbci r17,-1
 4929               	.LVL503:
 4930               	.LBE313:
 778:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4931               		.loc 3 778 0 discriminator 2
 4932 0a78 80E0      		ldi r24,lo8(receivedBuffer+256)
 4933 0a7a 90E0      		ldi r25,hi8(receivedBuffer+256)
 4934 0a7c 8017      		cp r24,r16
 4935 0a7e 9107      		cpc r25,r17
 4936 0a80 01F4      		brne .L208
 4937 0a82 90E8      		ldi r25,-128
 4938 0a84 C90E      		add r12,r25
 4939 0a86 D11C      		adc r13,__zero_reg__
 4940 0a88 E11C      		adc r14,__zero_reg__
 4941 0a8a F11C      		adc r15,__zero_reg__
 4942 0a8c 00C0      		rjmp .L350
 4943               	.LVL504:
 4944               	.L206:
 4945               	.LBE312:
 4946               	.LBE311:
 790:main.c        **** 			usart_read_bytes(256);
 4947               		.loc 3 790 0
 4948 0a8e 8336      		cpi r24,lo8(99)
 4949 0a90 01F0      		breq .+2
 4950 0a92 00C0      		rjmp .L209
 4951               	.LBB314:
 791:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4952               		.loc 3 791 0
 4953 0a94 80E0      		ldi r24,0
 4954 0a96 91E0      		ldi r25,lo8(1)
 4955 0a98 00D0      		rcall usart_read_bytes
 4956               	.LVL505:
 792:main.c        **** 			
 4957               		.loc 3 792 0
 4958 0a9a 939A      		sbi 0x12,3
 4959               	.LVL506:
 4960 0a9c 00E0      		ldi r16,lo8(receivedBuffer)
 4961 0a9e 10E0      		ldi r17,hi8(receivedBuffer)
 4962               	.LVL507:
 4963               	.L217:
 4964               	.LBB315:
 4965               	.LBB316:
 797:main.c        **** 				
 4966               		.loc 3 797 0
 4967 0aa0 00D0      		rcall start_timeout_timer
 4968               	.LVL508:
 800:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4969               		.loc 3 800 0
 4970 0aa2 74BA      		out 0x14,r7
 801:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4971               		.loc 3 801 0
 4972 0aa4 7ABA      		out 0x1a,r7
 802:main.c        **** 				
 4973               		.loc 3 802 0
 4974 0aa6 77BA      		out 0x17,r7
 4975               	.LVL509:
 4976 0aa8 FE01      		movw r30,r28
 4977 0aaa 3196      		adiw r30,1
 4978 0aac 5F01      		movw r10,r30
 4979 0aae D801      		movw r26,r16
 4980               	.LVL510:
 4981               	.L210:
 4982               	.LBB317:
 807:main.c        **** 					byteCounter++;
 4983               		.loc 3 807 0 discriminator 3
 4984 0ab0 8D91      		ld r24,X+
 4985               	.LVL511:
 4986 0ab2 8193      		st Z+,r24
 4987               	.LVL512:
 806:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 4988               		.loc 3 806 0 discriminator 3
 4989 0ab4 89A1      		ldd r24,Y+33
 4990 0ab6 9AA1      		ldd r25,Y+34
 4991 0ab8 E817      		cp r30,r24
 4992 0aba F907      		cpc r31,r25
 4993 0abc 01F4      		brne .L210
 4994               	.LBE317:
 811:main.c        **** 				gba_flash_write_bus_cycle(0x2AA, 0x55);
 4995               		.loc 3 811 0
 4996 0abe 4AEA      		ldi r20,lo8(-86)
 4997 0ac0 50E0      		ldi r21,0
 4998 0ac2 65E5      		ldi r22,lo8(85)
 4999 0ac4 75E0      		ldi r23,lo8(5)
 5000 0ac6 80E0      		ldi r24,0
 5001 0ac8 90E0      		ldi r25,0
 5002 0aca 00D0      		rcall gba_flash_write_bus_cycle
 5003               	.LVL513:
 812:main.c        **** 				gba_flash_write_bus_cycle(address, 0x25);
 5004               		.loc 3 812 0
 5005 0acc 45E5      		ldi r20,lo8(85)
 5006 0ace 50E0      		ldi r21,0
 5007 0ad0 6AEA      		ldi r22,lo8(-86)
 5008 0ad2 72E0      		ldi r23,lo8(2)
 5009 0ad4 80E0      		ldi r24,0
 5010 0ad6 90E0      		ldi r25,0
 5011 0ad8 00D0      		rcall gba_flash_write_bus_cycle
 5012               	.LVL514:
 813:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // Length
 5013               		.loc 3 813 0
 5014 0ada 45E2      		ldi r20,lo8(37)
 5015 0adc 50E0      		ldi r21,0
 5016 0ade C701      		movw r24,r14
 5017 0ae0 B601      		movw r22,r12
 5018 0ae2 00D0      		rcall gba_flash_write_bus_cycle
 5019               	.LVL515:
 814:main.c        **** 				_delay_us(1);
 5020               		.loc 3 814 0
 5021 0ae4 4FE0      		ldi r20,lo8(15)
 5022 0ae6 50E0      		ldi r21,0
 5023 0ae8 C701      		movw r24,r14
 5024 0aea B601      		movw r22,r12
 5025 0aec 00D0      		rcall gba_flash_write_bus_cycle
 5026               	.LVL516:
 5027               	.LBB318:
 5028               	.LBB319:
 5029               		.loc 2 276 0
 5030 0aee 92E0      		ldi r25,lo8(2)
 5031 0af0 9A95      	1:	dec r25
 5032 0af2 01F4      		brne 1b
 5033 0af4 00C0      		rjmp .
 5034               	.LVL517:
 5035               	.LBE319:
 5036               	.LBE318:
 818:main.c        **** 				GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 5037               		.loc 3 818 0
 5038 0af6 C701      		movw r24,r14
 5039 0af8 AA27      		clr r26
 5040 0afa BB27      		clr r27
 5041 0afc 85BB      		out 0x15,r24
 819:main.c        **** 				GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 5042               		.loc 3 819 0
 5043 0afe BB27      		clr r27
 5044 0b00 AF2D      		mov r26,r15
 5045 0b02 9E2D      		mov r25,r14
 5046 0b04 8D2D      		mov r24,r13
 5047 0b06 8BBB      		out 0x1b,r24
 820:main.c        **** 				cs_mreqPin_low;
 5048               		.loc 3 820 0
 5049 0b08 C8BA      		out 0x18,r12
 821:main.c        **** 				
 5050               		.loc 3 821 0
 5051 0b0a 9498      		cbi 0x12,4
 5052               	.LVL518:
 5053               	.L211:
 5054               	.LBB320:
 825:main.c        **** 					GBA_PORT_ROM_DATA7_0 = localBuffer[x];
 5055               		.loc 3 825 0 discriminator 3
 5056 0b0c F501      		movw r30,r10
 5057 0b0e 8181      		ldd r24,Z+1
 5058 0b10 8BBB      		out 0x1b,r24
 826:main.c        **** 					
 5059               		.loc 3 826 0 discriminator 3
 5060 0b12 8081      		ld r24,Z
 5061 0b14 88BB      		out 0x18,r24
 828:main.c        **** 					asm volatile("nop");
 5062               		.loc 3 828 0 discriminator 3
 5063 0b16 9698      		cbi 0x12,6
 829:main.c        **** 					asm volatile("nop");
 5064               		.loc 3 829 0 discriminator 3
 5065               	/* #APP */
 5066               	 ;  829 "main.c" 1
 5067 0b18 0000      		nop
 5068               	 ;  0 "" 2
 830:main.c        **** 					asm volatile("nop");
 5069               		.loc 3 830 0 discriminator 3
 5070               	 ;  830 "main.c" 1
 5071 0b1a 0000      		nop
 5072               	 ;  0 "" 2
 831:main.c        **** 					wrPin_high;
 5073               		.loc 3 831 0 discriminator 3
 5074               	 ;  831 "main.c" 1
 5075 0b1c 0000      		nop
 5076               	 ;  0 "" 2
 832:main.c        **** 					
 5077               		.loc 3 832 0 discriminator 3
 5078               	/* #NOAPP */
 5079 0b1e 969A      		sbi 0x12,6
 835:main.c        **** 					asm volatile("nop");
 5080               		.loc 3 835 0 discriminator 3
 5081 0b20 9598      		cbi 0x12,5
 836:main.c        **** 					rdPin_high;
 5082               		.loc 3 836 0 discriminator 3
 5083               	/* #APP */
 5084               	 ;  836 "main.c" 1
 5085 0b22 0000      		nop
 5086               	 ;  0 "" 2
 837:main.c        **** 					address++;
 5087               		.loc 3 837 0 discriminator 3
 5088               	/* #NOAPP */
 5089 0b24 959A      		sbi 0x12,5
 5090 0b26 F2E0      		ldi r31,2
 5091 0b28 AF0E      		add r10,r31
 5092 0b2a B11C      		adc r11,__zero_reg__
 824:main.c        **** 					GBA_PORT_ROM_DATA15_8 = localBuffer[x+1];
 5093               		.loc 3 824 0 discriminator 3
 5094 0b2c 89A1      		ldd r24,Y+33
 5095 0b2e 9AA1      		ldd r25,Y+34
 5096 0b30 A816      		cp r10,r24
 5097 0b32 B906      		cpc r11,r25
 5098 0b34 01F4      		brne .L211
 5099 0b36 4601      		movw r8,r12
 5100 0b38 5701      		movw r10,r14
 5101 0b3a 90E1      		ldi r25,16
 5102 0b3c 890E      		add r8,r25
 5103 0b3e 911C      		adc r9,__zero_reg__
 5104 0b40 A11C      		adc r10,__zero_reg__
 5105 0b42 B11C      		adc r11,__zero_reg__
 5106 0b44 1601      		movw r2,r12
 5107 0b46 2701      		movw r4,r14
 5108 0b48 EFE0      		ldi r30,15
 5109 0b4a 2E0E      		add r2,r30
 5110 0b4c 311C      		adc r3,__zero_reg__
 5111 0b4e 411C      		adc r4,__zero_reg__
 5112 0b50 511C      		adc r5,__zero_reg__
 5113               	.LBE320:
 840:main.c        **** 				
 5114               		.loc 3 840 0
 5115 0b52 949A      		sbi 0x12,4
 843:main.c        **** 				_delay_us(200);
 5116               		.loc 3 843 0
 5117 0b54 C701      		movw r24,r14
 5118 0b56 B601      		movw r22,r12
 5119 0b58 6F5F      		subi r22,-1
 5120 0b5a 7F4F      		sbci r23,-1
 5121 0b5c 8F4F      		sbci r24,-1
 5122 0b5e 9F4F      		sbci r25,-1
 5123 0b60 49E2      		ldi r20,lo8(41)
 5124 0b62 50E0      		ldi r21,0
 5125 0b64 00D0      		rcall gba_flash_write_bus_cycle
 5126               	.LVL519:
 5127               	.LBB321:
 5128               	.LBB322:
 5129               		.loc 2 276 0
 5130 0b66 8FE8      		ldi r24,lo8(399)
 5131 0b68 91E0      		ldi r25,hi8(399)
 5132 0b6a 0197      	1:	sbiw r24,1
 5133 0b6c 01F4      		brne 1b
 5134 0b6e 00C0      		rjmp .
 5135 0b70 0000      		nop
 5136               	.LVL520:
 5137               	.LBE322:
 5138               	.LBE321:
 847:main.c        **** 				uint16_t dataVerify = gba_read_16bit_data(address-1);
 5139               		.loc 3 847 0
 5140 0b72 EF8C      		ldd r14,Y+31
 5141 0b74 F8A0      		ldd r15,Y+32
 5142               	.LVL521:
 848:main.c        **** 				while (dataVerify != combinedBytes) {
 5143               		.loc 3 848 0
 5144 0b76 C201      		movw r24,r4
 5145 0b78 B101      		movw r22,r2
 5146 0b7a 00D0      		rcall gba_read_16bit_data
 5147               	.LVL522:
 5148               	.L212:
 849:main.c        **** 					dataVerify = gba_read_16bit_data(address-1);
 5149               		.loc 3 849 0
 5150 0b7c 8E15      		cp r24,r14
 5151 0b7e 9F05      		cpc r25,r15
 5152 0b80 01F0      		breq .L216
 850:main.c        **** 					_delay_us(1);
 5153               		.loc 3 850 0
 5154 0b82 C201      		movw r24,r4
 5155 0b84 B101      		movw r22,r2
 5156 0b86 00D0      		rcall gba_read_16bit_data
 5157               	.LVL523:
 5158               	.LBB323:
 5159               	.LBB324:
 5160               		.loc 2 276 0
 5161 0b88 E2E0      		ldi r30,lo8(2)
 5162 0b8a EA95      	1:	dec r30
 5163 0b8c 01F4      		brne 1b
 5164 0b8e 00C0      		rjmp .
 5165               	.LVL524:
 5166               	.LBE324:
 5167               	.LBE323:
 852:main.c        **** 						break;
 5168               		.loc 3 852 0
 5169 0b90 2091 0000 		lds r18,writingTimedout
 5170 0b94 2130      		cpi r18,lo8(1)
 5171 0b96 01F4      		brne .L212
 5172               	.L216:
 856:main.c        **** 					break;
 5173               		.loc 3 856 0
 5174 0b98 8091 0000 		lds r24,writingTimedout
 5175               	.LVL525:
 5176 0b9c 8130      		cpi r24,lo8(1)
 5177 0b9e 01F0      		breq .L218
 5178               	.LVL526:
 5179 0ba0 005E      		subi r16,-32
 5180 0ba2 1F4F      		sbci r17,-1
 5181               	.LVL527:
 5182               	.LBE316:
 796:main.c        **** 				start_timeout_timer();
 5183               		.loc 3 796 0
 5184 0ba4 80E0      		ldi r24,lo8(receivedBuffer+256)
 5185 0ba6 90E0      		ldi r25,hi8(receivedBuffer+256)
 5186 0ba8 8017      		cp r24,r16
 5187 0baa 9107      		cpc r25,r17
 5188 0bac 01F0      		breq .L218
 5189 0bae 7501      		movw r14,r10
 5190 0bb0 6401      		movw r12,r8
 5191 0bb2 00C0      		rjmp .L217
 5192               	.LVL528:
 5193               	.L218:
 5194               	.LBE315:
 860:main.c        **** 		}
 5195               		.loc 3 860 0
 5196 0bb4 00D0      		rcall check_if_timed_out
 5197               	.LVL529:
 5198               	.LBE314:
 5199 0bb6 7501      		movw r14,r10
 5200 0bb8 6401      		movw r12,r8
 5201 0bba 00C0      		rjmp .L106
 5202               	.LVL530:
 5203               	.L209:
 865:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5204               		.loc 3 865 0
 5205 0bbc 8C36      		cpi r24,lo8(108)
 5206 0bbe 01F0      		breq .+2
 5207 0bc0 00C0      		rjmp .L219
 5208               	.LBB325:
 866:main.c        **** 			usart_read_bytes(64);
 5209               		.loc 3 866 0
 5210 0bc2 939A      		sbi 0x12,3
 867:main.c        **** 			start_timeout_timer();
 5211               		.loc 3 867 0
 5212 0bc4 80E4      		ldi r24,lo8(64)
 5213 0bc6 90E0      		ldi r25,0
 5214 0bc8 00D0      		rcall usart_read_bytes
 5215               	.LVL531:
 868:main.c        **** 			
 5216               		.loc 3 868 0
 5217 0bca 00D0      		rcall start_timeout_timer
 5218               	.LVL532:
 871:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5219               		.loc 3 871 0
 5220 0bcc 74BA      		out 0x14,r7
 872:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5221               		.loc 3 872 0
 5222 0bce 7ABA      		out 0x1a,r7
 873:main.c        **** 			
 5223               		.loc 3 873 0
 5224 0bd0 77BA      		out 0x17,r7
 876:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 5225               		.loc 3 876 0
 5226 0bd2 40E6      		ldi r20,lo8(96)
 5227 0bd4 50E0      		ldi r21,0
 5228 0bd6 C701      		movw r24,r14
 5229 0bd8 B601      		movw r22,r12
 5230 0bda 00D0      		rcall gba_flash_write_bus_cycle
 5231               	.LVL533:
 877:main.c        **** 			
 5232               		.loc 3 877 0
 5233 0bdc 40ED      		ldi r20,lo8(-48)
 5234 0bde 50E0      		ldi r21,0
 5235 0be0 C701      		movw r24,r14
 5236 0be2 B601      		movw r22,r12
 5237 0be4 00D0      		rcall gba_flash_write_bus_cycle
 5238               	.LVL534:
 880:main.c        **** 			_delay_us(50);
 5239               		.loc 3 880 0
 5240 0be6 48EE      		ldi r20,lo8(-24)
 5241 0be8 50E0      		ldi r21,0
 5242 0bea C701      		movw r24,r14
 5243 0bec B601      		movw r22,r12
 5244 0bee 00D0      		rcall gba_flash_write_bus_cycle
 5245               	.LVL535:
 5246               	.LBB326:
 5247               	.LBB327:
 5248               		.loc 2 276 0
 5249 0bf0 95E8      		ldi r25,lo8(-123)
 5250 0bf2 9A95      	1:	dec r25
 5251 0bf4 01F4      		brne 1b
 5252 0bf6 0000      		nop
 5253               	.LVL536:
 5254               	.LBE327:
 5255               	.LBE326:
 884:main.c        **** 			while (dataVerify != 0x0080) {
 5256               		.loc 3 884 0
 5257 0bf8 C701      		movw r24,r14
 5258 0bfa B601      		movw r22,r12
 5259 0bfc 00D0      		rcall gba_read_16bit_data
 5260               	.LVL537:
 5261               	.L220:
 885:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 5262               		.loc 3 885 0
 5263 0bfe 8038      		cpi r24,-128
 5264 0c00 9105      		cpc r25,__zero_reg__
 5265 0c02 01F0      		breq .L223
 886:main.c        **** 				_delay_us(50);
 5266               		.loc 3 886 0
 5267 0c04 C701      		movw r24,r14
 5268 0c06 B601      		movw r22,r12
 5269 0c08 00D0      		rcall gba_read_16bit_data
 5270               	.LVL538:
 5271               	.LBB328:
 5272               	.LBB329:
 5273               		.loc 2 276 0
 5274 0c0a E5E8      		ldi r30,lo8(-123)
 5275 0c0c EA95      	1:	dec r30
 5276 0c0e 01F4      		brne 1b
 5277 0c10 0000      		nop
 5278               	.LVL539:
 5279               	.LBE329:
 5280               	.LBE328:
 888:main.c        **** 					break;
 5281               		.loc 3 888 0
 5282 0c12 2091 0000 		lds r18,writingTimedout
 5283 0c16 2130      		cpi r18,lo8(1)
 5284 0c18 01F4      		brne .L220
 5285               	.L223:
 895:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5286               		.loc 3 895 0
 5287 0c1a 74BA      		out 0x14,r7
 896:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5288               		.loc 3 896 0
 5289 0c1c 7ABA      		out 0x1a,r7
 897:main.c        **** 			
 5290               		.loc 3 897 0
 5291 0c1e 77BA      		out 0x17,r7
 900:main.c        **** 			
 5292               		.loc 3 900 0
 5293 0c20 4FE1      		ldi r20,lo8(31)
 5294 0c22 50E0      		ldi r21,0
 5295 0c24 C701      		movw r24,r14
 5296 0c26 B601      		movw r22,r12
 5297 0c28 00D0      		rcall gba_flash_write_bus_cycle
 5298               	.LVL540:
 5299 0c2a 00E0      		ldi r16,lo8(receivedBuffer)
 5300 0c2c 10E0      		ldi r17,hi8(receivedBuffer)
 5301 0c2e 4601      		movw r8,r12
 5302 0c30 5701      		movw r10,r14
 5303               	.LVL541:
 5304               	.L221:
 5305               	.LBB330:
 5306               	.LBB331:
 905:main.c        **** 				address++;
 5307               		.loc 3 905 0 discriminator 3
 5308 0c32 F801      		movw r30,r16
 5309 0c34 4181      		ldd r20,Z+1
 5310 0c36 50E0      		ldi r21,0
 5311 0c38 542F      		mov r21,r20
 5312 0c3a 4427      		clr r20
 5313 0c3c 8081      		ld r24,Z
 5314 0c3e 482B      		or r20,r24
 5315 0c40 C501      		movw r24,r10
 5316 0c42 B401      		movw r22,r8
 5317 0c44 00D0      		rcall gba_flash_write_bus_cycle
 5318               	.LVL542:
 906:main.c        **** 			}
 5319               		.loc 3 906 0 discriminator 3
 5320 0c46 FFEF      		ldi r31,-1
 5321 0c48 8F1A      		sub r8,r31
 5322 0c4a 9F0A      		sbc r9,r31
 5323 0c4c AF0A      		sbc r10,r31
 5324 0c4e BF0A      		sbc r11,r31
 5325               	.LVL543:
 5326 0c50 0E5F      		subi r16,-2
 5327 0c52 1F4F      		sbci r17,-1
 5328               	.LVL544:
 5329               	.LBE331:
 903:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5330               		.loc 3 903 0 discriminator 3
 5331 0c54 80E0      		ldi r24,lo8(receivedBuffer+64)
 5332 0c56 90E0      		ldi r25,hi8(receivedBuffer+64)
 5333 0c58 8017      		cp r24,r16
 5334 0c5a 9107      		cpc r25,r17
 5335 0c5c 01F4      		brne .L221
 5336 0c5e 90E2      		ldi r25,32
 5337 0c60 C90E      		add r12,r25
 5338 0c62 D11C      		adc r13,__zero_reg__
 5339 0c64 E11C      		adc r14,__zero_reg__
 5340 0c66 F11C      		adc r15,__zero_reg__
 5341               	.LBE330:
 910:main.c        **** 			_delay_us(440);
 5342               		.loc 3 910 0
 5343 0c68 40ED      		ldi r20,lo8(-48)
 5344 0c6a 50E0      		ldi r21,0
 5345 0c6c C701      		movw r24,r14
 5346 0c6e B601      		movw r22,r12
 5347 0c70 00D0      		rcall gba_flash_write_bus_cycle
 5348               	.LVL545:
 5349               	.LBB332:
 5350               	.LBB333:
 5351               		.loc 2 276 0
 5352 0c72 EFE6      		ldi r30,lo8(879)
 5353 0c74 F3E0      		ldi r31,hi8(879)
 5354 0c76 3197      	1:	sbiw r30,1
 5355 0c78 01F4      		brne 1b
 5356 0c7a 00C0      		rjmp .
 5357 0c7c 0000      		nop
 5358               	.LVL546:
 5359               	.LBE333:
 5360               	.LBE332:
 914:main.c        **** 			while (dataVerify != 0x0080) {
 5361               		.loc 3 914 0
 5362 0c7e C701      		movw r24,r14
 5363 0c80 B601      		movw r22,r12
 5364 0c82 00D0      		rcall gba_read_16bit_data
 5365               	.LVL547:
 5366               	.L224:
 915:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 5367               		.loc 3 915 0
 5368 0c84 8038      		cpi r24,-128
 5369 0c86 9105      		cpc r25,__zero_reg__
 5370 0c88 01F0      		breq .L226
 916:main.c        **** 				_delay_us(50);
 5371               		.loc 3 916 0
 5372 0c8a C701      		movw r24,r14
 5373 0c8c B601      		movw r22,r12
 5374 0c8e 00D0      		rcall gba_read_16bit_data
 5375               	.LVL548:
 5376               	.LBB334:
 5377               	.LBB335:
 5378               		.loc 2 276 0
 5379 0c90 F5E8      		ldi r31,lo8(-123)
 5380 0c92 FA95      	1:	dec r31
 5381 0c94 01F4      		brne 1b
 5382 0c96 0000      		nop
 5383               	.LVL549:
 5384               	.LBE335:
 5385               	.LBE334:
 918:main.c        **** 					break;
 5386               		.loc 3 918 0
 5387 0c98 2091 0000 		lds r18,writingTimedout
 5388 0c9c 2130      		cpi r18,lo8(1)
 5389 0c9e 01F4      		brne .L224
 5390               	.L226:
 925:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5391               		.loc 3 925 0
 5392 0ca0 74BA      		out 0x14,r7
 926:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5393               		.loc 3 926 0
 5394 0ca2 7ABA      		out 0x1a,r7
 927:main.c        **** 			
 5395               		.loc 3 927 0
 5396 0ca4 77BA      		out 0x17,r7
 930:main.c        **** 			
 5397               		.loc 3 930 0
 5398 0ca6 4FEF      		ldi r20,lo8(-1)
 5399 0ca8 50E0      		ldi r21,0
 5400 0caa C701      		movw r24,r14
 5401 0cac B601      		movw r22,r12
 5402 0cae 00D0      		rcall gba_flash_write_bus_cycle
 5403               	.LVL550:
 5404 0cb0 00C0      		rjmp .L350
 5405               	.LVL551:
 5406               	.L219:
 5407               	.LBE325:
 936:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5408               		.loc 3 936 0
 5409 0cb2 8537      		cpi r24,lo8(117)
 5410 0cb4 01F0      		breq .+2
 5411 0cb6 00C0      		rjmp .L227
 937:main.c        **** 			usart_read_bytes(64);
 5412               		.loc 3 937 0
 5413 0cb8 939A      		sbi 0x12,3
 938:main.c        **** 			start_timeout_timer();
 5414               		.loc 3 938 0
 5415 0cba 80E4      		ldi r24,lo8(64)
 5416 0cbc 90E0      		ldi r25,0
 5417 0cbe 00D0      		rcall usart_read_bytes
 5418               	.LVL552:
 939:main.c        **** 			
 5419               		.loc 3 939 0
 5420 0cc0 00D0      		rcall start_timeout_timer
 5421               	.LVL553:
 5422 0cc2 40E0      		ldi r20,lo8(receivedBuffer)
 5423 0cc4 A42E      		mov r10,r20
 5424 0cc6 40E0      		ldi r20,hi8(receivedBuffer)
 5425 0cc8 B42E      		mov r11,r20
 5426 0cca 1601      		movw r2,r12
 5427 0ccc 2701      		movw r4,r14
 5428               	.LVL554:
 5429               	.L229:
 5430               	.LBB336:
 5431               	.LBB337:
 944:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5432               		.loc 3 944 0
 5433 0cce 74BA      		out 0x14,r7
 945:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5434               		.loc 3 945 0
 5435 0cd0 7ABA      		out 0x1a,r7
 946:main.c        **** 				
 5436               		.loc 3 946 0
 5437 0cd2 77BA      		out 0x17,r7
 948:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 5438               		.loc 3 948 0
 5439 0cd4 F501      		movw r30,r10
 5440 0cd6 0181      		ldd r16,Z+1
 5441 0cd8 10E0      		ldi r17,0
 5442 0cda 102F      		mov r17,r16
 5443 0cdc 0027      		clr r16
 5444 0cde 8081      		ld r24,Z
 5445 0ce0 082B      		or r16,r24
 5446               	.LVL555:
 949:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5447               		.loc 3 949 0
 5448 0ce2 40E4      		ldi r20,lo8(64)
 5449 0ce4 50E0      		ldi r21,0
 5450 0ce6 C201      		movw r24,r4
 5451 0ce8 B101      		movw r22,r2
 5452 0cea 00D0      		rcall gba_flash_write_bus_cycle
 5453               	.LVL556:
 950:main.c        **** 				
 5454               		.loc 3 950 0
 5455 0cec A801      		movw r20,r16
 5456 0cee C201      		movw r24,r4
 5457 0cf0 B101      		movw r22,r2
 5458 0cf2 00D0      		rcall gba_flash_write_bus_cycle
 5459               	.LVL557:
 953:main.c        **** 				while ((status & 0x80) == 0) {
 5460               		.loc 3 953 0
 5461 0cf4 C201      		movw r24,r4
 5462 0cf6 B101      		movw r22,r2
 5463 0cf8 00D0      		rcall gba_read_16bit_data
 5464               	.LVL558:
 5465               	.L228:
 954:main.c        **** 					status = gba_read_16bit_data(address);
 5466               		.loc 3 954 0
 5467 0cfa 87FD      		sbrc r24,7
 5468 0cfc 00C0      		rjmp .L232
 955:main.c        **** 					_delay_us(2);
 5469               		.loc 3 955 0
 5470 0cfe C201      		movw r24,r4
 5471 0d00 B101      		movw r22,r2
 5472 0d02 00D0      		rcall gba_read_16bit_data
 5473               	.LVL559:
 5474               	.LBB338:
 5475               	.LBB339:
 5476               		.loc 2 276 0
 5477 0d04 F5E0      		ldi r31,lo8(5)
 5478 0d06 FA95      	1:	dec r31
 5479 0d08 01F4      		brne 1b
 5480 0d0a 0000      		nop
 5481               	.LVL560:
 5482               	.LBE339:
 5483               	.LBE338:
 957:main.c        **** 						break;
 5484               		.loc 3 957 0
 5485 0d0c 9091 0000 		lds r25,writingTimedout
 5486 0d10 9130      		cpi r25,lo8(1)
 5487 0d12 01F4      		brne .L228
 5488               	.L232:
 961:main.c        **** 			}
 5489               		.loc 3 961 0
 5490 0d14 2FEF      		ldi r18,-1
 5491 0d16 221A      		sub r2,r18
 5492 0d18 320A      		sbc r3,r18
 5493 0d1a 420A      		sbc r4,r18
 5494 0d1c 520A      		sbc r5,r18
 5495               	.LVL561:
 5496 0d1e 82E0      		ldi r24,2
 5497 0d20 A80E      		add r10,r24
 5498 0d22 B11C      		adc r11,__zero_reg__
 5499               	.LVL562:
 5500               	.LBE337:
 942:main.c        **** 				// Set address lines as outputs
 5501               		.loc 3 942 0
 5502 0d24 90E0      		ldi r25,lo8(receivedBuffer+64)
 5503 0d26 A916      		cp r10,r25
 5504 0d28 90E0      		ldi r25,hi8(receivedBuffer+64)
 5505 0d2a B906      		cpc r11,r25
 5506 0d2c 01F4      		brne .L229
 5507 0d2e E0E2      		ldi r30,32
 5508 0d30 CE0E      		add r12,r30
 5509 0d32 D11C      		adc r13,__zero_reg__
 5510 0d34 E11C      		adc r14,__zero_reg__
 5511 0d36 F11C      		adc r15,__zero_reg__
 5512 0d38 00C0      		rjmp .L350
 5513               	.LVL563:
 5514               	.L227:
 5515               	.LBE336:
 970:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5516               		.loc 3 970 0
 5517 0d3a 8637      		cpi r24,lo8(118)
 5518 0d3c 01F0      		breq .+2
 5519 0d3e 00C0      		rjmp .L233
 971:main.c        **** 			usart_read_bytes(256);
 5520               		.loc 3 971 0
 5521 0d40 939A      		sbi 0x12,3
 972:main.c        **** 			start_timeout_timer();
 5522               		.loc 3 972 0
 5523 0d42 80E0      		ldi r24,0
 5524 0d44 91E0      		ldi r25,lo8(1)
 5525 0d46 00D0      		rcall usart_read_bytes
 5526               	.LVL564:
 973:main.c        **** 			
 5527               		.loc 3 973 0
 5528 0d48 00D0      		rcall start_timeout_timer
 5529               	.LVL565:
 5530 0d4a 00E0      		ldi r16,lo8(receivedBuffer)
 5531 0d4c 10E0      		ldi r17,hi8(receivedBuffer)
 5532               	.LVL566:
 5533               	.L245:
 5534               	.LBB340:
 978:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5535               		.loc 3 978 0
 5536 0d4e 74BA      		out 0x14,r7
 979:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5537               		.loc 3 979 0
 5538 0d50 7ABA      		out 0x1a,r7
 980:main.c        **** 				
 5539               		.loc 3 980 0
 5540 0d52 77BA      		out 0x17,r7
 983:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 5541               		.loc 3 983 0
 5542 0d54 48EE      		ldi r20,lo8(-24)
 5543 0d56 50E0      		ldi r21,0
 5544 0d58 C701      		movw r24,r14
 5545 0d5a B601      		movw r22,r12
 5546 0d5c 00D0      		rcall gba_flash_write_bus_cycle
 5547               	.LVL567:
 984:main.c        **** 				
 5548               		.loc 3 984 0
 5549 0d5e 4601      		movw r8,r12
 5550 0d60 5701      		movw r10,r14
 5551 0d62 FFEF      		ldi r31,-1
 5552 0d64 8F1A      		sub r8,r31
 5553 0d66 9F0A      		sbc r9,r31
 5554 0d68 AF0A      		sbc r10,r31
 5555 0d6a BF0A      		sbc r11,r31
 5556 0d6c 48EE      		ldi r20,lo8(-24)
 5557 0d6e 50E0      		ldi r21,0
 5558 0d70 C501      		movw r24,r10
 5559 0d72 B401      		movw r22,r8
 5560 0d74 00D0      		rcall gba_flash_write_bus_cycle
 5561               	.LVL568:
 5562               	.L234:
 987:main.c        **** 					if (writingTimedout == 1) {
 5563               		.loc 3 987 0
 5564 0d76 C701      		movw r24,r14
 5565 0d78 B601      		movw r22,r12
 5566 0d7a 00D0      		rcall gba_read_16bit_data
 5567               	.LVL569:
 5568 0d7c 8038      		cpi r24,-128
 5569 0d7e 9105      		cpc r25,__zero_reg__
 5570 0d80 01F0      		breq .L325
 988:main.c        **** 						break;
 5571               		.loc 3 988 0
 5572 0d82 8091 0000 		lds r24,writingTimedout
 5573 0d86 8130      		cpi r24,lo8(1)
 5574 0d88 01F4      		brne .L234
 5575 0d8a 00C0      		rjmp .L325
 5576               	.L238:
 993:main.c        **** 						break;
 5577               		.loc 3 993 0
 5578 0d8c 8091 0000 		lds r24,writingTimedout
 5579 0d90 8130      		cpi r24,lo8(1)
 5580 0d92 01F0      		breq .L237
 5581               	.L325:
 992:main.c        **** 					if (writingTimedout == 1) {
 5582               		.loc 3 992 0
 5583 0d94 C501      		movw r24,r10
 5584 0d96 B401      		movw r22,r8
 5585 0d98 00D0      		rcall gba_read_16bit_data
 5586               	.LVL570:
 5587 0d9a 8038      		cpi r24,-128
 5588 0d9c 9105      		cpc r25,__zero_reg__
 5589 0d9e 01F4      		brne .L238
 5590               	.L237:
1001:main.c        **** 					start_timeout_timer();
 5591               		.loc 3 1001 0
 5592 0da0 8091 0000 		lds r24,writingTimedout
 5593 0da4 8111      		cpse r24,__zero_reg__
 5594 0da6 00C0      		rjmp .L259
 5595               	.LBB341:
1002:main.c        **** 					
 5596               		.loc 3 1002 0
 5597 0da8 00D0      		rcall start_timeout_timer
 5598               	.LVL571:
1005:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5599               		.loc 3 1005 0
 5600 0daa 74BA      		out 0x14,r7
1006:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5601               		.loc 3 1006 0
 5602 0dac 7ABA      		out 0x1a,r7
1007:main.c        **** 					
 5603               		.loc 3 1007 0
 5604 0dae 77BA      		out 0x17,r7
1010:main.c        **** 					gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
 5605               		.loc 3 1010 0
 5606 0db0 4FE0      		ldi r20,lo8(15)
 5607 0db2 50E0      		ldi r21,0
 5608 0db4 C701      		movw r24,r14
 5609 0db6 B601      		movw r22,r12
 5610 0db8 00D0      		rcall gba_flash_write_bus_cycle
 5611               	.LVL572:
1011:main.c        **** 					
 5612               		.loc 3 1011 0
 5613 0dba 4FE0      		ldi r20,lo8(15)
 5614 0dbc 50E0      		ldi r21,0
 5615 0dbe C501      		movw r24,r10
 5616 0dc0 B401      		movw r22,r8
 5617 0dc2 00D0      		rcall gba_flash_write_bus_cycle
 5618               	.LVL573:
 5619 0dc4 1CA3      		std Y+36,r17
 5620 0dc6 0BA3      		std Y+35,r16
 5621 0dc8 1601      		movw r2,r12
 5622 0dca 2701      		movw r4,r14
 5623               	.LBB342:
1015:main.c        **** 						combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 5624               		.loc 3 1015 0
 5625 0dcc 1FA2      		std Y+39,__zero_reg__
 5626 0dce 1EA2      		std Y+38,__zero_reg__
 5627               	.LVL574:
 5628               	.L240:
1017:main.c        **** 						address++;
 5629               		.loc 3 1017 0 discriminator 3
 5630 0dd0 EBA1      		ldd r30,Y+35
 5631 0dd2 FCA1      		ldd r31,Y+36
 5632 0dd4 4181      		ldd r20,Z+1
 5633 0dd6 50E0      		ldi r21,0
 5634 0dd8 542F      		mov r21,r20
 5635 0dda 4427      		clr r20
 5636 0ddc 8081      		ld r24,Z
 5637 0dde 482B      		or r20,r24
 5638 0de0 C201      		movw r24,r4
 5639 0de2 B101      		movw r22,r2
 5640 0de4 00D0      		rcall gba_flash_write_bus_cycle
 5641               	.LVL575:
1018:main.c        **** 					}
 5642               		.loc 3 1018 0 discriminator 3
 5643 0de6 FFEF      		ldi r31,-1
 5644 0de8 2F1A      		sub r2,r31
 5645 0dea 3F0A      		sbc r3,r31
 5646 0dec 4F0A      		sbc r4,r31
 5647 0dee 5F0A      		sbc r5,r31
 5648               	.LVL576:
1015:main.c        **** 						combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 5649               		.loc 3 1015 0 discriminator 3
 5650 0df0 8EA1      		ldd r24,Y+38
 5651 0df2 9FA1      		ldd r25,Y+39
 5652 0df4 0296      		adiw r24,2
 5653 0df6 9FA3      		std Y+39,r25
 5654 0df8 8EA3      		std Y+38,r24
 5655               	.LVL577:
 5656 0dfa EBA1      		ldd r30,Y+35
 5657 0dfc FCA1      		ldd r31,Y+36
 5658 0dfe 3296      		adiw r30,2
 5659 0e00 FCA3      		std Y+36,r31
 5660 0e02 EBA3      		std Y+35,r30
 5661 0e04 8034      		cpi r24,64
 5662 0e06 9105      		cpc r25,__zero_reg__
 5663 0e08 01F4      		brne .L240
 5664 0e0a 1601      		movw r2,r12
 5665 0e0c 2701      		movw r4,r14
 5666               	.LVL578:
 5667 0e0e F0E2      		ldi r31,32
 5668 0e10 2F0E      		add r2,r31
 5669 0e12 311C      		adc r3,__zero_reg__
 5670 0e14 411C      		adc r4,__zero_reg__
 5671 0e16 511C      		adc r5,__zero_reg__
 5672               	.LBE342:
1022:main.c        **** 					gba_flash_write_bus_cycle(address-32+1, 0xD0);
 5673               		.loc 3 1022 0
 5674 0e18 40ED      		ldi r20,lo8(-48)
 5675 0e1a 50E0      		ldi r21,0
 5676 0e1c C701      		movw r24,r14
 5677 0e1e B601      		movw r22,r12
 5678 0e20 00D0      		rcall gba_flash_write_bus_cycle
 5679               	.LVL579:
1023:main.c        **** 					
 5680               		.loc 3 1023 0
 5681 0e22 40ED      		ldi r20,lo8(-48)
 5682 0e24 50E0      		ldi r21,0
 5683 0e26 C501      		movw r24,r10
 5684 0e28 B401      		movw r22,r8
 5685 0e2a 00D0      		rcall gba_flash_write_bus_cycle
 5686               	.LVL580:
 5687               	.L241:
1026:main.c        **** 						if (writingTimedout == 1) {
 5688               		.loc 3 1026 0
 5689 0e2c C201      		movw r24,r4
 5690 0e2e B101      		movw r22,r2
 5691 0e30 00D0      		rcall gba_read_16bit_data
 5692               	.LVL581:
 5693 0e32 8038      		cpi r24,-128
 5694 0e34 9105      		cpc r25,__zero_reg__
 5695 0e36 01F0      		breq .L242
1027:main.c        **** 							break;
 5696               		.loc 3 1027 0
 5697 0e38 8091 0000 		lds r24,writingTimedout
 5698 0e3c 8130      		cpi r24,lo8(1)
 5699 0e3e 01F4      		brne .L241
 5700               	.L242:
1031:main.c        **** 						if (writingTimedout == 1) {
 5701               		.loc 3 1031 0
 5702 0e40 21E2      		ldi r18,33
 5703 0e42 C20E      		add r12,r18
 5704 0e44 D11C      		adc r13,__zero_reg__
 5705 0e46 E11C      		adc r14,__zero_reg__
 5706 0e48 F11C      		adc r15,__zero_reg__
 5707               	.L346:
 5708 0e4a C701      		movw r24,r14
 5709 0e4c B601      		movw r22,r12
 5710 0e4e 00D0      		rcall gba_read_16bit_data
 5711               	.LVL582:
 5712 0e50 8038      		cpi r24,-128
 5713 0e52 9105      		cpc r25,__zero_reg__
 5714 0e54 01F0      		breq .L239
1032:main.c        **** 							break;
 5715               		.loc 3 1032 0
 5716 0e56 8091 0000 		lds r24,writingTimedout
 5717 0e5a 8130      		cpi r24,lo8(1)
 5718 0e5c 01F4      		brne .L346
 5719 0e5e 00C0      		rjmp .L239
 5720               	.LVL583:
 5721               	.L259:
 5722 0e60 1601      		movw r2,r12
 5723 0e62 2701      		movw r4,r14
 5724               	.LVL584:
 5725               	.L239:
 5726 0e64 005C      		subi r16,-64
 5727 0e66 1F4F      		sbci r17,-1
 5728               	.LBE341:
 976:main.c        **** 				// Set address lines as outputs
 5729               		.loc 3 976 0 discriminator 2
 5730 0e68 80E0      		ldi r24,lo8(receivedBuffer+256)
 5731 0e6a 90E0      		ldi r25,hi8(receivedBuffer+256)
 5732 0e6c 8017      		cp r24,r16
 5733 0e6e 9107      		cpc r25,r17
 5734 0e70 01F0      		breq .L363
 5735 0e72 7201      		movw r14,r4
 5736 0e74 6101      		movw r12,r2
 5737 0e76 00C0      		rjmp .L245
 5738               	.L363:
 5739               	.LBE340:
1041:main.c        **** 		}
 5740               		.loc 3 1041 0
 5741 0e78 00D0      		rcall check_if_timed_out
 5742               	.LVL585:
 5743 0e7a 7201      		movw r14,r4
 5744 0e7c 6101      		movw r12,r2
 5745 0e7e 00C0      		rjmp .L106
 5746               	.LVL586:
 5747               	.L233:
1045:main.c        **** 			uint16_t status = 0;
 5748               		.loc 3 1045 0
 5749 0e80 8837      		cpi r24,lo8(120)
 5750 0e82 01F0      		breq .+2
 5751 0e84 00C0      		rjmp .L246
 5752               	.LVL587:
 5753               	.LBB343:
1048:main.c        **** 			usart_read_bytes(64);
 5754               		.loc 3 1048 0
 5755 0e86 939A      		sbi 0x12,3
1049:main.c        **** 			start_timeout_timer();
 5756               		.loc 3 1049 0
 5757 0e88 80E4      		ldi r24,lo8(64)
 5758 0e8a 90E0      		ldi r25,0
 5759 0e8c 00D0      		rcall usart_read_bytes
 5760               	.LVL588:
1050:main.c        **** 			
 5761               		.loc 3 1050 0
 5762 0e8e 00D0      		rcall start_timeout_timer
 5763               	.LVL589:
 5764 0e90 90E0      		ldi r25,lo8(receivedBuffer)
 5765 0e92 A92E      		mov r10,r25
 5766 0e94 90E0      		ldi r25,hi8(receivedBuffer)
 5767 0e96 B92E      		mov r11,r25
 5768 0e98 1601      		movw r2,r12
 5769 0e9a 2701      		movw r4,r14
1046:main.c        **** 			
 5770               		.loc 3 1046 0
 5771 0e9c 912C      		mov r9,__zero_reg__
 5772               	.LVL590:
 5773               	.L250:
 5774               	.LBB226:
 5775               	.LBB225:
 5776               		.loc 3 1057 0
 5777 0e9e 74BA      		out 0x14,r7
1058:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5778               		.loc 3 1058 0
 5779 0ea0 7ABA      		out 0x1a,r7
1059:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5780               		.loc 3 1059 0
 5781 0ea2 77BA      		out 0x17,r7
1055:main.c        **** 					// Set address lines as outputs
 5782               		.loc 3 1055 0
 5783 0ea4 97FC      		sbrc r9,7
 5784 0ea6 00C0      		rjmp .L364
1060:main.c        **** 					
1061:main.c        **** 					gba_flash_write_bus_cycle(address, 0x70); // Query status register
 5785               		.loc 3 1061 0
 5786 0ea8 40E7      		ldi r20,lo8(112)
 5787 0eaa 50E0      		ldi r21,0
 5788 0eac C201      		movw r24,r4
 5789 0eae B101      		movw r22,r2
 5790 0eb0 00D0      		rcall gba_flash_write_bus_cycle
 5791               	.LVL591:
1062:main.c        **** 					status = gba_read_16bit_data(address);
 5792               		.loc 3 1062 0
 5793 0eb2 C201      		movw r24,r4
 5794 0eb4 B101      		movw r22,r2
 5795 0eb6 00D0      		rcall gba_read_16bit_data
 5796               	.LVL592:
 5797 0eb8 982E      		mov r9,r24
 5798 0eba 00C0      		rjmp .L250
 5799               	.L364:
1063:main.c        **** 				}
1064:main.c        **** 				
1065:main.c        **** 				// Set address lines as outputs
1066:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
1067:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
1068:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
1069:main.c        **** 				
1070:main.c        **** 				// Write one word to flash
1071:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5800               		.loc 3 1071 0 discriminator 2
 5801 0ebc F501      		movw r30,r10
 5802 0ebe 0181      		ldd r16,Z+1
 5803 0ec0 10E0      		ldi r17,0
 5804 0ec2 102F      		mov r17,r16
 5805 0ec4 0027      		clr r16
 5806 0ec6 8081      		ld r24,Z
 5807 0ec8 082B      		or r16,r24
 5808               	.LVL593:
1072:main.c        **** 				gba_flash_write_bus_cycle(address, 0x10);
 5809               		.loc 3 1072 0 discriminator 2
 5810 0eca 40E1      		ldi r20,lo8(16)
 5811 0ecc 50E0      		ldi r21,0
 5812 0ece C201      		movw r24,r4
 5813 0ed0 B101      		movw r22,r2
 5814 0ed2 00D0      		rcall gba_flash_write_bus_cycle
 5815               	.LVL594:
1073:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5816               		.loc 3 1073 0 discriminator 2
 5817 0ed4 A801      		movw r20,r16
 5818 0ed6 C201      		movw r24,r4
 5819 0ed8 B101      		movw r22,r2
 5820 0eda 00D0      		rcall gba_flash_write_bus_cycle
 5821               	.LVL595:
 5822               	.LBB223:
 5823               	.LBB224:
 5824               		.loc 2 276 0 discriminator 2
 5825 0edc FAE6      		ldi r31,lo8(106)
 5826 0ede FA95      	1:	dec r31
 5827 0ee0 01F4      		brne 1b
 5828 0ee2 00C0      		rjmp .
 5829               	.LVL596:
 5830               	.LBE224:
 5831               	.LBE223:
1074:main.c        **** 				_delay_us(40);
1075:main.c        **** 				
1076:main.c        **** 				address++;
 5832               		.loc 3 1076 0 discriminator 2
 5833 0ee4 2FEF      		ldi r18,-1
 5834 0ee6 221A      		sub r2,r18
 5835 0ee8 320A      		sbc r3,r18
 5836 0eea 420A      		sbc r4,r18
 5837 0eec 520A      		sbc r5,r18
 5838               	.LVL597:
 5839 0eee 82E0      		ldi r24,2
 5840 0ef0 A80E      		add r10,r24
 5841 0ef2 B11C      		adc r11,__zero_reg__
 5842               	.LVL598:
 5843               	.LBE225:
1053:main.c        **** 				// Wait until ready
 5844               		.loc 3 1053 0 discriminator 2
 5845 0ef4 E0E0      		ldi r30,lo8(receivedBuffer+64)
 5846 0ef6 F0E0      		ldi r31,hi8(receivedBuffer+64)
 5847 0ef8 EA15      		cp r30,r10
 5848 0efa FB05      		cpc r31,r11
 5849 0efc 01F4      		brne .L250
 5850 0efe F0E2      		ldi r31,32
 5851 0f00 CF0E      		add r12,r31
 5852 0f02 D11C      		adc r13,__zero_reg__
 5853 0f04 E11C      		adc r14,__zero_reg__
 5854 0f06 F11C      		adc r15,__zero_reg__
 5855               	.LVL599:
 5856               	.L350:
 5857               	.LBE226:
1077:main.c        **** 			}
1078:main.c        **** 			
1079:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 5858               		.loc 3 1079 0
 5859 0f08 00D0      		rcall check_if_timed_out
 5860               	.LVL600:
 5861               	.LBE343:
 5862 0f0a 00C0      		rjmp .L106
 5863               	.LVL601:
 5864               	.L246:
1080:main.c        **** 		}
1081:main.c        **** 		
1082:main.c        **** 		// ---------- General commands ----------
1083:main.c        **** 		// Set any pin as input/output
1084:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
1085:main.c        **** 		/*else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
1086:main.c        **** 			char portChar = USART_Receive();
1087:main.c        **** 			usart_read_chars();
1088:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
1089:main.c        **** 			
1090:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1091:main.c        **** 			if (receivedChar == SET_INPUT) {
1092:main.c        **** 				if (portChar == 'A') {
1093:main.c        **** 					DDRA &= ~(setValue);
1094:main.c        **** 				}
1095:main.c        **** 				else if (portChar == 'B') {
1096:main.c        **** 					DDRB &= ~(setValue);
1097:main.c        **** 				}
1098:main.c        **** 				else if (portChar == 'C') {
1099:main.c        **** 					DDRC &= ~(setValue);
1100:main.c        **** 				}
1101:main.c        **** 				else if (portChar == 'D') {
1102:main.c        **** 					DDRD &= ~(setValue);
1103:main.c        **** 				}
1104:main.c        **** 				else if (portChar == 'E') {
1105:main.c        **** 					DDRE &= ~(setValue);
1106:main.c        **** 				}
1107:main.c        **** 			}
1108:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
1109:main.c        **** 				if (portChar == 'A') {
1110:main.c        **** 					DDRA |= (setValue);
1111:main.c        **** 				}
1112:main.c        **** 				else if (portChar == 'B') {
1113:main.c        **** 					DDRB |= (setValue);
1114:main.c        **** 				}
1115:main.c        **** 				else if (portChar == 'C') {
1116:main.c        **** 					DDRC |= (setValue);
1117:main.c        **** 				}
1118:main.c        **** 				else if (portChar == 'D') {
1119:main.c        **** 					DDRD |= (setValue);
1120:main.c        **** 				}
1121:main.c        **** 				else if (portChar == 'E') {
1122:main.c        **** 					DDRE |= (setValue);
1123:main.c        **** 				}
1124:main.c        **** 			}
1125:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1126:main.c        **** 		}
1127:main.c        **** 		
1128:main.c        **** 		// Set pin output as low
1129:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
1130:main.c        **** 			char portChar = USART_Receive();			
1131:main.c        **** 			usart_read_chars();
1132:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
1133:main.c        **** 			
1134:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1135:main.c        **** 			if (portChar == 'A') {
1136:main.c        **** 				PORTA &= ~(setValue);
1137:main.c        **** 			}
1138:main.c        **** 			else if (portChar == 'B') {
1139:main.c        **** 				PORTB &= ~(setValue);
1140:main.c        **** 			}
1141:main.c        **** 			else if (portChar == 'C') {
1142:main.c        **** 				PORTC &= ~(setValue);
1143:main.c        **** 			}
1144:main.c        **** 			else if (portChar == 'D') {
1145:main.c        **** 				PORTD &= ~(setValue);
1146:main.c        **** 			}
1147:main.c        **** 			else if (portChar == 'E') {
1148:main.c        **** 				PORTE &= ~(setValue);
1149:main.c        **** 			}
1150:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1151:main.c        **** 		}
1152:main.c        **** 		
1153:main.c        **** 		// Set pin output as high
1154:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
1155:main.c        **** 			char portChar = USART_Receive();			
1156:main.c        **** 			usart_read_chars();
1157:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
1158:main.c        **** 			
1159:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1160:main.c        **** 			if (portChar == 'A') {
1161:main.c        **** 				PORTA |= (setValue);
1162:main.c        **** 			}
1163:main.c        **** 			else if (portChar == 'B') {
1164:main.c        **** 				PORTB |= (setValue);
1165:main.c        **** 			}
1166:main.c        **** 			else if (portChar == 'C') {
1167:main.c        **** 				PORTC |= (setValue);
1168:main.c        **** 			}
1169:main.c        **** 			else if (portChar == 'D') {
1170:main.c        **** 				PORTD |= (setValue);
1171:main.c        **** 			}
1172:main.c        **** 			else if (portChar == 'E') {
1173:main.c        **** 				PORTE |= (setValue);
1174:main.c        **** 			}
1175:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1176:main.c        **** 		}
1177:main.c        **** 		
1178:main.c        **** 		// Read all pins of a PORT and return the value
1179:main.c        **** 		else if (receivedChar == READ_INPUT) {
1180:main.c        **** 			char portChar = USART_Receive();			
1181:main.c        **** 			
1182:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1183:main.c        **** 			if (portChar == 'A') {
1184:main.c        **** 				USART_Transmit(PINA);
1185:main.c        **** 			}
1186:main.c        **** 			else if (portChar == 'B') {
1187:main.c        **** 				USART_Transmit(PINB);
1188:main.c        **** 			}
1189:main.c        **** 			else if (portChar == 'C') {
1190:main.c        **** 				USART_Transmit(PINC);
1191:main.c        **** 			}
1192:main.c        **** 			else if (portChar == 'D') {
1193:main.c        **** 				USART_Transmit(PIND);
1194:main.c        **** 			}
1195:main.c        **** 			else if (portChar == 'E') {
1196:main.c        **** 				USART_Transmit(PINE);
1197:main.c        **** 			}
1198:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1199:main.c        **** 		}
1200:main.c        **** 		*/
1201:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
1202:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5865               		.loc 3 1202 0
 5866 0f0c 8D34      		cpi r24,lo8(77)
 5867 0f0e 01F4      		brne .L251
 5868               	.LBB344:
1203:main.c        **** 			char commonChar = USART_Receive();
 5869               		.loc 3 1203 0
 5870 0f10 00D0      		rcall USART_Receive
 5871               	.LVL602:
1204:main.c        **** 			if (commonChar == '1') {
 5872               		.loc 3 1204 0
 5873 0f12 8133      		cpi r24,lo8(49)
 5874 0f14 01F4      		brne .L365
1205:main.c        **** 				resetCommonLines = 1;
 5875               		.loc 3 1205 0
 5876 0f16 91E0      		ldi r25,lo8(1)
 5877 0f18 9DA3      		std Y+37,r25
 5878 0f1a 00C0      		rjmp .L341
 5879               	.L365:
1206:main.c        **** 			}
1207:main.c        **** 			else if (commonChar == '0') {
 5880               		.loc 3 1207 0
 5881 0f1c 8033      		cpi r24,lo8(48)
 5882 0f1e 01F0      		breq .+2
 5883 0f20 00C0      		rjmp .L106
1208:main.c        **** 				resetCommonLines = 0;
 5884               		.loc 3 1208 0
 5885 0f22 1DA2      		std Y+37,__zero_reg__
 5886 0f24 00C0      		rjmp .L107
 5887               	.LVL603:
 5888               	.L251:
 5889               	.LBE344:
1209:main.c        **** 			}
1210:main.c        **** 		}
1211:main.c        **** 		
1212:main.c        **** 		// Send back the PCB version number
1213:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5890               		.loc 3 1213 0
 5891 0f26 8836      		cpi r24,lo8(104)
 5892 0f28 01F4      		brne .L252
1214:main.c        **** 			USART_Transmit(PCB_VERSION);
 5893               		.loc 3 1214 0
 5894 0f2a 84E0      		ldi r24,lo8(4)
 5895 0f2c 00C0      		rjmp .L347
 5896               	.L252:
1215:main.c        **** 		}
1216:main.c        **** 		
1217:main.c        **** 		// Send back the firmware version number
1218:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5897               		.loc 3 1218 0
 5898 0f2e 8635      		cpi r24,lo8(86)
 5899 0f30 01F4      		brne .L253
1219:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5900               		.loc 3 1219 0
 5901 0f32 86E1      		ldi r24,lo8(22)
 5902               	.LVL604:
 5903               	.L347:
 5904 0f34 00D0      		rcall USART_Transmit
 5905               	.LVL605:
 5906 0f36 00C0      		rjmp .L106
 5907               	.LVL606:
 5908               	.L253:
1220:main.c        **** 		}
1221:main.c        **** 		
1222:main.c        **** 		// Send back 32KB for a speed test
1223:main.c        **** 		else if (receivedChar == FAST_READ_CHECK) {
 5909               		.loc 3 1223 0
 5910 0f38 8B32      		cpi r24,lo8(43)
 5911 0f3a 01F4      		brne .L254
 5912 0f3c 00E0      		ldi r16,0
 5913 0f3e 10E4      		ldi r17,lo8(64)
 5914               	.L255:
 5915               	.LVL607:
 5916               	.LBB345:
1224:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
1225:main.c        **** 				USART_Transmit('1');
 5917               		.loc 3 1225 0 discriminator 3
 5918 0f40 81E3      		ldi r24,lo8(49)
 5919 0f42 00D0      		rcall USART_Transmit
 5920               	.LVL608:
1226:main.c        **** 				USART_Transmit('0');
 5921               		.loc 3 1226 0 discriminator 3
 5922 0f44 80E3      		ldi r24,lo8(48)
 5923 0f46 00D0      		rcall USART_Transmit
 5924               	.LVL609:
 5925 0f48 0150      		subi r16,1
 5926 0f4a 1109      		sbc r17,__zero_reg__
 5927               	.LVL610:
1224:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 5928               		.loc 3 1224 0 discriminator 3
 5929 0f4c 01F4      		brne .L255
 5930 0f4e 00C0      		rjmp .L106
 5931               	.LVL611:
 5932               	.L254:
 5933               	.LBE345:
1227:main.c        **** 			}
1228:main.c        **** 		}
1229:main.c        **** 		
1230:main.c        **** 		// Reset the AVR if it matches the number
1231:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5934               		.loc 3 1231 0
 5935 0f50 8A32      		cpi r24,lo8(42)
 5936 0f52 01F0      		breq .+2
 5937 0f54 00C0      		rjmp .L106
 5938               	.LBB346:
1232:main.c        **** 			usart_read_chars();
 5939               		.loc 3 1232 0
 5940 0f56 00D0      		rcall usart_read_chars
 5941               	.LVL612:
1233:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5942               		.loc 3 1233 0
 5943 0f58 40E1      		ldi r20,lo8(16)
 5944 0f5a 50E0      		ldi r21,0
 5945 0f5c 60E0      		ldi r22,0
 5946 0f5e 70E0      		ldi r23,0
 5947 0f60 80E0      		ldi r24,lo8(receivedBuffer)
 5948 0f62 90E0      		ldi r25,hi8(receivedBuffer)
 5949 0f64 00D0      		rcall strtol
 5950               	.LVL613:
1234:main.c        **** 			if (resetValue == RESET_VALUE) {
 5951               		.loc 3 1234 0
 5952 0f66 613E      		cpi r22,-31
 5953 0f68 754E      		sbci r23,-27
 5954 0f6a 8740      		sbci r24,7
 5955 0f6c 9105      		cpc r25,__zero_reg__
 5956 0f6e 01F0      		breq .+2
 5957 0f70 00C0      		rjmp .L106
1235:main.c        **** 				// Clear watchdog flag
1236:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5958               		.loc 3 1236 0
 5959 0f72 84B7      		in r24,0x34
 5960 0f74 877F      		andi r24,lo8(-9)
 5961 0f76 84BF      		out 0x34,r24
1237:main.c        **** 				
1238:main.c        **** 				// Start timed sequence
1239:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5962               		.loc 3 1239 0
 5963 0f78 88E1      		ldi r24,lo8(24)
 5964 0f7a 81BD      		out 0x21,r24
1240:main.c        **** 				
1241:main.c        **** 				// Reset in 250 ms
1242:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5965               		.loc 3 1242 0
 5966 0f7c 8CE0      		ldi r24,lo8(12)
 5967 0f7e 81BD      		out 0x21,r24
 5968               	.LVL614:
 5969               	.LBB347:
 5970               	.LBB348:
 5971               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5972               		.loc 4 105 0
 5973 0f80 8FEF      		ldi r24,lo8(-1)
 5974 0f82 9FEF      		ldi r25,lo8(-1)
 5975               	/* #APP */
 5976               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5977 0f84 0197      		1: sbiw r24,1
 5978 0f86 01F4      		brne 1b
 5979               	 ;  0 "" 2
 5980               	.LVL615:
 5981               	/* #NOAPP */
 5982 0f88 00C0      		rjmp .L106
 5983               	.LBE348:
 5984               	.LBE347:
 5985               	.LBE346:
 5986               		.cfi_endproc
 5987               	.LFE51:
 5989               		.text
 5990               	.global	__vector_6
 5992               	__vector_6:
 5993               	.LFB52:
1243:main.c        **** 				
1244:main.c        **** 				// Wait for reset
1245:main.c        **** 				_delay_loop_2(65535);
1246:main.c        **** 			}
1247:main.c        **** 		}
1248:main.c        **** 	}
1249:main.c        **** }
1250:main.c        **** 
1251:main.c        **** // Timeout after ~500ms which also blinks the LED
1252:main.c        **** ISR(TIMER1_OVF_vect) {
 5994               		.loc 3 1252 0
 5995               		.cfi_startproc
 5996 07d0 1F92      		push r1
 5997               	.LCFI49:
 5998               		.cfi_def_cfa_offset 3
 5999               		.cfi_offset 1, -2
 6000 07d2 0F92      		push r0
 6001               	.LCFI50:
 6002               		.cfi_def_cfa_offset 4
 6003               		.cfi_offset 0, -3
 6004 07d4 0FB6      		in r0,__SREG__
 6005 07d6 0F92      		push r0
 6006 07d8 1124      		clr __zero_reg__
 6007 07da 8F93      		push r24
 6008               	.LCFI51:
 6009               		.cfi_def_cfa_offset 5
 6010               		.cfi_offset 24, -4
 6011 07dc 9F93      		push r25
 6012               	.LCFI52:
 6013               		.cfi_def_cfa_offset 6
 6014               		.cfi_offset 25, -5
 6015               	/* prologue: Signal */
 6016               	/* frame size = 0 */
 6017               	/* stack size = 5 */
 6018               	.L__stack_usage = 5
1253:main.c        **** 	PORTD ^= (1<<ACTIVITY_LED);
 6019               		.loc 3 1253 0
 6020 07de 92B3      		in r25,0x12
 6021 07e0 88E0      		ldi r24,lo8(8)
 6022 07e2 8927      		eor r24,r25
 6023 07e4 82BB      		out 0x12,r24
1254:main.c        **** 	writingTimedout = 1;
 6024               		.loc 3 1254 0
 6025 07e6 81E0      		ldi r24,lo8(1)
 6026 07e8 8093 0000 		sts writingTimedout,r24
 6027               	/* epilogue start */
1255:main.c        **** }...
 6028               		.loc 3 1255 0
 6029 07ec 9F91      		pop r25
 6030 07ee 8F91      		pop r24
 6031 07f0 0F90      		pop r0
 6032 07f2 0FBE      		out __SREG__,r0
 6033 07f4 0F90      		pop r0
 6034 07f6 1F90      		pop r1
 6035 07f8 1895      		reti
 6036               		.cfi_endproc
 6037               	.LFE52:
 6039               	.global	cartMode
 6040               		.data
 6043               	cartMode:
 6044 0000 02        		.byte	2
 6045               	.global	writingTimedout
 6046               		.section .bss
 6049               	writingTimedout:
 6050 0000 00        		.zero	1
 6051               	.global	lastBankAccessed
 6054               	lastBankAccessed:
 6055 0001 00        		.zero	1
 6056               	.global	flashBank1CommandWrites
 6059               	flashBank1CommandWrites:
 6060 0002 00        		.zero	1
 6061               		.comm	flashWriteCycle,12,1
 6062               		.comm	flashWriteWePin,1,1
 6063               		.comm	flashChipIdBuffer,2,1
 6064               		.comm	eepromBuffer,8,1
 6065               		.comm	receivedChar,1,1
 6066               		.comm	receivedBuffer,256,1
 6067               		.text
 6068               	.Letext0:
 6069               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 6070               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1467   .text:0000040a gb_flash_read_byte_fast
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1499   .text:00000416 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1578   .text:00000448 gb_flash_write_bus_cycle_fast
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1648   .text:0000046e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:6049   .bss:00000000 writingTimedout
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1751   .text:000004d8 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:6059   .bss:00000002 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:6054   .bss:00000001 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:1876   .text:0000055a gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2042   .text:000005f4 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2108   .text:00000624 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2232   .text:00000684 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2354   .text:000006e0 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2465   .text:0000073c start_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2488   .text:0000074c stop_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2511   .text:0000075a check_if_timed_out
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2543   .text:0000076c setup
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:6043   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:2646   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccf9jXgP.s:5992   .text:000007d0 __vector_6

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
