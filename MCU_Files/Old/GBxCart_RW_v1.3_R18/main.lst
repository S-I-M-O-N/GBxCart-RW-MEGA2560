   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R18
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 3/07/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 146:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 147:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 148:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
 149:setup.c       **** 
 150:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 151:setup.c       **** 
 152:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 153:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 154:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 155:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 156:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 157:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 158:setup.c       **** #define GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE 'v'
 159:setup.c       **** #define GBA_FLASH_WRITE_SHARP_64BYTE 'x'
 160:setup.c       **** 
 161:setup.c       **** #define D0D1_NOT_SWAPPED 0
 162:setup.c       **** #define D0D1_SWAPPED 1
 163:setup.c       **** 
 164:setup.c       **** // General commands
 165:setup.c       **** #define SEND_ACK '1'
 166:setup.c       **** #define CART_MODE 'C'
 167:setup.c       **** #define SET_INPUT 'I'
 168:setup.c       **** #define SET_OUTPUT 'O'
 169:setup.c       **** #define SET_OUTPUT_LOW 'L'
 170:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 171:setup.c       **** #define READ_INPUT 'D'
 172:setup.c       **** #define RESET_COMMON_LINES 'M'
 173:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 174:setup.c       **** #define READ_PCB_VERSION 'h'
 175:setup.c       **** #define FAST_READ_CHECK '+'
 176:setup.c       **** #define VOLTAGE_3_3V '3'
 177:setup.c       **** #define VOLTAGE_5V '5'
 178:setup.c       **** 
 179:setup.c       **** #define RESET_AVR '*'
 180:setup.c       **** #define RESET_VALUE 0x7E5E1
 181:setup.c       **** 
 182:setup.c       **** 
 183:setup.c       **** char receivedBuffer[256];
 184:setup.c       **** char receivedChar;
 185:setup.c       **** uint8_t eepromBuffer[8];
 186:setup.c       **** uint8_t flashChipIdBuffer[2];
 187:setup.c       **** 
 188:setup.c       **** char flashWriteWePin;
 189:setup.c       **** uint16_t flashWriteCycle[3][2];
 190:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 191:setup.c       **** uint8_t lastBankAccessed = 0;
 192:setup.c       **** 
 193:setup.c       **** uint8_t cartMode = GBA_MODE;
 194:setup.c       **** 
 195:setup.c       **** // Receive USART data
 196:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 196 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 197:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 197 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 198:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 198 0
  26 0004 8CB1      		in r24,0xc
 199:setup.c       **** }
  27               		.loc 1 199 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 200:setup.c       **** 
 201:setup.c       **** // Transmit USART data
 202:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 202 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 203:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 203 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 204:setup.c       **** 	UDR = data;
  47               		.loc 1 204 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 205:setup.c       **** }
 206:setup.c       **** 
 207:setup.c       **** // Read 1-256 bytes from the USART 
 208:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 208 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB146:
 209:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 209 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 209 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 210:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 210 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE146:
 211:setup.c       **** 	}
 212:setup.c       **** }
 106               		.loc 1 212 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 213:setup.c       **** 
 214:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 215:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 215 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 216:setup.c       **** 	int x = 0;
 217:setup.c       **** 	while (1) {
 218:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 218 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 219:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 219 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 220:setup.c       **** 			break;
 221:setup.c       **** 		}
 222:setup.c       **** 		x++;
 223:setup.c       **** 	}
 224:setup.c       **** }
 148               		.loc 1 224 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 225:setup.c       **** 
 226:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 227:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 227 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 228:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 228 0
 167 0050 3A9A      		sbi 0x7,2
 229:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 229 0
 169 0052 949A      		sbi 0x12,4
 230:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 230 0
 171 0054 959A      		sbi 0x12,5
 231:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 231 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 232:setup.c       **** }
 233:setup.c       **** 
 234:setup.c       **** 
 235:setup.c       **** 
 236:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 237:setup.c       **** 
 238:setup.c       **** // Set Gameboy mode
 239:setup.c       **** void gb_mode(void) {
 182               		.loc 1 239 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 240:setup.c       **** 	// Set inputs
 241:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 241 0
 189 005a 15BA      		out 0x15,__zero_reg__
 242:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 242 0
 191 005c 14BA      		out 0x14,__zero_reg__
 243:setup.c       **** 	
 244:setup.c       **** 	// Set outputs
 245:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 245 0
 193 005e 18BA      		out 0x18,__zero_reg__
 246:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 246 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 247:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 247 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 248:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 248 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 249:setup.c       **** }
 250:setup.c       **** 
 251:setup.c       **** // Set the 16 bit address on A15-0
 252:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 252 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 253:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 253 0
 217 006a 9BBB      		out 0x1b,r25
 254:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 254 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 255:setup.c       **** }
 256:setup.c       **** 
 257:setup.c       **** // Set the address and read a byte from the 8 bit data line
 258:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 258 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 259:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 259 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 260:setup.c       **** 	
 261:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 261 0
 239 0072 9498      		cbi 0x12,4
 262:setup.c       **** 	rdPin_low;
 240               		.loc 1 262 0
 241 0074 9598      		cbi 0x12,5
 263:setup.c       **** 	
 264:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 264 0
 243               	/* #APP */
 244               	 ;  264 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 265:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 265 0
 248               	 ;  265 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 266:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 266 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 267:setup.c       **** 	
 268:setup.c       **** 	rdPin_high;
 255               		.loc 1 268 0
 256 007c 959A      		sbi 0x12,5
 269:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 269 0
 258 007e 949A      		sbi 0x12,4
 270:setup.c       **** 	
 271:setup.c       **** 	return data;
 272:setup.c       **** }
 259               		.loc 1 272 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 273:setup.c       **** 
 274:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 275:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 275 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 276:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 276 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 277:setup.c       **** 	
 278:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 278 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 279:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 279 0
 292 0090 D5BB      		out 0x15,r29
 280:setup.c       **** 	
 281:setup.c       **** 	// Pulse WR and mREQ if the type matches
 282:setup.c       **** 	wrPin_low;
 293               		.loc 1 282 0
 294 0092 9698      		cbi 0x12,6
 283:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 283 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 284:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 284 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 285:setup.c       **** 	}
 286:setup.c       **** 	
 287:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 287 0
 302               	/* #APP */
 303               	 ;  287 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 288:setup.c       **** 	
 289:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 289 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 290:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 290 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 291:setup.c       **** 	}
 292:setup.c       **** 	wrPin_high;
 313               		.loc 1 292 0
 314 00a2 969A      		sbi 0x12,6
 293:setup.c       **** 	
 294:setup.c       **** 	// Clear data outputs and set data pins as inputs
 295:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 295 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 296:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 296 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 297:setup.c       **** }
 320               		.loc 1 297 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 298:setup.c       **** 
 299:setup.c       **** 
 300:setup.c       **** 
 301:setup.c       **** // ****** Gameboy Advance functions ****** 
 302:setup.c       **** 
 303:setup.c       **** // Set GBA mode
 304:setup.c       **** void gba_mode(void) {
 333               		.loc 1 304 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 305:setup.c       **** 	// Set outputs for reading ROM addresses as default
 306:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 306 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 307:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 307 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 308:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 308 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 309:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 309 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 310:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 310 0
 349 00b8 8ABB      		out 0x1a,r24
 311:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 311 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 312:setup.c       **** }
 313:setup.c       **** 
 314:setup.c       **** // Set the 24 bit address on A23-0
 315:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 315 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 316:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 316 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 317:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 317 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 318:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 318 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 319:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 319 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 320:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 320 0
 385 00cc 2ABB      		out 0x1a,r18
 321:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 321 0
 387 00ce 27BB      		out 0x17,r18
 322:setup.c       **** 	
 323:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 323 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 324:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 324 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 325:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 325 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 326:setup.c       **** }
 402               		.loc 1 326 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 327:setup.c       **** 
 328:setup.c       **** 
 329:setup.c       **** 
 330:setup.c       **** // ---------- ROM/SRAM ----------
 331:setup.c       **** 
 332:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 333:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 333 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 334:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 334 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 335:setup.c       **** 	
 336:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 336 0
 424 00ec 9498      		cbi 0x12,4
 337:setup.c       **** 	
 338:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 338 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 339:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 339 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 340:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 340 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 341:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 341 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 342:setup.c       **** 	
 343:setup.c       **** 	rdPin_low;
 433               		.loc 1 343 0
 434 00f6 9598      		cbi 0x12,5
 344:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 344 0
 436               	/* #APP */
 437               	 ;  344 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 345:setup.c       **** 	
 346:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 346 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 347:setup.c       **** 	
 348:setup.c       **** 	rdPin_high;
 445               		.loc 1 348 0
 446 00fe 959A      		sbi 0x12,5
 349:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 349 0
 448 0100 949A      		sbi 0x12,4
 350:setup.c       **** 	
 351:setup.c       **** 	return data;
 449               		.loc 1 351 0
 450 0102 90E0      		ldi r25,0
 352:setup.c       **** }
 451               		.loc 1 352 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 353:setup.c       **** 
 354:setup.c       **** // Set the address and read a byte from the 8 bit data line
 355:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 355 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 356:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 356 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 357:setup.c       **** 	
 358:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 471               		.loc 1 358 0
 472 010a 3A98      		cbi 0x7,2
 359:setup.c       **** 	rdPin_low;
 473               		.loc 1 359 0
 474 010c 9598      		cbi 0x12,5
 360:setup.c       **** 	
 361:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 361 0
 476               	/* #APP */
 477               	 ;  361 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 362:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 362 0
 481               	 ;  362 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 363:setup.c       **** 	
 364:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 364 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 365:setup.c       **** 	
 366:setup.c       **** 	rdPin_high;
 488               		.loc 1 366 0
 489 0114 959A      		sbi 0x12,5
 367:setup.c       **** 	cs2Pin_high;
 490               		.loc 1 367 0
 491 0116 3A9A      		sbi 0x7,2
 368:setup.c       **** 	
 369:setup.c       **** 	return data;
 370:setup.c       **** }
 492               		.loc 1 370 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 371:setup.c       **** 
 372:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 373:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 373 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 374:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 374 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 375:setup.c       **** 	
 376:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 376 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 377:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 377 0
 520 0124 C5BB      		out 0x15,r28
 378:setup.c       **** 	
 379:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 521               		.loc 1 379 0
 522 0126 3A98      		cbi 0x7,2
 380:setup.c       **** 	wrPin_low; // Pulse WR
 523               		.loc 1 380 0
 524 0128 9698      		cbi 0x12,6
 381:setup.c       **** 	
 382:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 382 0
 526               	/* #APP */
 527               	 ;  382 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 383:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 383 0
 531               	 ;  383 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 384:setup.c       **** 	
 385:setup.c       **** 	wrPin_high;
 534               		.loc 1 385 0
 535               	/* #NOAPP */
 536 012e 969A      		sbi 0x12,6
 386:setup.c       **** 	cs2Pin_high;
 537               		.loc 1 386 0
 538 0130 3A9A      		sbi 0x7,2
 387:setup.c       **** 	
 388:setup.c       **** 	// Clear data outputs and set data pins as inputs
 389:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 389 0
 540 0132 15BA      		out 0x15,__zero_reg__
 390:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 390 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 391:setup.c       **** }
 544               		.loc 1 391 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 392:setup.c       **** 
 393:setup.c       **** 
 394:setup.c       **** 
 395:setup.c       **** // ---------- EEPROM ----------
 396:setup.c       **** 
 397:setup.c       **** // Set address/data all high (includes AD0/A23)
 398:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 398 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 399:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 399 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 400:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 400 0
 565 013e 8ABB      		out 0x1a,r24
 401:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 401 0
 567 0140 84BB      		out 0x14,r24
 402:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 402 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 403:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 403 0
 572 0146 8BBB      		out 0x1b,r24
 404:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 404 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 405:setup.c       **** }
 406:setup.c       **** 
 407:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 408:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 408 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 409:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 409 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 410:setup.c       **** 	
 411:setup.c       **** 	int8_t x = 0;
 412:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 412 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 413:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 413 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 414:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 414 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 415:setup.c       **** 		}
 416:setup.c       **** 		else {
 417:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 418:setup.c       **** 		}
 419:setup.c       **** 		x = 15;
 603               		.loc 1 419 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 420:setup.c       **** 	}
 421:setup.c       **** 	else {
 422:setup.c       **** 		if (command == EEPROM_READ) {
 423:setup.c       **** 			address |= (1<<7) | (1<<6);
 424:setup.c       **** 		}
 425:setup.c       **** 		else {
 426:setup.c       **** 			address |= (1<<7);
 427:setup.c       **** 		}
 428:setup.c       **** 		x = 7;
 429:setup.c       **** 	}
 430:setup.c       **** 	
 431:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 432:setup.c       **** 	while (x >= 0) {
 433:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 433 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 417:setup.c       **** 		}
 613               		.loc 1 417 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 422:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 422 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 423:setup.c       **** 		}
 621               		.loc 1 423 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 426:setup.c       **** 		}
 626               		.loc 1 426 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 428:setup.c       **** 	}
 630               		.loc 1 428 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 434:setup.c       **** 			ad0Pin_high;
 435:setup.c       **** 		}
 436:setup.c       **** 		else {
 437:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 437 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 438:setup.c       **** 		}
 439:setup.c       **** 		
 440:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 440 0
 639 0174 9698      		cbi 0x12,6
 441:setup.c       **** 		asm ("nop");
 640               		.loc 1 441 0
 641               	/* #APP */
 642               	 ;  441 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 442:setup.c       **** 		asm ("nop");
 645               		.loc 1 442 0
 646               	 ;  442 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 443:setup.c       **** 		wrPin_high; 
 649               		.loc 1 443 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 444:setup.c       **** 		asm ("nop");
 652               		.loc 1 444 0
 653               	/* #APP */
 654               	 ;  444 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 445:setup.c       **** 		asm ("nop");
 657               		.loc 1 445 0
 658               	 ;  445 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 432:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 432 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 433:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 433 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 434:setup.c       **** 		}
 682               		.loc 1 434 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 446:setup.c       **** 		
 447:setup.c       **** 		x--;
 448:setup.c       **** 	}
 449:setup.c       **** 	
 450:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 451:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 451 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 452:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 452 0
 690 01a4 C098      		cbi 0x18,0
 453:setup.c       **** 		asm ("nop");
 691               		.loc 1 453 0
 692               	/* #APP */
 693               	 ;  453 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 454:setup.c       **** 		wrPin_low;
 696               		.loc 1 454 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 455:setup.c       **** 		asm ("nop");
 699               		.loc 1 455 0
 700               	/* #APP */
 701               	 ;  455 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 456:setup.c       **** 		asm ("nop");
 704               		.loc 1 456 0
 705               	 ;  456 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 457:setup.c       **** 		
 458:setup.c       **** 		wrPin_high;
 708               		.loc 1 458 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 459:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 459 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 460:setup.c       **** 	}
 461:setup.c       **** }
 462:setup.c       **** 
 463:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 464:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 464 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 465:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 465 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 466:setup.c       **** 	
 467:setup.c       **** 	// Set AD0 pin as input
 468:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 468 0
 734 01b8 C098      		cbi 0x18,0
 469:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 469 0
 736 01ba B898      		cbi 0x17,0
 470:setup.c       **** 	
 471:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 471 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB147:
 472:setup.c       **** 	
 473:setup.c       **** 	// Ignore first 4 bits
 474:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 475:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 475 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 476:setup.c       **** 		asm ("nop");
 746               		.loc 1 476 0 discriminator 3
 747               	/* #APP */
 748               	 ;  476 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 477:setup.c       **** 		asm ("nop");
 751               		.loc 1 477 0 discriminator 3
 752               	 ;  477 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 478:setup.c       **** 		rdPin_high; 
 755               		.loc 1 478 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 479:setup.c       **** 		asm ("nop");
 758               		.loc 1 479 0 discriminator 3
 759               	/* #APP */
 760               	 ;  479 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 480:setup.c       **** 		asm ("nop");
 763               		.loc 1 480 0 discriminator 3
 764               	 ;  480 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 474:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 474 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE147:
 776               	.LBB148:
 777               	.LBB149:
 778               	.LBB150:
 481:setup.c       **** 	}
 482:setup.c       **** 	
 483:setup.c       **** 	// Read out 64 bits
 484:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 485:setup.c       **** 		uint8_t data = 0;
 486:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 487:setup.c       **** 			rdPin_low; // CLK
 488:setup.c       **** 			asm ("nop");
 489:setup.c       **** 			asm ("nop");
 490:setup.c       **** 			rdPin_high;
 491:setup.c       **** 			
 492:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 493:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 493 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE150:
 785               	.LBE149:
 786               	.LBE148:
 471:setup.c       **** 	
 787               		.loc 1 471 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB153:
 794               	.LBB152:
 795               	.LBB151:
 487:setup.c       **** 			asm ("nop");
 796               		.loc 1 487 0
 797 01de 9598      		cbi 0x12,5
 488:setup.c       **** 			asm ("nop");
 798               		.loc 1 488 0
 799               	/* #APP */
 800               	 ;  488 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 489:setup.c       **** 			rdPin_high;
 803               		.loc 1 489 0
 804               	 ;  489 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 490:setup.c       **** 			
 807               		.loc 1 490 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 492:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 492 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 493 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE151:
 494:setup.c       **** 			}
 495:setup.c       **** 		}
 496:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 496 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE152:
 484:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 484 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE153:
 497:setup.c       **** 	}
 498:setup.c       **** 	
 499:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 499 0
 841 0206 949A      		sbi 0x12,4
 500:setup.c       **** 	
 501:setup.c       **** 	// Set AD0 pin as output
 502:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 502 0
 843 0208 C09A      		sbi 0x18,0
 503:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 503 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 504:setup.c       **** }
 505:setup.c       **** 
 506:setup.c       **** // Write 8 bytes to the EEPROM address
 507:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 507 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 508:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 508 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 507:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 507 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB154:
 876               	.LBB155:
 509:setup.c       **** 	
 510:setup.c       **** 	// Write 64 bits
 511:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 512:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 513:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 513 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 514:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 514 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 515:setup.c       **** 			}
 516:setup.c       **** 			else {
 517:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 517 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 518:setup.c       **** 			}
 519:setup.c       **** 			
 520:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 520 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 521:setup.c       **** 			asm ("nop");
 899               		.loc 1 521 0 discriminator 2
 900               	/* #APP */
 901               	 ;  521 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 522:setup.c       **** 			asm ("nop");
 904               		.loc 1 522 0 discriminator 2
 905               	 ;  522 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 523:setup.c       **** 			wrPin_high; 
 908               		.loc 1 523 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 524:setup.c       **** 			asm ("nop");
 911               		.loc 1 524 0 discriminator 2
 912               	/* #APP */
 913               	 ;  524 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 525:setup.c       **** 			asm ("nop");
 916               		.loc 1 525 0 discriminator 2
 917               	 ;  525 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE155:
 511:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 511 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE154:
 526:setup.c       **** 		}
 527:setup.c       **** 	}
 528:setup.c       **** 	
 529:setup.c       **** 	// Last bit low
 530:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 530 0
 935 0250 C098      		cbi 0x18,0
 531:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 531 0
 937 0252 9698      		cbi 0x12,6
 532:setup.c       **** 	asm ("nop");
 938               		.loc 1 532 0
 939               	/* #APP */
 940               	 ;  532 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 533:setup.c       **** 	asm ("nop");
 943               		.loc 1 533 0
 944               	 ;  533 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 534:setup.c       **** 	wrPin_high; 
 947               		.loc 1 534 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 535:setup.c       **** 	asm ("nop");
 950               		.loc 1 535 0
 951               	/* #APP */
 952               	 ;  535 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 536:setup.c       **** 	asm ("nop");
 955               		.loc 1 536 0
 956               	 ;  536 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 537:setup.c       **** 	
 538:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 538 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 539:setup.c       **** }
 540:setup.c       **** 
 541:setup.c       **** 
 542:setup.c       **** 
 543:setup.c       **** // ---------- FLASH ----------
 544:setup.c       **** 
 545:setup.c       **** // Set the address and data for the write byte cycle to the flash
 546:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 546 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 547:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 547 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 548:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 548 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 549:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 549 0
 989 026c C5BB      		out 0x15,r28
 550:setup.c       **** 	
 551:setup.c       **** 	cs2Pin_low;
 990               		.loc 1 551 0
 991 026e 3A98      		cbi 0x7,2
 552:setup.c       **** 	wrPin_low;
 992               		.loc 1 552 0
 993 0270 9698      		cbi 0x12,6
 553:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 553 0
 995               	/* #APP */
 996               	 ;  553 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 554:setup.c       **** 	cs2Pin_high;
 999               		.loc 1 554 0
 1000               	/* #NOAPP */
 1001 0274 3A9A      		sbi 0x7,2
 555:setup.c       **** 	wrPin_high;
 1002               		.loc 1 555 0
 1003 0276 969A      		sbi 0x12,6
 1004               	/* epilogue start */
 556:setup.c       **** }
 1005               		.loc 1 556 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 557:setup.c       **** 
 558:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 559:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 559 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 560:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 560 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 561:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 561 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 562 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB156:
 1049               	.LBB157:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE157:
 1060               	.LBE156:
 563:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 564:setup.c       **** 	
 565:setup.c       **** 	// Set data as inputs
 566:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 566 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 567:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 567 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 568:setup.c       **** 	
 569:setup.c       **** 	// Read and transmit the 2 bytes
 570:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 570 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 571:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 571 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 572:setup.c       **** 	
 573:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 573 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 574:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 574 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 575:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 575 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB158:
 1098               	.LBB159:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE159:
 1109               	.LBE158:
 576:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 577:setup.c       **** }
 1110               		.loc 1 577 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 578:setup.c       **** 
 579:setup.c       **** // Switch banks on the Flash
 580:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 580 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 581 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 582:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 582 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 583:setup.c       **** 	
 584:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 584 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 585:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 585 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 586:setup.c       **** }
 1157               		.loc 1 586 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 585:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 585 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 587:setup.c       **** 
 588:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 589:setup.c       **** // Takes 25ms after last command to erase sector
 590:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 590 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 591:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 591 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 592:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 592 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 593:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 593 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 594:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 594 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 595:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 595 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 596:setup.c       **** 	
 597:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 597 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB160:
 1222               	.LBB161:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE161:
 1233               	.LBE160:
 598:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 599:setup.c       **** }
 1234               		.loc 1 599 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 600:setup.c       **** 
 601:setup.c       **** // Write a single byte to the Flash address
 602:setup.c       **** // Takes 20us to program Flash
 603:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 603 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 604:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 604 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 605:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 605 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 606:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 606 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 607:setup.c       **** 	
 608:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 608 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB162:
 1292               	.LBB163:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE163:
 1301               	.LBE162:
 609:setup.c       **** 	_delay_us(20); // Wait byte program time
 610:setup.c       **** }
 1302               		.loc 1 610 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 611:setup.c       **** 
 612:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 613:setup.c       **** // Takes 20ms for write cycle
 614:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 614 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 615:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 615 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 616:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 616 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 617:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 617 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB164:
 618:setup.c       **** 	
 619:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 620:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 621:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 621 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 621 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 620:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 620 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE164:
 1400               	.LBB165:
 1401               	.LBB166:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE166:
 1412               	.LBE165:
 622:setup.c       **** 	}
 623:setup.c       **** 	_delay_ms(20); // Wait sector program time
 624:setup.c       **** }
 1413               		.loc 1 624 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 625:setup.c       **** 
 626:setup.c       **** 
 627:setup.c       **** 
 628:setup.c       **** // ---------- GB FLASH CARTS ----------
 629:setup.c       **** 
 630:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 631:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 631 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 632:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 632 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 633:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 633 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 634:setup.c       **** 	
 635:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 635 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 636:setup.c       **** 	
 637:setup.c       **** 	rdPin_low;
 1443               		.loc 1 637 0
 1444 03fe 9598      		cbi 0x12,5
 638:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 638 0
 1446               	/* #APP */
 1447               	 ;  638 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 639:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 639 0
 1451               	 ;  639 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 640:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 640 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 641:setup.c       **** 	rdPin_high;
 1458               		.loc 1 641 0
 1459 0406 959A      		sbi 0x12,5
 642:setup.c       **** 	
 643:setup.c       **** 	return data;
 644:setup.c       **** }
 1460               		.loc 1 644 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_read_byte_fast
 1467               	gb_flash_read_byte_fast:
 1468               	.LFB37:
 645:setup.c       **** 
 646:setup.c       **** // No setting address or outputs, assuming already set
 647:setup.c       **** uint8_t gb_flash_read_byte_fast(void) {
 1469               		.loc 1 647 0
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 648:setup.c       **** 	rdPin_low;
 1475               		.loc 1 648 0
 1476 040a 9598      		cbi 0x12,5
 649:setup.c       **** 	asm volatile("nop"); // Delay a little
 1477               		.loc 1 649 0
 1478               	/* #APP */
 1479               	 ;  649 "setup.c" 1
 1480 040c 0000      		nop
 1481               	 ;  0 "" 2
 650:setup.c       **** 	asm volatile("nop");
 1482               		.loc 1 650 0
 1483               	 ;  650 "setup.c" 1
 1484 040e 0000      		nop
 1485               	 ;  0 "" 2
 651:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1486               		.loc 1 651 0
 1487               	/* #NOAPP */
 1488 0410 83B3      		in r24,0x13
 1489               	.LVL116:
 652:setup.c       **** 	rdPin_high;
 1490               		.loc 1 652 0
 1491 0412 959A      		sbi 0x12,5
 653:setup.c       **** 	
 654:setup.c       **** 	return data;
 655:setup.c       **** }
 1492               		.loc 1 655 0
 1493 0414 0895      		ret
 1494               		.cfi_endproc
 1495               	.LFE37:
 1497               	.global	gb_flash_write_bus_cycle
 1499               	gb_flash_write_bus_cycle:
 1500               	.LFB38:
 656:setup.c       **** 
 657:setup.c       **** // Set the address and data for the write byte cycle to the flash
 658:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1501               		.loc 1 658 0
 1502               		.cfi_startproc
 1503               	.LVL117:
 1504 0416 CF93      		push r28
 1505               	.LCFI25:
 1506               		.cfi_def_cfa_offset 3
 1507               		.cfi_offset 28, -2
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 1 */
 1511               	.L__stack_usage = 1
 1512 0418 C62F      		mov r28,r22
 659:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1513               		.loc 1 659 0
 1514 041a 2FEF      		ldi r18,lo8(-1)
 1515 041c 24BB      		out 0x14,r18
 660:setup.c       **** 	set_16bit_address(address);
 1516               		.loc 1 660 0
 1517 041e 00D0      		rcall set_16bit_address
 1518               	.LVL118:
 661:setup.c       **** 	PORT_DATA7_0 = data;
 1519               		.loc 1 661 0
 1520 0420 C5BB      		out 0x15,r28
 662:setup.c       **** 	
 663:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1521               		.loc 1 663 0
 1522 0422 8091 0000 		lds r24,flashWriteWePin
 1523 0426 8134      		cpi r24,lo8(65)
 1524 0428 01F4      		brne .L71
 664:setup.c       **** 		audioPin_low; // WE low
 1525               		.loc 1 664 0
 1526 042a 3998      		cbi 0x7,1
 665:setup.c       **** 		asm volatile("nop");
 1527               		.loc 1 665 0
 1528               	/* #APP */
 1529               	 ;  665 "setup.c" 1
 1530 042c 0000      		nop
 1531               	 ;  0 "" 2
 666:setup.c       **** 		asm volatile("nop");
 1532               		.loc 1 666 0
 1533               	 ;  666 "setup.c" 1
 1534 042e 0000      		nop
 1535               	 ;  0 "" 2
 667:setup.c       **** 		asm volatile("nop");
 1536               		.loc 1 667 0
 1537               	 ;  667 "setup.c" 1
 1538 0430 0000      		nop
 1539               	 ;  0 "" 2
 668:setup.c       **** 		audioPin_high; // WE high
 1540               		.loc 1 668 0
 1541               	/* #NOAPP */
 1542 0432 399A      		sbi 0x7,1
 1543 0434 00C0      		rjmp .L72
 1544               	.L71:
 669:setup.c       **** 	}
 670:setup.c       **** 	else { // WR pin
 671:setup.c       **** 		wrPin_low; // WE low
 1545               		.loc 1 671 0
 1546 0436 9698      		cbi 0x12,6
 672:setup.c       **** 		asm volatile("nop");
 1547               		.loc 1 672 0
 1548               	/* #APP */
 1549               	 ;  672 "setup.c" 1
 1550 0438 0000      		nop
 1551               	 ;  0 "" 2
 673:setup.c       **** 		asm volatile("nop");
 1552               		.loc 1 673 0
 1553               	 ;  673 "setup.c" 1
 1554 043a 0000      		nop
 1555               	 ;  0 "" 2
 674:setup.c       **** 		asm volatile("nop");
 1556               		.loc 1 674 0
 1557               	 ;  674 "setup.c" 1
 1558 043c 0000      		nop
 1559               	 ;  0 "" 2
 675:setup.c       **** 		wrPin_high; // WE high
 1560               		.loc 1 675 0
 1561               	/* #NOAPP */
 1562 043e 969A      		sbi 0x12,6
 1563               	.L72:
 676:setup.c       **** 	}
 677:setup.c       **** 	
 678:setup.c       **** 	// Clear data outputs and set data pins as inputs
 679:setup.c       **** 	PORT_DATA7_0 = 0;
 1564               		.loc 1 679 0
 1565 0440 15BA      		out 0x15,__zero_reg__
 680:setup.c       **** 	DDR_DATA7_0 = 0;
 1566               		.loc 1 680 0
 1567 0442 14BA      		out 0x14,__zero_reg__
 1568               	/* epilogue start */
 681:setup.c       **** }
 1569               		.loc 1 681 0
 1570 0444 CF91      		pop r28
 1571               	.LVL119:
 1572 0446 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE38:
 1576               	.global	gb_flash_write_bus_cycle_fast
 1578               	gb_flash_write_bus_cycle_fast:
 1579               	.LFB39:
 682:setup.c       **** 
 683:setup.c       **** void gb_flash_write_bus_cycle_fast(uint16_t address, uint8_t data) {
 1580               		.loc 1 683 0
 1581               		.cfi_startproc
 1582               	.LVL120:
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1585               	/* stack size = 0 */
 1586               	.L__stack_usage = 0
 684:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 1587               		.loc 1 684 0
 1588 0448 9BBB      		out 0x1b,r25
 685:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1589               		.loc 1 685 0
 1590 044a 88BB      		out 0x18,r24
 686:setup.c       **** 	PORT_DATA7_0 = data;
 1591               		.loc 1 686 0
 1592 044c 65BB      		out 0x15,r22
 687:setup.c       **** 	
 688:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1593               		.loc 1 688 0
 1594 044e 8091 0000 		lds r24,flashWriteWePin
 1595               	.LVL121:
 1596 0452 8134      		cpi r24,lo8(65)
 1597 0454 01F4      		brne .L74
 1598               	.LVL122:
 1599               	.LBB169:
 1600               	.LBB170:
 689:setup.c       **** 		audioPin_low; // WE low
 1601               		.loc 1 689 0
 1602 0456 3998      		cbi 0x7,1
 690:setup.c       **** 		asm volatile("nop");
 1603               		.loc 1 690 0
 1604               	/* #APP */
 1605               	 ;  690 "setup.c" 1
 1606 0458 0000      		nop
 1607               	 ;  0 "" 2
 691:setup.c       **** 		asm volatile("nop");
 1608               		.loc 1 691 0
 1609               	 ;  691 "setup.c" 1
 1610 045a 0000      		nop
 1611               	 ;  0 "" 2
 692:setup.c       **** 		asm volatile("nop");
 1612               		.loc 1 692 0
 1613               	 ;  692 "setup.c" 1
 1614 045c 0000      		nop
 1615               	 ;  0 "" 2
 693:setup.c       **** 		audioPin_high; // WE high
 1616               		.loc 1 693 0
 1617               	/* #NOAPP */
 1618 045e 399A      		sbi 0x7,1
 1619 0460 0895      		ret
 1620               	.LVL123:
 1621               	.L74:
 1622               	.LBE170:
 1623               	.LBE169:
 694:setup.c       **** 	}
 695:setup.c       **** 	else { // WR pin
 696:setup.c       **** 		wrPin_low; // WE low
 1624               		.loc 1 696 0
 1625 0462 9698      		cbi 0x12,6
 697:setup.c       **** 		asm volatile("nop");
 1626               		.loc 1 697 0
 1627               	/* #APP */
 1628               	 ;  697 "setup.c" 1
 1629 0464 0000      		nop
 1630               	 ;  0 "" 2
 698:setup.c       **** 		asm volatile("nop");
 1631               		.loc 1 698 0
 1632               	 ;  698 "setup.c" 1
 1633 0466 0000      		nop
 1634               	 ;  0 "" 2
 699:setup.c       **** 		asm volatile("nop");
 1635               		.loc 1 699 0
 1636               	 ;  699 "setup.c" 1
 1637 0468 0000      		nop
 1638               	 ;  0 "" 2
 700:setup.c       **** 		wrPin_high; // WE high
 1639               		.loc 1 700 0
 1640               	/* #NOAPP */
 1641 046a 969A      		sbi 0x12,6
 1642 046c 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE39:
 1646               	.global	gb_flash_write_byte
 1648               	gb_flash_write_byte:
 1649               	.LFB40:
 701:setup.c       **** 	}
 702:setup.c       **** }
 703:setup.c       **** 
 704:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 705:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1650               		.loc 1 705 0
 1651               		.cfi_startproc
 1652               	.LVL124:
 1653 046e 0F93      		push r16
 1654               	.LCFI26:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 0470 1F93      		push r17
 1658               	.LCFI27:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661 0472 CF93      		push r28
 1662               	.LCFI28:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 28, -4
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 3 */
 1668               	.L__stack_usage = 3
 1669 0474 8C01      		movw r16,r24
 1670 0476 C62F      		mov r28,r22
 706:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1671               		.loc 1 706 0
 1672 0478 8FEF      		ldi r24,lo8(-1)
 1673               	.LVL125:
 1674 047a 84BB      		out 0x14,r24
 707:setup.c       **** 	
 708:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1675               		.loc 1 708 0
 1676 047c 6091 0000 		lds r22,flashWriteCycle+2
 1677               	.LVL126:
 1678 0480 8091 0000 		lds r24,flashWriteCycle
 1679 0484 9091 0000 		lds r25,flashWriteCycle+1
 1680 0488 00D0      		rcall gb_flash_write_bus_cycle_fast
 1681               	.LVL127:
 709:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1682               		.loc 1 709 0
 1683 048a 6091 0000 		lds r22,flashWriteCycle+6
 1684 048e 8091 0000 		lds r24,flashWriteCycle+4
 1685 0492 9091 0000 		lds r25,flashWriteCycle+4+1
 1686 0496 00D0      		rcall gb_flash_write_bus_cycle_fast
 1687               	.LVL128:
 710:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1688               		.loc 1 710 0
 1689 0498 6091 0000 		lds r22,flashWriteCycle+10
 1690 049c 8091 0000 		lds r24,flashWriteCycle+8
 1691 04a0 9091 0000 		lds r25,flashWriteCycle+8+1
 1692 04a4 00D0      		rcall gb_flash_write_bus_cycle_fast
 1693               	.LVL129:
 711:setup.c       **** 	gb_flash_write_bus_cycle_fast(address, data);
 1694               		.loc 1 711 0
 1695 04a6 6C2F      		mov r22,r28
 1696 04a8 C801      		movw r24,r16
 1697 04aa 00D0      		rcall gb_flash_write_bus_cycle_fast
 1698               	.LVL130:
 1699               	.LBB171:
 1700               	.LBB172:
 1701               		.loc 2 276 0
 1702 04ac 8DE0      		ldi r24,lo8(13)
 1703 04ae 8A95      	1:	dec r24
 1704 04b0 01F4      		brne 1b
 1705 04b2 0000      		nop
 1706               	.LVL131:
 1707               	.LBE172:
 1708               	.LBE171:
 712:setup.c       **** 	_delay_us(5); // Wait byte program time
 713:setup.c       **** 	
 714:setup.c       **** 	// Set data pins inputs
 715:setup.c       **** 	PORT_DATA7_0 = 0;
 1709               		.loc 1 715 0
 1710 04b4 15BA      		out 0x15,__zero_reg__
 716:setup.c       **** 	DDR_DATA7_0 = 0;
 1711               		.loc 1 716 0
 1712 04b6 14BA      		out 0x14,__zero_reg__
 717:setup.c       **** 	
 718:setup.c       **** 	// Verify data
 719:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte_fast();
 1713               		.loc 1 719 0
 1714 04b8 00D0      		rcall gb_flash_read_byte_fast
 1715               	.LVL132:
 1716               	.L77:
 720:setup.c       **** 	while (data != dataVerify) {
 1717               		.loc 1 720 0
 1718 04ba 8C17      		cp r24,r28
 1719 04bc 01F0      		breq .L79
 721:setup.c       **** 		dataVerify = gb_flash_read_byte_fast();
 1720               		.loc 1 721 0
 1721 04be 00D0      		rcall gb_flash_read_byte_fast
 1722               	.LVL133:
 1723               	.LBB173:
 1724               	.LBB174:
 1725               		.loc 2 276 0
 1726 04c0 92E0      		ldi r25,lo8(2)
 1727 04c2 9A95      	1:	dec r25
 1728 04c4 01F4      		brne 1b
 1729 04c6 00C0      		rjmp .
 1730 04c8 00C0      		rjmp .L77
 1731               	.LVL134:
 1732               	.L79:
 1733               	/* epilogue start */
 1734               	.LBE174:
 1735               	.LBE173:
 722:setup.c       **** 		_delay_us(1);
 723:setup.c       **** 	}
 724:setup.c       **** }
 1736               		.loc 1 724 0
 1737 04ca CF91      		pop r28
 1738               	.LVL135:
 1739 04cc 1F91      		pop r17
 1740 04ce 0F91      		pop r16
 1741               	.LVL136:
 1742 04d0 0895      		ret
 1743               		.cfi_endproc
 1744               	.LFE40:
 1746               	.global	gb_flash_write_byte_special
 1748               	gb_flash_write_byte_special:
 1749               	.LFB41:
 725:setup.c       **** 
 726:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 727:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1750               		.loc 1 727 0
 1751               		.cfi_startproc
 1752               	.LVL137:
 1753 04d2 1F93      		push r17
 1754               	.LCFI29:
 1755               		.cfi_def_cfa_offset 3
 1756               		.cfi_offset 17, -2
 1757 04d4 CF93      		push r28
 1758               	.LCFI30:
 1759               		.cfi_def_cfa_offset 4
 1760               		.cfi_offset 28, -3
 1761 04d6 DF93      		push r29
 1762               	.LCFI31:
 1763               		.cfi_def_cfa_offset 5
 1764               		.cfi_offset 29, -4
 1765               	/* prologue: function */
 1766               	/* frame size = 0 */
 1767               	/* stack size = 3 */
 1768               	.L__stack_usage = 3
 1769 04d8 EC01      		movw r28,r24
 1770 04da 162F      		mov r17,r22
 728:setup.c       **** 	// Set bank back
 729:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1771               		.loc 1 729 0
 1772 04dc 8091 0000 		lds r24,flashBank1CommandWrites
 1773               	.LVL138:
 1774 04e0 8130      		cpi r24,lo8(1)
 1775 04e2 01F4      		brne .L81
 730:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1776               		.loc 1 730 0
 1777 04e4 40E0      		ldi r20,0
 1778 04e6 6091 0000 		lds r22,lastBankAccessed
 1779               	.LVL139:
 1780 04ea 80E0      		ldi r24,0
 1781 04ec 91E2      		ldi r25,lo8(33)
 1782 04ee 00D0      		rcall write_8bit_data
 1783               	.LVL140:
 1784               	.LBB175:
 1785               	.LBB176:
 1786               		.loc 2 276 0
 1787 04f0 85E8      		ldi r24,lo8(-123)
 1788 04f2 8A95      	1:	dec r24
 1789 04f4 01F4      		brne 1b
 1790 04f6 0000      		nop
 1791               	.LVL141:
 1792               	.L81:
 1793               	.LBE176:
 1794               	.LBE175:
 731:setup.c       **** 		_delay_us(50);
 732:setup.c       **** 	}
 733:setup.c       **** 	
 734:setup.c       **** 	// Write
 735:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1795               		.loc 1 735 0
 1796 04f8 6091 0000 		lds r22,flashWriteCycle+2
 1797 04fc 8091 0000 		lds r24,flashWriteCycle
 1798 0500 9091 0000 		lds r25,flashWriteCycle+1
 1799 0504 00D0      		rcall gb_flash_write_bus_cycle
 1800               	.LVL142:
 736:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1801               		.loc 1 736 0
 1802 0506 6091 0000 		lds r22,flashWriteCycle+6
 1803 050a 8091 0000 		lds r24,flashWriteCycle+4
 1804 050e 9091 0000 		lds r25,flashWriteCycle+4+1
 1805 0512 00D0      		rcall gb_flash_write_bus_cycle
 1806               	.LVL143:
 737:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1807               		.loc 1 737 0
 1808 0514 6091 0000 		lds r22,flashWriteCycle+10
 1809 0518 8091 0000 		lds r24,flashWriteCycle+8
 1810 051c 9091 0000 		lds r25,flashWriteCycle+8+1
 1811 0520 00D0      		rcall gb_flash_write_bus_cycle
 1812               	.LVL144:
 738:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1813               		.loc 1 738 0
 1814 0522 612F      		mov r22,r17
 1815 0524 CE01      		movw r24,r28
 1816 0526 00D0      		rcall gb_flash_write_bus_cycle
 1817               	.LVL145:
 1818               	.LBB177:
 1819               	.LBB178:
 1820               		.loc 2 276 0
 1821 0528 83EF      		ldi r24,lo8(499)
 1822 052a 91E0      		ldi r25,hi8(499)
 1823 052c 0197      	1:	sbiw r24,1
 1824 052e 01F4      		brne 1b
 1825 0530 00C0      		rjmp .
 1826 0532 0000      		nop
 1827               	.LVL146:
 1828               	.LBE178:
 1829               	.LBE177:
 739:setup.c       **** 	_delay_us(250); // Wait byte program time
 740:setup.c       **** 	
 741:setup.c       **** 	// Set data pins inputs
 742:setup.c       **** 	PORT_DATA7_0 = 0;
 1830               		.loc 1 742 0
 1831 0534 15BA      		out 0x15,__zero_reg__
 743:setup.c       **** 	DDR_DATA7_0 = 0;
 1832               		.loc 1 743 0
 1833 0536 14BA      		out 0x14,__zero_reg__
 744:setup.c       **** 	
 745:setup.c       **** 	// Pulse reset
 746:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1834               		.loc 1 746 0
 1835 0538 3A98      		cbi 0x7,2
 1836               	.LVL147:
 1837               	.LBB179:
 1838               	.LBB180:
 1839               		.loc 2 276 0
 1840 053a 95E8      		ldi r25,lo8(-123)
 1841 053c 9A95      	1:	dec r25
 1842 053e 01F4      		brne 1b
 1843 0540 0000      		nop
 1844               	.LVL148:
 1845               	.LBE180:
 1846               	.LBE179:
 747:setup.c       **** 	_delay_us(50);
 748:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1847               		.loc 1 748 0
 1848 0542 3A9A      		sbi 0x7,2
 1849               	.LVL149:
 1850               	.LBB181:
 1851               	.LBB182:
 1852               		.loc 2 276 0
 1853 0544 85E8      		ldi r24,lo8(-123)
 1854 0546 8A95      	1:	dec r24
 1855 0548 01F4      		brne 1b
 1856 054a 0000      		nop
 1857               	.LVL150:
 1858               	/* epilogue start */
 1859               	.LBE182:
 1860               	.LBE181:
 749:setup.c       **** 	_delay_us(50);
 750:setup.c       **** }
 1861               		.loc 1 750 0
 1862 054c DF91      		pop r29
 1863 054e CF91      		pop r28
 1864               	.LVL151:
 1865 0550 1F91      		pop r17
 1866               	.LVL152:
 1867 0552 0895      		ret
 1868               		.cfi_endproc
 1869               	.LFE41:
 1871               	.global	gb_flash_write_byte_bank1_commands
 1873               	gb_flash_write_byte_bank1_commands:
 1874               	.LFB42:
 751:setup.c       **** 
 752:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 753:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 754:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1875               		.loc 1 754 0
 1876               		.cfi_startproc
 1877               	.LVL153:
 1878 0554 FF92      		push r15
 1879               	.LCFI32:
 1880               		.cfi_def_cfa_offset 3
 1881               		.cfi_offset 15, -2
 1882 0556 0F93      		push r16
 1883               	.LCFI33:
 1884               		.cfi_def_cfa_offset 4
 1885               		.cfi_offset 16, -3
 1886 0558 1F93      		push r17
 1887               	.LCFI34:
 1888               		.cfi_def_cfa_offset 5
 1889               		.cfi_offset 17, -4
 1890 055a CF93      		push r28
 1891               	.LCFI35:
 1892               		.cfi_def_cfa_offset 6
 1893               		.cfi_offset 28, -5
 1894 055c DF93      		push r29
 1895               	.LCFI36:
 1896               		.cfi_def_cfa_offset 7
 1897               		.cfi_offset 29, -6
 1898               	/* prologue: function */
 1899               	/* frame size = 0 */
 1900               	/* stack size = 5 */
 1901               	.L__stack_usage = 5
 1902 055e EC01      		movw r28,r24
 1903 0560 162F      		mov r17,r22
 755:setup.c       **** 	// Set bank 1
 756:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1904               		.loc 1 756 0
 1905 0562 FF24      		clr r15
 1906 0564 FA94      		dec r15
 1907 0566 F4BA      		out 0x14,r15
 1908               	.LVL154:
 1909               	.LBB183:
 1910               	.LBB184:
 253:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1911               		.loc 1 253 0
 1912 0568 01E2      		ldi r16,lo8(33)
 1913 056a 0BBB      		out 0x1b,r16
 254:setup.c       **** }
 1914               		.loc 1 254 0
 1915 056c 18BA      		out 0x18,__zero_reg__
 1916               	.LVL155:
 1917               	.LBE184:
 1918               	.LBE183:
 757:setup.c       **** 	set_16bit_address(0x2100);
 758:setup.c       **** 	PORT_DATA7_0 = 1;
 1919               		.loc 1 758 0
 1920 056e 81E0      		ldi r24,lo8(1)
 1921               	.LVL156:
 1922 0570 85BB      		out 0x15,r24
 759:setup.c       **** 	wrPin_low; // Pulse WR
 1923               		.loc 1 759 0
 1924 0572 9698      		cbi 0x12,6
 760:setup.c       **** 	asm volatile("nop");
 1925               		.loc 1 760 0
 1926               	/* #APP */
 1927               	 ;  760 "setup.c" 1
 1928 0574 0000      		nop
 1929               	 ;  0 "" 2
 761:setup.c       **** 	wrPin_high;
 1930               		.loc 1 761 0
 1931               	/* #NOAPP */
 1932 0576 969A      		sbi 0x12,6
 762:setup.c       **** 	
 763:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1933               		.loc 1 763 0
 1934 0578 6091 0000 		lds r22,flashWriteCycle+2
 1935               	.LVL157:
 1936 057c 8091 0000 		lds r24,flashWriteCycle
 1937 0580 9091 0000 		lds r25,flashWriteCycle+1
 1938 0584 00D0      		rcall gb_flash_write_bus_cycle
 1939               	.LVL158:
 764:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1940               		.loc 1 764 0
 1941 0586 6091 0000 		lds r22,flashWriteCycle+6
 1942 058a 8091 0000 		lds r24,flashWriteCycle+4
 1943 058e 9091 0000 		lds r25,flashWriteCycle+4+1
 1944 0592 00D0      		rcall gb_flash_write_bus_cycle
 1945               	.LVL159:
 765:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1946               		.loc 1 765 0
 1947 0594 6091 0000 		lds r22,flashWriteCycle+10
 1948 0598 8091 0000 		lds r24,flashWriteCycle+8
 1949 059c 9091 0000 		lds r25,flashWriteCycle+8+1
 1950 05a0 00D0      		rcall gb_flash_write_bus_cycle
 1951               	.LVL160:
 766:setup.c       **** 	
 767:setup.c       **** 	
 768:setup.c       **** 	// Set bank back
 769:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1952               		.loc 1 769 0
 1953 05a2 F4BA      		out 0x14,r15
 1954               	.LVL161:
 1955               	.LBB185:
 1956               	.LBB186:
 253:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1957               		.loc 1 253 0
 1958 05a4 0BBB      		out 0x1b,r16
 254:setup.c       **** }
 1959               		.loc 1 254 0
 1960 05a6 18BA      		out 0x18,__zero_reg__
 1961               	.LVL162:
 1962               	.LBE186:
 1963               	.LBE185:
 770:setup.c       **** 	set_16bit_address(0x2100);
 771:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1964               		.loc 1 771 0
 1965 05a8 8091 0000 		lds r24,lastBankAccessed
 1966 05ac 85BB      		out 0x15,r24
 772:setup.c       **** 	wrPin_low; // Pulse WR
 1967               		.loc 1 772 0
 1968 05ae 9698      		cbi 0x12,6
 773:setup.c       **** 	asm volatile("nop");
 1969               		.loc 1 773 0
 1970               	/* #APP */
 1971               	 ;  773 "setup.c" 1
 1972 05b0 0000      		nop
 1973               	 ;  0 "" 2
 774:setup.c       **** 	wrPin_high;
 1974               		.loc 1 774 0
 1975               	/* #NOAPP */
 1976 05b2 969A      		sbi 0x12,6
 775:setup.c       **** 	
 776:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1977               		.loc 1 776 0
 1978 05b4 612F      		mov r22,r17
 1979 05b6 CE01      		movw r24,r28
 1980 05b8 00D0      		rcall gb_flash_write_bus_cycle
 1981               	.LVL163:
 1982               	.LBB187:
 1983               	.LBB188:
 1984               		.loc 2 276 0
 1985 05ba 8AE1      		ldi r24,lo8(26)
 1986 05bc 8A95      	1:	dec r24
 1987 05be 01F4      		brne 1b
 1988 05c0 00C0      		rjmp .
 1989               	.LVL164:
 1990               	.LBE188:
 1991               	.LBE187:
 777:setup.c       **** 	_delay_us(10); // Wait byte program time
 778:setup.c       **** 	
 779:setup.c       **** 	// Set data pins inputs
 780:setup.c       **** 	PORT_DATA7_0 = 0;
 1992               		.loc 1 780 0
 1993 05c2 15BA      		out 0x15,__zero_reg__
 781:setup.c       **** 	DDR_DATA7_0 = 0;
 1994               		.loc 1 781 0
 1995 05c4 14BA      		out 0x14,__zero_reg__
 782:setup.c       **** 	
 783:setup.c       **** 	// Verify data
 784:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1996               		.loc 1 784 0
 1997 05c6 CE01      		movw r24,r28
 1998 05c8 00D0      		rcall gb_flash_read_byte
 1999               	.LVL165:
 2000               	.L83:
 785:setup.c       **** 	while (data != dataVerify) {
 2001               		.loc 1 785 0
 2002 05ca 8117      		cp r24,r17
 2003 05cc 01F0      		breq .L85
 786:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2004               		.loc 1 786 0
 2005 05ce CE01      		movw r24,r28
 2006               	.LVL166:
 2007 05d0 00D0      		rcall gb_flash_read_byte
 2008               	.LVL167:
 2009               	.LBB189:
 2010               	.LBB190:
 2011               		.loc 2 276 0
 2012 05d2 9DE0      		ldi r25,lo8(13)
 2013 05d4 9A95      	1:	dec r25
 2014 05d6 01F4      		brne 1b
 2015 05d8 0000      		nop
 2016 05da 00C0      		rjmp .L83
 2017               	.LVL168:
 2018               	.L85:
 2019               	/* epilogue start */
 2020               	.LBE190:
 2021               	.LBE189:
 787:setup.c       **** 		_delay_us(5);
 788:setup.c       **** 	}
 789:setup.c       **** }
 2022               		.loc 1 789 0
 2023 05dc DF91      		pop r29
 2024 05de CF91      		pop r28
 2025               	.LVL169:
 2026 05e0 1F91      		pop r17
 2027               	.LVL170:
 2028 05e2 0F91      		pop r16
 2029 05e4 FF90      		pop r15
 2030 05e6 0895      		ret
 2031               		.cfi_endproc
 2032               	.LFE42:
 2034               	.global	gba_flash_write_bus_cycle
 2036               	gba_flash_write_bus_cycle:
 2037               	.LFB43:
 790:setup.c       **** 
 791:setup.c       **** 
 792:setup.c       **** 
 793:setup.c       **** // ---------- GBA FLASH CARTS ----------
 794:setup.c       **** 
 795:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 796:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2038               		.loc 1 796 0
 2039               		.cfi_startproc
 2040               	.LVL171:
 2041 05e8 0F93      		push r16
 2042               	.LCFI37:
 2043               		.cfi_def_cfa_offset 3
 2044               		.cfi_offset 16, -2
 2045 05ea 1F93      		push r17
 2046               	.LCFI38:
 2047               		.cfi_def_cfa_offset 4
 2048               		.cfi_offset 17, -3
 2049               	/* prologue: function */
 2050               	/* frame size = 0 */
 2051               	/* stack size = 2 */
 2052               	.L__stack_usage = 2
 797:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 2053               		.loc 1 797 0
 2054 05ec 8C01      		movw r16,r24
 2055 05ee 2227      		clr r18
 2056 05f0 3327      		clr r19
 2057 05f2 05BB      		out 0x15,r16
 798:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 2058               		.loc 1 798 0
 2059 05f4 072F      		mov r16,r23
 2060 05f6 182F      		mov r17,r24
 2061 05f8 292F      		mov r18,r25
 2062 05fa 3327      		clr r19
 2063 05fc 0BBB      		out 0x1b,r16
 799:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 2064               		.loc 1 799 0
 2065 05fe 68BB      		out 0x18,r22
 800:setup.c       **** 	
 801:setup.c       **** 	cs_mreqPin_low;
 2066               		.loc 1 801 0
 2067 0600 9498      		cbi 0x12,4
 802:setup.c       **** 	
 803:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2068               		.loc 1 803 0
 2069 0602 5BBB      		out 0x1b,r21
 804:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2070               		.loc 1 804 0
 2071 0604 48BB      		out 0x18,r20
 805:setup.c       **** 	
 806:setup.c       **** 	wrPin_low;
 2072               		.loc 1 806 0
 2073 0606 9698      		cbi 0x12,6
 807:setup.c       **** 	asm volatile("nop");
 2074               		.loc 1 807 0
 2075               	/* #APP */
 2076               	 ;  807 "setup.c" 1
 2077 0608 0000      		nop
 2078               	 ;  0 "" 2
 808:setup.c       **** 	asm volatile("nop");
 2079               		.loc 1 808 0
 2080               	 ;  808 "setup.c" 1
 2081 060a 0000      		nop
 2082               	 ;  0 "" 2
 809:setup.c       **** 	asm volatile("nop");
 2083               		.loc 1 809 0
 2084               	 ;  809 "setup.c" 1
 2085 060c 0000      		nop
 2086               	 ;  0 "" 2
 810:setup.c       **** 	wrPin_high;
 2087               		.loc 1 810 0
 2088               	/* #NOAPP */
 2089 060e 969A      		sbi 0x12,6
 811:setup.c       **** 	cs_mreqPin_high;
 2090               		.loc 1 811 0
 2091 0610 949A      		sbi 0x12,4
 2092               	/* epilogue start */
 812:setup.c       **** }
 2093               		.loc 1 812 0
 2094 0612 1F91      		pop r17
 2095 0614 0F91      		pop r16
 2096 0616 0895      		ret
 2097               		.cfi_endproc
 2098               	.LFE43:
 2100               	.global	gba_flash_write_cycle_start_swapped
 2102               	gba_flash_write_cycle_start_swapped:
 2103               	.LFB44:
 813:setup.c       **** 
 814:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 815:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2104               		.loc 1 815 0
 2105               		.cfi_startproc
 2106               	/* prologue: function */
 2107               	/* frame size = 0 */
 2108               	/* stack size = 0 */
 2109               	.L__stack_usage = 0
 816:setup.c       **** 	// Set outputs
 817:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2110               		.loc 1 817 0
 2111 0618 8FEF      		ldi r24,lo8(-1)
 2112 061a 84BB      		out 0x14,r24
 818:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2113               		.loc 1 818 0
 2114 061c 8ABB      		out 0x1a,r24
 819:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2115               		.loc 1 819 0
 2116 061e 87BB      		out 0x17,r24
 820:setup.c       **** 	
 821:setup.c       **** 	// 0x555, 0xA9
 822:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2117               		.loc 1 822 0
 2118 0620 15BA      		out 0x15,__zero_reg__
 823:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2119               		.loc 1 823 0
 2120 0622 95E0      		ldi r25,lo8(5)
 2121 0624 9BBB      		out 0x1b,r25
 824:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2122               		.loc 1 824 0
 2123 0626 85E5      		ldi r24,lo8(85)
 2124 0628 88BB      		out 0x18,r24
 825:setup.c       **** 	cs_mreqPin_low;
 2125               		.loc 1 825 0
 2126 062a 9498      		cbi 0x12,4
 826:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2127               		.loc 1 826 0
 2128 062c 1BBA      		out 0x1b,__zero_reg__
 827:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2129               		.loc 1 827 0
 2130 062e 29EA      		ldi r18,lo8(-87)
 2131 0630 28BB      		out 0x18,r18
 828:setup.c       **** 	wrPin_low;
 2132               		.loc 1 828 0
 2133 0632 9698      		cbi 0x12,6
 829:setup.c       **** 	asm volatile("nop");
 2134               		.loc 1 829 0
 2135               	/* #APP */
 2136               	 ;  829 "setup.c" 1
 2137 0634 0000      		nop
 2138               	 ;  0 "" 2
 830:setup.c       **** 	asm volatile("nop");
 2139               		.loc 1 830 0
 2140               	 ;  830 "setup.c" 1
 2141 0636 0000      		nop
 2142               	 ;  0 "" 2
 831:setup.c       **** 	asm volatile("nop");
 2143               		.loc 1 831 0
 2144               	 ;  831 "setup.c" 1
 2145 0638 0000      		nop
 2146               	 ;  0 "" 2
 832:setup.c       **** 	wrPin_high;
 2147               		.loc 1 832 0
 2148               	/* #NOAPP */
 2149 063a 969A      		sbi 0x12,6
 833:setup.c       **** 	cs_mreqPin_high;
 2150               		.loc 1 833 0
 2151 063c 949A      		sbi 0x12,4
 834:setup.c       **** 	
 835:setup.c       **** 	// 0x2AA, 0x56
 836:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2152               		.loc 1 836 0
 2153 063e 15BA      		out 0x15,__zero_reg__
 837:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2154               		.loc 1 837 0
 2155 0640 22E0      		ldi r18,lo8(2)
 2156 0642 2BBB      		out 0x1b,r18
 838:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2157               		.loc 1 838 0
 2158 0644 2AEA      		ldi r18,lo8(-86)
 2159 0646 28BB      		out 0x18,r18
 839:setup.c       **** 	cs_mreqPin_low;
 2160               		.loc 1 839 0
 2161 0648 9498      		cbi 0x12,4
 840:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2162               		.loc 1 840 0
 2163 064a 1BBA      		out 0x1b,__zero_reg__
 841:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2164               		.loc 1 841 0
 2165 064c 26E5      		ldi r18,lo8(86)
 2166 064e 28BB      		out 0x18,r18
 842:setup.c       **** 	wrPin_low;
 2167               		.loc 1 842 0
 2168 0650 9698      		cbi 0x12,6
 843:setup.c       **** 	asm volatile("nop");
 2169               		.loc 1 843 0
 2170               	/* #APP */
 2171               	 ;  843 "setup.c" 1
 2172 0652 0000      		nop
 2173               	 ;  0 "" 2
 844:setup.c       **** 	asm volatile("nop");
 2174               		.loc 1 844 0
 2175               	 ;  844 "setup.c" 1
 2176 0654 0000      		nop
 2177               	 ;  0 "" 2
 845:setup.c       **** 	asm volatile("nop");
 2178               		.loc 1 845 0
 2179               	 ;  845 "setup.c" 1
 2180 0656 0000      		nop
 2181               	 ;  0 "" 2
 846:setup.c       **** 	wrPin_high;
 2182               		.loc 1 846 0
 2183               	/* #NOAPP */
 2184 0658 969A      		sbi 0x12,6
 847:setup.c       **** 	cs_mreqPin_high;
 2185               		.loc 1 847 0
 2186 065a 949A      		sbi 0x12,4
 848:setup.c       **** 	
 849:setup.c       **** 	// 0x555, 0xA0;
 850:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2187               		.loc 1 850 0
 2188 065c 15BA      		out 0x15,__zero_reg__
 851:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2189               		.loc 1 851 0
 2190 065e 9BBB      		out 0x1b,r25
 852:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2191               		.loc 1 852 0
 2192 0660 88BB      		out 0x18,r24
 853:setup.c       **** 	cs_mreqPin_low;
 2193               		.loc 1 853 0
 2194 0662 9498      		cbi 0x12,4
 854:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2195               		.loc 1 854 0
 2196 0664 1BBA      		out 0x1b,__zero_reg__
 855:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2197               		.loc 1 855 0
 2198 0666 80EA      		ldi r24,lo8(-96)
 2199 0668 88BB      		out 0x18,r24
 856:setup.c       **** 	wrPin_low;
 2200               		.loc 1 856 0
 2201 066a 9698      		cbi 0x12,6
 857:setup.c       **** 	asm volatile("nop");
 2202               		.loc 1 857 0
 2203               	/* #APP */
 2204               	 ;  857 "setup.c" 1
 2205 066c 0000      		nop
 2206               	 ;  0 "" 2
 858:setup.c       **** 	asm volatile("nop");
 2207               		.loc 1 858 0
 2208               	 ;  858 "setup.c" 1
 2209 066e 0000      		nop
 2210               	 ;  0 "" 2
 859:setup.c       **** 	asm volatile("nop");
 2211               		.loc 1 859 0
 2212               	 ;  859 "setup.c" 1
 2213 0670 0000      		nop
 2214               	 ;  0 "" 2
 860:setup.c       **** 	wrPin_high;
 2215               		.loc 1 860 0
 2216               	/* #NOAPP */
 2217 0672 969A      		sbi 0x12,6
 861:setup.c       **** 	cs_mreqPin_high;
 2218               		.loc 1 861 0
 2219 0674 949A      		sbi 0x12,4
 2220 0676 0895      		ret
 2221               		.cfi_endproc
 2222               	.LFE44:
 2224               	.global	gba_flash_write_cycle_start
 2226               	gba_flash_write_cycle_start:
 2227               	.LFB45:
 862:setup.c       **** }
 863:setup.c       **** 
 864:setup.c       **** 
 865:setup.c       **** // Send the first 3 write cycles to the flash
 866:setup.c       **** void gba_flash_write_cycle_start(void) {
 2228               		.loc 1 866 0
 2229               		.cfi_startproc
 2230               	/* prologue: function */
 2231               	/* frame size = 0 */
 2232               	/* stack size = 0 */
 2233               	.L__stack_usage = 0
 867:setup.c       **** 	// Set outputs
 868:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2234               		.loc 1 868 0
 2235 0678 8FEF      		ldi r24,lo8(-1)
 2236 067a 84BB      		out 0x14,r24
 869:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2237               		.loc 1 869 0
 2238 067c 8ABB      		out 0x1a,r24
 870:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2239               		.loc 1 870 0
 2240 067e 87BB      		out 0x17,r24
 871:setup.c       **** 	
 872:setup.c       **** 	// 0x555, 0xAA
 873:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2241               		.loc 1 873 0
 2242 0680 15BA      		out 0x15,__zero_reg__
 874:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2243               		.loc 1 874 0
 2244 0682 95E0      		ldi r25,lo8(5)
 2245 0684 9BBB      		out 0x1b,r25
 875:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2246               		.loc 1 875 0
 2247 0686 85E5      		ldi r24,lo8(85)
 2248 0688 88BB      		out 0x18,r24
 876:setup.c       **** 	cs_mreqPin_low;
 2249               		.loc 1 876 0
 2250 068a 9498      		cbi 0x12,4
 877:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2251               		.loc 1 877 0
 2252 068c 1BBA      		out 0x1b,__zero_reg__
 878:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2253               		.loc 1 878 0
 2254 068e 2AEA      		ldi r18,lo8(-86)
 2255 0690 28BB      		out 0x18,r18
 879:setup.c       **** 	wrPin_low;
 2256               		.loc 1 879 0
 2257 0692 9698      		cbi 0x12,6
 880:setup.c       **** 	asm volatile("nop");
 2258               		.loc 1 880 0
 2259               	/* #APP */
 2260               	 ;  880 "setup.c" 1
 2261 0694 0000      		nop
 2262               	 ;  0 "" 2
 881:setup.c       **** 	asm volatile("nop");
 2263               		.loc 1 881 0
 2264               	 ;  881 "setup.c" 1
 2265 0696 0000      		nop
 2266               	 ;  0 "" 2
 882:setup.c       **** 	asm volatile("nop");
 2267               		.loc 1 882 0
 2268               	 ;  882 "setup.c" 1
 2269 0698 0000      		nop
 2270               	 ;  0 "" 2
 883:setup.c       **** 	wrPin_high;
 2271               		.loc 1 883 0
 2272               	/* #NOAPP */
 2273 069a 969A      		sbi 0x12,6
 884:setup.c       **** 	cs_mreqPin_high;
 2274               		.loc 1 884 0
 2275 069c 949A      		sbi 0x12,4
 885:setup.c       **** 	
 886:setup.c       **** 	// 0x2AA, 0x55
 887:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2276               		.loc 1 887 0
 2277 069e 15BA      		out 0x15,__zero_reg__
 888:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2278               		.loc 1 888 0
 2279 06a0 32E0      		ldi r19,lo8(2)
 2280 06a2 3BBB      		out 0x1b,r19
 889:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2281               		.loc 1 889 0
 2282 06a4 28BB      		out 0x18,r18
 890:setup.c       **** 	cs_mreqPin_low;
 2283               		.loc 1 890 0
 2284 06a6 9498      		cbi 0x12,4
 891:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2285               		.loc 1 891 0
 2286 06a8 1BBA      		out 0x1b,__zero_reg__
 892:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2287               		.loc 1 892 0
 2288 06aa 88BB      		out 0x18,r24
 893:setup.c       **** 	wrPin_low;
 2289               		.loc 1 893 0
 2290 06ac 9698      		cbi 0x12,6
 894:setup.c       **** 	asm volatile("nop");
 2291               		.loc 1 894 0
 2292               	/* #APP */
 2293               	 ;  894 "setup.c" 1
 2294 06ae 0000      		nop
 2295               	 ;  0 "" 2
 895:setup.c       **** 	asm volatile("nop");
 2296               		.loc 1 895 0
 2297               	 ;  895 "setup.c" 1
 2298 06b0 0000      		nop
 2299               	 ;  0 "" 2
 896:setup.c       **** 	asm volatile("nop");
 2300               		.loc 1 896 0
 2301               	 ;  896 "setup.c" 1
 2302 06b2 0000      		nop
 2303               	 ;  0 "" 2
 897:setup.c       **** 	wrPin_high;
 2304               		.loc 1 897 0
 2305               	/* #NOAPP */
 2306 06b4 969A      		sbi 0x12,6
 898:setup.c       **** 	cs_mreqPin_high;
 2307               		.loc 1 898 0
 2308 06b6 949A      		sbi 0x12,4
 899:setup.c       **** 	
 900:setup.c       **** 	// 0x555, 0xA0;
 901:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2309               		.loc 1 901 0
 2310 06b8 15BA      		out 0x15,__zero_reg__
 902:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2311               		.loc 1 902 0
 2312 06ba 9BBB      		out 0x1b,r25
 903:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2313               		.loc 1 903 0
 2314 06bc 88BB      		out 0x18,r24
 904:setup.c       **** 	cs_mreqPin_low;
 2315               		.loc 1 904 0
 2316 06be 9498      		cbi 0x12,4
 905:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2317               		.loc 1 905 0
 2318 06c0 1BBA      		out 0x1b,__zero_reg__
 906:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2319               		.loc 1 906 0
 2320 06c2 80EA      		ldi r24,lo8(-96)
 2321 06c4 88BB      		out 0x18,r24
 907:setup.c       **** 	wrPin_low;
 2322               		.loc 1 907 0
 2323 06c6 9698      		cbi 0x12,6
 908:setup.c       **** 	asm volatile("nop");
 2324               		.loc 1 908 0
 2325               	/* #APP */
 2326               	 ;  908 "setup.c" 1
 2327 06c8 0000      		nop
 2328               	 ;  0 "" 2
 909:setup.c       **** 	asm volatile("nop");
 2329               		.loc 1 909 0
 2330               	 ;  909 "setup.c" 1
 2331 06ca 0000      		nop
 2332               	 ;  0 "" 2
 910:setup.c       **** 	asm volatile("nop");
 2333               		.loc 1 910 0
 2334               	 ;  910 "setup.c" 1
 2335 06cc 0000      		nop
 2336               	 ;  0 "" 2
 911:setup.c       **** 	wrPin_high;
 2337               		.loc 1 911 0
 2338               	/* #NOAPP */
 2339 06ce 969A      		sbi 0x12,6
 912:setup.c       **** 	cs_mreqPin_high;
 2340               		.loc 1 912 0
 2341 06d0 949A      		sbi 0x12,4
 2342 06d2 0895      		ret
 2343               		.cfi_endproc
 2344               	.LFE45:
 2346               	.global	gba_flash_write_byte
 2348               	gba_flash_write_byte:
 2349               	.LFB46:
 913:setup.c       **** }	
 914:setup.c       **** 
 915:setup.c       **** 
 916:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 917:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 918:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2350               		.loc 1 918 0
 2351               		.cfi_startproc
 2352               	.LVL172:
 2353 06d4 CF92      		push r12
 2354               	.LCFI39:
 2355               		.cfi_def_cfa_offset 3
 2356               		.cfi_offset 12, -2
 2357 06d6 DF92      		push r13
 2358               	.LCFI40:
 2359               		.cfi_def_cfa_offset 4
 2360               		.cfi_offset 13, -3
 2361 06d8 EF92      		push r14
 2362               	.LCFI41:
 2363               		.cfi_def_cfa_offset 5
 2364               		.cfi_offset 14, -4
 2365 06da FF92      		push r15
 2366               	.LCFI42:
 2367               		.cfi_def_cfa_offset 6
 2368               		.cfi_offset 15, -5
 2369 06dc CF93      		push r28
 2370               	.LCFI43:
 2371               		.cfi_def_cfa_offset 7
 2372               		.cfi_offset 28, -6
 2373 06de DF93      		push r29
 2374               	.LCFI44:
 2375               		.cfi_def_cfa_offset 8
 2376               		.cfi_offset 29, -7
 2377               	/* prologue: function */
 2378               	/* frame size = 0 */
 2379               	/* stack size = 6 */
 2380               	.L__stack_usage = 6
 2381 06e0 6B01      		movw r12,r22
 2382 06e2 7C01      		movw r14,r24
 2383 06e4 EA01      		movw r28,r20
 919:setup.c       **** 	if (isD0D1Swapped == 0) {
 2384               		.loc 1 919 0
 2385 06e6 2111      		cpse r18,__zero_reg__
 2386 06e8 00C0      		rjmp .L90
 920:setup.c       **** 		gba_flash_write_cycle_start();
 2387               		.loc 1 920 0
 2388 06ea 00D0      		rcall gba_flash_write_cycle_start
 2389               	.LVL173:
 2390 06ec 00C0      		rjmp .L91
 2391               	.LVL174:
 2392               	.L90:
 921:setup.c       **** 	}
 922:setup.c       **** 	else {
 923:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2393               		.loc 1 923 0
 2394 06ee 00D0      		rcall gba_flash_write_cycle_start_swapped
 2395               	.LVL175:
 2396               	.L91:
 924:setup.c       **** 	}
 925:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2397               		.loc 1 925 0
 2398 06f0 AE01      		movw r20,r28
 2399 06f2 C701      		movw r24,r14
 2400 06f4 B601      		movw r22,r12
 2401 06f6 00D0      		rcall gba_flash_write_bus_cycle
 2402               	.LVL176:
 2403               	.LBB191:
 2404               	.LBB192:
 2405               		.loc 2 276 0
 2406 06f8 25E0      		ldi r18,lo8(5)
 2407 06fa 2A95      	1:	dec r18
 2408 06fc 01F4      		brne 1b
 2409 06fe 0000      		nop
 2410               	.LVL177:
 2411               	.LBE192:
 2412               	.LBE191:
 926:setup.c       **** 	_delay_us(2); // Wait byte program time
 927:setup.c       **** 	
 928:setup.c       **** 	// Verify data
 929:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2413               		.loc 1 929 0
 2414 0700 C701      		movw r24,r14
 2415 0702 B601      		movw r22,r12
 2416 0704 00D0      		rcall gba_read_16bit_data
 2417               	.LVL178:
 2418               	.L92:
 930:setup.c       **** 	while (data != dataVerify) {
 2419               		.loc 1 930 0
 2420 0706 8C17      		cp r24,r28
 2421 0708 9D07      		cpc r25,r29
 2422 070a 01F0      		breq .L94
 931:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2423               		.loc 1 931 0
 2424 070c C701      		movw r24,r14
 2425 070e B601      		movw r22,r12
 2426 0710 00D0      		rcall gba_read_16bit_data
 2427               	.LVL179:
 2428               	.LBB193:
 2429               	.LBB194:
 2430               		.loc 2 276 0
 2431 0712 25E0      		ldi r18,lo8(5)
 2432 0714 2A95      	1:	dec r18
 2433 0716 01F4      		brne 1b
 2434 0718 0000      		nop
 2435 071a 00C0      		rjmp .L92
 2436               	.LVL180:
 2437               	.L94:
 2438               	/* epilogue start */
 2439               	.LBE194:
 2440               	.LBE193:
 932:setup.c       **** 		_delay_us(2);
 933:setup.c       **** 	}
 934:setup.c       **** }
 2441               		.loc 1 934 0
 2442 071c DF91      		pop r29
 2443 071e CF91      		pop r28
 2444               	.LVL181:
 2445 0720 FF90      		pop r15
 2446 0722 EF90      		pop r14
 2447 0724 DF90      		pop r13
 2448 0726 CF90      		pop r12
 2449               	.LVL182:
 2450 0728 0895      		ret
 2451               		.cfi_endproc
 2452               	.LFE46:
 2454               	.global	setup
 2456               	setup:
 2457               	.LFB47:
 935:setup.c       **** 
 936:setup.c       **** 
 937:setup.c       **** // Setup
 938:setup.c       **** void setup(void) {
 2458               		.loc 1 938 0
 2459               		.cfi_startproc
 2460               	/* prologue: function */
 2461               	/* frame size = 0 */
 2462               	/* stack size = 0 */
 2463               	.L__stack_usage = 0
 939:setup.c       **** 	// Turn off watchdog
 940:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2464               		.loc 1 940 0
 2465 072a 84B7      		in r24,0x34
 2466 072c 877F      		andi r24,lo8(-9)
 2467 072e 84BF      		out 0x34,r24
 941:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2468               		.loc 1 941 0
 2469 0730 88E1      		ldi r24,lo8(24)
 2470 0732 81BD      		out 0x21,r24
 942:setup.c       **** 	WDTCR = 0;
 2471               		.loc 1 942 0
 2472 0734 11BC      		out 0x21,__zero_reg__
 943:setup.c       **** 	
 944:setup.c       **** 	// Reset common lines
 945:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2473               		.loc 1 945 0
 2474 0736 00D0      		rcall rd_wr_csmreq_cs2_reset
 2475               	.LVL183:
 946:setup.c       **** 	
 947:setup.c       **** 	// Set outputs
 948:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2476               		.loc 1 948 0
 2477 0738 81B3      		in r24,0x11
 2478 073a 8C6F      		ori r24,lo8(-4)
 2479 073c 81BB      		out 0x11,r24
 949:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2480               		.loc 1 949 0
 2481 073e 86B1      		in r24,0x6
 2482 0740 8560      		ori r24,lo8(5)
 2483 0742 86B9      		out 0x6,r24
 950:setup.c       **** 	
 951:setup.c       **** 	// Set all pins as inputs
 952:setup.c       **** 	PORT_DATA7_0 = 0;
 2484               		.loc 1 952 0
 2485 0744 15BA      		out 0x15,__zero_reg__
 953:setup.c       **** 	DDR_DATA7_0 = 0;
 2486               		.loc 1 953 0
 2487 0746 14BA      		out 0x14,__zero_reg__
 954:setup.c       **** 	PORT_ADDR7_0 = 0;
 2488               		.loc 1 954 0
 2489 0748 18BA      		out 0x18,__zero_reg__
 955:setup.c       **** 	DDR_ADDR7_0 = 0;
 2490               		.loc 1 955 0
 2491 074a 17BA      		out 0x17,__zero_reg__
 956:setup.c       **** 	PORT_ADDR15_8 = 0;
 2492               		.loc 1 956 0
 2493 074c 1BBA      		out 0x1b,__zero_reg__
 957:setup.c       **** 	DDR_ADDR15_8 = 0;
 2494               		.loc 1 957 0
 2495 074e 1ABA      		out 0x1a,__zero_reg__
 958:setup.c       **** 	
 959:setup.c       **** 	// Light up 3.3V or 5V
 960:setup.c       **** 	if (cartMode == GB_MODE) {
 2496               		.loc 1 960 0
 2497 0750 8091 0000 		lds r24,cartMode
 2498 0754 8130      		cpi r24,lo8(1)
 2499 0756 01F4      		brne .L96
 961:setup.c       **** 		PORTD |= (1<<LED_5V);
 2500               		.loc 1 961 0
 2501 0758 979A      		sbi 0x12,7
 962:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2502               		.loc 1 962 0
 2503 075a 3898      		cbi 0x7,0
 2504 075c 00C0      		rjmp .L97
 2505               	.L96:
 963:setup.c       **** 	}
 964:setup.c       **** 	else {
 965:setup.c       **** 		PORTE |= (1<<LED_3V);
 2506               		.loc 1 965 0
 2507 075e 389A      		sbi 0x7,0
 966:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2508               		.loc 1 966 0
 2509 0760 9798      		cbi 0x12,7
 2510               	.L97:
 967:setup.c       **** 	}
 968:setup.c       **** 	
 969:setup.c       **** 	// Light LED
 970:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2511               		.loc 1 970 0
 2512 0762 939A      		sbi 0x12,3
 2513               	.LVL184:
 2514               	.LBB195:
 2515               	.LBB196:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2516               		.loc 2 187 0
 2517 0764 2FEF      		ldi r18,lo8(799999)
 2518 0766 84E3      		ldi r24,hi8(799999)
 2519 0768 9CE0      		ldi r25,hlo8(799999)
 2520 076a 2150      	1:	subi r18,1
 2521 076c 8040      		sbci r24,0
 2522 076e 9040      		sbci r25,0
 2523 0770 01F4      		brne 1b
 2524 0772 00C0      		rjmp .
 2525 0774 0000      		nop
 2526               	.LVL185:
 2527               	.LBE196:
 2528               	.LBE195:
 971:setup.c       **** 	_delay_ms(500);
 972:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2529               		.loc 1 972 0
 2530 0776 9398      		cbi 0x12,3
 973:setup.c       **** 	
 974:setup.c       **** 	// Setup USART
 975:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2531               		.loc 1 975 0
 2532 0778 19B8      		out 0x9,__zero_reg__
 976:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2533               		.loc 1 976 0
 2534 077a 599A      		sbi 0xb,1
 977:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2535               		.loc 1 977 0
 2536 077c 539A      		sbi 0xa,3
 978:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2537               		.loc 1 978 0
 2538 077e 549A      		sbi 0xa,4
 979:setup.c       **** 	
 980:setup.c       **** 	// Turn on interrupts
 981:setup.c       **** 	sei();
 2539               		.loc 1 981 0
 2540               	/* #APP */
 2541               	 ;  981 "setup.c" 1
 2542 0780 7894      		sei
 2543               	 ;  0 "" 2
 2544               	/* #NOAPP */
 2545 0782 0895      		ret
 2546               		.cfi_endproc
 2547               	.LFE47:
 2549               		.section	.text.startup,"ax",@progbits
 2550               	.global	main
 2552               	main:
 2553               	.LFB48:
 2554               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R18
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 3/07/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 4
  53:main.c        **** #define FIRMWARE_VERSION 18
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2555               		.loc 3 66 0
 2556               		.cfi_startproc
 2557 0000 CF93      		push r28
 2558               	.LCFI45:
 2559               		.cfi_def_cfa_offset 3
 2560               		.cfi_offset 28, -2
 2561 0002 DF93      		push r29
 2562               	.LCFI46:
 2563               		.cfi_def_cfa_offset 4
 2564               		.cfi_offset 29, -3
 2565 0004 CDB7      		in r28,__SP_L__
 2566 0006 DEB7      		in r29,__SP_H__
 2567               	.LCFI47:
 2568               		.cfi_def_cfa_register 28
 2569 0008 2897      		sbiw r28,8
 2570               	.LCFI48:
 2571               		.cfi_def_cfa_offset 12
 2572 000a 0FB6      		in __tmp_reg__,__SREG__
 2573 000c F894      		cli
 2574 000e DEBF      		out __SP_H__,r29
 2575 0010 0FBE      		out __SREG__,__tmp_reg__
 2576 0012 CDBF      		out __SP_L__,r28
 2577               	/* prologue: function */
 2578               	/* frame size = 8 */
 2579               	/* stack size = 10 */
 2580               	.L__stack_usage = 10
  67:main.c        **** 	setup();
 2581               		.loc 3 67 0
 2582 0014 00D0      		rcall setup
 2583               	.LVL186:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t resetCommonLines = 1;
 2584               		.loc 3 71 0
 2585 0016 21E0      		ldi r18,lo8(1)
 2586 0018 2D83      		std Y+5,r18
  70:main.c        **** 	uint8_t resetCommonLines = 1;
 2587               		.loc 3 70 0
 2588 001a 81E0      		ldi r24,lo8(1)
 2589 001c 8887      		std Y+8,r24
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2590               		.loc 3 69 0
 2591 001e C12C      		mov r12,__zero_reg__
 2592 0020 D12C      		mov r13,__zero_reg__
 2593 0022 7601      		movw r14,r12
 2594               	.LVL187:
 2595               	.L99:
  72:main.c        **** 	
  73:main.c        **** 	while(1) {
  74:main.c        **** 		if (resetCommonLines == 1) {
 2596               		.loc 3 74 0
 2597 0024 AD81      		ldd r26,Y+5
 2598 0026 A130      		cpi r26,lo8(1)
 2599 0028 01F4      		brne .L100
 2600               	.LVL188:
 2601               	.L291:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2602               		.loc 3 75 0
 2603 002a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2604               	.LVL189:
 2605               	.L100:
  76:main.c        **** 		}
  77:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2606               		.loc 3 77 0
 2607 002c 00D0      		rcall USART_Receive
 2608               	.LVL190:
 2609 002e 8093 0000 		sts receivedChar,r24
  78:main.c        **** 		
  79:main.c        **** 		// Return the cart mode in use
  80:main.c        **** 		if (receivedChar == CART_MODE) {
 2610               		.loc 3 80 0
 2611 0032 8334      		cpi r24,lo8(67)
 2612 0034 01F4      		brne .L101
  81:main.c        **** 			USART_Transmit(cartMode);
 2613               		.loc 3 81 0
 2614 0036 8091 0000 		lds r24,cartMode
 2615 003a 00C0      		rjmp .L292
 2616               	.L101:
  82:main.c        **** 		}
  83:main.c        **** 		
  84:main.c        **** 		// Change to GB mode or GBA mode if requested
  85:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2617               		.loc 3 85 0
 2618 003c 8734      		cpi r24,lo8(71)
 2619 003e 01F4      		brne .L103
  86:main.c        **** 			gb_mode();
 2620               		.loc 3 86 0
 2621 0040 00D0      		rcall gb_mode
 2622               	.LVL191:
 2623 0042 00C0      		rjmp .L99
 2624               	.L103:
  87:main.c        **** 		}
  88:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2625               		.loc 3 88 0
 2626 0044 8736      		cpi r24,lo8(103)
 2627 0046 01F4      		brne .+2
 2628 0048 00C0      		rjmp .L294
  89:main.c        **** 			gba_mode();
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Switch voltage if requested
  93:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
 2629               		.loc 3 93 0
 2630 004a 8333      		cpi r24,lo8(51)
 2631 004c 01F4      		brne .L105
  94:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2632               		.loc 3 94 0
 2633 004e 9298      		cbi 0x12,2
  95:main.c        **** 			cartMode = GBA_MODE;
 2634               		.loc 3 95 0
 2635 0050 82E0      		ldi r24,lo8(2)
 2636 0052 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTE |= (1<<LED_3V);
 2637               		.loc 3 96 0
 2638 0056 389A      		sbi 0x7,0
  97:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2639               		.loc 3 97 0
 2640 0058 9798      		cbi 0x12,7
 2641 005a 00C0      		rjmp .L99
 2642               	.L105:
  98:main.c        **** 		}
  99:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
 2643               		.loc 3 99 0
 2644 005c 8533      		cpi r24,lo8(53)
 2645 005e 01F4      		brne .L106
 100:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2646               		.loc 3 100 0
 2647 0060 929A      		sbi 0x12,2
 101:main.c        **** 			cartMode = GB_MODE;
 2648               		.loc 3 101 0
 2649 0062 81E0      		ldi r24,lo8(1)
 2650 0064 8093 0000 		sts cartMode,r24
 102:main.c        **** 			PORTD |= (1<<LED_5V);
 2651               		.loc 3 102 0
 2652 0068 979A      		sbi 0x12,7
 103:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2653               		.loc 3 103 0
 2654 006a 3898      		cbi 0x7,0
 2655 006c 00C0      		rjmp .L99
 2656               	.L106:
 104:main.c        **** 		}
 105:main.c        **** 		
 106:main.c        **** 		
 107:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 108:main.c        **** 		
 109:main.c        **** 		// Set address
 110:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2657               		.loc 3 110 0
 2658 006e 8134      		cpi r24,lo8(65)
 2659 0070 01F4      		brne .L107
 111:main.c        **** 			usart_read_chars(); // Read start address
 2660               		.loc 3 111 0
 2661 0072 00D0      		rcall usart_read_chars
 2662               	.LVL192:
 112:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2663               		.loc 3 112 0
 2664 0074 40E1      		ldi r20,lo8(16)
 2665 0076 50E0      		ldi r21,0
 2666 0078 60E0      		ldi r22,0
 2667 007a 70E0      		ldi r23,0
 2668 007c 80E0      		ldi r24,lo8(receivedBuffer)
 2669 007e 90E0      		ldi r25,hi8(receivedBuffer)
 2670 0080 00D0      		rcall strtol
 2671               	.LVL193:
 2672 0082 6B01      		movw r12,r22
 2673 0084 7C01      		movw r14,r24
 2674               	.LVL194:
 2675 0086 00C0      		rjmp .L99
 2676               	.L107:
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 116:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2677               		.loc 3 116 0
 2678 0088 8235      		cpi r24,lo8(82)
 2679 008a 01F4      		brne .L108
 117:main.c        **** 			gb_mode();
 2680               		.loc 3 117 0
 2681 008c 00D0      		rcall gb_mode
 2682               	.LVL195:
 118:main.c        **** 			receivedChar = '1';
 2683               		.loc 3 118 0
 2684 008e B1E3      		ldi r27,lo8(49)
 2685 0090 B093 0000 		sts receivedChar,r27
 2686               	.LVL196:
 2687               	.L109:
 119:main.c        **** 			while (receivedChar == '1') {
 2688               		.loc 3 119 0
 2689 0094 8091 0000 		lds r24,receivedChar
 2690 0098 8133      		cpi r24,lo8(49)
 2691 009a 01F4      		brne .L99
 120:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2692               		.loc 3 120 0
 2693 009c 939A      		sbi 0x12,3
 2694               	.LVL197:
 2695 009e 00E0      		ldi r16,0
 2696 00a0 10E0      		ldi r17,0
 2697               	.LVL198:
 2698               	.L110:
 2699               	.LBB197:
 121:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 122:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2700               		.loc 3 122 0 discriminator 3
 2701 00a2 C801      		movw r24,r16
 2702 00a4 8C0D      		add r24,r12
 2703 00a6 9D1D      		adc r25,r13
 2704 00a8 00D0      		rcall read_8bit_data
 2705               	.LVL199:
 2706 00aa 00D0      		rcall USART_Transmit
 2707               	.LVL200:
 2708 00ac 0F5F      		subi r16,-1
 2709 00ae 1F4F      		sbci r17,-1
 2710               	.LVL201:
 121:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2711               		.loc 3 121 0 discriminator 3
 2712 00b0 0034      		cpi r16,64
 2713 00b2 1105      		cpc r17,__zero_reg__
 2714 00b4 01F4      		brne .L110
 2715 00b6 E0E4      		ldi r30,64
 2716 00b8 CE0E      		add r12,r30
 2717 00ba D11C      		adc r13,__zero_reg__
 2718 00bc E11C      		adc r14,__zero_reg__
 2719 00be F11C      		adc r15,__zero_reg__
 2720               	.LBE197:
 123:main.c        **** 					address++;
 124:main.c        **** 				}
 125:main.c        **** 				
 126:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2721               		.loc 3 126 0
 2722 00c0 9398      		cbi 0x12,3
 127:main.c        **** 				receivedChar = USART_Receive();
 2723               		.loc 3 127 0
 2724 00c2 00D0      		rcall USART_Receive
 2725               	.LVL202:
 2726 00c4 8093 0000 		sts receivedChar,r24
 2727 00c8 00C0      		rjmp .L109
 2728               	.LVL203:
 2729               	.L108:
 128:main.c        **** 			}
 129:main.c        **** 		}
 130:main.c        **** 		
 131:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 132:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2730               		.loc 3 132 0
 2731 00ca 8735      		cpi r24,lo8(87)
 2732 00cc 01F4      		brne .L112
 133:main.c        **** 			gb_mode();
 2733               		.loc 3 133 0
 2734 00ce 00D0      		rcall gb_mode
 2735               	.LVL204:
 134:main.c        **** 			
 135:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 136:main.c        **** 			usart_read_bytes(64);
 2736               		.loc 3 136 0
 2737 00d0 80E4      		ldi r24,lo8(64)
 2738 00d2 90E0      		ldi r25,0
 2739 00d4 00D0      		rcall usart_read_bytes
 2740               	.LVL205:
 137:main.c        **** 			
 138:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2741               		.loc 3 138 0
 2742 00d6 939A      		sbi 0x12,3
 2743               	.LVL206:
 2744 00d8 50E0      		ldi r21,lo8(receivedBuffer)
 2745 00da A52E      		mov r10,r21
 2746 00dc 50E0      		ldi r21,hi8(receivedBuffer)
 2747 00de B52E      		mov r11,r21
 2748 00e0 00E0      		ldi r16,0
 2749 00e2 10E0      		ldi r17,0
 2750               	.LVL207:
 2751               	.L113:
 2752               	.LBB198:
 139:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 140:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2753               		.loc 3 140 0 discriminator 3
 2754 00e4 D501      		movw r26,r10
 2755 00e6 6D91      		ld r22,X+
 2756 00e8 5D01      		movw r10,r26
 2757 00ea C801      		movw r24,r16
 2758 00ec 8C0D      		add r24,r12
 2759 00ee 9D1D      		adc r25,r13
 2760 00f0 41E0      		ldi r20,lo8(1)
 2761 00f2 00D0      		rcall write_8bit_data
 2762               	.LVL208:
 2763 00f4 0F5F      		subi r16,-1
 2764 00f6 1F4F      		sbci r17,-1
 2765               	.LVL209:
 139:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2766               		.loc 3 139 0 discriminator 3
 2767 00f8 0034      		cpi r16,64
 2768 00fa 1105      		cpc r17,__zero_reg__
 2769 00fc 01F4      		brne .L113
 2770 00fe B0E4      		ldi r27,64
 2771 0100 CB0E      		add r12,r27
 2772 0102 D11C      		adc r13,__zero_reg__
 2773 0104 E11C      		adc r14,__zero_reg__
 2774 0106 F11C      		adc r15,__zero_reg__
 2775 0108 00C0      		rjmp .L312
 2776               	.LVL210:
 2777               	.L112:
 2778               	.LBE198:
 141:main.c        **** 				address++;
 142:main.c        **** 			}
 143:main.c        **** 			
 144:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 145:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 146:main.c        **** 		}
 147:main.c        **** 		
 148:main.c        **** 		// Set bank address and write a byte
 149:main.c        **** 		else if (receivedChar == SET_BANK) {
 2779               		.loc 3 149 0
 2780 010a 8234      		cpi r24,lo8(66)
 2781 010c 01F4      		brne .L114
 2782               	.LBB199:
 150:main.c        **** 			gb_mode();
 2783               		.loc 3 150 0
 2784 010e 00D0      		rcall gb_mode
 2785               	.LVL211:
 151:main.c        **** 			
 152:main.c        **** 			usart_read_chars(); // Read start address
 2786               		.loc 3 152 0
 2787 0110 00D0      		rcall usart_read_chars
 2788               	.LVL212:
 153:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2789               		.loc 3 153 0
 2790 0112 40E1      		ldi r20,lo8(16)
 2791 0114 50E0      		ldi r21,0
 2792 0116 60E0      		ldi r22,0
 2793 0118 70E0      		ldi r23,0
 2794 011a 80E0      		ldi r24,lo8(receivedBuffer)
 2795 011c 90E0      		ldi r25,hi8(receivedBuffer)
 2796 011e 00D0      		rcall strtol
 2797               	.LVL213:
 2798 0120 4B01      		movw r8,r22
 2799 0122 5C01      		movw r10,r24
 2800               	.LVL214:
 154:main.c        **** 			
 155:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2801               		.loc 3 155 0
 2802 0124 00D0      		rcall USART_Receive
 2803               	.LVL215:
 2804 0126 8093 0000 		sts receivedChar,r24
 156:main.c        **** 			if (receivedChar == 'B') {
 2805               		.loc 3 156 0
 2806 012a 8234      		cpi r24,lo8(66)
 2807 012c 01F0      		breq .+2
 2808 012e 00C0      		rjmp .L99
 2809               	.LBB200:
 157:main.c        **** 				usart_read_chars(); // Read data
 2810               		.loc 3 157 0
 2811 0130 00D0      		rcall usart_read_chars
 2812               	.LVL216:
 158:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2813               		.loc 3 158 0
 2814 0132 80E0      		ldi r24,lo8(receivedBuffer)
 2815 0134 90E0      		ldi r25,hi8(receivedBuffer)
 2816 0136 00D0      		rcall atoi
 2817               	.LVL217:
 159:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2818               		.loc 3 159 0
 2819 0138 8093 0000 		sts lastBankAccessed,r24
 160:main.c        **** 				
 161:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2820               		.loc 3 161 0
 2821 013c 40E0      		ldi r20,0
 2822 013e 682F      		mov r22,r24
 2823 0140 C401      		movw r24,r8
 2824               	.LVL218:
 2825 0142 00D0      		rcall write_8bit_data
 2826               	.LVL219:
 2827 0144 00C0      		rjmp .L99
 2828               	.LVL220:
 2829               	.L114:
 2830               	.LBE200:
 2831               	.LBE199:
 162:main.c        **** 			}
 163:main.c        **** 		}
 164:main.c        **** 		
 165:main.c        **** 		
 166:main.c        **** 		// ****** Gameboy Advance ******
 167:main.c        **** 		
 168:main.c        **** 		// ---------- ROM ----------
 169:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 170:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2832               		.loc 3 170 0
 2833 0146 8237      		cpi r24,lo8(114)
 2834 0148 01F0      		breq .L115
 2835               		.loc 3 170 0 is_stmt 0 discriminator 1
 2836 014a 8A36      		cpi r24,lo8(106)
 2837 014c 01F4      		brne .L116
 2838               	.L115:
 2839               	.LBB201:
 171:main.c        **** 			gba_mode();
 2840               		.loc 3 171 0 is_stmt 1
 2841 014e 00D0      		rcall gba_mode
 2842               	.LVL221:
 172:main.c        **** 			
 173:main.c        **** 			uint8_t readEnd = 32;
 174:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2843               		.loc 3 174 0
 2844 0150 8091 0000 		lds r24,receivedChar
 2845 0154 8A36      		cpi r24,lo8(106)
 2846 0156 01F4      		brne .L236
 175:main.c        **** 				readEnd = 128;
 2847               		.loc 3 175 0
 2848 0158 10E8      		ldi r17,lo8(-128)
 2849 015a 00C0      		rjmp .L117
 2850               	.L236:
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2851               		.loc 3 173 0
 2852 015c 10E2      		ldi r17,lo8(32)
 2853               	.L117:
 2854               	.LVL222:
 176:main.c        **** 			}
 177:main.c        **** 			
 178:main.c        **** 			receivedChar = '1';
 2855               		.loc 3 178 0
 2856 015e E1E3      		ldi r30,lo8(49)
 2857 0160 E093 0000 		sts receivedChar,r30
 2858 0164 8824      		clr r8
 2859 0166 8A94      		dec r8
 2860 0168 810E      		add r8,r17
 2861 016a 912C      		mov r9,__zero_reg__
 2862 016c A12C      		mov r10,__zero_reg__
 2863 016e B12C      		mov r11,__zero_reg__
 2864 0170 FFEF      		ldi r31,-1
 2865 0172 8F1A      		sub r8,r31
 2866 0174 9F0A      		sbc r9,r31
 2867 0176 AF0A      		sbc r10,r31
 2868 0178 BF0A      		sbc r11,r31
 2869               	.LVL223:
 2870               	.L118:
 179:main.c        **** 			while (receivedChar == '1') {
 2871               		.loc 3 179 0
 2872 017a 8091 0000 		lds r24,receivedChar
 2873 017e 8133      		cpi r24,lo8(49)
 2874 0180 01F0      		breq .+2
 2875 0182 00C0      		rjmp .L99
 180:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2876               		.loc 3 180 0
 2877 0184 939A      		sbi 0x12,3
 2878               	.LVL224:
 2879 0186 2601      		movw r4,r12
 2880 0188 3701      		movw r6,r14
 2881               	.LVL225:
 2882               	.L119:
 2883               	.LBB202:
 2884               	.LBB203:
 181:main.c        **** 				
 182:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 183:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2885               		.loc 3 183 0 discriminator 3
 2886 018a C301      		movw r24,r6
 2887 018c B201      		movw r22,r4
 2888 018e 00D0      		rcall gba_read_16bit_data
 2889               	.LVL226:
 2890 0190 092F      		mov r16,r25
 2891               	.LVL227:
 184:main.c        **** 					
 185:main.c        **** 					// Low byte & High byte
 186:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 2892               		.loc 3 186 0 discriminator 3
 2893 0192 00D0      		rcall USART_Transmit
 2894               	.LVL228:
 187:main.c        **** 					USART_Transmit(dataRead >> 8);
 2895               		.loc 3 187 0 discriminator 3
 2896 0194 802F      		mov r24,r16
 2897 0196 00D0      		rcall USART_Transmit
 2898               	.LVL229:
 188:main.c        **** 					
 189:main.c        **** 					address++;
 2899               		.loc 3 189 0 discriminator 3
 2900 0198 2FEF      		ldi r18,-1
 2901 019a 421A      		sub r4,r18
 2902 019c 520A      		sbc r5,r18
 2903 019e 620A      		sbc r6,r18
 2904 01a0 720A      		sbc r7,r18
 2905               	.LVL230:
 2906               	.LBE203:
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2907               		.loc 3 182 0 discriminator 3
 2908 01a2 842D      		mov r24,r4
 2909 01a4 8C19      		sub r24,r12
 2910 01a6 8117      		cp r24,r17
 2911 01a8 00F0      		brlo .L119
 2912 01aa C80C      		add r12,r8
 2913 01ac D91C      		adc r13,r9
 2914 01ae EA1C      		adc r14,r10
 2915 01b0 FB1C      		adc r15,r11
 2916               	.LVL231:
 2917               	.LBE202:
 190:main.c        **** 				}
 191:main.c        **** 				
 192:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2918               		.loc 3 192 0
 2919 01b2 9398      		cbi 0x12,3
 193:main.c        **** 				receivedChar = USART_Receive();
 2920               		.loc 3 193 0
 2921 01b4 00D0      		rcall USART_Receive
 2922               	.LVL232:
 2923 01b6 8093 0000 		sts receivedChar,r24
 2924 01ba 00C0      		rjmp .L118
 2925               	.LVL233:
 2926               	.L116:
 2927               	.LBE201:
 194:main.c        **** 			}
 195:main.c        **** 		}
 196:main.c        **** 		
 197:main.c        **** 		// ---------- SRAM ----------
 198:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 199:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 2928               		.loc 3 199 0
 2929 01bc 8D36      		cpi r24,lo8(109)
 2930 01be 01F4      		brne .L121
 200:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2931               		.loc 3 200 0
 2932 01c0 00D0      		rcall gb_mode
 2933               	.LVL234:
 201:main.c        **** 			
 202:main.c        **** 			receivedChar = '1';
 2934               		.loc 3 202 0
 2935 01c2 81E3      		ldi r24,lo8(49)
 2936               	.LVL235:
 2937               	.L297:
 203:main.c        **** 			while (receivedChar == '1') {
 204:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 205:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 206:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 207:main.c        **** 					address++;
 208:main.c        **** 				}
 209:main.c        **** 				
 210:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 211:main.c        **** 				receivedChar = USART_Receive();
 2938               		.loc 3 211 0
 2939 01c4 8093 0000 		sts receivedChar,r24
 2940               	.LVL236:
 203:main.c        **** 			while (receivedChar == '1') {
 2941               		.loc 3 203 0
 2942 01c8 8091 0000 		lds r24,receivedChar
 2943 01cc 8133      		cpi r24,lo8(49)
 2944 01ce 01F4      		brne .L294
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2945               		.loc 3 204 0
 2946 01d0 939A      		sbi 0x12,3
 2947               	.LVL237:
 2948 01d2 00E0      		ldi r16,0
 2949 01d4 10E0      		ldi r17,0
 2950               	.LVL238:
 2951               	.L123:
 2952               	.LBB204:
 206:main.c        **** 					address++;
 2953               		.loc 3 206 0 discriminator 3
 2954 01d6 C801      		movw r24,r16
 2955 01d8 8C0D      		add r24,r12
 2956 01da 9D1D      		adc r25,r13
 2957 01dc 00D0      		rcall gba_read_ram_8bit_data
 2958               	.LVL239:
 2959 01de 00D0      		rcall USART_Transmit
 2960               	.LVL240:
 2961 01e0 0F5F      		subi r16,-1
 2962 01e2 1F4F      		sbci r17,-1
 2963               	.LVL241:
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2964               		.loc 3 205 0 discriminator 3
 2965 01e4 0034      		cpi r16,64
 2966 01e6 1105      		cpc r17,__zero_reg__
 2967 01e8 01F4      		brne .L123
 2968 01ea 90E4      		ldi r25,64
 2969 01ec C90E      		add r12,r25
 2970 01ee D11C      		adc r13,__zero_reg__
 2971 01f0 E11C      		adc r14,__zero_reg__
 2972 01f2 F11C      		adc r15,__zero_reg__
 2973               	.LBE204:
 210:main.c        **** 				receivedChar = USART_Receive();
 2974               		.loc 3 210 0
 2975 01f4 9398      		cbi 0x12,3
 2976               		.loc 3 211 0
 2977 01f6 00D0      		rcall USART_Receive
 2978               	.LVL242:
 2979 01f8 00C0      		rjmp .L297
 2980               	.LVL243:
 2981               	.L121:
 212:main.c        **** 			}
 213:main.c        **** 			
 214:main.c        **** 			gba_mode(); // Set back
 215:main.c        **** 		}
 216:main.c        **** 		
 217:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 218:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 2982               		.loc 3 218 0
 2983 01fa 8737      		cpi r24,lo8(119)
 2984 01fc 01F4      		brne .L125
 219:main.c        **** 			gb_mode();
 2985               		.loc 3 219 0
 2986 01fe 00D0      		rcall gb_mode
 2987               	.LVL244:
 220:main.c        **** 			
 221:main.c        **** 			usart_read_bytes(64);
 2988               		.loc 3 221 0
 2989 0200 80E4      		ldi r24,lo8(64)
 2990 0202 90E0      		ldi r25,0
 2991 0204 00D0      		rcall usart_read_bytes
 2992               	.LVL245:
 222:main.c        **** 			
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2993               		.loc 3 223 0
 2994 0206 939A      		sbi 0x12,3
 2995               	.LVL246:
 2996 0208 40E0      		ldi r20,lo8(receivedBuffer)
 2997 020a A42E      		mov r10,r20
 2998 020c 40E0      		ldi r20,hi8(receivedBuffer)
 2999 020e B42E      		mov r11,r20
 3000 0210 00E0      		ldi r16,0
 3001 0212 10E0      		ldi r17,0
 3002               	.LVL247:
 3003               	.L126:
 3004               	.LBB205:
 224:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 225:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 3005               		.loc 3 225 0 discriminator 3
 3006 0214 D501      		movw r26,r10
 3007 0216 6D91      		ld r22,X+
 3008 0218 5D01      		movw r10,r26
 3009 021a C801      		movw r24,r16
 3010 021c 8C0D      		add r24,r12
 3011 021e 9D1D      		adc r25,r13
 3012 0220 00D0      		rcall gba_write_ram_8bit_data
 3013               	.LVL248:
 3014 0222 0F5F      		subi r16,-1
 3015 0224 1F4F      		sbci r17,-1
 3016               	.LVL249:
 224:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3017               		.loc 3 224 0 discriminator 3
 3018 0226 0034      		cpi r16,64
 3019 0228 1105      		cpc r17,__zero_reg__
 3020 022a 01F4      		brne .L126
 3021 022c B0E4      		ldi r27,64
 3022 022e CB0E      		add r12,r27
 3023 0230 D11C      		adc r13,__zero_reg__
 3024 0232 E11C      		adc r14,__zero_reg__
 3025 0234 F11C      		adc r15,__zero_reg__
 3026               	.LVL250:
 3027               	.L296:
 3028               	.LBE205:
 226:main.c        **** 				address++;
 227:main.c        **** 			}
 228:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3029               		.loc 3 228 0
 3030 0236 81E3      		ldi r24,lo8(49)
 3031 0238 00D0      		rcall USART_Transmit
 3032               	.LVL251:
 229:main.c        **** 			
 230:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3033               		.loc 3 230 0
 3034 023a 9398      		cbi 0x12,3
 3035               	.L294:
 231:main.c        **** 			gba_mode(); // Set back
 3036               		.loc 3 231 0
 3037 023c 00D0      		rcall gba_mode
 3038               	.LVL252:
 3039 023e 00C0      		rjmp .L99
 3040               	.LVL253:
 3041               	.L125:
 232:main.c        **** 		}
 233:main.c        **** 		
 234:main.c        **** 		// Write 1 byte to SRAM address
 235:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 3042               		.loc 3 235 0
 3043 0240 8F36      		cpi r24,lo8(111)
 3044 0242 01F4      		brne .L127
 3045               	.LBB206:
 236:main.c        **** 			gb_mode();
 3046               		.loc 3 236 0
 3047 0244 00D0      		rcall gb_mode
 3048               	.LVL254:
 237:main.c        **** 			
 238:main.c        **** 			uint8_t data = USART_Receive();
 3049               		.loc 3 238 0
 3050 0246 00D0      		rcall USART_Receive
 3051               	.LVL255:
 239:main.c        **** 			gba_write_ram_8bit_data(address, data);
 3052               		.loc 3 239 0
 3053 0248 682F      		mov r22,r24
 3054 024a C601      		movw r24,r12
 3055               	.LVL256:
 3056 024c 00D0      		rcall gba_write_ram_8bit_data
 3057               	.LVL257:
 3058 024e 00C0      		rjmp .L299
 3059               	.L127:
 3060               	.LBE206:
 240:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 241:main.c        **** 			
 242:main.c        **** 			gba_mode(); // Set back
 243:main.c        **** 		}
 244:main.c        **** 		
 245:main.c        **** 		
 246:main.c        **** 		// ---------- FLASH ----------
 247:main.c        **** 		// Read the Flash Manufacturer and Device ID
 248:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 3061               		.loc 3 248 0
 3062 0250 8936      		cpi r24,lo8(105)
 3063 0252 01F4      		brne .L128
 249:main.c        **** 			gb_mode();
 3064               		.loc 3 249 0
 3065 0254 00D0      		rcall gb_mode
 3066               	.LVL258:
 250:main.c        **** 			
 251:main.c        **** 			flash_read_chip_id();
 3067               		.loc 3 251 0
 3068 0256 00D0      		rcall flash_read_chip_id
 3069               	.LVL259:
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 3070               		.loc 3 252 0
 3071 0258 8091 0000 		lds r24,flashChipIdBuffer
 3072 025c 00D0      		rcall USART_Transmit
 3073               	.LVL260:
 253:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 3074               		.loc 3 253 0
 3075 025e 8091 0000 		lds r24,flashChipIdBuffer+1
 3076               	.L298:
 3077 0262 00D0      		rcall USART_Transmit
 3078               	.LVL261:
 3079 0264 00C0      		rjmp .L294
 3080               	.L128:
 254:main.c        **** 			
 255:main.c        **** 			gba_mode(); // Set back
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Change bank
 259:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 3081               		.loc 3 259 0
 3082 0266 8B36      		cpi r24,lo8(107)
 3083 0268 01F4      		brne .L129
 3084               	.LBB207:
 260:main.c        **** 			usart_read_chars(); // Read data
 3085               		.loc 3 260 0
 3086 026a 00D0      		rcall usart_read_chars
 3087               	.LVL262:
 261:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3088               		.loc 3 261 0
 3089 026c 80E0      		ldi r24,lo8(receivedBuffer)
 3090 026e 90E0      		ldi r25,hi8(receivedBuffer)
 3091 0270 00D0      		rcall atoi
 3092               	.LVL263:
 3093 0272 182F      		mov r17,r24
 3094               	.LVL264:
 262:main.c        **** 			
 263:main.c        **** 			gb_mode();
 3095               		.loc 3 263 0
 3096 0274 00D0      		rcall gb_mode
 3097               	.LVL265:
 264:main.c        **** 			flash_switch_bank(bank);
 3098               		.loc 3 264 0
 3099 0276 812F      		mov r24,r17
 3100 0278 00D0      		rcall flash_switch_bank
 3101               	.LVL266:
 3102 027a 00C0      		rjmp .L294
 3103               	.LVL267:
 3104               	.L129:
 3105               	.LBE207:
 265:main.c        **** 			
 266:main.c        **** 			gba_mode(); // Set back
 267:main.c        **** 		}
 268:main.c        **** 		
 269:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 270:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 3106               		.loc 3 270 0
 3107 027c 8337      		cpi r24,lo8(115)
 3108 027e 01F4      		brne .L130
 3109               	.LBB208:
 271:main.c        **** 			gb_mode();
 3110               		.loc 3 271 0
 3111 0280 00D0      		rcall gb_mode
 3112               	.LVL268:
 272:main.c        **** 			
 273:main.c        **** 			usart_read_chars(); // Read sector
 3113               		.loc 3 273 0
 3114 0282 00D0      		rcall usart_read_chars
 3115               	.LVL269:
 274:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3116               		.loc 3 274 0
 3117 0284 40E1      		ldi r20,lo8(16)
 3118 0286 50E0      		ldi r21,0
 3119 0288 60E0      		ldi r22,0
 3120 028a 70E0      		ldi r23,0
 3121 028c 80E0      		ldi r24,lo8(receivedBuffer)
 3122 028e 90E0      		ldi r25,hi8(receivedBuffer)
 3123 0290 00D0      		rcall strtol
 3124               	.LVL270:
 3125 0292 862F      		mov r24,r22
 3126               	.LVL271:
 275:main.c        **** 			
 276:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 3127               		.loc 3 276 0
 3128 0294 00D0      		rcall flash_erase_4k_sector
 3129               	.LVL272:
 3130               	.L299:
 277:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3131               		.loc 3 277 0
 3132 0296 81E3      		ldi r24,lo8(49)
 3133 0298 00C0      		rjmp .L298
 3134               	.L130:
 3135               	.LBE208:
 278:main.c        **** 			
 279:main.c        **** 			gba_mode(); // Set back
 280:main.c        **** 		}
 281:main.c        **** 		
 282:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 283:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 3136               		.loc 3 283 0
 3137 029a 8236      		cpi r24,lo8(98)
 3138 029c 01F4      		brne .L131
 284:main.c        **** 			gb_mode();
 3139               		.loc 3 284 0
 3140 029e 00D0      		rcall gb_mode
 3141               	.LVL273:
 285:main.c        **** 			
 286:main.c        **** 			usart_read_bytes(64);
 3142               		.loc 3 286 0
 3143 02a0 80E4      		ldi r24,lo8(64)
 3144 02a2 90E0      		ldi r25,0
 3145 02a4 00D0      		rcall usart_read_bytes
 3146               	.LVL274:
 287:main.c        **** 			
 288:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3147               		.loc 3 288 0
 3148 02a6 939A      		sbi 0x12,3
 3149               	.LVL275:
 3150 02a8 30E0      		ldi r19,lo8(receivedBuffer)
 3151 02aa A32E      		mov r10,r19
 3152 02ac 30E0      		ldi r19,hi8(receivedBuffer)
 3153 02ae B32E      		mov r11,r19
 3154 02b0 00E0      		ldi r16,0
 3155 02b2 10E0      		ldi r17,0
 3156               	.LVL276:
 3157               	.L132:
 3158               	.LBB209:
 289:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 290:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3159               		.loc 3 290 0 discriminator 3
 3160 02b4 F501      		movw r30,r10
 3161 02b6 6191      		ld r22,Z+
 3162 02b8 5F01      		movw r10,r30
 3163 02ba C801      		movw r24,r16
 3164 02bc 8C0D      		add r24,r12
 3165 02be 9D1D      		adc r25,r13
 3166 02c0 00D0      		rcall flash_write_byte
 3167               	.LVL277:
 3168 02c2 0F5F      		subi r16,-1
 3169 02c4 1F4F      		sbci r17,-1
 3170               	.LVL278:
 289:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3171               		.loc 3 289 0 discriminator 3
 3172 02c6 0034      		cpi r16,64
 3173 02c8 1105      		cpc r17,__zero_reg__
 3174 02ca 01F4      		brne .L132
 3175 02cc F0E4      		ldi r31,64
 3176 02ce CF0E      		add r12,r31
 3177 02d0 D11C      		adc r13,__zero_reg__
 3178 02d2 E11C      		adc r14,__zero_reg__
 3179 02d4 F11C      		adc r15,__zero_reg__
 3180 02d6 00C0      		rjmp .L296
 3181               	.LVL279:
 3182               	.L131:
 3183               	.LBE209:
 291:main.c        **** 				address++;
 292:main.c        **** 			}
 293:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 294:main.c        **** 			
 295:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 296:main.c        **** 			gba_mode(); // Set back
 297:main.c        **** 		}
 298:main.c        **** 		
 299:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 300:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 3184               		.loc 3 300 0
 3185 02d8 8136      		cpi r24,lo8(97)
 3186 02da 01F4      		brne .L133
 301:main.c        **** 			gb_mode();
 3187               		.loc 3 301 0
 3188 02dc 00D0      		rcall gb_mode
 3189               	.LVL280:
 302:main.c        **** 			
 303:main.c        **** 			usart_read_bytes(128);
 3190               		.loc 3 303 0
 3191 02de 80E8      		ldi r24,lo8(-128)
 3192 02e0 90E0      		ldi r25,0
 3193 02e2 00D0      		rcall usart_read_bytes
 3194               	.LVL281:
 304:main.c        **** 			
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3195               		.loc 3 305 0
 3196 02e4 939A      		sbi 0x12,3
 306:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3197               		.loc 3 306 0
 3198 02e6 C601      		movw r24,r12
 3199 02e8 00D0      		rcall flash_write_sector
 3200               	.LVL282:
 307:main.c        **** 			address++;
 3201               		.loc 3 307 0
 3202 02ea 2FEF      		ldi r18,-1
 3203 02ec C21A      		sub r12,r18
 3204 02ee D20A      		sbc r13,r18
 3205 02f0 E20A      		sbc r14,r18
 3206 02f2 F20A      		sbc r15,r18
 3207               	.LVL283:
 3208 02f4 00C0      		rjmp .L296
 3209               	.L133:
 308:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 309:main.c        **** 			
 310:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		
 315:main.c        **** 		// ---------- EEPROM ----------
 316:main.c        **** 		// Set EEPROM size
 317:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 3210               		.loc 3 317 0
 3211 02f6 8335      		cpi r24,lo8(83)
 3212 02f8 01F4      		brne .L134
 318:main.c        **** 			usart_read_chars(); // Read size
 3213               		.loc 3 318 0
 3214 02fa 00D0      		rcall usart_read_chars
 3215               	.LVL284:
 319:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3216               		.loc 3 319 0
 3217 02fc 40E1      		ldi r20,lo8(16)
 3218 02fe 50E0      		ldi r21,0
 3219 0300 60E0      		ldi r22,0
 3220 0302 70E0      		ldi r23,0
 3221 0304 80E0      		ldi r24,lo8(receivedBuffer)
 3222 0306 90E0      		ldi r25,hi8(receivedBuffer)
 3223 0308 00D0      		rcall strtol
 3224               	.LVL285:
 3225 030a 6887      		std Y+8,r22
 3226               	.LVL286:
 3227 030c 00C0      		rjmp .L99
 3228               	.LVL287:
 3229               	.L134:
 320:main.c        **** 		}
 321:main.c        **** 		
 322:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 323:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 3230               		.loc 3 323 0
 3231 030e 8536      		cpi r24,lo8(101)
 3232 0310 01F4      		brne .L135
 324:main.c        **** 			gba_eeprom_mode();
 3233               		.loc 3 324 0
 3234 0312 00D0      		rcall gba_eeprom_mode
 3235               	.LVL288:
 325:main.c        **** 			
 326:main.c        **** 			receivedChar = '1';
 3236               		.loc 3 326 0
 3237 0314 81E3      		ldi r24,lo8(49)
 3238               	.L300:
 327:main.c        **** 			while (receivedChar == '1') {
 328:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 329:main.c        **** 				gba_eeprom_read(address, eepromSize);
 330:main.c        **** 				
 331:main.c        **** 				// Send back the 8 bytes of data
 332:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 333:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 334:main.c        **** 				}
 335:main.c        **** 				address++; // Increment to next 8 bytes
 336:main.c        **** 				
 337:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 338:main.c        **** 				receivedChar = USART_Receive();
 3239               		.loc 3 338 0
 3240 0316 8093 0000 		sts receivedChar,r24
 327:main.c        **** 			while (receivedChar == '1') {
 3241               		.loc 3 327 0
 3242 031a 8091 0000 		lds r24,receivedChar
 3243 031e 8133      		cpi r24,lo8(49)
 3244 0320 01F0      		breq .+2
 3245 0322 00C0      		rjmp .L294
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3246               		.loc 3 328 0
 3247 0324 939A      		sbi 0x12,3
 329:main.c        **** 				
 3248               		.loc 3 329 0
 3249 0326 6885      		ldd r22,Y+8
 3250 0328 C601      		movw r24,r12
 3251 032a 00D0      		rcall gba_eeprom_read
 3252               	.LVL289:
 3253 032c 00E0      		ldi r16,lo8(eepromBuffer)
 3254 032e 10E0      		ldi r17,hi8(eepromBuffer)
 3255               	.LVL290:
 3256               	.L137:
 3257               	.LBB210:
 333:main.c        **** 				}
 3258               		.loc 3 333 0 discriminator 3
 3259 0330 D801      		movw r26,r16
 3260 0332 8D91      		ld r24,X+
 3261 0334 8D01      		movw r16,r26
 3262               	.LVL291:
 3263 0336 00D0      		rcall USART_Transmit
 3264               	.LVL292:
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3265               		.loc 3 332 0 discriminator 3
 3266 0338 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3267 033a F0E0      		ldi r31,hi8(eepromBuffer+8)
 3268 033c E017      		cp r30,r16
 3269 033e F107      		cpc r31,r17
 3270 0340 01F4      		brne .L137
 3271               	.LBE210:
 335:main.c        **** 				
 3272               		.loc 3 335 0
 3273 0342 FFEF      		ldi r31,-1
 3274 0344 CF1A      		sub r12,r31
 3275 0346 DF0A      		sbc r13,r31
 3276 0348 EF0A      		sbc r14,r31
 3277 034a FF0A      		sbc r15,r31
 3278               	.LVL293:
 337:main.c        **** 				receivedChar = USART_Receive();
 3279               		.loc 3 337 0
 3280 034c 9398      		cbi 0x12,3
 3281               		.loc 3 338 0
 3282 034e 00D0      		rcall USART_Receive
 3283               	.LVL294:
 3284 0350 00C0      		rjmp .L300
 3285               	.LVL295:
 3286               	.L135:
 339:main.c        **** 			}
 340:main.c        **** 			
 341:main.c        **** 			gba_mode(); // Set back
 342:main.c        **** 		}
 343:main.c        **** 		
 344:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 345:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3287               		.loc 3 345 0
 3288 0352 8037      		cpi r24,lo8(112)
 3289 0354 01F4      		brne .L139
 346:main.c        **** 			gba_eeprom_mode();
 3290               		.loc 3 346 0
 3291 0356 00D0      		rcall gba_eeprom_mode
 3292               	.LVL296:
 3293 0358 00E0      		ldi r16,lo8(eepromBuffer)
 3294 035a 10E0      		ldi r17,hi8(eepromBuffer)
 3295               	.LVL297:
 3296               	.L140:
 3297               	.LBB211:
 347:main.c        **** 			
 348:main.c        **** 			// Read 8 bytes from USART and place in buffer
 349:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 350:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3298               		.loc 3 350 0 discriminator 3
 3299 035c 00D0      		rcall USART_Receive
 3300               	.LVL298:
 3301 035e D801      		movw r26,r16
 3302 0360 8D93      		st X+,r24
 3303 0362 8D01      		movw r16,r26
 3304               	.LVL299:
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3305               		.loc 3 349 0 discriminator 3
 3306 0364 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3307 0366 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3308 0368 EA17      		cp r30,r26
 3309 036a FB07      		cpc r31,r27
 3310 036c 01F4      		brne .L140
 3311               	.LBE211:
 351:main.c        **** 			}
 352:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3312               		.loc 3 352 0
 3313 036e 939A      		sbi 0x12,3
 353:main.c        **** 			
 354:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3314               		.loc 3 354 0
 3315 0370 6885      		ldd r22,Y+8
 3316 0372 C601      		movw r24,r12
 3317 0374 00D0      		rcall gba_eeprom_write
 3318               	.LVL300:
 355:main.c        **** 			address++;
 3319               		.loc 3 355 0
 3320 0376 FFEF      		ldi r31,-1
 3321 0378 CF1A      		sub r12,r31
 3322 037a DF0A      		sbc r13,r31
 3323 037c EF0A      		sbc r14,r31
 3324 037e FF0A      		sbc r15,r31
 3325               	.LVL301:
 3326               	.LBB212:
 3327               	.LBB213:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3328               		.loc 2 187 0
 3329 0380 8FE7      		ldi r24,lo8(15999)
 3330 0382 9EE3      		ldi r25,hi8(15999)
 3331 0384 0197      	1:	sbiw r24,1
 3332 0386 01F4      		brne 1b
 3333 0388 00C0      		rjmp .
 3334 038a 0000      		nop
 3335               	.LVL302:
 3336 038c 00C0      		rjmp .L296
 3337               	.LVL303:
 3338               	.L139:
 3339               	.LBE213:
 3340               	.LBE212:
 356:main.c        **** 			
 357:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 358:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 359:main.c        **** 			
 360:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 361:main.c        **** 			gba_mode(); // Set back
 362:main.c        **** 		}
 363:main.c        **** 		
 364:main.c        **** 		
 365:main.c        **** 		// ---------- GB FLASH CARTS ----------
 366:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 367:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3341               		.loc 3 367 0
 3342 038e 8035      		cpi r24,lo8(80)
 3343 0390 01F4      		brne .L141
 368:main.c        **** 			flashWriteWePin = USART_Receive();
 3344               		.loc 3 368 0
 3345 0392 00D0      		rcall USART_Receive
 3346               	.LVL304:
 3347 0394 8093 0000 		sts flashWriteWePin,r24
 369:main.c        **** 			
 370:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3348               		.loc 3 370 0
 3349 0398 8134      		cpi r24,lo8(65)
 3350 039a 01F0      		breq .+2
 3351 039c 00C0      		rjmp .L99
 371:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3352               		.loc 3 371 0
 3353 039e 319A      		sbi 0x6,1
 372:main.c        **** 				audioPin_high;
 3354               		.loc 3 372 0
 3355 03a0 399A      		sbi 0x7,1
 3356 03a2 00C0      		rjmp .L99
 3357               	.L141:
 373:main.c        **** 			}
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 377:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3358               		.loc 3 377 0
 3359 03a4 8E34      		cpi r24,lo8(78)
 3360 03a6 01F4      		brne .L142
 378:main.c        **** 			flashBank1CommandWrites = 1;
 3361               		.loc 3 378 0
 3362 03a8 81E0      		ldi r24,lo8(1)
 3363 03aa 8093 0000 		sts flashBank1CommandWrites,r24
 3364 03ae 00C0      		rjmp .L99
 3365               	.L142:
 379:main.c        **** 		}
 380:main.c        **** 		
 381:main.c        **** 		// Load the program method to use
 382:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3366               		.loc 3 382 0
 3367 03b0 8534      		cpi r24,lo8(69)
 3368 03b2 01F4      		brne .L143
 3369 03b4 00E0      		ldi r16,lo8(flashWriteCycle)
 3370 03b6 10E0      		ldi r17,hi8(flashWriteCycle)
 3371               	.L144:
 3372               	.LBB214:
 383:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 384:main.c        **** 				usart_read_chars(); // Address
 3373               		.loc 3 384 0 discriminator 3
 3374 03b8 00D0      		rcall usart_read_chars
 3375               	.LVL305:
 385:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3376               		.loc 3 385 0 discriminator 3
 3377 03ba 40E1      		ldi r20,lo8(16)
 3378 03bc 50E0      		ldi r21,0
 3379 03be 60E0      		ldi r22,0
 3380 03c0 70E0      		ldi r23,0
 3381 03c2 80E0      		ldi r24,lo8(receivedBuffer)
 3382 03c4 90E0      		ldi r25,hi8(receivedBuffer)
 3383 03c6 00D0      		rcall strtol
 3384               	.LVL306:
 3385 03c8 D801      		movw r26,r16
 3386 03ca 6D93      		st X+,r22
 3387 03cc 7C93      		st X,r23
 386:main.c        **** 				USART_Transmit(SEND_ACK);
 3388               		.loc 3 386 0 discriminator 3
 3389 03ce 81E3      		ldi r24,lo8(49)
 3390 03d0 00D0      		rcall USART_Transmit
 3391               	.LVL307:
 387:main.c        **** 				
 388:main.c        **** 				usart_read_chars(); // Data
 3392               		.loc 3 388 0 discriminator 3
 3393 03d2 00D0      		rcall usart_read_chars
 3394               	.LVL308:
 389:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3395               		.loc 3 389 0 discriminator 3
 3396 03d4 40E1      		ldi r20,lo8(16)
 3397 03d6 50E0      		ldi r21,0
 3398 03d8 60E0      		ldi r22,0
 3399 03da 70E0      		ldi r23,0
 3400 03dc 80E0      		ldi r24,lo8(receivedBuffer)
 3401 03de 90E0      		ldi r25,hi8(receivedBuffer)
 3402 03e0 00D0      		rcall strtol
 3403               	.LVL309:
 3404 03e2 F801      		movw r30,r16
 3405 03e4 7383      		std Z+3,r23
 3406 03e6 6283      		std Z+2,r22
 390:main.c        **** 				USART_Transmit(SEND_ACK);
 3407               		.loc 3 390 0 discriminator 3
 3408 03e8 81E3      		ldi r24,lo8(49)
 3409 03ea 00D0      		rcall USART_Transmit
 3410               	.LVL310:
 3411 03ec 0C5F      		subi r16,-4
 3412 03ee 1F4F      		sbci r17,-1
 383:main.c        **** 				usart_read_chars(); // Address
 3413               		.loc 3 383 0 discriminator 3
 3414 03f0 F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3415 03f2 0030      		cpi r16,lo8(flashWriteCycle+12)
 3416 03f4 1F07      		cpc r17,r31
 3417 03f6 01F4      		brne .L144
 3418 03f8 00C0      		rjmp .L99
 3419               	.L143:
 3420               	.LBE214:
 391:main.c        **** 			}
 392:main.c        **** 		}
 393:main.c        **** 		
 394:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 395:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3421               		.loc 3 395 0
 3422 03fa 8634      		cpi r24,lo8(70)
 3423 03fc 01F4      		brne .L145
 3424               	.LBB215:
 396:main.c        **** 			usart_read_chars(); // Read address
 3425               		.loc 3 396 0
 3426 03fe 00D0      		rcall usart_read_chars
 3427               	.LVL311:
 397:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3428               		.loc 3 397 0
 3429 0400 40E1      		ldi r20,lo8(16)
 3430 0402 50E0      		ldi r21,0
 3431 0404 60E0      		ldi r22,0
 3432 0406 70E0      		ldi r23,0
 3433 0408 80E0      		ldi r24,lo8(receivedBuffer)
 3434 040a 90E0      		ldi r25,hi8(receivedBuffer)
 3435 040c 00D0      		rcall strtol
 3436               	.LVL312:
 3437 040e 4B01      		movw r8,r22
 3438 0410 5C01      		movw r10,r24
 3439               	.LVL313:
 398:main.c        **** 			
 399:main.c        **** 			usart_read_chars(); // Read data byte
 3440               		.loc 3 399 0
 3441 0412 00D0      		rcall usart_read_chars
 3442               	.LVL314:
 400:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3443               		.loc 3 400 0
 3444 0414 40E1      		ldi r20,lo8(16)
 3445 0416 50E0      		ldi r21,0
 3446 0418 60E0      		ldi r22,0
 3447 041a 70E0      		ldi r23,0
 3448 041c 80E0      		ldi r24,lo8(receivedBuffer)
 3449 041e 90E0      		ldi r25,hi8(receivedBuffer)
 3450 0420 00D0      		rcall strtol
 3451               	.LVL315:
 401:main.c        **** 			
 402:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3452               		.loc 3 402 0
 3453 0422 939A      		sbi 0x12,3
 403:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3454               		.loc 3 403 0
 3455 0424 C401      		movw r24,r8
 3456 0426 00D0      		rcall gb_flash_write_bus_cycle
 3457               	.LVL316:
 3458 0428 00C0      		rjmp .L312
 3459               	.LVL317:
 3460               	.L145:
 3461               	.LBE215:
 404:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 405:main.c        **** 			
 406:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 407:main.c        **** 		}
 408:main.c        **** 		
 409:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 410:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3462               		.loc 3 410 0
 3463 042a 8435      		cpi r24,lo8(84)
 3464 042c 01F4      		brne .L146
 411:main.c        **** 			usart_read_bytes(64);
 3465               		.loc 3 411 0
 3466 042e 80E4      		ldi r24,lo8(64)
 3467 0430 90E0      		ldi r25,0
 3468 0432 00D0      		rcall usart_read_bytes
 3469               	.LVL318:
 412:main.c        **** 			
 413:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3470               		.loc 3 413 0
 3471 0434 939A      		sbi 0x12,3
 414:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3472               		.loc 3 414 0
 3473 0436 8091 0000 		lds r24,flashBank1CommandWrites
 3474 043a 20E0      		ldi r18,lo8(receivedBuffer)
 3475 043c A22E      		mov r10,r18
 3476 043e 20E0      		ldi r18,hi8(receivedBuffer)
 3477 0440 B22E      		mov r11,r18
 3478 0442 00E0      		ldi r16,0
 3479 0444 10E0      		ldi r17,0
 3480 0446 8111      		cpse r24,__zero_reg__
 3481 0448 00C0      		rjmp .L152
 3482               	.LVL319:
 3483               	.L149:
 3484               	.LBB216:
 415:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 416:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3485               		.loc 3 416 0
 3486 044a D501      		movw r26,r10
 3487 044c 6D91      		ld r22,X+
 3488 044e 5D01      		movw r10,r26
 3489 0450 6F3F      		cpi r22,lo8(-1)
 3490 0452 01F0      		breq .L148
 417:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3491               		.loc 3 417 0
 3492 0454 C801      		movw r24,r16
 3493 0456 8C0D      		add r24,r12
 3494 0458 9D1D      		adc r25,r13
 3495 045a 00D0      		rcall gb_flash_write_byte
 3496               	.LVL320:
 3497               	.L148:
 3498 045c 0F5F      		subi r16,-1
 3499 045e 1F4F      		sbci r17,-1
 3500               	.LVL321:
 415:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3501               		.loc 3 415 0 discriminator 2
 3502 0460 0034      		cpi r16,64
 3503 0462 1105      		cpc r17,__zero_reg__
 3504 0464 01F4      		brne .L149
 3505 0466 00C0      		rjmp .L313
 3506               	.LVL322:
 3507               	.L152:
 3508               	.LBE216:
 3509               	.LBB217:
 418:main.c        **** 					}
 419:main.c        **** 					address++;
 420:main.c        **** 				}
 421:main.c        **** 			}
 422:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 423:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 424:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3510               		.loc 3 424 0
 3511 0468 F501      		movw r30,r10
 3512 046a 6191      		ld r22,Z+
 3513 046c 5F01      		movw r10,r30
 3514 046e 6F3F      		cpi r22,lo8(-1)
 3515 0470 01F0      		breq .L151
 425:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3516               		.loc 3 425 0
 3517 0472 C801      		movw r24,r16
 3518 0474 8C0D      		add r24,r12
 3519 0476 9D1D      		adc r25,r13
 3520 0478 00D0      		rcall gb_flash_write_byte_bank1_commands
 3521               	.LVL323:
 3522               	.L151:
 3523 047a 0F5F      		subi r16,-1
 3524 047c 1F4F      		sbci r17,-1
 3525               	.LVL324:
 423:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3526               		.loc 3 423 0 discriminator 2
 3527 047e 0034      		cpi r16,64
 3528 0480 1105      		cpc r17,__zero_reg__
 3529 0482 01F4      		brne .L152
 3530 0484 F0E4      		ldi r31,64
 3531 0486 CF0E      		add r12,r31
 3532 0488 D11C      		adc r13,__zero_reg__
 3533 048a E11C      		adc r14,__zero_reg__
 3534 048c F11C      		adc r15,__zero_reg__
 3535               	.LVL325:
 3536 048e 00C0      		rjmp .L301
 3537               	.LVL326:
 3538               	.L146:
 3539               	.LBE217:
 426:main.c        **** 					}
 427:main.c        **** 					address++;
 428:main.c        **** 				}
 429:main.c        **** 			}
 430:main.c        **** 			
 431:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 432:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 433:main.c        **** 		}
 434:main.c        **** 		
 435:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 436:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 3540               		.loc 3 436 0
 3541 0490 8935      		cpi r24,lo8(89)
 3542 0492 01F0      		breq .+2
 3543 0494 00C0      		rjmp .L153
 3544               	.LBB218:
 437:main.c        **** 			usart_read_bytes(32);
 3545               		.loc 3 437 0
 3546 0496 80E2      		ldi r24,lo8(32)
 3547 0498 90E0      		ldi r25,0
 3548 049a 00D0      		rcall usart_read_bytes
 3549               	.LVL327:
 438:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3550               		.loc 3 438 0
 3551 049c 939A      		sbi 0x12,3
 439:main.c        **** 			
 440:main.c        **** 			// Setup buffered write
 441:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 3552               		.loc 3 441 0
 3553 049e 6AEA      		ldi r22,lo8(-86)
 3554 04a0 8AEA      		ldi r24,lo8(-86)
 3555 04a2 9AE0      		ldi r25,lo8(10)
 3556 04a4 00D0      		rcall gb_flash_write_bus_cycle
 3557               	.LVL328:
 442:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3558               		.loc 3 442 0
 3559 04a6 65E5      		ldi r22,lo8(85)
 3560 04a8 85E5      		ldi r24,lo8(85)
 3561 04aa 95E0      		ldi r25,lo8(5)
 3562 04ac 00D0      		rcall gb_flash_write_bus_cycle
 3563               	.LVL329:
 443:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3564               		.loc 3 443 0
 3565 04ae 5601      		movw r10,r12
 3566 04b0 65E2      		ldi r22,lo8(37)
 3567 04b2 C601      		movw r24,r12
 3568 04b4 00D0      		rcall gb_flash_write_bus_cycle
 3569               	.LVL330:
 444:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3570               		.loc 3 444 0
 3571 04b6 6FE1      		ldi r22,lo8(31)
 3572 04b8 C601      		movw r24,r12
 3573 04ba 00D0      		rcall gb_flash_write_bus_cycle
 3574               	.LVL331:
 3575               	.LBB219:
 3576               	.LBB220:
 3577               		.loc 2 276 0
 3578 04bc 22E0      		ldi r18,lo8(2)
 3579 04be 2A95      	1:	dec r18
 3580 04c0 01F4      		brne 1b
 3581 04c2 00C0      		rjmp .
 3582               	.LVL332:
 3583 04c4 00E0      		ldi r16,lo8(receivedBuffer)
 3584 04c6 10E0      		ldi r17,hi8(receivedBuffer)
 3585 04c8 812C      		mov r8,__zero_reg__
 3586 04ca 912C      		mov r9,__zero_reg__
 3587               	.LVL333:
 3588               	.L154:
 3589               	.LBE220:
 3590               	.LBE219:
 3591               	.LBB221:
 445:main.c        **** 			_delay_us(1);
 446:main.c        **** 			
 447:main.c        **** 			// Write data
 448:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 449:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3592               		.loc 3 449 0 discriminator 3
 3593 04cc D801      		movw r26,r16
 3594 04ce 6D91      		ld r22,X+
 3595 04d0 8D01      		movw r16,r26
 3596 04d2 C401      		movw r24,r8
 3597 04d4 8A0D      		add r24,r10
 3598 04d6 9B1D      		adc r25,r11
 3599 04d8 00D0      		rcall gb_flash_write_bus_cycle
 3600               	.LVL334:
 3601 04da BFEF      		ldi r27,-1
 3602 04dc 8B1A      		sub r8,r27
 3603 04de 9B0A      		sbc r9,r27
 3604               	.LVL335:
 448:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3605               		.loc 3 448 0 discriminator 3
 3606 04e0 E0E2      		ldi r30,32
 3607 04e2 8E16      		cp r8,r30
 3608 04e4 9104      		cpc r9,__zero_reg__
 3609 04e6 01F4      		brne .L154
 3610 04e8 F0E2      		ldi r31,32
 3611 04ea CF0E      		add r12,r31
 3612 04ec D11C      		adc r13,__zero_reg__
 3613 04ee E11C      		adc r14,__zero_reg__
 3614 04f0 F11C      		adc r15,__zero_reg__
 3615               	.LBE221:
 450:main.c        **** 				address++;
 451:main.c        **** 			}
 452:main.c        **** 			
 453:main.c        **** 			// Write buffer to flash
 454:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 3616               		.loc 3 454 0
 3617 04f2 C601      		movw r24,r12
 3618 04f4 8097      		sbiw r24,32
 3619 04f6 69E2      		ldi r22,lo8(41)
 3620 04f8 00D0      		rcall gb_flash_write_bus_cycle
 3621               	.LVL336:
 3622               	.LBB222:
 3623               	.LBB223:
 3624               		.loc 2 276 0
 3625 04fa 8FE8      		ldi r24,lo8(399)
 3626 04fc 91E0      		ldi r25,hi8(399)
 3627 04fe 0197      	1:	sbiw r24,1
 3628 0500 01F4      		brne 1b
 3629 0502 00C0      		rjmp .
 3630 0504 0000      		nop
 3631               	.LVL337:
 3632               	.LBE223:
 3633               	.LBE222:
 455:main.c        **** 			_delay_us(200);
 456:main.c        **** 			
 457:main.c        **** 			// Verify last byte written
 458:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3634               		.loc 3 458 0
 3635 0506 8601      		movw r16,r12
 3636 0508 0150      		subi r16,1
 3637 050a 1109      		sbc r17,__zero_reg__
 3638 050c C801      		movw r24,r16
 3639 050e 00D0      		rcall gb_flash_read_byte
 3640               	.LVL338:
 459:main.c        **** 			uint8_t verifyCount = 0;
 460:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3641               		.loc 3 460 0
 3642 0510 98EC      		ldi r25,lo8(-56)
 3643 0512 B92E      		mov r11,r25
 3644               	.LVL339:
 3645               	.L155:
 3646 0514 9091 0000 		lds r25,receivedBuffer+31
 3647 0518 8917      		cp r24,r25
 3648 051a 01F4      		brne .+2
 3649 051c 00C0      		rjmp .L301
 461:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3650               		.loc 3 461 0
 3651 051e C801      		movw r24,r16
 3652               	.LVL340:
 3653 0520 00D0      		rcall gb_flash_read_byte
 3654               	.LVL341:
 3655               	.LBB224:
 3656               	.LBB225:
 3657               		.loc 2 276 0
 3658 0522 9DE0      		ldi r25,lo8(13)
 3659 0524 9A95      	1:	dec r25
 3660 0526 01F4      		brne 1b
 3661 0528 0000      		nop
 3662               	.LVL342:
 3663 052a BA94      		dec r11
 3664               	.LVL343:
 3665               	.LBE225:
 3666               	.LBE224:
 462:main.c        **** 				_delay_us(5);
 463:main.c        **** 				verifyCount++;
 464:main.c        **** 				if (verifyCount >= 200) {
 3667               		.loc 3 464 0
 3668 052c B110      		cpse r11,__zero_reg__
 3669 052e 00C0      		rjmp .L155
 3670               	.LVL344:
 3671               	.LBB226:
 3672               	.LBB227:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3673               		.loc 2 187 0
 3674 0530 AFEF      		ldi r26,lo8(799999)
 3675 0532 B4E3      		ldi r27,hi8(799999)
 3676 0534 ECE0      		ldi r30,hlo8(799999)
 3677 0536 A150      	1:	subi r26,1
 3678 0538 B040      		sbci r27,0
 3679 053a E040      		sbci r30,0
 3680 053c 01F4      		brne 1b
 3681 053e 00C0      		rjmp .L314
 3682               	.LVL345:
 3683               	.L153:
 3684               	.LBE227:
 3685               	.LBE226:
 3686               	.LBE218:
 465:main.c        **** 					_delay_ms(500);
 466:main.c        **** 					break;
 467:main.c        **** 				}
 468:main.c        **** 			}
 469:main.c        **** 			
 470:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 471:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 472:main.c        **** 		}
 473:main.c        **** 		
 474:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 475:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 3687               		.loc 3 475 0
 3688 0540 8A34      		cpi r24,lo8(74)
 3689 0542 01F4      		brne .L158
 476:main.c        **** 			usart_read_bytes(64);
 3690               		.loc 3 476 0
 3691 0544 80E4      		ldi r24,lo8(64)
 3692 0546 90E0      		ldi r25,0
 3693 0548 00D0      		rcall usart_read_bytes
 3694               	.LVL346:
 477:main.c        **** 			
 478:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3695               		.loc 3 478 0
 3696 054a 939A      		sbi 0x12,3
 3697               	.LVL347:
 3698 054c 10E0      		ldi r17,lo8(receivedBuffer)
 3699 054e A12E      		mov r10,r17
 3700 0550 10E0      		ldi r17,hi8(receivedBuffer)
 3701 0552 B12E      		mov r11,r17
 3702 0554 00E0      		ldi r16,0
 3703 0556 10E0      		ldi r17,0
 3704               	.LVL348:
 3705               	.L160:
 3706               	.LBB228:
 479:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 480:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 3707               		.loc 3 480 0
 3708 0558 D501      		movw r26,r10
 3709 055a 6D91      		ld r22,X+
 3710 055c 5D01      		movw r10,r26
 3711 055e 6F3F      		cpi r22,lo8(-1)
 3712 0560 01F0      		breq .L159
 481:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3713               		.loc 3 481 0
 3714 0562 C801      		movw r24,r16
 3715 0564 8C0D      		add r24,r12
 3716 0566 9D1D      		adc r25,r13
 3717 0568 00D0      		rcall gb_flash_write_byte_special
 3718               	.LVL349:
 3719               	.L159:
 3720 056a 0F5F      		subi r16,-1
 3721 056c 1F4F      		sbci r17,-1
 3722               	.LVL350:
 479:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3723               		.loc 3 479 0 discriminator 2
 3724 056e 0034      		cpi r16,64
 3725 0570 1105      		cpc r17,__zero_reg__
 3726 0572 01F4      		brne .L160
 3727               	.LVL351:
 3728               	.L313:
 3729 0574 B0E4      		ldi r27,64
 3730 0576 CB0E      		add r12,r27
 3731 0578 D11C      		adc r13,__zero_reg__
 3732 057a E11C      		adc r14,__zero_reg__
 3733 057c F11C      		adc r15,__zero_reg__
 3734 057e 00C0      		rjmp .L301
 3735               	.LVL352:
 3736               	.L158:
 3737               	.LBE228:
 482:main.c        **** 				}
 483:main.c        **** 				address++;
 484:main.c        **** 			}
 485:main.c        **** 			
 486:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 487:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 488:main.c        **** 		}
 489:main.c        **** 		
 490:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 491:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3738               		.loc 3 491 0
 3739 0580 8835      		cpi r24,lo8(88)
 3740 0582 01F0      		breq .+2
 3741 0584 00C0      		rjmp .L161
 3742               	.LBB229:
 492:main.c        **** 			usart_read_bytes(256);
 3743               		.loc 3 492 0
 3744 0586 80E0      		ldi r24,0
 3745 0588 91E0      		ldi r25,lo8(1)
 3746 058a 00D0      		rcall usart_read_bytes
 3747               	.LVL353:
 493:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3748               		.loc 3 493 0
 3749 058c 939A      		sbi 0x12,3
 494:main.c        **** 			
 495:main.c        **** 			// Setup buffered write
 496:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3750               		.loc 3 496 0
 3751 058e 69EA      		ldi r22,lo8(-87)
 3752 0590 8AEA      		ldi r24,lo8(-86)
 3753 0592 9AE0      		ldi r25,lo8(10)
 3754 0594 00D0      		rcall gb_flash_write_bus_cycle
 3755               	.LVL354:
 497:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3756               		.loc 3 497 0
 3757 0596 66E5      		ldi r22,lo8(86)
 3758 0598 85E5      		ldi r24,lo8(85)
 3759 059a 95E0      		ldi r25,lo8(5)
 3760 059c 00D0      		rcall gb_flash_write_bus_cycle
 3761               	.LVL355:
 498:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3762               		.loc 3 498 0
 3763 059e 5601      		movw r10,r12
 3764 05a0 66E2      		ldi r22,lo8(38)
 3765 05a2 C601      		movw r24,r12
 3766 05a4 00D0      		rcall gb_flash_write_bus_cycle
 3767               	.LVL356:
 499:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3768               		.loc 3 499 0
 3769 05a6 6FEF      		ldi r22,lo8(-1)
 3770 05a8 C601      		movw r24,r12
 3771 05aa 00D0      		rcall gb_flash_write_bus_cycle
 3772               	.LVL357:
 3773               	.LBB230:
 3774               	.LBB231:
 3775               		.loc 2 276 0
 3776 05ac E5E8      		ldi r30,lo8(-123)
 3777 05ae EA95      	1:	dec r30
 3778 05b0 01F4      		brne 1b
 3779 05b2 0000      		nop
 3780               	.LVL358:
 3781 05b4 00E0      		ldi r16,lo8(receivedBuffer)
 3782 05b6 10E0      		ldi r17,hi8(receivedBuffer)
 3783               	.LBE231:
 3784               	.LBE230:
 3785               	.LBB232:
 500:main.c        **** 			_delay_us(50);
 501:main.c        **** 			
 502:main.c        **** 			// Write data
 503:main.c        **** 			for (int x = 0; x < 256; x++) {
 3786               		.loc 3 503 0
 3787 05b8 812C      		mov r8,__zero_reg__
 3788 05ba 912C      		mov r9,__zero_reg__
 3789               	.LVL359:
 3790               	.L162:
 504:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3791               		.loc 3 504 0 discriminator 3
 3792 05bc D801      		movw r26,r16
 3793 05be 6D91      		ld r22,X+
 3794 05c0 8D01      		movw r16,r26
 3795 05c2 C401      		movw r24,r8
 3796 05c4 8A0D      		add r24,r10
 3797 05c6 9B1D      		adc r25,r11
 3798 05c8 00D0      		rcall gb_flash_write_bus_cycle
 3799               	.LVL360:
 503:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3800               		.loc 3 503 0 discriminator 3
 3801 05ca BFEF      		ldi r27,-1
 3802 05cc 8B1A      		sub r8,r27
 3803 05ce 9B0A      		sbc r9,r27
 3804               	.LVL361:
 3805 05d0 8114      		cp r8,__zero_reg__
 3806 05d2 E1E0      		ldi r30,1
 3807 05d4 9E06      		cpc r9,r30
 3808 05d6 01F4      		brne .L162
 3809 05d8 FFEF      		ldi r31,-1
 3810 05da DF1A      		sub r13,r31
 3811 05dc EF0A      		sbc r14,r31
 3812 05de FF0A      		sbc r15,r31
 3813               	.LBE232:
 505:main.c        **** 				address++;
 506:main.c        **** 			}
 507:main.c        **** 			
 508:main.c        **** 			// Write buffer to flash
 509:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 3814               		.loc 3 509 0
 3815 05e0 C601      		movw r24,r12
 3816 05e2 9A95      		dec r25
 3817 05e4 6AE2      		ldi r22,lo8(42)
 3818 05e6 00D0      		rcall gb_flash_write_bus_cycle
 3819               	.LVL362:
 510:main.c        **** 			
 511:main.c        **** 			// Verify last byte written
 512:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3820               		.loc 3 512 0
 3821 05e8 8601      		movw r16,r12
 3822 05ea 0150      		subi r16,1
 3823 05ec 1109      		sbc r17,__zero_reg__
 3824 05ee C801      		movw r24,r16
 3825 05f0 00D0      		rcall gb_flash_read_byte
 3826               	.LVL363:
 3827               	.L163:
 513:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3828               		.loc 3 513 0
 3829 05f2 9091 0000 		lds r25,receivedBuffer+255
 3830 05f6 8917      		cp r24,r25
 3831 05f8 01F4      		brne .+2
 3832 05fa 00C0      		rjmp .L301
 514:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3833               		.loc 3 514 0
 3834 05fc C801      		movw r24,r16
 3835               	.LVL364:
 3836 05fe 00D0      		rcall gb_flash_read_byte
 3837               	.LVL365:
 3838               	.LBB233:
 3839               	.LBB234:
 3840               		.loc 2 276 0
 3841 0600 2DE0      		ldi r18,lo8(13)
 3842 0602 2A95      	1:	dec r18
 3843 0604 01F4      		brne 1b
 3844 0606 0000      		nop
 3845 0608 00C0      		rjmp .L163
 3846               	.LVL366:
 3847               	.L161:
 3848               	.LBE234:
 3849               	.LBE233:
 3850               	.LBE229:
 515:main.c        **** 				_delay_us(5);
 516:main.c        **** 			}
 517:main.c        **** 			
 518:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 519:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 520:main.c        **** 		}
 521:main.c        **** 		
 522:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 523:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 3851               		.loc 3 523 0
 3852 060a 8A35      		cpi r24,lo8(90)
 3853 060c 01F0      		breq .+2
 3854 060e 00C0      		rjmp .L165
 524:main.c        **** 			usart_read_bytes(128);
 3855               		.loc 3 524 0
 3856 0610 80E8      		ldi r24,lo8(-128)
 3857 0612 90E0      		ldi r25,0
 3858 0614 00D0      		rcall usart_read_bytes
 3859               	.LVL367:
 525:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3860               		.loc 3 525 0
 3861 0616 939A      		sbi 0x12,3
 526:main.c        **** 			
 527:main.c        **** 			// Enable flash chip access
 528:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 3862               		.loc 3 528 0
 3863 0618 69E0      		ldi r22,lo8(9)
 3864 061a 80E2      		ldi r24,lo8(32)
 3865 061c 91E0      		ldi r25,lo8(1)
 3866 061e 00D0      		rcall gb_flash_write_bus_cycle
 3867               	.LVL368:
 529:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3868               		.loc 3 529 0
 3869 0620 6AEA      		ldi r22,lo8(-86)
 3870 0622 81E2      		ldi r24,lo8(33)
 3871 0624 91E0      		ldi r25,lo8(1)
 3872 0626 00D0      		rcall gb_flash_write_bus_cycle
 3873               	.LVL369:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3874               		.loc 3 530 0
 3875 0628 65E5      		ldi r22,lo8(85)
 3876 062a 82E2      		ldi r24,lo8(34)
 3877 062c 91E0      		ldi r25,lo8(1)
 3878 062e 00D0      		rcall gb_flash_write_bus_cycle
 3879               	.LVL370:
 531:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3880               		.loc 3 531 0
 3881 0630 65EA      		ldi r22,lo8(-91)
 3882 0632 8FE3      		ldi r24,lo8(63)
 3883 0634 91E0      		ldi r25,lo8(1)
 3884 0636 00D0      		rcall gb_flash_write_bus_cycle
 3885               	.LVL371:
 3886               	.LBB235:
 3887               	.LBB236:
 3888               		.loc 2 276 0
 3889 0638 8DE0      		ldi r24,lo8(13)
 3890 063a 8A95      	1:	dec r24
 3891 063c 01F4      		brne 1b
 3892 063e 0000      		nop
 3893               	.LVL372:
 3894               	.LBE236:
 3895               	.LBE235:
 532:main.c        **** 			_delay_us(5);
 533:main.c        **** 			
 534:main.c        **** 			// Re-Enable writes to MBC registers
 535:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 3896               		.loc 3 535 0
 3897 0640 61E1      		ldi r22,lo8(17)
 3898 0642 80E2      		ldi r24,lo8(32)
 3899 0644 91E0      		ldi r25,lo8(1)
 3900 0646 00D0      		rcall gb_flash_write_bus_cycle
 3901               	.LVL373:
 536:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3902               		.loc 3 536 0
 3903 0648 65EA      		ldi r22,lo8(-91)
 3904 064a 8FE3      		ldi r24,lo8(63)
 3905 064c 91E0      		ldi r25,lo8(1)
 3906 064e 00D0      		rcall gb_flash_write_bus_cycle
 3907               	.LVL374:
 3908               	.LBB237:
 3909               	.LBB238:
 3910               		.loc 2 276 0
 3911 0650 9DE0      		ldi r25,lo8(13)
 3912 0652 9A95      	1:	dec r25
 3913 0654 01F4      		brne 1b
 3914 0656 0000      		nop
 3915               	.LVL375:
 3916               	.LBE238:
 3917               	.LBE237:
 537:main.c        **** 			_delay_us(5);
 538:main.c        **** 			
 539:main.c        **** 			// Bank 1 for commands
 540:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 3918               		.loc 3 540 0
 3919 0658 61E0      		ldi r22,lo8(1)
 3920 065a 80E0      		ldi r24,0
 3921 065c 91E2      		ldi r25,lo8(33)
 3922 065e 00D0      		rcall gb_flash_write_bus_cycle
 3923               	.LVL376:
 3924               	.LBB239:
 3925               	.LBB240:
 3926               		.loc 2 276 0
 3927 0660 ADE0      		ldi r26,lo8(13)
 3928 0662 AA95      	1:	dec r26
 3929 0664 01F4      		brne 1b
 3930 0666 0000      		nop
 3931               	.LVL377:
 3932               	.LBE240:
 3933               	.LBE239:
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			
 544:main.c        **** 			// Write setup
 545:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3934               		.loc 3 545 0
 3935 0668 6FE0      		ldi r22,lo8(15)
 3936 066a 80E2      		ldi r24,lo8(32)
 3937 066c 91E0      		ldi r25,lo8(1)
 3938 066e 00D0      		rcall gb_flash_write_bus_cycle
 3939               	.LVL378:
 546:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3940               		.loc 3 546 0
 3941 0670 65E5      		ldi r22,lo8(85)
 3942 0672 85E2      		ldi r24,lo8(37)
 3943 0674 91E0      		ldi r25,lo8(1)
 3944 0676 00D0      		rcall gb_flash_write_bus_cycle
 3945               	.LVL379:
 547:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3946               		.loc 3 547 0
 3947 0678 65E5      		ldi r22,lo8(85)
 3948 067a 86E2      		ldi r24,lo8(38)
 3949 067c 91E0      		ldi r25,lo8(1)
 3950 067e 00D0      		rcall gb_flash_write_bus_cycle
 3951               	.LVL380:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3952               		.loc 3 548 0
 3953 0680 6AEA      		ldi r22,lo8(-86)
 3954 0682 87E2      		ldi r24,lo8(39)
 3955 0684 91E0      		ldi r25,lo8(1)
 3956 0686 00D0      		rcall gb_flash_write_bus_cycle
 3957               	.LVL381:
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3958               		.loc 3 549 0
 3959 0688 65EA      		ldi r22,lo8(-91)
 3960 068a 8FE3      		ldi r24,lo8(63)
 3961 068c 91E0      		ldi r25,lo8(1)
 3962 068e 00D0      		rcall gb_flash_write_bus_cycle
 3963               	.LVL382:
 3964               	.LBB241:
 3965               	.LBB242:
 3966               		.loc 2 276 0
 3967 0690 BDE0      		ldi r27,lo8(13)
 3968 0692 BA95      	1:	dec r27
 3969 0694 01F4      		brne 1b
 3970 0696 0000      		nop
 3971               	.LVL383:
 3972               	.LBE242:
 3973               	.LBE241:
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 3974               		.loc 3 552 0
 3975 0698 6FE0      		ldi r22,lo8(15)
 3976 069a 80E2      		ldi r24,lo8(32)
 3977 069c 91E0      		ldi r25,lo8(1)
 3978 069e 00D0      		rcall gb_flash_write_bus_cycle
 3979               	.LVL384:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3980               		.loc 3 553 0
 3981 06a0 6AE2      		ldi r22,lo8(42)
 3982 06a2 85E2      		ldi r24,lo8(37)
 3983 06a4 91E0      		ldi r25,lo8(1)
 3984 06a6 00D0      		rcall gb_flash_write_bus_cycle
 3985               	.LVL385:
 554:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3986               		.loc 3 554 0
 3987 06a8 6AEA      		ldi r22,lo8(-86)
 3988 06aa 86E2      		ldi r24,lo8(38)
 3989 06ac 91E0      		ldi r25,lo8(1)
 3990 06ae 00D0      		rcall gb_flash_write_bus_cycle
 3991               	.LVL386:
 555:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3992               		.loc 3 555 0
 3993 06b0 65E5      		ldi r22,lo8(85)
 3994 06b2 87E2      		ldi r24,lo8(39)
 3995 06b4 91E0      		ldi r25,lo8(1)
 3996 06b6 00D0      		rcall gb_flash_write_bus_cycle
 3997               	.LVL387:
 556:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3998               		.loc 3 556 0
 3999 06b8 65EA      		ldi r22,lo8(-91)
 4000 06ba 8FE3      		ldi r24,lo8(63)
 4001 06bc 91E0      		ldi r25,lo8(1)
 4002 06be 00D0      		rcall gb_flash_write_bus_cycle
 4003               	.LVL388:
 4004               	.LBB243:
 4005               	.LBB244:
 4006               		.loc 2 276 0
 4007 06c0 EDE0      		ldi r30,lo8(13)
 4008 06c2 EA95      	1:	dec r30
 4009 06c4 01F4      		brne 1b
 4010 06c6 0000      		nop
 4011               	.LVL389:
 4012               	.LBE244:
 4013               	.LBE243:
 557:main.c        **** 			_delay_us(5);
 558:main.c        **** 			
 559:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 4014               		.loc 3 559 0
 4015 06c8 6FE0      		ldi r22,lo8(15)
 4016 06ca 80E2      		ldi r24,lo8(32)
 4017 06cc 91E0      		ldi r25,lo8(1)
 4018 06ce 00D0      		rcall gb_flash_write_bus_cycle
 4019               	.LVL390:
 560:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 4020               		.loc 3 560 0
 4021 06d0 65E5      		ldi r22,lo8(85)
 4022 06d2 85E2      		ldi r24,lo8(37)
 4023 06d4 91E0      		ldi r25,lo8(1)
 4024 06d6 00D0      		rcall gb_flash_write_bus_cycle
 4025               	.LVL391:
 561:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 4026               		.loc 3 561 0
 4027 06d8 65E5      		ldi r22,lo8(85)
 4028 06da 86E2      		ldi r24,lo8(38)
 4029 06dc 91E0      		ldi r25,lo8(1)
 4030 06de 00D0      		rcall gb_flash_write_bus_cycle
 4031               	.LVL392:
 562:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 4032               		.loc 3 562 0
 4033 06e0 60EA      		ldi r22,lo8(-96)
 4034 06e2 87E2      		ldi r24,lo8(39)
 4035 06e4 91E0      		ldi r25,lo8(1)
 4036 06e6 00D0      		rcall gb_flash_write_bus_cycle
 4037               	.LVL393:
 563:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4038               		.loc 3 563 0
 4039 06e8 65EA      		ldi r22,lo8(-91)
 4040 06ea 8FE3      		ldi r24,lo8(63)
 4041 06ec 91E0      		ldi r25,lo8(1)
 4042 06ee 00D0      		rcall gb_flash_write_bus_cycle
 4043               	.LVL394:
 4044               	.LBB245:
 4045               	.LBB246:
 4046               		.loc 2 276 0
 4047 06f0 FDE0      		ldi r31,lo8(13)
 4048 06f2 FA95      	1:	dec r31
 4049 06f4 01F4      		brne 1b
 4050 06f6 0000      		nop
 4051               	.LVL395:
 4052               	.LBE246:
 4053               	.LBE245:
 564:main.c        **** 			_delay_us(5);
 565:main.c        **** 			
 566:main.c        **** 			// Set bank back
 567:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 4054               		.loc 3 567 0
 4055 06f8 40E0      		ldi r20,0
 4056 06fa 6091 0000 		lds r22,lastBankAccessed
 4057 06fe 80E0      		ldi r24,0
 4058 0700 91E2      		ldi r25,lo8(33)
 4059 0702 00D0      		rcall write_8bit_data
 4060               	.LVL396:
 4061               	.LBB247:
 4062               	.LBB248:
 4063               		.loc 2 276 0
 4064 0704 2DE0      		ldi r18,lo8(13)
 4065 0706 2A95      	1:	dec r18
 4066 0708 01F4      		brne 1b
 4067 070a 0000      		nop
 4068               	.LVL397:
 4069               	.LBE248:
 4070               	.LBE247:
 568:main.c        **** 			_delay_us(5);
 569:main.c        **** 			
 570:main.c        **** 			// Disable writes to MBC registers
 571:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 4071               		.loc 3 571 0
 4072 070c 60E1      		ldi r22,lo8(16)
 4073 070e 80E2      		ldi r24,lo8(32)
 4074 0710 91E0      		ldi r25,lo8(1)
 4075 0712 00D0      		rcall gb_flash_write_bus_cycle
 4076               	.LVL398:
 572:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4077               		.loc 3 572 0
 4078 0714 65EA      		ldi r22,lo8(-91)
 4079 0716 8FE3      		ldi r24,lo8(63)
 4080 0718 91E0      		ldi r25,lo8(1)
 4081 071a 00D0      		rcall gb_flash_write_bus_cycle
 4082               	.LVL399:
 4083               	.LBB249:
 4084               	.LBB250:
 4085               		.loc 2 276 0
 4086 071c 8DE0      		ldi r24,lo8(13)
 4087 071e 8A95      	1:	dec r24
 4088 0720 01F4      		brne 1b
 4089 0722 0000      		nop
 4090               	.LVL400:
 4091               	.LBE250:
 4092               	.LBE249:
 573:main.c        **** 			_delay_us(5);
 574:main.c        **** 			
 575:main.c        **** 			// Undo Wakeup
 576:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 4093               		.loc 3 576 0
 4094 0724 68E0      		ldi r22,lo8(8)
 4095 0726 80E2      		ldi r24,lo8(32)
 4096 0728 91E0      		ldi r25,lo8(1)
 4097 072a 00D0      		rcall gb_flash_write_bus_cycle
 4098               	.LVL401:
 577:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4099               		.loc 3 577 0
 4100 072c 65EA      		ldi r22,lo8(-91)
 4101 072e 8FE3      		ldi r24,lo8(63)
 4102 0730 91E0      		ldi r25,lo8(1)
 4103 0732 00D0      		rcall gb_flash_write_bus_cycle
 4104               	.LVL402:
 4105               	.LBB251:
 4106               	.LBB252:
 4107               		.loc 2 276 0
 4108 0734 9DE0      		ldi r25,lo8(13)
 4109 0736 9A95      	1:	dec r25
 4110 0738 01F4      		brne 1b
 4111 073a 0000      		nop
 4112               	.LVL403:
 4113 073c 00E0      		ldi r16,lo8(receivedBuffer)
 4114 073e 10E0      		ldi r17,hi8(receivedBuffer)
 4115               	.L166:
 4116               	.LBE252:
 4117               	.LBE251:
 4118               	.LBB253:
 578:main.c        **** 			_delay_us(5);
 579:main.c        **** 			
 580:main.c        **** 			
 581:main.c        **** 			// Write data
 582:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 4119               		.loc 3 582 0 discriminator 1
 4120 0740 F0E0      		ldi r31,hi8(receivedBuffer+128)
 4121 0742 0030      		cpi r16,lo8(receivedBuffer+128)
 4122 0744 1F07      		cpc r17,r31
 4123 0746 01F0      		breq .L315
 583:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4124               		.loc 3 583 0 discriminator 3
 4125 0748 D801      		movw r26,r16
 4126 074a 6D91      		ld r22,X+
 4127 074c 8D01      		movw r16,r26
 4128 074e C601      		movw r24,r12
 4129 0750 00D0      		rcall gb_flash_write_bus_cycle
 4130               	.LVL404:
 4131               	.LBB254:
 4132               	.LBB255:
 4133               		.loc 2 276 0 discriminator 3
 4134 0752 BDE0      		ldi r27,lo8(13)
 4135 0754 BA95      	1:	dec r27
 4136 0756 01F4      		brne 1b
 4137 0758 0000      		nop
 4138               	.LVL405:
 4139               	.LBE255:
 4140               	.LBE254:
 584:main.c        **** 				_delay_us(5);
 585:main.c        **** 				address++;
 4141               		.loc 3 585 0 discriminator 3
 4142 075a EFEF      		ldi r30,-1
 4143 075c CE1A      		sub r12,r30
 4144 075e DE0A      		sbc r13,r30
 4145 0760 EE0A      		sbc r14,r30
 4146 0762 FE0A      		sbc r15,r30
 4147               	.LVL406:
 4148 0764 00C0      		rjmp .L166
 4149               	.L315:
 4150               	.LVL407:
 4151               	.LBE253:
 586:main.c        **** 			}
 587:main.c        **** 			
 588:main.c        **** 			// Write buffer to flash
 589:main.c        **** 			address--;
 590:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 4152               		.loc 3 590 0
 4153 0766 6FEF      		ldi r22,lo8(-1)
 4154 0768 D701      		movw r26,r14
 4155 076a C601      		movw r24,r12
 4156 076c 0197      		sbiw r24,1
 4157 076e A109      		sbc r26,__zero_reg__
 4158 0770 B109      		sbc r27,__zero_reg__
 4159               	.LVL408:
 4160 0772 00D0      		rcall gb_flash_write_bus_cycle
 4161               	.LVL409:
 4162               	.LBB256:
 4163               	.LBB257:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4164               		.loc 2 187 0
 4165 0774 8FE1      		ldi r24,lo8(19999)
 4166 0776 9EE4      		ldi r25,hi8(19999)
 4167 0778 0197      	1:	sbiw r24,1
 4168 077a 01F4      		brne 1b
 4169               	.LVL410:
 4170               	.L314:
 4171 077c 00C0      		rjmp .
 4172 077e 0000      		nop
 4173 0780 00C0      		rjmp .L301
 4174               	.LVL411:
 4175               	.L165:
 4176               	.LBE257:
 4177               	.LBE256:
 591:main.c        **** 			address++;
 592:main.c        **** 			_delay_ms(10);
 593:main.c        **** 			
 594:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 595:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 596:main.c        **** 		}
 597:main.c        **** 		
 598:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 599:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 600:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 4178               		.loc 3 600 0
 4179 0782 8937      		cpi r24,lo8(121)
 4180 0784 01F4      		brne .L168
 601:main.c        **** 			usart_read_bytes(32);
 4181               		.loc 3 601 0
 4182 0786 80E2      		ldi r24,lo8(32)
 4183 0788 90E0      		ldi r25,0
 4184 078a 00D0      		rcall usart_read_bytes
 4185               	.LVL412:
 602:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4186               		.loc 3 602 0
 4187 078c 939A      		sbi 0x12,3
 603:main.c        **** 			
 604:main.c        **** 			// Setup buffered write
 605:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 4188               		.loc 3 605 0
 4189 078e 5601      		movw r10,r12
 4190 0790 68EE      		ldi r22,lo8(-24)
 4191 0792 C601      		movw r24,r12
 4192 0794 00D0      		rcall gb_flash_write_bus_cycle
 4193               	.LVL413:
 4194               	.L169:
 606:main.c        **** 			
 607:main.c        **** 			// Wait until ready
 608:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 609:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 4195               		.loc 3 609 0 discriminator 1
 4196 0796 C501      		movw r24,r10
 4197 0798 00D0      		rcall gb_flash_read_byte
 4198               	.LVL414:
 4199 079a 8038      		cpi r24,lo8(-128)
 4200 079c 01F4      		brne .L169
 610:main.c        **** 			
 611:main.c        **** 			// Set buffer size
 612:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 4201               		.loc 3 612 0
 4202 079e 6FE1      		ldi r22,lo8(31)
 4203 07a0 C501      		movw r24,r10
 4204 07a2 00D0      		rcall gb_flash_write_bus_cycle
 4205               	.LVL415:
 4206 07a4 00E0      		ldi r16,lo8(receivedBuffer)
 4207 07a6 10E0      		ldi r17,hi8(receivedBuffer)
 4208 07a8 812C      		mov r8,__zero_reg__
 4209 07aa 912C      		mov r9,__zero_reg__
 4210               	.LVL416:
 4211               	.L170:
 4212               	.LBB258:
 613:main.c        **** 			
 614:main.c        **** 			// Write data to buffer
 615:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 616:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4213               		.loc 3 616 0 discriminator 3
 4214 07ac D801      		movw r26,r16
 4215 07ae 6D91      		ld r22,X+
 4216 07b0 8D01      		movw r16,r26
 4217 07b2 C401      		movw r24,r8
 4218 07b4 8A0D      		add r24,r10
 4219 07b6 9B1D      		adc r25,r11
 4220 07b8 00D0      		rcall gb_flash_write_bus_cycle
 4221               	.LVL417:
 4222 07ba BFEF      		ldi r27,-1
 4223 07bc 8B1A      		sub r8,r27
 4224 07be 9B0A      		sbc r9,r27
 4225               	.LVL418:
 615:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4226               		.loc 3 615 0 discriminator 3
 4227 07c0 E0E2      		ldi r30,32
 4228 07c2 8E16      		cp r8,r30
 4229 07c4 9104      		cpc r9,__zero_reg__
 4230 07c6 01F4      		brne .L170
 4231 07c8 F0E2      		ldi r31,32
 4232 07ca CF0E      		add r12,r31
 4233 07cc D11C      		adc r13,__zero_reg__
 4234 07ce E11C      		adc r14,__zero_reg__
 4235 07d0 F11C      		adc r15,__zero_reg__
 4236               	.LBE258:
 617:main.c        **** 				address++;
 618:main.c        **** 			}
 619:main.c        **** 			
 620:main.c        **** 			// Write buffer to flash
 621:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 4237               		.loc 3 621 0
 4238 07d2 8601      		movw r16,r12
 4239 07d4 0052      		subi r16,32
 4240 07d6 1109      		sbc r17,__zero_reg__
 4241 07d8 60ED      		ldi r22,lo8(-48)
 4242 07da C801      		movw r24,r16
 4243 07dc 00D0      		rcall gb_flash_write_bus_cycle
 4244               	.LVL419:
 4245               	.LBB259:
 4246               	.LBB260:
 4247               		.loc 2 276 0
 4248 07de 87E8      		ldi r24,lo8(391)
 4249 07e0 91E0      		ldi r25,hi8(391)
 4250 07e2 0197      	1:	sbiw r24,1
 4251 07e4 01F4      		brne 1b
 4252 07e6 00C0      		rjmp .
 4253 07e8 0000      		nop
 4254               	.L171:
 4255               	.LBE260:
 4256               	.LBE259:
 622:main.c        **** 			_delay_us(196);
 623:main.c        **** 			
 624:main.c        **** 			// Wait until ready
 625:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 626:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 4257               		.loc 3 626 0 discriminator 1
 4258 07ea C801      		movw r24,r16
 4259 07ec 00D0      		rcall gb_flash_read_byte
 4260               	.LVL420:
 4261 07ee 8038      		cpi r24,lo8(-128)
 4262 07f0 01F4      		brne .L171
 4263 07f2 00C0      		rjmp .L301
 4264               	.LVL421:
 4265               	.L168:
 627:main.c        **** 			
 628:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 629:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 630:main.c        **** 		}
 631:main.c        **** 		
 632:main.c        **** 		
 633:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 634:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 635:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4266               		.loc 3 635 0
 4267 07f4 8E36      		cpi r24,lo8(110)
 4268 07f6 01F4      		brne .L172
 4269               	.LBB261:
 636:main.c        **** 			usart_read_chars(); // Read address
 4270               		.loc 3 636 0
 4271 07f8 00D0      		rcall usart_read_chars
 4272               	.LVL422:
 637:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4273               		.loc 3 637 0
 4274 07fa 40E1      		ldi r20,lo8(16)
 4275 07fc 50E0      		ldi r21,0
 4276 07fe 60E0      		ldi r22,0
 4277 0800 70E0      		ldi r23,0
 4278 0802 80E0      		ldi r24,lo8(receivedBuffer)
 4279 0804 90E0      		ldi r25,hi8(receivedBuffer)
 4280 0806 00D0      		rcall strtol
 4281               	.LVL423:
 4282 0808 4B01      		movw r8,r22
 4283 080a 5C01      		movw r10,r24
 4284               	.LVL424:
 638:main.c        **** 			
 639:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 4285               		.loc 3 639 0
 4286 080c 00D0      		rcall USART_Receive
 4287               	.LVL425:
 4288 080e 8093 0000 		sts receivedChar,r24
 640:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4289               		.loc 3 640 0
 4290 0812 8E36      		cpi r24,lo8(110)
 4291 0814 01F0      		breq .+2
 4292 0816 00C0      		rjmp .L99
 4293               	.LBB262:
 641:main.c        **** 				usart_read_chars(); // Read data
 4294               		.loc 3 641 0
 4295 0818 00D0      		rcall usart_read_chars
 4296               	.LVL426:
 642:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4297               		.loc 3 642 0
 4298 081a 40E1      		ldi r20,lo8(16)
 4299 081c 50E0      		ldi r21,0
 4300 081e 60E0      		ldi r22,0
 4301 0820 70E0      		ldi r23,0
 4302 0822 80E0      		ldi r24,lo8(receivedBuffer)
 4303 0824 90E0      		ldi r25,hi8(receivedBuffer)
 4304 0826 00D0      		rcall strtol
 4305               	.LVL427:
 643:main.c        **** 				
 644:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 4306               		.loc 3 644 0
 4307 0828 939A      		sbi 0x12,3
 645:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4308               		.loc 3 645 0
 4309 082a AFEF      		ldi r26,lo8(-1)
 4310 082c A4BB      		out 0x14,r26
 646:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4311               		.loc 3 646 0
 4312 082e AABB      		out 0x1a,r26
 647:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4313               		.loc 3 647 0
 4314 0830 A7BB      		out 0x17,r26
 648:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4315               		.loc 3 648 0
 4316 0832 AB01      		movw r20,r22
 4317 0834 C501      		movw r24,r10
 4318 0836 B401      		movw r22,r8
 4319               	.LVL428:
 4320 0838 00D0      		rcall gba_flash_write_bus_cycle
 4321               	.LVL429:
 4322               	.L312:
 649:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4323               		.loc 3 649 0
 4324 083a 9398      		cbi 0x12,3
 650:main.c        **** 				
 651:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 4325               		.loc 3 651 0
 4326 083c 81E3      		ldi r24,lo8(49)
 4327 083e 00C0      		rjmp .L292
 4328               	.LVL430:
 4329               	.L172:
 4330               	.LBE262:
 4331               	.LBE261:
 652:main.c        **** 			}
 653:main.c        **** 		}
 654:main.c        **** 		
 655:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 656:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 4332               		.loc 3 656 0
 4333 0840 8137      		cpi r24,lo8(113)
 4334 0842 01F0      		breq .L173
 4335               		.loc 3 656 0 is_stmt 0 discriminator 1
 4336 0844 8437      		cpi r24,lo8(116)
 4337 0846 01F4      		brne .L174
 4338               	.L173:
 4339               	.LBB263:
 657:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4340               		.loc 3 657 0 is_stmt 1
 4341 0848 939A      		sbi 0x12,3
 4342               	.LVL431:
 658:main.c        **** 			
 659:main.c        **** 			int readLength = 64;
 660:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4343               		.loc 3 660 0
 4344 084a 8091 0000 		lds r24,receivedChar
 4345 084e 8437      		cpi r24,lo8(116)
 4346 0850 01F4      		brne .L237
 661:main.c        **** 				readLength = 256;
 4347               		.loc 3 661 0
 4348 0852 00E0      		ldi r16,0
 4349 0854 11E0      		ldi r17,lo8(1)
 4350 0856 00C0      		rjmp .L175
 4351               	.L237:
 659:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4352               		.loc 3 659 0
 4353 0858 00E4      		ldi r16,lo8(64)
 4354 085a 10E0      		ldi r17,0
 4355               	.L175:
 4356               	.LVL432:
 662:main.c        **** 			}
 663:main.c        **** 			usart_read_bytes(readLength);
 4357               		.loc 3 663 0
 4358 085c C801      		movw r24,r16
 4359 085e 00D0      		rcall usart_read_bytes
 4360               	.LVL433:
 4361 0860 B0E0      		ldi r27,lo8(receivedBuffer)
 4362 0862 AB2E      		mov r10,r27
 4363 0864 B0E0      		ldi r27,hi8(receivedBuffer)
 4364 0866 BB2E      		mov r11,r27
 4365 0868 2601      		movw r4,r12
 4366 086a 3701      		movw r6,r14
 4367               	.LVL434:
 4368               	.L177:
 4369               	.LBB264:
 4370               	.LBB265:
 664:main.c        **** 			
 665:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 666:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4371               		.loc 3 666 0
 4372 086c F501      		movw r30,r10
 4373 086e 4181      		ldd r20,Z+1
 4374 0870 50E0      		ldi r21,0
 4375 0872 542F      		mov r21,r20
 4376 0874 4427      		clr r20
 4377 0876 8081      		ld r24,Z
 4378 0878 482B      		or r20,r24
 4379               	.LVL435:
 667:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4380               		.loc 3 667 0
 4381 087a 4F3F      		cpi r20,-1
 4382 087c FFEF      		ldi r31,-1
 4383 087e 5F07      		cpc r21,r31
 4384 0880 01F0      		breq .L176
 668:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4385               		.loc 3 668 0
 4386 0882 21E0      		ldi r18,lo8(1)
 4387 0884 C301      		movw r24,r6
 4388 0886 B201      		movw r22,r4
 4389 0888 00D0      		rcall gba_flash_write_byte
 4390               	.LVL436:
 4391               	.L176:
 669:main.c        **** 				}
 670:main.c        **** 				address++;
 4392               		.loc 3 670 0 discriminator 2
 4393 088a 2FEF      		ldi r18,-1
 4394 088c 421A      		sub r4,r18
 4395 088e 520A      		sbc r5,r18
 4396 0890 620A      		sbc r6,r18
 4397 0892 720A      		sbc r7,r18
 4398               	.LVL437:
 4399 0894 82E0      		ldi r24,2
 4400 0896 A80E      		add r10,r24
 4401 0898 B11C      		adc r11,__zero_reg__
 4402               	.LVL438:
 4403               	.LBE265:
 665:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4404               		.loc 3 665 0 discriminator 2
 4405 089a C501      		movw r24,r10
 4406 089c 8050      		subi r24,lo8(receivedBuffer)
 4407 089e 9040      		sbci r25,hi8(receivedBuffer)
 4408 08a0 8017      		cp r24,r16
 4409 08a2 9107      		cpc r25,r17
 4410 08a4 04F0      		brlt .L177
 4411 08a6 9FEF      		ldi r25,-1
 4412 08a8 C91A      		sub r12,r25
 4413 08aa D90A      		sbc r13,r25
 4414 08ac E90A      		sbc r14,r25
 4415 08ae F90A      		sbc r15,r25
 4416 08b0 0150      		subi r16,1
 4417 08b2 1109      		sbc r17,__zero_reg__
 4418               	.LVL439:
 4419 08b4 1695      		lsr r17
 4420 08b6 0795      		ror r16
 4421               	.LVL440:
 4422 08b8 C00E      		add r12,r16
 4423 08ba D11E      		adc r13,r17
 4424 08bc E11C      		adc r14,__zero_reg__
 4425 08be F11C      		adc r15,__zero_reg__
 4426 08c0 00C0      		rjmp .L301
 4427               	.LVL441:
 4428               	.L174:
 4429               	.LBE264:
 4430               	.LBE263:
 671:main.c        **** 			}
 672:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 673:main.c        **** 			
 674:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 675:main.c        **** 		}
 676:main.c        **** 		
 677:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 678:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 4431               		.loc 3 678 0
 4432 08c2 8636      		cpi r24,lo8(102)
 4433 08c4 01F4      		brne .L178
 4434               	.LBB266:
 679:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4435               		.loc 3 679 0
 4436 08c6 939A      		sbi 0x12,3
 4437               	.LVL442:
 680:main.c        **** 			
 681:main.c        **** 			int readLength = 256;
 682:main.c        **** 			usart_read_bytes(readLength);
 4438               		.loc 3 682 0
 4439 08c8 80E0      		ldi r24,0
 4440 08ca 91E0      		ldi r25,lo8(1)
 4441 08cc 00D0      		rcall usart_read_bytes
 4442               	.LVL443:
 4443 08ce 00E0      		ldi r16,lo8(receivedBuffer)
 4444 08d0 10E0      		ldi r17,hi8(receivedBuffer)
 4445 08d2 4601      		movw r8,r12
 4446 08d4 5701      		movw r10,r14
 4447               	.LVL444:
 4448               	.L180:
 4449               	.LBB267:
 4450               	.LBB268:
 683:main.c        **** 			
 684:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 685:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4451               		.loc 3 685 0
 4452 08d6 D801      		movw r26,r16
 4453 08d8 1196      		adiw r26,1
 4454 08da 4C91      		ld r20,X
 4455 08dc 1197      		sbiw r26,1
 4456 08de 50E0      		ldi r21,0
 4457 08e0 542F      		mov r21,r20
 4458 08e2 4427      		clr r20
 4459 08e4 8C91      		ld r24,X
 4460 08e6 482B      		or r20,r24
 4461               	.LVL445:
 686:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4462               		.loc 3 686 0
 4463 08e8 4F3F      		cpi r20,-1
 4464 08ea BFEF      		ldi r27,-1
 4465 08ec 5B07      		cpc r21,r27
 4466 08ee 01F0      		breq .L179
 687:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4467               		.loc 3 687 0
 4468 08f0 20E0      		ldi r18,0
 4469 08f2 C501      		movw r24,r10
 4470 08f4 B401      		movw r22,r8
 4471 08f6 00D0      		rcall gba_flash_write_byte
 4472               	.LVL446:
 4473               	.L179:
 688:main.c        **** 				}
 689:main.c        **** 				address++;
 4474               		.loc 3 689 0 discriminator 2
 4475 08f8 EFEF      		ldi r30,-1
 4476 08fa 8E1A      		sub r8,r30
 4477 08fc 9E0A      		sbc r9,r30
 4478 08fe AE0A      		sbc r10,r30
 4479 0900 BE0A      		sbc r11,r30
 4480               	.LVL447:
 4481 0902 0E5F      		subi r16,-2
 4482 0904 1F4F      		sbci r17,-1
 4483               	.LVL448:
 4484               	.LBE268:
 684:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4485               		.loc 3 684 0 discriminator 2
 4486 0906 F0E0      		ldi r31,hi8(receivedBuffer+256)
 4487 0908 0030      		cpi r16,lo8(receivedBuffer+256)
 4488 090a 1F07      		cpc r17,r31
 4489 090c 01F4      		brne .L180
 4490 090e 20E8      		ldi r18,-128
 4491 0910 C20E      		add r12,r18
 4492 0912 D11C      		adc r13,__zero_reg__
 4493 0914 E11C      		adc r14,__zero_reg__
 4494 0916 F11C      		adc r15,__zero_reg__
 4495 0918 00C0      		rjmp .L301
 4496               	.LVL449:
 4497               	.L178:
 4498               	.LBE267:
 4499               	.LBE266:
 690:main.c        **** 			}
 691:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 692:main.c        **** 			
 693:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 694:main.c        **** 		}
 695:main.c        **** 		
 696:main.c        **** 		// Intel flash command based chips
 697:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 698:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 4500               		.loc 3 698 0
 4501 091a 8C36      		cpi r24,lo8(108)
 4502 091c 01F0      		breq .+2
 4503 091e 00C0      		rjmp .L181
 4504               	.LBB269:
 699:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4505               		.loc 3 699 0
 4506 0920 939A      		sbi 0x12,3
 700:main.c        **** 			usart_read_bytes(64);
 4507               		.loc 3 700 0
 4508 0922 80E4      		ldi r24,lo8(64)
 4509 0924 90E0      		ldi r25,0
 4510 0926 00D0      		rcall usart_read_bytes
 4511               	.LVL450:
 701:main.c        **** 			
 702:main.c        **** 			// Set address lines as outputs
 703:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4512               		.loc 3 703 0
 4513 0928 8FEF      		ldi r24,lo8(-1)
 4514 092a 84BB      		out 0x14,r24
 704:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4515               		.loc 3 704 0
 4516 092c 8ABB      		out 0x1a,r24
 705:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4517               		.loc 3 705 0
 4518 092e 87BB      		out 0x17,r24
 706:main.c        **** 			
 707:main.c        **** 			// Unlock
 708:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 4519               		.loc 3 708 0
 4520 0930 40E6      		ldi r20,lo8(96)
 4521 0932 50E0      		ldi r21,0
 4522 0934 C701      		movw r24,r14
 4523 0936 B601      		movw r22,r12
 4524 0938 00D0      		rcall gba_flash_write_bus_cycle
 4525               	.LVL451:
 709:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4526               		.loc 3 709 0
 4527 093a 40ED      		ldi r20,lo8(-48)
 4528 093c 50E0      		ldi r21,0
 4529 093e C701      		movw r24,r14
 4530 0940 B601      		movw r22,r12
 4531 0942 00D0      		rcall gba_flash_write_bus_cycle
 4532               	.LVL452:
 710:main.c        **** 			
 711:main.c        **** 			// Buffered write command
 712:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 4533               		.loc 3 712 0
 4534 0944 48EE      		ldi r20,lo8(-24)
 4535 0946 50E0      		ldi r21,0
 4536 0948 C701      		movw r24,r14
 4537 094a B601      		movw r22,r12
 4538 094c 00D0      		rcall gba_flash_write_bus_cycle
 4539               	.LVL453:
 4540               	.LBB270:
 4541               	.LBB271:
 4542               		.loc 2 276 0
 4543 094e 95E8      		ldi r25,lo8(-123)
 4544 0950 9A95      	1:	dec r25
 4545 0952 01F4      		brne 1b
 4546 0954 0000      		nop
 4547               	.LVL454:
 4548               	.LBE271:
 4549               	.LBE270:
 713:main.c        **** 			_delay_us(50);
 714:main.c        **** 			
 715:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 716:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 4550               		.loc 3 716 0
 4551 0956 C701      		movw r24,r14
 4552 0958 B601      		movw r22,r12
 4553 095a 00D0      		rcall gba_read_16bit_data
 4554               	.LVL455:
 4555               	.L182:
 717:main.c        **** 			while (dataVerify != 0x0080) {
 4556               		.loc 3 717 0
 4557 095c 8038      		cpi r24,-128
 4558 095e 9105      		cpc r25,__zero_reg__
 4559 0960 01F0      		breq .L316
 718:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4560               		.loc 3 718 0
 4561 0962 C701      		movw r24,r14
 4562 0964 B601      		movw r22,r12
 4563 0966 00D0      		rcall gba_read_16bit_data
 4564               	.LVL456:
 4565               	.LBB272:
 4566               	.LBB273:
 4567               		.loc 2 276 0
 4568 0968 A5E8      		ldi r26,lo8(-123)
 4569 096a AA95      	1:	dec r26
 4570 096c 01F4      		brne 1b
 4571 096e 0000      		nop
 4572 0970 00C0      		rjmp .L182
 4573               	.LVL457:
 4574               	.L316:
 4575               	.LBE273:
 4576               	.LBE272:
 719:main.c        **** 				_delay_us(50);
 720:main.c        **** 			}
 721:main.c        **** 			
 722:main.c        **** 			
 723:main.c        **** 			// Set address lines as outputs
 724:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4577               		.loc 3 724 0
 4578 0972 BFEF      		ldi r27,lo8(-1)
 4579 0974 B4BB      		out 0x14,r27
 725:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4580               		.loc 3 725 0
 4581 0976 BABB      		out 0x1a,r27
 726:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4582               		.loc 3 726 0
 4583 0978 B7BB      		out 0x17,r27
 727:main.c        **** 			
 728:main.c        **** 			// Set length
 729:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 4584               		.loc 3 729 0
 4585 097a 4FE1      		ldi r20,lo8(31)
 4586 097c 50E0      		ldi r21,0
 4587 097e C701      		movw r24,r14
 4588 0980 B601      		movw r22,r12
 4589 0982 00D0      		rcall gba_flash_write_bus_cycle
 4590               	.LVL458:
 4591 0984 00E0      		ldi r16,lo8(receivedBuffer)
 4592 0986 10E0      		ldi r17,hi8(receivedBuffer)
 4593 0988 4601      		movw r8,r12
 4594 098a 5701      		movw r10,r14
 4595               	.LVL459:
 4596               	.L184:
 4597               	.LBB274:
 4598               	.LBB275:
 730:main.c        **** 			
 731:main.c        **** 			// Write data
 732:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 733:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 734:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4599               		.loc 3 734 0 discriminator 3
 4600 098c F801      		movw r30,r16
 4601 098e 4181      		ldd r20,Z+1
 4602 0990 50E0      		ldi r21,0
 4603 0992 542F      		mov r21,r20
 4604 0994 4427      		clr r20
 4605 0996 8081      		ld r24,Z
 4606 0998 482B      		or r20,r24
 4607 099a C501      		movw r24,r10
 4608 099c B401      		movw r22,r8
 4609 099e 00D0      		rcall gba_flash_write_bus_cycle
 4610               	.LVL460:
 735:main.c        **** 				address++;
 4611               		.loc 3 735 0 discriminator 3
 4612 09a0 FFEF      		ldi r31,-1
 4613 09a2 8F1A      		sub r8,r31
 4614 09a4 9F0A      		sbc r9,r31
 4615 09a6 AF0A      		sbc r10,r31
 4616 09a8 BF0A      		sbc r11,r31
 4617               	.LVL461:
 4618 09aa 0E5F      		subi r16,-2
 4619 09ac 1F4F      		sbci r17,-1
 4620               	.LVL462:
 4621               	.LBE275:
 732:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4622               		.loc 3 732 0 discriminator 3
 4623 09ae 80E0      		ldi r24,lo8(receivedBuffer+64)
 4624 09b0 90E0      		ldi r25,hi8(receivedBuffer+64)
 4625 09b2 8017      		cp r24,r16
 4626 09b4 9107      		cpc r25,r17
 4627 09b6 01F4      		brne .L184
 4628 09b8 90E2      		ldi r25,32
 4629 09ba C90E      		add r12,r25
 4630 09bc D11C      		adc r13,__zero_reg__
 4631 09be E11C      		adc r14,__zero_reg__
 4632 09c0 F11C      		adc r15,__zero_reg__
 4633               	.LBE274:
 736:main.c        **** 			}
 737:main.c        **** 			
 738:main.c        **** 			// Write buffer to flash
 739:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4634               		.loc 3 739 0
 4635 09c2 40ED      		ldi r20,lo8(-48)
 4636 09c4 50E0      		ldi r21,0
 4637 09c6 C701      		movw r24,r14
 4638 09c8 B601      		movw r22,r12
 4639 09ca 00D0      		rcall gba_flash_write_bus_cycle
 4640               	.LVL463:
 4641               	.LBB276:
 4642               	.LBB277:
 4643               		.loc 2 276 0
 4644 09cc AFE6      		ldi r26,lo8(879)
 4645 09ce B3E0      		ldi r27,hi8(879)
 4646 09d0 1197      	1:	sbiw r26,1
 4647 09d2 01F4      		brne 1b
 4648 09d4 00C0      		rjmp .
 4649 09d6 0000      		nop
 4650               	.LVL464:
 4651               	.LBE277:
 4652               	.LBE276:
 740:main.c        **** 			_delay_us(440);
 741:main.c        **** 			
 742:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 743:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 4653               		.loc 3 743 0
 4654 09d8 C701      		movw r24,r14
 4655 09da B601      		movw r22,r12
 4656 09dc 00D0      		rcall gba_read_16bit_data
 4657               	.LVL465:
 4658               	.L185:
 744:main.c        **** 			while (dataVerify != 0x0080) {
 4659               		.loc 3 744 0
 4660 09de 8038      		cpi r24,-128
 4661 09e0 9105      		cpc r25,__zero_reg__
 4662 09e2 01F0      		breq .L317
 745:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4663               		.loc 3 745 0
 4664 09e4 C701      		movw r24,r14
 4665 09e6 B601      		movw r22,r12
 4666 09e8 00D0      		rcall gba_read_16bit_data
 4667               	.LVL466:
 4668               	.LBB278:
 4669               	.LBB279:
 4670               		.loc 2 276 0
 4671 09ea B5E8      		ldi r27,lo8(-123)
 4672 09ec BA95      	1:	dec r27
 4673 09ee 01F4      		brne 1b
 4674 09f0 0000      		nop
 4675 09f2 00C0      		rjmp .L185
 4676               	.LVL467:
 4677               	.L317:
 4678               	.LBE279:
 4679               	.LBE278:
 746:main.c        **** 				_delay_us(50);
 747:main.c        **** 			}
 748:main.c        **** 			
 749:main.c        **** 			
 750:main.c        **** 			// Set address lines as outputs
 751:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4680               		.loc 3 751 0
 4681 09f4 EFEF      		ldi r30,lo8(-1)
 4682 09f6 E4BB      		out 0x14,r30
 752:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4683               		.loc 3 752 0
 4684 09f8 EABB      		out 0x1a,r30
 753:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4685               		.loc 3 753 0
 4686 09fa E7BB      		out 0x17,r30
 754:main.c        **** 			
 755:main.c        **** 			// Back to reading mode
 756:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 4687               		.loc 3 756 0
 4688 09fc 4FEF      		ldi r20,lo8(-1)
 4689 09fe 50E0      		ldi r21,0
 4690 0a00 C701      		movw r24,r14
 4691 0a02 B601      		movw r22,r12
 4692 0a04 00D0      		rcall gba_flash_write_bus_cycle
 4693               	.LVL468:
 4694 0a06 00C0      		rjmp .L301
 4695               	.LVL469:
 4696               	.L181:
 4697               	.LBE269:
 757:main.c        **** 			
 758:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 759:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 760:main.c        **** 		}
 761:main.c        **** 		
 762:main.c        **** 		// Intel word programming
 763:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 4698               		.loc 3 763 0
 4699 0a08 8537      		cpi r24,lo8(117)
 4700 0a0a 01F0      		breq .+2
 4701 0a0c 00C0      		rjmp .L187
 764:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4702               		.loc 3 764 0
 4703 0a0e 939A      		sbi 0x12,3
 765:main.c        **** 			usart_read_bytes(64);
 4704               		.loc 3 765 0
 4705 0a10 80E4      		ldi r24,lo8(64)
 4706 0a12 90E0      		ldi r25,0
 4707 0a14 00D0      		rcall usart_read_bytes
 4708               	.LVL470:
 4709 0a16 50E0      		ldi r21,lo8(receivedBuffer)
 4710 0a18 A52E      		mov r10,r21
 4711 0a1a 50E0      		ldi r21,hi8(receivedBuffer)
 4712 0a1c B52E      		mov r11,r21
 4713 0a1e 2601      		movw r4,r12
 4714 0a20 3701      		movw r6,r14
 4715               	.LVL471:
 4716               	.L190:
 4717               	.LBB280:
 4718               	.LBB281:
 766:main.c        **** 			
 767:main.c        **** 			// Write data
 768:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 769:main.c        **** 				// Set address lines as outputs
 770:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4719               		.loc 3 770 0
 4720 0a22 FFEF      		ldi r31,lo8(-1)
 4721 0a24 F4BB      		out 0x14,r31
 771:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4722               		.loc 3 771 0
 4723 0a26 FABB      		out 0x1a,r31
 772:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4724               		.loc 3 772 0
 4725 0a28 F7BB      		out 0x17,r31
 773:main.c        **** 				
 774:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4726               		.loc 3 774 0
 4727 0a2a D501      		movw r26,r10
 4728 0a2c 1196      		adiw r26,1
 4729 0a2e 0C91      		ld r16,X
 4730 0a30 1197      		sbiw r26,1
 4731 0a32 10E0      		ldi r17,0
 4732 0a34 102F      		mov r17,r16
 4733 0a36 0027      		clr r16
 4734 0a38 8C91      		ld r24,X
 4735 0a3a 082B      		or r16,r24
 4736               	.LVL472:
 775:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4737               		.loc 3 775 0
 4738 0a3c 40E4      		ldi r20,lo8(64)
 4739 0a3e 50E0      		ldi r21,0
 4740 0a40 C301      		movw r24,r6
 4741 0a42 B201      		movw r22,r4
 4742 0a44 00D0      		rcall gba_flash_write_bus_cycle
 4743               	.LVL473:
 776:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4744               		.loc 3 776 0
 4745 0a46 A801      		movw r20,r16
 4746 0a48 C301      		movw r24,r6
 4747 0a4a B201      		movw r22,r4
 4748 0a4c 00D0      		rcall gba_flash_write_bus_cycle
 4749               	.LVL474:
 777:main.c        **** 				
 778:main.c        **** 				// Verify status ok
 779:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4750               		.loc 3 779 0
 4751 0a4e C301      		movw r24,r6
 4752 0a50 B201      		movw r22,r4
 4753 0a52 00D0      		rcall gba_read_16bit_data
 4754               	.LVL475:
 4755               	.L188:
 780:main.c        **** 				while ((status & 0x80) == 0) {
 4756               		.loc 3 780 0
 4757 0a54 87FD      		sbrc r24,7
 4758 0a56 00C0      		rjmp .L318
 781:main.c        **** 					status = gba_read_16bit_data(address);
 4759               		.loc 3 781 0
 4760 0a58 C301      		movw r24,r6
 4761 0a5a B201      		movw r22,r4
 4762 0a5c 00D0      		rcall gba_read_16bit_data
 4763               	.LVL476:
 4764               	.LBB282:
 4765               	.LBB283:
 4766               		.loc 2 276 0
 4767 0a5e B5E0      		ldi r27,lo8(5)
 4768 0a60 BA95      	1:	dec r27
 4769 0a62 01F4      		brne 1b
 4770 0a64 0000      		nop
 4771 0a66 00C0      		rjmp .L188
 4772               	.LVL477:
 4773               	.L318:
 4774               	.LBE283:
 4775               	.LBE282:
 782:main.c        **** 					_delay_us(2);
 783:main.c        **** 				}
 784:main.c        **** 				address++;
 4776               		.loc 3 784 0 discriminator 2
 4777 0a68 EFEF      		ldi r30,-1
 4778 0a6a 4E1A      		sub r4,r30
 4779 0a6c 5E0A      		sbc r5,r30
 4780 0a6e 6E0A      		sbc r6,r30
 4781 0a70 7E0A      		sbc r7,r30
 4782               	.LVL478:
 4783 0a72 F2E0      		ldi r31,2
 4784 0a74 AF0E      		add r10,r31
 4785 0a76 B11C      		adc r11,__zero_reg__
 4786               	.LVL479:
 4787               	.LBE281:
 768:main.c        **** 				// Set address lines as outputs
 4788               		.loc 3 768 0 discriminator 2
 4789 0a78 20E0      		ldi r18,lo8(receivedBuffer+64)
 4790 0a7a A216      		cp r10,r18
 4791 0a7c 20E0      		ldi r18,hi8(receivedBuffer+64)
 4792 0a7e B206      		cpc r11,r18
 4793 0a80 01F4      		brne .L190
 4794 0a82 80E2      		ldi r24,32
 4795 0a84 C80E      		add r12,r24
 4796 0a86 D11C      		adc r13,__zero_reg__
 4797 0a88 E11C      		adc r14,__zero_reg__
 4798 0a8a F11C      		adc r15,__zero_reg__
 4799 0a8c 00C0      		rjmp .L301
 4800               	.LVL480:
 4801               	.L187:
 4802               	.LBE280:
 785:main.c        **** 			}
 786:main.c        **** 			
 787:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 788:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 789:main.c        **** 		}
 790:main.c        **** 		
 791:main.c        **** 		// Intel flash command based chips, two chips interleaved (Flash2Advance 256M cart)
 792:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 793:main.c        **** 		// Thanks to lesserkuma for adding support
 794:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE) {
 4803               		.loc 3 794 0
 4804 0a8e 8637      		cpi r24,lo8(118)
 4805 0a90 01F0      		breq .+2
 4806 0a92 00C0      		rjmp .L191
 795:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4807               		.loc 3 795 0
 4808 0a94 939A      		sbi 0x12,3
 796:main.c        **** 			usart_read_bytes(256);
 4809               		.loc 3 796 0
 4810 0a96 80E0      		ldi r24,0
 4811 0a98 91E0      		ldi r25,lo8(1)
 4812 0a9a 00D0      		rcall usart_read_bytes
 4813               	.LVL481:
 4814 0a9c 30E0      		ldi r19,lo8(receivedBuffer)
 4815 0a9e 232E      		mov r2,r19
 4816 0aa0 30E0      		ldi r19,hi8(receivedBuffer)
 4817 0aa2 332E      		mov r3,r19
 4818 0aa4 4601      		movw r8,r12
 4819 0aa6 5701      		movw r10,r14
 4820               	.LVL482:
 4821               	.L197:
 4822               	.LBB284:
 4823               	.LBB285:
 797:main.c        **** 			
 798:main.c        **** 			// Loop four times, transferring 256 bytes over USB at once is faster than doing four transfers
 799:main.c        **** 			for (int c = 0; c < 4; c++) {
 800:main.c        **** 				// Set address lines as outputs
 801:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4824               		.loc 3 801 0
 4825 0aa8 9FEF      		ldi r25,lo8(-1)
 4826 0aaa 94BB      		out 0x14,r25
 802:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4827               		.loc 3 802 0
 4828 0aac 9ABB      		out 0x1a,r25
 803:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4829               		.loc 3 803 0
 4830 0aae 97BB      		out 0x17,r25
 804:main.c        **** 				
 805:main.c        **** 				// Setup buffered write
 806:main.c        **** 				gba_flash_write_bus_cycle(address, 0xE8);
 4831               		.loc 3 806 0
 4832 0ab0 48EE      		ldi r20,lo8(-24)
 4833 0ab2 50E0      		ldi r21,0
 4834 0ab4 C501      		movw r24,r10
 4835 0ab6 B401      		movw r22,r8
 4836 0ab8 00D0      		rcall gba_flash_write_bus_cycle
 4837               	.LVL483:
 4838 0aba D501      		movw r26,r10
 4839 0abc C401      		movw r24,r8
 4840 0abe 0196      		adiw r24,1
 4841 0ac0 A11D      		adc r26,__zero_reg__
 4842 0ac2 B11D      		adc r27,__zero_reg__
 4843 0ac4 8983      		std Y+1,r24
 4844 0ac6 9A83      		std Y+2,r25
 4845 0ac8 AB83      		std Y+3,r26
 4846 0aca BC83      		std Y+4,r27
 807:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 4847               		.loc 3 807 0
 4848 0acc 48EE      		ldi r20,lo8(-24)
 4849 0ace 50E0      		ldi r21,0
 4850 0ad0 BC01      		movw r22,r24
 4851 0ad2 CD01      		movw r24,r26
 4852 0ad4 00D0      		rcall gba_flash_write_bus_cycle
 4853               	.LVL484:
 4854               	.L192:
 808:main.c        **** 				
 809:main.c        **** 				// Wait until both chips are ready
 810:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4855               		.loc 3 810 0 discriminator 1
 4856 0ad6 C501      		movw r24,r10
 4857 0ad8 B401      		movw r22,r8
 4858 0ada 00D0      		rcall gba_read_16bit_data
 4859               	.LVL485:
 4860 0adc 8038      		cpi r24,-128
 4861 0ade 9105      		cpc r25,__zero_reg__
 4862 0ae0 01F4      		brne .L192
 4863               	.L193:
 811:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4864               		.loc 3 811 0 discriminator 1
 4865 0ae2 6981      		ldd r22,Y+1
 4866 0ae4 7A81      		ldd r23,Y+2
 4867 0ae6 8B81      		ldd r24,Y+3
 4868 0ae8 9C81      		ldd r25,Y+4
 4869 0aea 00D0      		rcall gba_read_16bit_data
 4870               	.LVL486:
 4871 0aec 8038      		cpi r24,-128
 4872 0aee 9105      		cpc r25,__zero_reg__
 4873 0af0 01F4      		brne .L193
 812:main.c        **** 				
 813:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 814:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 815:main.c        **** 				
 816:main.c        **** 				// Set address lines as outputs
 817:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4874               		.loc 3 817 0
 4875 0af2 9FEF      		ldi r25,lo8(-1)
 4876 0af4 94BB      		out 0x14,r25
 818:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4877               		.loc 3 818 0
 4878 0af6 9ABB      		out 0x1a,r25
 819:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4879               		.loc 3 819 0
 4880 0af8 97BB      		out 0x17,r25
 820:main.c        **** 				
 821:main.c        **** 				// Set length (number of words+1 to write)
 822:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // 16 words
 4881               		.loc 3 822 0
 4882 0afa 4FE0      		ldi r20,lo8(15)
 4883 0afc 50E0      		ldi r21,0
 4884 0afe C501      		movw r24,r10
 4885 0b00 B401      		movw r22,r8
 4886 0b02 00D0      		rcall gba_flash_write_bus_cycle
 4887               	.LVL487:
 823:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
 4888               		.loc 3 823 0
 4889 0b04 4FE0      		ldi r20,lo8(15)
 4890 0b06 50E0      		ldi r21,0
 4891 0b08 6981      		ldd r22,Y+1
 4892 0b0a 7A81      		ldd r23,Y+2
 4893 0b0c 8B81      		ldd r24,Y+3
 4894 0b0e 9C81      		ldd r25,Y+4
 4895 0b10 00D0      		rcall gba_flash_write_bus_cycle
 4896               	.LVL488:
 4897 0b12 8101      		movw r16,r2
 4898 0b14 2401      		movw r4,r8
 4899 0b16 3501      		movw r6,r10
 4900               	.LBB286:
 824:main.c        **** 				
 825:main.c        **** 				// Write data (32 words total)
 826:main.c        **** 				uint16_t combinedBytes;
 827:main.c        **** 				for (int x = 0; x < 64; x += 2) {
 4901               		.loc 3 827 0
 4902 0b18 1F82      		std Y+7,__zero_reg__
 4903 0b1a 1E82      		std Y+6,__zero_reg__
 4904               	.LVL489:
 4905               	.L194:
 828:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 829:main.c        **** 					gba_flash_write_bus_cycle(address, combinedBytes);
 4906               		.loc 3 829 0 discriminator 3
 4907 0b1c D801      		movw r26,r16
 4908 0b1e 1196      		adiw r26,1
 4909 0b20 4C91      		ld r20,X
 4910 0b22 1197      		sbiw r26,1
 4911 0b24 50E0      		ldi r21,0
 4912 0b26 542F      		mov r21,r20
 4913 0b28 4427      		clr r20
 4914 0b2a 8C91      		ld r24,X
 4915 0b2c 482B      		or r20,r24
 4916 0b2e C301      		movw r24,r6
 4917 0b30 B201      		movw r22,r4
 4918 0b32 00D0      		rcall gba_flash_write_bus_cycle
 4919               	.LVL490:
 830:main.c        **** 					address++;
 4920               		.loc 3 830 0 discriminator 3
 4921 0b34 BFEF      		ldi r27,-1
 4922 0b36 4B1A      		sub r4,r27
 4923 0b38 5B0A      		sbc r5,r27
 4924 0b3a 6B0A      		sbc r6,r27
 4925 0b3c 7B0A      		sbc r7,r27
 4926               	.LVL491:
 827:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 4927               		.loc 3 827 0 discriminator 3
 4928 0b3e EE81      		ldd r30,Y+6
 4929 0b40 FF81      		ldd r31,Y+7
 4930 0b42 3296      		adiw r30,2
 4931 0b44 FF83      		std Y+7,r31
 4932 0b46 EE83      		std Y+6,r30
 4933               	.LVL492:
 4934 0b48 0E5F      		subi r16,-2
 4935 0b4a 1F4F      		sbci r17,-1
 4936 0b4c E034      		cpi r30,64
 4937 0b4e F105      		cpc r31,__zero_reg__
 4938 0b50 01F4      		brne .L194
 4939 0b52 2401      		movw r4,r8
 4940 0b54 3501      		movw r6,r10
 4941               	.LVL493:
 4942 0b56 F0E2      		ldi r31,32
 4943 0b58 4F0E      		add r4,r31
 4944 0b5a 511C      		adc r5,__zero_reg__
 4945 0b5c 611C      		adc r6,__zero_reg__
 4946 0b5e 711C      		adc r7,__zero_reg__
 4947               	.LBE286:
 831:main.c        **** 				}
 832:main.c        **** 				
 833:main.c        **** 				// Write buffer to flash
 834:main.c        **** 				gba_flash_write_bus_cycle(address-32, 0xD0);
 4948               		.loc 3 834 0
 4949 0b60 40ED      		ldi r20,lo8(-48)
 4950 0b62 50E0      		ldi r21,0
 4951 0b64 C501      		movw r24,r10
 4952 0b66 B401      		movw r22,r8
 4953 0b68 00D0      		rcall gba_flash_write_bus_cycle
 4954               	.LVL494:
 835:main.c        **** 				gba_flash_write_bus_cycle(address-32+1, 0xD0);
 4955               		.loc 3 835 0
 4956 0b6a 40ED      		ldi r20,lo8(-48)
 4957 0b6c 50E0      		ldi r21,0
 4958 0b6e 6981      		ldd r22,Y+1
 4959 0b70 7A81      		ldd r23,Y+2
 4960 0b72 8B81      		ldd r24,Y+3
 4961 0b74 9C81      		ldd r25,Y+4
 4962 0b76 00D0      		rcall gba_flash_write_bus_cycle
 4963               	.LVL495:
 4964               	.L195:
 836:main.c        **** 				
 837:main.c        **** 				// Wait until ready
 838:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4965               		.loc 3 838 0 discriminator 1
 4966 0b78 C301      		movw r24,r6
 4967 0b7a B201      		movw r22,r4
 4968 0b7c 00D0      		rcall gba_read_16bit_data
 4969               	.LVL496:
 4970 0b7e 8038      		cpi r24,-128
 4971 0b80 9105      		cpc r25,__zero_reg__
 4972 0b82 01F4      		brne .L195
 839:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4973               		.loc 3 839 0
 4974 0b84 21E2      		ldi r18,33
 4975 0b86 820E      		add r8,r18
 4976 0b88 911C      		adc r9,__zero_reg__
 4977 0b8a A11C      		adc r10,__zero_reg__
 4978 0b8c B11C      		adc r11,__zero_reg__
 4979               	.L196:
 4980               		.loc 3 839 0 is_stmt 0 discriminator 1
 4981 0b8e C501      		movw r24,r10
 4982 0b90 B401      		movw r22,r8
 4983 0b92 00D0      		rcall gba_read_16bit_data
 4984               	.LVL497:
 4985 0b94 8038      		cpi r24,-128
 4986 0b96 9105      		cpc r25,__zero_reg__
 4987 0b98 01F4      		brne .L196
 4988               	.LVL498:
 4989 0b9a 80E4      		ldi r24,64
 4990 0b9c 280E      		add r2,r24
 4991 0b9e 311C      		adc r3,__zero_reg__
 4992               	.LBE285:
 799:main.c        **** 				// Set address lines as outputs
 4993               		.loc 3 799 0 is_stmt 1 discriminator 2
 4994 0ba0 90E0      		ldi r25,lo8(receivedBuffer+256)
 4995 0ba2 2916      		cp r2,r25
 4996 0ba4 90E0      		ldi r25,hi8(receivedBuffer+256)
 4997 0ba6 3906      		cpc r3,r25
 4998 0ba8 01F0      		breq .L319
 4999               	.LBB288:
 5000               	.LBB287:
 830:main.c        **** 				}
 5001               		.loc 3 830 0
 5002 0baa 5301      		movw r10,r6
 5003 0bac 4201      		movw r8,r4
 5004 0bae 00C0      		rjmp .L197
 5005               	.L319:
 5006 0bb0 A0E8      		ldi r26,-128
 5007 0bb2 CA0E      		add r12,r26
 5008 0bb4 D11C      		adc r13,__zero_reg__
 5009 0bb6 E11C      		adc r14,__zero_reg__
 5010 0bb8 F11C      		adc r15,__zero_reg__
 5011 0bba 00C0      		rjmp .L301
 5012               	.LVL499:
 5013               	.L191:
 5014               	.LBE287:
 5015               	.LBE288:
 5016               	.LBE284:
 840:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 841:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 842:main.c        **** 			}
 843:main.c        **** 			
 844:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 845:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 846:main.c        **** 		}
 847:main.c        **** 
 848:main.c        **** 		// Sharp LH28F320BJE programming (Thanks to lesserkuma for adding support)
 849:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_SHARP_64BYTE) {
 5017               		.loc 3 849 0
 5018 0bbc 8837      		cpi r24,lo8(120)
 5019 0bbe 01F0      		breq .+2
 5020 0bc0 00C0      		rjmp .L198
 5021               	.LVL500:
 5022               	.LBB289:
 850:main.c        **** 			uint16_t status = 0;
 851:main.c        **** 			
 852:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5023               		.loc 3 852 0
 5024 0bc2 939A      		sbi 0x12,3
 853:main.c        **** 			usart_read_bytes(64);
 5025               		.loc 3 853 0
 5026 0bc4 80E4      		ldi r24,lo8(64)
 5027 0bc6 90E0      		ldi r25,0
 5028 0bc8 00D0      		rcall usart_read_bytes
 5029               	.LVL501:
 5030 0bca 90E0      		ldi r25,lo8(receivedBuffer)
 5031 0bcc A92E      		mov r10,r25
 5032 0bce 90E0      		ldi r25,hi8(receivedBuffer)
 5033 0bd0 B92E      		mov r11,r25
 5034 0bd2 2601      		movw r4,r12
 5035 0bd4 3701      		movw r6,r14
 850:main.c        **** 			uint16_t status = 0;
 5036               		.loc 3 850 0
 5037 0bd6 912C      		mov r9,__zero_reg__
 5038               	.LVL502:
 5039               	.L202:
 5040               	.LBB290:
 5041               	.LBB291:
 854:main.c        **** 			
 855:main.c        **** 			// Write data
 856:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 857:main.c        **** 				// Wait until ready
 858:main.c        **** 				while ((status & 0x80) != 0x80) {
 5042               		.loc 3 858 0
 5043 0bd8 97FC      		sbrc r9,7
 5044 0bda 00C0      		rjmp .L320
 859:main.c        **** 					// Set address lines as outputs
 860:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
 5045               		.loc 3 860 0
 5046 0bdc BFEF      		ldi r27,lo8(-1)
 5047 0bde B4BB      		out 0x14,r27
 861:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5048               		.loc 3 861 0
 5049 0be0 BABB      		out 0x1a,r27
 862:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5050               		.loc 3 862 0
 5051 0be2 B7BB      		out 0x17,r27
 863:main.c        **** 					
 864:main.c        **** 					gba_flash_write_bus_cycle(address, 0x70); // Query status register
 5052               		.loc 3 864 0
 5053 0be4 40E7      		ldi r20,lo8(112)
 5054 0be6 50E0      		ldi r21,0
 5055 0be8 C301      		movw r24,r6
 5056 0bea B201      		movw r22,r4
 5057 0bec 00D0      		rcall gba_flash_write_bus_cycle
 5058               	.LVL503:
 865:main.c        **** 					status = gba_read_16bit_data(address);
 5059               		.loc 3 865 0
 5060 0bee C301      		movw r24,r6
 5061 0bf0 B201      		movw r22,r4
 5062 0bf2 00D0      		rcall gba_read_16bit_data
 5063               	.LVL504:
 5064 0bf4 982E      		mov r9,r24
 5065 0bf6 00C0      		rjmp .L202
 5066               	.L320:
 866:main.c        **** 				}
 867:main.c        **** 				
 868:main.c        **** 				// Set address lines as outputs
 869:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 5067               		.loc 3 869 0 discriminator 2
 5068 0bf8 EFEF      		ldi r30,lo8(-1)
 5069 0bfa E4BB      		out 0x14,r30
 870:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5070               		.loc 3 870 0 discriminator 2
 5071 0bfc EABB      		out 0x1a,r30
 871:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5072               		.loc 3 871 0 discriminator 2
 5073 0bfe E7BB      		out 0x17,r30
 872:main.c        **** 				
 873:main.c        **** 				// Write one word to flash
 874:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5074               		.loc 3 874 0 discriminator 2
 5075 0c00 D501      		movw r26,r10
 5076 0c02 1196      		adiw r26,1
 5077 0c04 0C91      		ld r16,X
 5078 0c06 1197      		sbiw r26,1
 5079 0c08 10E0      		ldi r17,0
 5080 0c0a 102F      		mov r17,r16
 5081 0c0c 0027      		clr r16
 5082 0c0e 8C91      		ld r24,X
 5083 0c10 082B      		or r16,r24
 5084               	.LVL505:
 875:main.c        **** 				gba_flash_write_bus_cycle(address, 0x10);
 5085               		.loc 3 875 0 discriminator 2
 5086 0c12 40E1      		ldi r20,lo8(16)
 5087 0c14 50E0      		ldi r21,0
 5088 0c16 C301      		movw r24,r6
 5089 0c18 B201      		movw r22,r4
 5090 0c1a 00D0      		rcall gba_flash_write_bus_cycle
 5091               	.LVL506:
 876:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5092               		.loc 3 876 0 discriminator 2
 5093 0c1c A801      		movw r20,r16
 5094 0c1e C301      		movw r24,r6
 5095 0c20 B201      		movw r22,r4
 5096 0c22 00D0      		rcall gba_flash_write_bus_cycle
 5097               	.LVL507:
 5098               	.LBB292:
 5099               	.LBB293:
 5100               		.loc 2 276 0 discriminator 2
 5101 0c24 BAE6      		ldi r27,lo8(106)
 5102 0c26 BA95      	1:	dec r27
 5103 0c28 01F4      		brne 1b
 5104 0c2a 00C0      		rjmp .
 5105               	.LVL508:
 5106               	.LBE293:
 5107               	.LBE292:
 877:main.c        **** 				_delay_us(40);
 878:main.c        **** 				
 879:main.c        **** 				address++;
 5108               		.loc 3 879 0 discriminator 2
 5109 0c2c EFEF      		ldi r30,-1
 5110 0c2e 4E1A      		sub r4,r30
 5111 0c30 5E0A      		sbc r5,r30
 5112 0c32 6E0A      		sbc r6,r30
 5113 0c34 7E0A      		sbc r7,r30
 5114               	.LVL509:
 5115 0c36 F2E0      		ldi r31,2
 5116 0c38 AF0E      		add r10,r31
 5117 0c3a B11C      		adc r11,__zero_reg__
 5118               	.LVL510:
 5119               	.LBE291:
 856:main.c        **** 				// Wait until ready
 5120               		.loc 3 856 0 discriminator 2
 5121 0c3c 80E0      		ldi r24,lo8(receivedBuffer+64)
 5122 0c3e 90E0      		ldi r25,hi8(receivedBuffer+64)
 5123 0c40 8A15      		cp r24,r10
 5124 0c42 9B05      		cpc r25,r11
 5125 0c44 01F4      		brne .L202
 5126 0c46 90E2      		ldi r25,32
 5127 0c48 C90E      		add r12,r25
 5128 0c4a D11C      		adc r13,__zero_reg__
 5129 0c4c E11C      		adc r14,__zero_reg__
 5130 0c4e F11C      		adc r15,__zero_reg__
 5131               	.LVL511:
 5132               	.L301:
 5133               	.LBE290:
 880:main.c        **** 			}
 881:main.c        **** 			
 882:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 5134               		.loc 3 882 0
 5135 0c50 81E3      		ldi r24,lo8(49)
 5136 0c52 00C0      		rjmp .L295
 5137               	.LVL512:
 5138               	.L198:
 5139               	.LBE289:
 883:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 884:main.c        **** 		}
 885:main.c        **** 		
 886:main.c        **** 		// ---------- General commands ----------
 887:main.c        **** 		// Set any pin as input/output
 888:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 889:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 5140               		.loc 3 889 0
 5141 0c54 8934      		cpi r24,lo8(73)
 5142 0c56 01F0      		breq .L203
 5143               		.loc 3 889 0 is_stmt 0 discriminator 1
 5144 0c58 8F34      		cpi r24,lo8(79)
 5145 0c5a 01F0      		breq .+2
 5146 0c5c 00C0      		rjmp .L204
 5147               	.L203:
 5148               	.LBB294:
 890:main.c        **** 			char portChar = USART_Receive();
 5149               		.loc 3 890 0 is_stmt 1
 5150 0c5e 00D0      		rcall USART_Receive
 5151               	.LVL513:
 5152 0c60 182F      		mov r17,r24
 5153               	.LVL514:
 891:main.c        **** 			usart_read_chars();
 5154               		.loc 3 891 0
 5155 0c62 00D0      		rcall usart_read_chars
 5156               	.LVL515:
 892:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5157               		.loc 3 892 0
 5158 0c64 40E1      		ldi r20,lo8(16)
 5159 0c66 50E0      		ldi r21,0
 5160 0c68 60E0      		ldi r22,0
 5161 0c6a 70E0      		ldi r23,0
 5162 0c6c 80E0      		ldi r24,lo8(receivedBuffer)
 5163 0c6e 90E0      		ldi r25,hi8(receivedBuffer)
 5164 0c70 00D0      		rcall strtol
 5165               	.LVL516:
 893:main.c        **** 			
 894:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5166               		.loc 3 894 0
 5167 0c72 939A      		sbi 0x12,3
 895:main.c        **** 			if (receivedChar == SET_INPUT) {
 5168               		.loc 3 895 0
 5169 0c74 8091 0000 		lds r24,receivedChar
 5170 0c78 8934      		cpi r24,lo8(73)
 5171 0c7a 01F4      		brne .L205
 896:main.c        **** 				if (portChar == 'A') {
 5172               		.loc 3 896 0
 5173 0c7c 1134      		cpi r17,lo8(65)
 5174 0c7e 01F4      		brne .L206
 897:main.c        **** 					DDRA &= ~(setValue);
 5175               		.loc 3 897 0
 5176 0c80 8AB3      		in r24,0x1a
 5177 0c82 6095      		com r22
 5178               	.LVL517:
 5179 0c84 6823      		and r22,r24
 5180               	.LVL518:
 5181 0c86 00C0      		rjmp .L303
 5182               	.LVL519:
 5183               	.L206:
 898:main.c        **** 				}
 899:main.c        **** 				else if (portChar == 'B') {
 5184               		.loc 3 899 0
 5185 0c88 1234      		cpi r17,lo8(66)
 5186 0c8a 01F4      		brne .L208
 900:main.c        **** 					DDRB &= ~(setValue);
 5187               		.loc 3 900 0
 5188 0c8c 87B3      		in r24,0x17
 5189 0c8e 6095      		com r22
 5190               	.LVL520:
 5191 0c90 6823      		and r22,r24
 5192               	.LVL521:
 5193 0c92 00C0      		rjmp .L304
 5194               	.LVL522:
 5195               	.L208:
 901:main.c        **** 				}
 902:main.c        **** 				else if (portChar == 'C') {
 5196               		.loc 3 902 0
 5197 0c94 1334      		cpi r17,lo8(67)
 5198 0c96 01F4      		brne .L209
 903:main.c        **** 					DDRC &= ~(setValue);
 5199               		.loc 3 903 0
 5200 0c98 84B3      		in r24,0x14
 5201 0c9a 6095      		com r22
 5202               	.LVL523:
 5203 0c9c 6823      		and r22,r24
 5204               	.LVL524:
 5205 0c9e 00C0      		rjmp .L309
 5206               	.LVL525:
 5207               	.L209:
 904:main.c        **** 				}
 905:main.c        **** 				else if (portChar == 'D') {
 5208               		.loc 3 905 0
 5209 0ca0 1434      		cpi r17,lo8(68)
 5210 0ca2 01F4      		brne .L210
 906:main.c        **** 					DDRD &= ~(setValue);
 5211               		.loc 3 906 0
 5212 0ca4 81B3      		in r24,0x11
 5213 0ca6 6095      		com r22
 5214               	.LVL526:
 5215 0ca8 6823      		and r22,r24
 5216               	.LVL527:
 5217 0caa 00C0      		rjmp .L310
 5218               	.LVL528:
 5219               	.L210:
 907:main.c        **** 				}
 908:main.c        **** 				else if (portChar == 'E') {
 5220               		.loc 3 908 0
 5221 0cac 1534      		cpi r17,lo8(69)
 5222 0cae 01F0      		breq .+2
 5223 0cb0 00C0      		rjmp .L229
 909:main.c        **** 					DDRE &= ~(setValue);
 5224               		.loc 3 909 0
 5225 0cb2 86B1      		in r24,0x6
 5226 0cb4 6095      		com r22
 5227               	.LVL529:
 5228 0cb6 6823      		and r22,r24
 5229               	.LVL530:
 5230 0cb8 00C0      		rjmp .L311
 5231               	.LVL531:
 5232               	.L205:
 910:main.c        **** 				}
 911:main.c        **** 			}
 912:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 5233               		.loc 3 912 0
 5234 0cba 8F34      		cpi r24,lo8(79)
 5235 0cbc 01F0      		breq .+2
 5236 0cbe 00C0      		rjmp .L229
 913:main.c        **** 				if (portChar == 'A') {
 5237               		.loc 3 913 0
 5238 0cc0 1134      		cpi r17,lo8(65)
 5239 0cc2 01F4      		brne .L211
 914:main.c        **** 					DDRA |= (setValue);
 5240               		.loc 3 914 0
 5241 0cc4 8AB3      		in r24,0x1a
 5242 0cc6 682B      		or r22,r24
 5243               	.LVL532:
 5244               	.L303:
 5245 0cc8 6ABB      		out 0x1a,r22
 5246 0cca 00C0      		rjmp .L229
 5247               	.LVL533:
 5248               	.L211:
 915:main.c        **** 				}
 916:main.c        **** 				else if (portChar == 'B') {
 5249               		.loc 3 916 0
 5250 0ccc 1234      		cpi r17,lo8(66)
 5251 0cce 01F4      		brne .L212
 917:main.c        **** 					DDRB |= (setValue);
 5252               		.loc 3 917 0
 5253 0cd0 87B3      		in r24,0x17
 5254 0cd2 682B      		or r22,r24
 5255               	.LVL534:
 5256               	.L304:
 5257 0cd4 67BB      		out 0x17,r22
 5258 0cd6 00C0      		rjmp .L229
 5259               	.LVL535:
 5260               	.L212:
 918:main.c        **** 				}
 919:main.c        **** 				else if (portChar == 'C') {
 5261               		.loc 3 919 0
 5262 0cd8 1334      		cpi r17,lo8(67)
 5263 0cda 01F4      		brne .L213
 920:main.c        **** 					DDRC |= (setValue);
 5264               		.loc 3 920 0
 5265 0cdc 84B3      		in r24,0x14
 5266 0cde 682B      		or r22,r24
 5267               	.LVL536:
 5268               	.L309:
 5269 0ce0 64BB      		out 0x14,r22
 5270 0ce2 00C0      		rjmp .L229
 5271               	.LVL537:
 5272               	.L213:
 921:main.c        **** 				}
 922:main.c        **** 				else if (portChar == 'D') {
 5273               		.loc 3 922 0
 5274 0ce4 1434      		cpi r17,lo8(68)
 5275 0ce6 01F4      		brne .L214
 923:main.c        **** 					DDRD |= (setValue);
 5276               		.loc 3 923 0
 5277 0ce8 81B3      		in r24,0x11
 5278 0cea 682B      		or r22,r24
 5279               	.LVL538:
 5280               	.L310:
 5281 0cec 61BB      		out 0x11,r22
 5282 0cee 00C0      		rjmp .L229
 5283               	.LVL539:
 5284               	.L214:
 924:main.c        **** 				}
 925:main.c        **** 				else if (portChar == 'E') {
 5285               		.loc 3 925 0
 5286 0cf0 1534      		cpi r17,lo8(69)
 5287 0cf2 01F0      		breq .+2
 5288 0cf4 00C0      		rjmp .L229
 926:main.c        **** 					DDRE |= (setValue);
 5289               		.loc 3 926 0
 5290 0cf6 86B1      		in r24,0x6
 5291 0cf8 682B      		or r22,r24
 5292               	.LVL540:
 5293               	.L311:
 5294 0cfa 66B9      		out 0x6,r22
 5295 0cfc 00C0      		rjmp .L229
 5296               	.LVL541:
 5297               	.L204:
 5298               	.LBE294:
 927:main.c        **** 				}
 928:main.c        **** 			}
 929:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 930:main.c        **** 		}
 931:main.c        **** 		
 932:main.c        **** 		// Set pin output as low
 933:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 5299               		.loc 3 933 0
 5300 0cfe 8C34      		cpi r24,lo8(76)
 5301 0d00 01F4      		brne .L215
 5302               	.LBB295:
 934:main.c        **** 			char portChar = USART_Receive();			
 5303               		.loc 3 934 0
 5304 0d02 00D0      		rcall USART_Receive
 5305               	.LVL542:
 5306 0d04 182F      		mov r17,r24
 5307               	.LVL543:
 935:main.c        **** 			usart_read_chars();
 5308               		.loc 3 935 0
 5309 0d06 00D0      		rcall usart_read_chars
 5310               	.LVL544:
 936:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5311               		.loc 3 936 0
 5312 0d08 40E1      		ldi r20,lo8(16)
 5313 0d0a 50E0      		ldi r21,0
 5314 0d0c 60E0      		ldi r22,0
 5315 0d0e 70E0      		ldi r23,0
 5316 0d10 80E0      		ldi r24,lo8(receivedBuffer)
 5317 0d12 90E0      		ldi r25,hi8(receivedBuffer)
 5318 0d14 00D0      		rcall strtol
 5319               	.LVL545:
 937:main.c        **** 			
 938:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5320               		.loc 3 938 0
 5321 0d16 939A      		sbi 0x12,3
 939:main.c        **** 			if (portChar == 'A') {
 5322               		.loc 3 939 0
 5323 0d18 1134      		cpi r17,lo8(65)
 5324 0d1a 01F4      		brne .L216
 940:main.c        **** 				PORTA &= ~(setValue);
 5325               		.loc 3 940 0
 5326 0d1c 8BB3      		in r24,0x1b
 5327 0d1e 6095      		com r22
 5328               	.LVL546:
 5329 0d20 6823      		and r22,r24
 5330               	.LVL547:
 5331 0d22 00C0      		rjmp .L308
 5332               	.LVL548:
 5333               	.L216:
 941:main.c        **** 			}
 942:main.c        **** 			else if (portChar == 'B') {
 5334               		.loc 3 942 0
 5335 0d24 1234      		cpi r17,lo8(66)
 5336 0d26 01F4      		brne .L218
 943:main.c        **** 				PORTB &= ~(setValue);
 5337               		.loc 3 943 0
 5338 0d28 88B3      		in r24,0x18
 5339 0d2a 6095      		com r22
 5340               	.LVL549:
 5341 0d2c 6823      		and r22,r24
 5342               	.LVL550:
 5343 0d2e 00C0      		rjmp .L307
 5344               	.LVL551:
 5345               	.L218:
 944:main.c        **** 			}
 945:main.c        **** 			else if (portChar == 'C') {
 5346               		.loc 3 945 0
 5347 0d30 1334      		cpi r17,lo8(67)
 5348 0d32 01F4      		brne .L219
 946:main.c        **** 				PORTC &= ~(setValue);
 5349               		.loc 3 946 0
 5350 0d34 85B3      		in r24,0x15
 5351 0d36 6095      		com r22
 5352               	.LVL552:
 5353 0d38 6823      		and r22,r24
 5354               	.LVL553:
 5355 0d3a 00C0      		rjmp .L306
 5356               	.LVL554:
 5357               	.L219:
 947:main.c        **** 			}
 948:main.c        **** 			else if (portChar == 'D') {
 5358               		.loc 3 948 0
 5359 0d3c 1434      		cpi r17,lo8(68)
 5360 0d3e 01F4      		brne .L220
 949:main.c        **** 				PORTD &= ~(setValue);
 5361               		.loc 3 949 0
 5362 0d40 82B3      		in r24,0x12
 5363 0d42 6095      		com r22
 5364               	.LVL555:
 5365 0d44 6823      		and r22,r24
 5366               	.LVL556:
 5367 0d46 00C0      		rjmp .L305
 5368               	.LVL557:
 5369               	.L220:
 950:main.c        **** 			}
 951:main.c        **** 			else if (portChar == 'E') {
 5370               		.loc 3 951 0
 5371 0d48 1534      		cpi r17,lo8(69)
 5372 0d4a 01F0      		breq .+2
 5373 0d4c 00C0      		rjmp .L229
 952:main.c        **** 				PORTE &= ~(setValue);
 5374               		.loc 3 952 0
 5375 0d4e 87B1      		in r24,0x7
 5376 0d50 6095      		com r22
 5377               	.LVL558:
 5378 0d52 6823      		and r22,r24
 5379               	.LVL559:
 5380 0d54 00C0      		rjmp .L302
 5381               	.LVL560:
 5382               	.L215:
 5383               	.LBE295:
 953:main.c        **** 			}
 954:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 955:main.c        **** 		}
 956:main.c        **** 		
 957:main.c        **** 		// Set pin output as high
 958:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 5384               		.loc 3 958 0
 5385 0d56 8834      		cpi r24,lo8(72)
 5386 0d58 01F4      		brne .L221
 5387               	.LBB296:
 959:main.c        **** 			char portChar = USART_Receive();			
 5388               		.loc 3 959 0
 5389 0d5a 00D0      		rcall USART_Receive
 5390               	.LVL561:
 5391 0d5c 182F      		mov r17,r24
 5392               	.LVL562:
 960:main.c        **** 			usart_read_chars();
 5393               		.loc 3 960 0
 5394 0d5e 00D0      		rcall usart_read_chars
 5395               	.LVL563:
 961:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5396               		.loc 3 961 0
 5397 0d60 40E1      		ldi r20,lo8(16)
 5398 0d62 50E0      		ldi r21,0
 5399 0d64 60E0      		ldi r22,0
 5400 0d66 70E0      		ldi r23,0
 5401 0d68 80E0      		ldi r24,lo8(receivedBuffer)
 5402 0d6a 90E0      		ldi r25,hi8(receivedBuffer)
 5403 0d6c 00D0      		rcall strtol
 5404               	.LVL564:
 962:main.c        **** 			
 963:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5405               		.loc 3 963 0
 5406 0d6e 939A      		sbi 0x12,3
 964:main.c        **** 			if (portChar == 'A') {
 5407               		.loc 3 964 0
 5408 0d70 1134      		cpi r17,lo8(65)
 5409 0d72 01F4      		brne .L222
 965:main.c        **** 				PORTA |= (setValue);
 5410               		.loc 3 965 0
 5411 0d74 8BB3      		in r24,0x1b
 5412 0d76 682B      		or r22,r24
 5413               	.LVL565:
 5414               	.L308:
 5415 0d78 6BBB      		out 0x1b,r22
 5416 0d7a 00C0      		rjmp .L229
 5417               	.LVL566:
 5418               	.L222:
 966:main.c        **** 			}
 967:main.c        **** 			else if (portChar == 'B') {
 5419               		.loc 3 967 0
 5420 0d7c 1234      		cpi r17,lo8(66)
 5421 0d7e 01F4      		brne .L224
 968:main.c        **** 				PORTB |= (setValue);
 5422               		.loc 3 968 0
 5423 0d80 88B3      		in r24,0x18
 5424 0d82 682B      		or r22,r24
 5425               	.LVL567:
 5426               	.L307:
 5427 0d84 68BB      		out 0x18,r22
 5428 0d86 00C0      		rjmp .L229
 5429               	.LVL568:
 5430               	.L224:
 969:main.c        **** 			}
 970:main.c        **** 			else if (portChar == 'C') {
 5431               		.loc 3 970 0
 5432 0d88 1334      		cpi r17,lo8(67)
 5433 0d8a 01F4      		brne .L225
 971:main.c        **** 				PORTC |= (setValue);
 5434               		.loc 3 971 0
 5435 0d8c 85B3      		in r24,0x15
 5436 0d8e 682B      		or r22,r24
 5437               	.LVL569:
 5438               	.L306:
 5439 0d90 65BB      		out 0x15,r22
 5440 0d92 00C0      		rjmp .L229
 5441               	.LVL570:
 5442               	.L225:
 972:main.c        **** 			}
 973:main.c        **** 			else if (portChar == 'D') {
 5443               		.loc 3 973 0
 5444 0d94 1434      		cpi r17,lo8(68)
 5445 0d96 01F4      		brne .L226
 974:main.c        **** 				PORTD |= (setValue);
 5446               		.loc 3 974 0
 5447 0d98 82B3      		in r24,0x12
 5448 0d9a 682B      		or r22,r24
 5449               	.LVL571:
 5450               	.L305:
 5451 0d9c 62BB      		out 0x12,r22
 5452 0d9e 00C0      		rjmp .L229
 5453               	.LVL572:
 5454               	.L226:
 975:main.c        **** 			}
 976:main.c        **** 			else if (portChar == 'E') {
 5455               		.loc 3 976 0
 5456 0da0 1534      		cpi r17,lo8(69)
 5457 0da2 01F4      		brne .L229
 977:main.c        **** 				PORTE |= (setValue);
 5458               		.loc 3 977 0
 5459 0da4 87B1      		in r24,0x7
 5460 0da6 682B      		or r22,r24
 5461               	.LVL573:
 5462               	.L302:
 5463 0da8 67B9      		out 0x7,r22
 5464 0daa 00C0      		rjmp .L229
 5465               	.L221:
 5466               	.LBE296:
 978:main.c        **** 			}
 979:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 980:main.c        **** 		}
 981:main.c        **** 		
 982:main.c        **** 		// Read all pins of a PORT and return the value
 983:main.c        **** 		else if (receivedChar == READ_INPUT) {
 5467               		.loc 3 983 0
 5468 0dac 8434      		cpi r24,lo8(68)
 5469 0dae 01F4      		brne .L227
 5470               	.LBB297:
 984:main.c        **** 			char portChar = USART_Receive();			
 5471               		.loc 3 984 0
 5472 0db0 00D0      		rcall USART_Receive
 5473               	.LVL574:
 985:main.c        **** 			
 986:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5474               		.loc 3 986 0
 5475 0db2 939A      		sbi 0x12,3
 987:main.c        **** 			if (portChar == 'A') {
 5476               		.loc 3 987 0
 5477 0db4 8134      		cpi r24,lo8(65)
 5478 0db6 01F4      		brne .L228
 988:main.c        **** 				USART_Transmit(PINA);
 5479               		.loc 3 988 0
 5480 0db8 89B3      		in r24,0x19
 5481               	.LVL575:
 5482 0dba 00C0      		rjmp .L295
 5483               	.LVL576:
 5484               	.L228:
 989:main.c        **** 			}
 990:main.c        **** 			else if (portChar == 'B') {
 5485               		.loc 3 990 0
 5486 0dbc 8234      		cpi r24,lo8(66)
 5487 0dbe 01F4      		brne .L230
 991:main.c        **** 				USART_Transmit(PINB);
 5488               		.loc 3 991 0
 5489 0dc0 86B3      		in r24,0x16
 5490               	.LVL577:
 5491 0dc2 00C0      		rjmp .L295
 5492               	.LVL578:
 5493               	.L230:
 992:main.c        **** 			}
 993:main.c        **** 			else if (portChar == 'C') {
 5494               		.loc 3 993 0
 5495 0dc4 8334      		cpi r24,lo8(67)
 5496 0dc6 01F4      		brne .L231
 994:main.c        **** 				USART_Transmit(PINC);
 5497               		.loc 3 994 0
 5498 0dc8 83B3      		in r24,0x13
 5499               	.LVL579:
 5500 0dca 00C0      		rjmp .L295
 5501               	.LVL580:
 5502               	.L231:
 995:main.c        **** 			}
 996:main.c        **** 			else if (portChar == 'D') {
 5503               		.loc 3 996 0
 5504 0dcc 8434      		cpi r24,lo8(68)
 5505 0dce 01F4      		brne .L232
 997:main.c        **** 				USART_Transmit(PIND);
 5506               		.loc 3 997 0
 5507 0dd0 80B3      		in r24,0x10
 5508               	.LVL581:
 5509 0dd2 00C0      		rjmp .L295
 5510               	.LVL582:
 5511               	.L232:
 998:main.c        **** 			}
 999:main.c        **** 			else if (portChar == 'E') {
 5512               		.loc 3 999 0
 5513 0dd4 8534      		cpi r24,lo8(69)
 5514 0dd6 01F4      		brne .L229
1000:main.c        **** 				USART_Transmit(PINE);
 5515               		.loc 3 1000 0
 5516 0dd8 85B1      		in r24,0x5
 5517               	.LVL583:
 5518               	.L295:
 5519 0dda 00D0      		rcall USART_Transmit
 5520               	.LVL584:
 5521               	.L229:
1001:main.c        **** 			}
1002:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 5522               		.loc 3 1002 0
 5523 0ddc 9398      		cbi 0x12,3
 5524               	.LBE297:
 5525 0dde 00C0      		rjmp .L99
 5526               	.LVL585:
 5527               	.L227:
1003:main.c        **** 		}
1004:main.c        **** 		
1005:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
1006:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5528               		.loc 3 1006 0
 5529 0de0 8D34      		cpi r24,lo8(77)
 5530 0de2 01F4      		brne .L233
 5531               	.LBB298:
1007:main.c        **** 			char commonChar = USART_Receive();
 5532               		.loc 3 1007 0
 5533 0de4 00D0      		rcall USART_Receive
 5534               	.LVL586:
1008:main.c        **** 			if (commonChar == '1') {
 5535               		.loc 3 1008 0
 5536 0de6 8133      		cpi r24,lo8(49)
 5537 0de8 01F4      		brne .L321
1009:main.c        **** 				resetCommonLines = 1;
 5538               		.loc 3 1009 0
 5539 0dea 91E0      		ldi r25,lo8(1)
 5540 0dec 9D83      		std Y+5,r25
 5541 0dee 00C0      		rjmp .L291
 5542               	.L321:
1010:main.c        **** 			}
1011:main.c        **** 			else if (commonChar == '0') {
 5543               		.loc 3 1011 0
 5544 0df0 8033      		cpi r24,lo8(48)
 5545 0df2 01F0      		breq .+2
 5546 0df4 00C0      		rjmp .L99
1012:main.c        **** 				resetCommonLines = 0;
 5547               		.loc 3 1012 0
 5548 0df6 1D82      		std Y+5,__zero_reg__
 5549 0df8 00C0      		rjmp .L100
 5550               	.LVL587:
 5551               	.L233:
 5552               	.LBE298:
1013:main.c        **** 			}
1014:main.c        **** 		}
1015:main.c        **** 		
1016:main.c        **** 		// Send back the PCB version number
1017:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5553               		.loc 3 1017 0
 5554 0dfa 8836      		cpi r24,lo8(104)
 5555 0dfc 01F4      		brne .L234
1018:main.c        **** 			USART_Transmit(PCB_VERSION);
 5556               		.loc 3 1018 0
 5557 0dfe 84E0      		ldi r24,lo8(4)
 5558 0e00 00C0      		rjmp .L292
 5559               	.L234:
1019:main.c        **** 		}
1020:main.c        **** 		
1021:main.c        **** 		// Send back the firmware version number
1022:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5560               		.loc 3 1022 0
 5561 0e02 8635      		cpi r24,lo8(86)
 5562 0e04 01F4      		brne .L235
1023:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5563               		.loc 3 1023 0
 5564 0e06 82E1      		ldi r24,lo8(18)
 5565               	.LVL588:
 5566               	.L292:
 5567 0e08 00D0      		rcall USART_Transmit
 5568               	.LVL589:
 5569 0e0a 00C0      		rjmp .L99
 5570               	.LVL590:
 5571               	.L235:
1024:main.c        **** 		}
1025:main.c        **** 		
1026:main.c        **** 		// Reset the AVR if it matches the number
1027:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5572               		.loc 3 1027 0
 5573 0e0c 8A32      		cpi r24,lo8(42)
 5574 0e0e 01F0      		breq .+2
 5575 0e10 00C0      		rjmp .L99
 5576               	.LBB299:
1028:main.c        **** 			usart_read_chars();
 5577               		.loc 3 1028 0
 5578 0e12 00D0      		rcall usart_read_chars
 5579               	.LVL591:
1029:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5580               		.loc 3 1029 0
 5581 0e14 40E1      		ldi r20,lo8(16)
 5582 0e16 50E0      		ldi r21,0
 5583 0e18 60E0      		ldi r22,0
 5584 0e1a 70E0      		ldi r23,0
 5585 0e1c 80E0      		ldi r24,lo8(receivedBuffer)
 5586 0e1e 90E0      		ldi r25,hi8(receivedBuffer)
 5587 0e20 00D0      		rcall strtol
 5588               	.LVL592:
1030:main.c        **** 			if (resetValue == RESET_VALUE) {
 5589               		.loc 3 1030 0
 5590 0e22 613E      		cpi r22,-31
 5591 0e24 754E      		sbci r23,-27
 5592 0e26 8740      		sbci r24,7
 5593 0e28 9105      		cpc r25,__zero_reg__
 5594 0e2a 01F0      		breq .+2
 5595 0e2c 00C0      		rjmp .L99
1031:main.c        **** 				// Clear watchdog flag
1032:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5596               		.loc 3 1032 0
 5597 0e2e 84B7      		in r24,0x34
 5598 0e30 877F      		andi r24,lo8(-9)
 5599 0e32 84BF      		out 0x34,r24
1033:main.c        **** 				
1034:main.c        **** 				// Start timed sequence
1035:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5600               		.loc 3 1035 0
 5601 0e34 B8E1      		ldi r27,lo8(24)
 5602 0e36 B1BD      		out 0x21,r27
1036:main.c        **** 				
1037:main.c        **** 				// Reset in 250 ms
1038:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5603               		.loc 3 1038 0
 5604 0e38 ECE0      		ldi r30,lo8(12)
 5605 0e3a E1BD      		out 0x21,r30
 5606               	.LVL593:
 5607               	.LBB300:
 5608               	.LBB301:
 5609               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5610               		.loc 4 105 0
 5611 0e3c 8FEF      		ldi r24,lo8(-1)
 5612 0e3e 9FEF      		ldi r25,lo8(-1)
 5613               	/* #APP */
 5614               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5615 0e40 0197      		1: sbiw r24,1
 5616 0e42 01F4      		brne 1b
 5617               	 ;  0 "" 2
 5618               	.LVL594:
 5619               	/* #NOAPP */
 5620 0e44 00C0      		rjmp .L99
 5621               	.LBE301:
 5622               	.LBE300:
 5623               	.LBE299:
 5624               		.cfi_endproc
 5625               	.LFE48:
 5627               	.global	cartMode
 5628               		.data
 5631               	cartMode:
 5632 0000 02        		.byte	2
 5633               	.global	lastBankAccessed
 5634               		.section .bss
 5637               	lastBankAccessed:
 5638 0000 00        		.zero	1
 5639               	.global	flashBank1CommandWrites
 5642               	flashBank1CommandWrites:
 5643 0001 00        		.zero	1
 5644               		.comm	flashWriteCycle,12,1
 5645               		.comm	flashWriteWePin,1,1
 5646               		.comm	flashChipIdBuffer,2,1
 5647               		.comm	eepromBuffer,8,1
 5648               		.comm	receivedChar,1,1
 5649               		.comm	receivedBuffer,256,1
 5650               		.text
 5651               	.Letext0:
 5652               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5653               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1467   .text:0000040a gb_flash_read_byte_fast
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1499   .text:00000416 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1578   .text:00000448 gb_flash_write_bus_cycle_fast
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1648   .text:0000046e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1748   .text:000004d2 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:5642   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:5637   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:1873   .text:00000554 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2036   .text:000005e8 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2102   .text:00000618 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2226   .text:00000678 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2348   .text:000006d4 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2456   .text:0000072a setup
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:5631   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccnRZK4I.s:2552   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
