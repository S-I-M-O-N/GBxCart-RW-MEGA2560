   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW Mini
   3:setup.c       ****  PCB version: 1.0
   4:setup.c       ****  Firmware version: R17
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 3/07/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define ACTIVITY_LED PD3
  28:setup.c       **** 
  29:setup.c       **** #define WR_PIN PD6
  30:setup.c       **** #define RD_PIN PD5
  31:setup.c       **** #define CS_MREQ_PIN PD4
  32:setup.c       **** #define CS2_PIN PE2
  33:setup.c       **** #define AUDIO_PIN PE1
  34:setup.c       **** 
  35:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  36:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  37:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  38:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  39:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  40:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  41:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  42:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  43:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  44:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  45:setup.c       **** 
  46:setup.c       **** #define GB_MODE 1
  47:setup.c       **** 
  48:setup.c       **** // GB/GBC
  49:setup.c       **** #define PORT_ADDR7_0 PORTB
  50:setup.c       **** #define PORT_ADDR15_8 PORTA
  51:setup.c       **** #define PORT_DATA7_0 PORTC
  52:setup.c       **** 
  53:setup.c       **** #define DDR_ADDR7_0 DDRB
  54:setup.c       **** #define DDR_ADDR15_8 DDRA
  55:setup.c       **** #define DDR_DATA7_0 DDRC
  56:setup.c       **** 
  57:setup.c       **** #define PIN_ADDR7_0 PINB
  58:setup.c       **** #define PIN_ADDR15_8 PINA
  59:setup.c       **** #define PIN_DATA7_0 PINC
  60:setup.c       **** 
  61:setup.c       **** #define BANK_WRITE 0
  62:setup.c       **** #define MEMORY_WRITE 1
  63:setup.c       **** 
  64:setup.c       **** 
  65:setup.c       **** // GB/GBC commands
  66:setup.c       **** #define SET_START_ADDRESS 'A'
  67:setup.c       **** #define READ_ROM_RAM 'R'
  68:setup.c       **** #define WRITE_RAM 'W'
  69:setup.c       **** #define SET_BANK 'B'
  70:setup.c       **** #define GB_CART_MODE 'G'
  71:setup.c       **** 
  72:setup.c       **** // Flash Cart commands
  73:setup.c       **** #define GB_FLASH_WE_PIN 'P'
  74:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
  75:setup.c       **** 	#define WE_AS_WR_PIN 'W'
  76:setup.c       **** 
  77:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
  78:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
  79:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
  80:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
  81:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
  82:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
  83:setup.c       **** 
  84:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
  85:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
  86:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
  87:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
  88:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
  89:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
  90:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
  91:setup.c       **** 
  92:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
  93:setup.c       **** 
  94:setup.c       **** #define D0D1_NOT_SWAPPED 0
  95:setup.c       **** #define D0D1_SWAPPED 1
  96:setup.c       **** 
  97:setup.c       **** // General commands
  98:setup.c       **** #define SEND_ACK '1'
  99:setup.c       **** #define CART_MODE 'C'
 100:setup.c       **** #define SET_INPUT 'I'
 101:setup.c       **** #define SET_OUTPUT 'O'
 102:setup.c       **** #define SET_OUTPUT_LOW 'L'
 103:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 104:setup.c       **** #define READ_INPUT 'D'
 105:setup.c       **** #define RESET_COMMON_LINES 'M'
 106:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 107:setup.c       **** #define READ_PCB_VERSION 'h'
 108:setup.c       **** 
 109:setup.c       **** #define RESET_AVR '*'
 110:setup.c       **** #define RESET_VALUE 0x7E5E1
 111:setup.c       **** 
 112:setup.c       **** 
 113:setup.c       **** char receivedBuffer[256];
 114:setup.c       **** char receivedChar;
 115:setup.c       **** 
 116:setup.c       **** char flashWriteWePin;
 117:setup.c       **** uint16_t flashWriteCycle[3][2];
 118:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 119:setup.c       **** uint8_t lastBankAccessed = 0;
 120:setup.c       **** 
 121:setup.c       **** uint8_t cartMode = GB_MODE;
 122:setup.c       **** 
 123:setup.c       **** // Receive USART data
 124:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 124 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 125:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 125 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 126:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 126 0
  26 0004 8CB1      		in r24,0xc
 127:setup.c       **** }
  27               		.loc 1 127 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 128:setup.c       **** 
 129:setup.c       **** // Transmit USART data
 130:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 130 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 131:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 131 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 132:setup.c       **** 	UDR = data;
  47               		.loc 1 132 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 133:setup.c       **** }
 134:setup.c       **** 
 135:setup.c       **** // Read 1-256 bytes from the USART 
 136:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 136 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB89:
 137:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 137 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 137 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 138:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 138 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE89:
 139:setup.c       **** 	}
 140:setup.c       **** }
 106               		.loc 1 140 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 141:setup.c       **** 
 142:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 143:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 143 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 144:setup.c       **** 	int x = 0;
 145:setup.c       **** 	while (1) {
 146:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 146 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 147:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 147 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 148:setup.c       **** 			break;
 149:setup.c       **** 		}
 150:setup.c       **** 		x++;
 151:setup.c       **** 	}
 152:setup.c       **** }
 148               		.loc 1 152 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 153:setup.c       **** 
 154:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 155:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 155 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 156:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 156 0
 167 0050 3A9A      		sbi 0x7,2
 157:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 157 0
 169 0052 949A      		sbi 0x12,4
 158:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 158 0
 171 0054 959A      		sbi 0x12,5
 159:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 159 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 160:setup.c       **** }
 161:setup.c       **** 
 162:setup.c       **** 
 163:setup.c       **** 
 164:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 165:setup.c       **** 
 166:setup.c       **** // Set Gameboy mode
 167:setup.c       **** void gb_mode(void) {
 182               		.loc 1 167 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 168:setup.c       **** 	// Set inputs
 169:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 169 0
 189 005a 15BA      		out 0x15,__zero_reg__
 170:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 170 0
 191 005c 14BA      		out 0x14,__zero_reg__
 171:setup.c       **** 	
 172:setup.c       **** 	// Set outputs
 173:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 173 0
 193 005e 18BA      		out 0x18,__zero_reg__
 174:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 174 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 175:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 175 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 176:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 176 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 177:setup.c       **** }
 178:setup.c       **** 
 179:setup.c       **** // Set the 16 bit address on A15-0
 180:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 180 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 181:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 181 0
 217 006a 9BBB      		out 0x1b,r25
 182:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 182 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 183:setup.c       **** }
 184:setup.c       **** 
 185:setup.c       **** // Set the address and read a byte from the 8 bit data line
 186:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 186 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 187:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 187 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 188:setup.c       **** 	
 189:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 189 0
 239 0072 9498      		cbi 0x12,4
 190:setup.c       **** 	rdPin_low;
 240               		.loc 1 190 0
 241 0074 9598      		cbi 0x12,5
 191:setup.c       **** 	
 192:setup.c       **** 	asm volatile("nop"); // Delay a little (At 8MHz - minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 192 0
 243               	/* #APP */
 244               	 ;  192 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 193:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 193 0
 248               	 ;  193 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 194:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 194 0
 252               	 ;  194 "setup.c" 1
 253 007a 0000      		nop
 254               	 ;  0 "" 2
 195:setup.c       **** 	asm volatile("nop");
 255               		.loc 1 195 0
 256               	 ;  195 "setup.c" 1
 257 007c 0000      		nop
 258               	 ;  0 "" 2
 196:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 259               		.loc 1 196 0
 260               	/* #NOAPP */
 261 007e 83B3      		in r24,0x13
 262               	.LVL17:
 197:setup.c       **** 	
 198:setup.c       **** 	rdPin_high;
 263               		.loc 1 198 0
 264 0080 959A      		sbi 0x12,5
 199:setup.c       **** 	cs_mreqPin_high;
 265               		.loc 1 199 0
 266 0082 949A      		sbi 0x12,4
 200:setup.c       **** 	
 201:setup.c       **** 	return data;
 202:setup.c       **** }
 267               		.loc 1 202 0
 268 0084 0895      		ret
 269               		.cfi_endproc
 270               	.LFE19:
 272               	.global	write_8bit_data
 274               	write_8bit_data:
 275               	.LFB20:
 203:setup.c       **** 
 204:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 205:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 276               		.loc 1 205 0
 277               		.cfi_startproc
 278               	.LVL18:
 279 0086 CF93      		push r28
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 28, -2
 283 0088 DF93      		push r29
 284               	.LCFI7:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 29, -3
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 2 */
 290               	.L__stack_usage = 2
 291 008a D62F      		mov r29,r22
 292 008c C42F      		mov r28,r20
 206:setup.c       **** 	set_16bit_address(address);
 293               		.loc 1 206 0
 294 008e 00D0      		rcall set_16bit_address
 295               	.LVL19:
 207:setup.c       **** 	
 208:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 296               		.loc 1 208 0
 297 0090 8FEF      		ldi r24,lo8(-1)
 298 0092 84BB      		out 0x14,r24
 209:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 299               		.loc 1 209 0
 300 0094 D5BB      		out 0x15,r29
 210:setup.c       **** 	
 211:setup.c       **** 	// Pulse WR and mREQ if the type matches
 212:setup.c       **** 	wrPin_low;
 301               		.loc 1 212 0
 302 0096 9698      		cbi 0x12,6
 213:setup.c       **** 	if (type == MEMORY_WRITE) {
 303               		.loc 1 213 0
 304 0098 C130      		cpi r28,lo8(1)
 305 009a 01F4      		brne .L21
 214:setup.c       **** 		cs_mreqPin_low;
 306               		.loc 1 214 0
 307 009c 9498      		cbi 0x12,4
 308               	.L21:
 215:setup.c       **** 	}
 216:setup.c       **** 	
 217:setup.c       **** 	asm volatile("nop");
 309               		.loc 1 217 0
 310               	/* #APP */
 311               	 ;  217 "setup.c" 1
 312 009e 0000      		nop
 313               	 ;  0 "" 2
 218:setup.c       **** 	asm volatile("nop");
 314               		.loc 1 218 0
 315               	 ;  218 "setup.c" 1
 316 00a0 0000      		nop
 317               	 ;  0 "" 2
 219:setup.c       **** 	
 220:setup.c       **** 	if (type == MEMORY_WRITE) {
 318               		.loc 1 220 0
 319               	/* #NOAPP */
 320 00a2 C130      		cpi r28,lo8(1)
 321 00a4 01F4      		brne .L22
 221:setup.c       **** 		cs_mreqPin_high;
 322               		.loc 1 221 0
 323 00a6 949A      		sbi 0x12,4
 324               	.L22:
 222:setup.c       **** 	}
 223:setup.c       **** 	wrPin_high;
 325               		.loc 1 223 0
 326 00a8 969A      		sbi 0x12,6
 224:setup.c       **** 	
 225:setup.c       **** 	// Clear data outputs and set data pins as inputs
 226:setup.c       **** 	PORT_DATA7_0 = 0;
 327               		.loc 1 226 0
 328 00aa 15BA      		out 0x15,__zero_reg__
 227:setup.c       **** 	DDR_DATA7_0 = 0;
 329               		.loc 1 227 0
 330 00ac 14BA      		out 0x14,__zero_reg__
 331               	/* epilogue start */
 228:setup.c       **** }
 332               		.loc 1 228 0
 333 00ae DF91      		pop r29
 334               	.LVL20:
 335 00b0 CF91      		pop r28
 336               	.LVL21:
 337 00b2 0895      		ret
 338               		.cfi_endproc
 339               	.LFE20:
 341               	.global	gb_flash_read_byte
 343               	gb_flash_read_byte:
 344               	.LFB21:
 229:setup.c       **** 
 230:setup.c       **** 
 231:setup.c       **** 
 232:setup.c       **** // ---------- GB FLASH CARTS ----------
 233:setup.c       **** 
 234:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 235:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 345               		.loc 1 235 0
 346               		.cfi_startproc
 347               	.LVL22:
 348               	/* prologue: function */
 349               	/* frame size = 0 */
 350               	/* stack size = 0 */
 351               	.L__stack_usage = 0
 236:setup.c       **** 	PORT_DATA7_0 = 0;
 352               		.loc 1 236 0
 353 00b4 15BA      		out 0x15,__zero_reg__
 237:setup.c       **** 	DDR_DATA7_0 = 0;
 354               		.loc 1 237 0
 355 00b6 14BA      		out 0x14,__zero_reg__
 238:setup.c       **** 	
 239:setup.c       **** 	set_16bit_address(address);
 356               		.loc 1 239 0
 357 00b8 00D0      		rcall set_16bit_address
 358               	.LVL23:
 240:setup.c       **** 	
 241:setup.c       **** 	rdPin_low;
 359               		.loc 1 241 0
 360 00ba 9598      		cbi 0x12,5
 242:setup.c       **** 	asm volatile("nop"); // Delay a little
 361               		.loc 1 242 0
 362               	/* #APP */
 363               	 ;  242 "setup.c" 1
 364 00bc 0000      		nop
 365               	 ;  0 "" 2
 243:setup.c       **** 	asm volatile("nop");
 366               		.loc 1 243 0
 367               	 ;  243 "setup.c" 1
 368 00be 0000      		nop
 369               	 ;  0 "" 2
 244:setup.c       **** 	asm volatile("nop");
 370               		.loc 1 244 0
 371               	 ;  244 "setup.c" 1
 372 00c0 0000      		nop
 373               	 ;  0 "" 2
 245:setup.c       **** 	asm volatile("nop");
 374               		.loc 1 245 0
 375               	 ;  245 "setup.c" 1
 376 00c2 0000      		nop
 377               	 ;  0 "" 2
 246:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 378               		.loc 1 246 0
 379               	/* #NOAPP */
 380 00c4 83B3      		in r24,0x13
 381               	.LVL24:
 247:setup.c       **** 	rdPin_high;
 382               		.loc 1 247 0
 383 00c6 959A      		sbi 0x12,5
 248:setup.c       **** 	
 249:setup.c       **** 	return data;
 250:setup.c       **** }
 384               		.loc 1 250 0
 385 00c8 0895      		ret
 386               		.cfi_endproc
 387               	.LFE21:
 389               	.global	gb_flash_write_bus_cycle
 391               	gb_flash_write_bus_cycle:
 392               	.LFB22:
 251:setup.c       **** 
 252:setup.c       **** // Set the address and data for the write byte cycle to the flash
 253:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 393               		.loc 1 253 0
 394               		.cfi_startproc
 395               	.LVL25:
 396 00ca CF93      		push r28
 397               	.LCFI8:
 398               		.cfi_def_cfa_offset 3
 399               		.cfi_offset 28, -2
 400               	/* prologue: function */
 401               	/* frame size = 0 */
 402               	/* stack size = 1 */
 403               	.L__stack_usage = 1
 404 00cc C62F      		mov r28,r22
 254:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 405               		.loc 1 254 0
 406 00ce 2FEF      		ldi r18,lo8(-1)
 407 00d0 24BB      		out 0x14,r18
 255:setup.c       **** 	set_16bit_address(address);
 408               		.loc 1 255 0
 409 00d2 00D0      		rcall set_16bit_address
 410               	.LVL26:
 256:setup.c       **** 	PORT_DATA7_0 = data;
 411               		.loc 1 256 0
 412 00d4 C5BB      		out 0x15,r28
 257:setup.c       **** 	
 258:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 413               		.loc 1 258 0
 414 00d6 8091 0000 		lds r24,flashWriteWePin
 415 00da 8134      		cpi r24,lo8(65)
 416 00dc 01F4      		brne .L25
 259:setup.c       **** 		audioPin_low; // WE low
 417               		.loc 1 259 0
 418 00de 3998      		cbi 0x7,1
 260:setup.c       **** 		asm volatile("nop");
 419               		.loc 1 260 0
 420               	/* #APP */
 421               	 ;  260 "setup.c" 1
 422 00e0 0000      		nop
 423               	 ;  0 "" 2
 261:setup.c       **** 		asm volatile("nop");
 424               		.loc 1 261 0
 425               	 ;  261 "setup.c" 1
 426 00e2 0000      		nop
 427               	 ;  0 "" 2
 262:setup.c       **** 		asm volatile("nop");
 428               		.loc 1 262 0
 429               	 ;  262 "setup.c" 1
 430 00e4 0000      		nop
 431               	 ;  0 "" 2
 263:setup.c       **** 		asm volatile("nop");
 432               		.loc 1 263 0
 433               	 ;  263 "setup.c" 1
 434 00e6 0000      		nop
 435               	 ;  0 "" 2
 264:setup.c       **** 		asm volatile("nop");
 436               		.loc 1 264 0
 437               	 ;  264 "setup.c" 1
 438 00e8 0000      		nop
 439               	 ;  0 "" 2
 265:setup.c       **** 		asm volatile("nop");
 440               		.loc 1 265 0
 441               	 ;  265 "setup.c" 1
 442 00ea 0000      		nop
 443               	 ;  0 "" 2
 266:setup.c       **** 		audioPin_high; // WE high
 444               		.loc 1 266 0
 445               	/* #NOAPP */
 446 00ec 399A      		sbi 0x7,1
 447 00ee 00C0      		rjmp .L26
 448               	.L25:
 267:setup.c       **** 	}
 268:setup.c       **** 	else { // WR pin
 269:setup.c       **** 		wrPin_low; // WE low
 449               		.loc 1 269 0
 450 00f0 9698      		cbi 0x12,6
 270:setup.c       **** 		asm volatile("nop");
 451               		.loc 1 270 0
 452               	/* #APP */
 453               	 ;  270 "setup.c" 1
 454 00f2 0000      		nop
 455               	 ;  0 "" 2
 271:setup.c       **** 		asm volatile("nop");
 456               		.loc 1 271 0
 457               	 ;  271 "setup.c" 1
 458 00f4 0000      		nop
 459               	 ;  0 "" 2
 272:setup.c       **** 		asm volatile("nop");
 460               		.loc 1 272 0
 461               	 ;  272 "setup.c" 1
 462 00f6 0000      		nop
 463               	 ;  0 "" 2
 273:setup.c       **** 		asm volatile("nop");
 464               		.loc 1 273 0
 465               	 ;  273 "setup.c" 1
 466 00f8 0000      		nop
 467               	 ;  0 "" 2
 274:setup.c       **** 		asm volatile("nop");
 468               		.loc 1 274 0
 469               	 ;  274 "setup.c" 1
 470 00fa 0000      		nop
 471               	 ;  0 "" 2
 275:setup.c       **** 		asm volatile("nop");
 472               		.loc 1 275 0
 473               	 ;  275 "setup.c" 1
 474 00fc 0000      		nop
 475               	 ;  0 "" 2
 276:setup.c       **** 		wrPin_high; // WE high
 476               		.loc 1 276 0
 477               	/* #NOAPP */
 478 00fe 969A      		sbi 0x12,6
 479               	.L26:
 277:setup.c       **** 	}
 278:setup.c       **** 	
 279:setup.c       **** 	// Clear data outputs and set data pins as inputs
 280:setup.c       **** 	PORT_DATA7_0 = 0;
 480               		.loc 1 280 0
 481 0100 15BA      		out 0x15,__zero_reg__
 281:setup.c       **** 	DDR_DATA7_0 = 0;
 482               		.loc 1 281 0
 483 0102 14BA      		out 0x14,__zero_reg__
 484               	/* epilogue start */
 282:setup.c       **** }
 485               		.loc 1 282 0
 486 0104 CF91      		pop r28
 487               	.LVL27:
 488 0106 0895      		ret
 489               		.cfi_endproc
 490               	.LFE22:
 492               	.global	gb_flash_write_byte
 494               	gb_flash_write_byte:
 495               	.LFB23:
 283:setup.c       **** 
 284:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 285:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 496               		.loc 1 285 0
 497               		.cfi_startproc
 498               	.LVL28:
 499 0108 1F93      		push r17
 500               	.LCFI9:
 501               		.cfi_def_cfa_offset 3
 502               		.cfi_offset 17, -2
 503 010a CF93      		push r28
 504               	.LCFI10:
 505               		.cfi_def_cfa_offset 4
 506               		.cfi_offset 28, -3
 507 010c DF93      		push r29
 508               	.LCFI11:
 509               		.cfi_def_cfa_offset 5
 510               		.cfi_offset 29, -4
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 3 */
 514               	.L__stack_usage = 3
 515 010e EC01      		movw r28,r24
 516 0110 162F      		mov r17,r22
 286:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 517               		.loc 1 286 0
 518 0112 6091 0000 		lds r22,flashWriteCycle+2
 519               	.LVL29:
 520 0116 8091 0000 		lds r24,flashWriteCycle
 521 011a 9091 0000 		lds r25,flashWriteCycle+1
 522               	.LVL30:
 523 011e 00D0      		rcall gb_flash_write_bus_cycle
 524               	.LVL31:
 287:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 525               		.loc 1 287 0
 526 0120 6091 0000 		lds r22,flashWriteCycle+6
 527 0124 8091 0000 		lds r24,flashWriteCycle+4
 528 0128 9091 0000 		lds r25,flashWriteCycle+4+1
 529 012c 00D0      		rcall gb_flash_write_bus_cycle
 530               	.LVL32:
 288:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 531               		.loc 1 288 0
 532 012e 6091 0000 		lds r22,flashWriteCycle+10
 533 0132 8091 0000 		lds r24,flashWriteCycle+8
 534 0136 9091 0000 		lds r25,flashWriteCycle+8+1
 535 013a 00D0      		rcall gb_flash_write_bus_cycle
 536               	.LVL33:
 289:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 537               		.loc 1 289 0
 538 013c 612F      		mov r22,r17
 539 013e CE01      		movw r24,r28
 540 0140 00D0      		rcall gb_flash_write_bus_cycle
 541               	.LVL34:
 542               	.LBB90:
 543               	.LBB91:
 544               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 545               		.loc 2 276 0
 546 0142 85E3      		ldi r24,lo8(53)
 547 0144 8A95      	1:	dec r24
 548 0146 01F4      		brne 1b
 549 0148 0000      		nop
 550               	.LVL35:
 551               	.LBE91:
 552               	.LBE90:
 290:setup.c       **** 	_delay_us(10); // Wait byte program time
 291:setup.c       **** 	
 292:setup.c       **** 	// Set data pins inputs
 293:setup.c       **** 	PORT_DATA7_0 = 0;
 553               		.loc 1 293 0
 554 014a 15BA      		out 0x15,__zero_reg__
 294:setup.c       **** 	DDR_DATA7_0 = 0;
 555               		.loc 1 294 0
 556 014c 14BA      		out 0x14,__zero_reg__
 295:setup.c       **** 	
 296:setup.c       **** 	// Verify data
 297:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 557               		.loc 1 297 0
 558 014e CE01      		movw r24,r28
 559 0150 00D0      		rcall gb_flash_read_byte
 560               	.LVL36:
 561               	.L28:
 298:setup.c       **** 	while (data != dataVerify) {
 562               		.loc 1 298 0
 563 0152 8117      		cp r24,r17
 564 0154 01F0      		breq .L30
 299:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 565               		.loc 1 299 0
 566 0156 CE01      		movw r24,r28
 567               	.LVL37:
 568 0158 00D0      		rcall gb_flash_read_byte
 569               	.LVL38:
 570               	.LBB92:
 571               	.LBB93:
 572               		.loc 2 276 0
 573 015a 9AE1      		ldi r25,lo8(26)
 574 015c 9A95      	1:	dec r25
 575 015e 01F4      		brne 1b
 576 0160 00C0      		rjmp .
 577 0162 00C0      		rjmp .L28
 578               	.LVL39:
 579               	.L30:
 580               	/* epilogue start */
 581               	.LBE93:
 582               	.LBE92:
 300:setup.c       **** 		_delay_us(5);
 301:setup.c       **** 	}
 302:setup.c       **** }
 583               		.loc 1 302 0
 584 0164 DF91      		pop r29
 585 0166 CF91      		pop r28
 586               	.LVL40:
 587 0168 1F91      		pop r17
 588               	.LVL41:
 589 016a 0895      		ret
 590               		.cfi_endproc
 591               	.LFE23:
 593               	.global	gb_flash_write_byte_special
 595               	gb_flash_write_byte_special:
 596               	.LFB24:
 303:setup.c       **** 
 304:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 305:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 597               		.loc 1 305 0
 598               		.cfi_startproc
 599               	.LVL42:
 600 016c 1F93      		push r17
 601               	.LCFI12:
 602               		.cfi_def_cfa_offset 3
 603               		.cfi_offset 17, -2
 604 016e CF93      		push r28
 605               	.LCFI13:
 606               		.cfi_def_cfa_offset 4
 607               		.cfi_offset 28, -3
 608 0170 DF93      		push r29
 609               	.LCFI14:
 610               		.cfi_def_cfa_offset 5
 611               		.cfi_offset 29, -4
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 3 */
 615               	.L__stack_usage = 3
 616 0172 EC01      		movw r28,r24
 617 0174 162F      		mov r17,r22
 306:setup.c       **** 	// Set bank back
 307:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 618               		.loc 1 307 0
 619 0176 8091 0000 		lds r24,flashBank1CommandWrites
 620               	.LVL43:
 621 017a 8130      		cpi r24,lo8(1)
 622 017c 01F4      		brne .L32
 308:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 623               		.loc 1 308 0
 624 017e 40E0      		ldi r20,0
 625 0180 6091 0000 		lds r22,lastBankAccessed
 626               	.LVL44:
 627 0184 80E0      		ldi r24,0
 628 0186 91E2      		ldi r25,lo8(33)
 629 0188 00D0      		rcall write_8bit_data
 630               	.LVL45:
 631               	.LBB94:
 632               	.LBB95:
 633               		.loc 2 276 0
 634 018a 87EC      		ldi r24,lo8(199)
 635 018c 90E0      		ldi r25,hi8(199)
 636 018e 0197      	1:	sbiw r24,1
 637 0190 01F4      		brne 1b
 638 0192 00C0      		rjmp .
 639 0194 0000      		nop
 640               	.LVL46:
 641               	.L32:
 642               	.LBE95:
 643               	.LBE94:
 309:setup.c       **** 		_delay_us(50);
 310:setup.c       **** 	}
 311:setup.c       **** 	
 312:setup.c       **** 	// Write
 313:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 644               		.loc 1 313 0
 645 0196 6091 0000 		lds r22,flashWriteCycle+2
 646 019a 8091 0000 		lds r24,flashWriteCycle
 647 019e 9091 0000 		lds r25,flashWriteCycle+1
 648 01a2 00D0      		rcall gb_flash_write_bus_cycle
 649               	.LVL47:
 314:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 650               		.loc 1 314 0
 651 01a4 6091 0000 		lds r22,flashWriteCycle+6
 652 01a8 8091 0000 		lds r24,flashWriteCycle+4
 653 01ac 9091 0000 		lds r25,flashWriteCycle+4+1
 654 01b0 00D0      		rcall gb_flash_write_bus_cycle
 655               	.LVL48:
 315:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 656               		.loc 1 315 0
 657 01b2 6091 0000 		lds r22,flashWriteCycle+10
 658 01b6 8091 0000 		lds r24,flashWriteCycle+8
 659 01ba 9091 0000 		lds r25,flashWriteCycle+8+1
 660 01be 00D0      		rcall gb_flash_write_bus_cycle
 661               	.LVL49:
 316:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 662               		.loc 1 316 0
 663 01c0 612F      		mov r22,r17
 664 01c2 CE01      		movw r24,r28
 665 01c4 00D0      		rcall gb_flash_write_bus_cycle
 666               	.LVL50:
 667               	.LBB96:
 668               	.LBB97:
 669               		.loc 2 276 0
 670 01c6 87EE      		ldi r24,lo8(999)
 671 01c8 93E0      		ldi r25,hi8(999)
 672 01ca 0197      	1:	sbiw r24,1
 673 01cc 01F4      		brne 1b
 674 01ce 00C0      		rjmp .
 675 01d0 0000      		nop
 676               	.LVL51:
 677               	.LBE97:
 678               	.LBE96:
 317:setup.c       **** 	_delay_us(250); // Wait byte program time
 318:setup.c       **** 	
 319:setup.c       **** 	// Set data pins inputs
 320:setup.c       **** 	PORT_DATA7_0 = 0;
 679               		.loc 1 320 0
 680 01d2 15BA      		out 0x15,__zero_reg__
 321:setup.c       **** 	DDR_DATA7_0 = 0;
 681               		.loc 1 321 0
 682 01d4 14BA      		out 0x14,__zero_reg__
 322:setup.c       **** 	
 323:setup.c       **** 	// Pulse reset
 324:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 683               		.loc 1 324 0
 684 01d6 3A98      		cbi 0x7,2
 685               	.LVL52:
 686               	.LBB98:
 687               	.LBB99:
 688               		.loc 2 276 0
 689 01d8 87EC      		ldi r24,lo8(199)
 690 01da 90E0      		ldi r25,hi8(199)
 691 01dc 0197      	1:	sbiw r24,1
 692 01de 01F4      		brne 1b
 693 01e0 00C0      		rjmp .
 694 01e2 0000      		nop
 695               	.LVL53:
 696               	.LBE99:
 697               	.LBE98:
 325:setup.c       **** 	_delay_us(50);
 326:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 698               		.loc 1 326 0
 699 01e4 3A9A      		sbi 0x7,2
 700               	.LVL54:
 701               	.LBB100:
 702               	.LBB101:
 703               		.loc 2 276 0
 704 01e6 87EC      		ldi r24,lo8(199)
 705 01e8 90E0      		ldi r25,hi8(199)
 706 01ea 0197      	1:	sbiw r24,1
 707 01ec 01F4      		brne 1b
 708 01ee 00C0      		rjmp .
 709 01f0 0000      		nop
 710               	.LVL55:
 711               	/* epilogue start */
 712               	.LBE101:
 713               	.LBE100:
 327:setup.c       **** 	_delay_us(50);
 328:setup.c       **** }
 714               		.loc 1 328 0
 715 01f2 DF91      		pop r29
 716 01f4 CF91      		pop r28
 717               	.LVL56:
 718 01f6 1F91      		pop r17
 719               	.LVL57:
 720 01f8 0895      		ret
 721               		.cfi_endproc
 722               	.LFE24:
 724               	.global	gb_flash_write_byte_bank1_commands
 726               	gb_flash_write_byte_bank1_commands:
 727               	.LFB25:
 329:setup.c       **** 
 330:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 331:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 332:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 728               		.loc 1 332 0
 729               		.cfi_startproc
 730               	.LVL58:
 731 01fa FF92      		push r15
 732               	.LCFI15:
 733               		.cfi_def_cfa_offset 3
 734               		.cfi_offset 15, -2
 735 01fc 0F93      		push r16
 736               	.LCFI16:
 737               		.cfi_def_cfa_offset 4
 738               		.cfi_offset 16, -3
 739 01fe 1F93      		push r17
 740               	.LCFI17:
 741               		.cfi_def_cfa_offset 5
 742               		.cfi_offset 17, -4
 743 0200 CF93      		push r28
 744               	.LCFI18:
 745               		.cfi_def_cfa_offset 6
 746               		.cfi_offset 28, -5
 747 0202 DF93      		push r29
 748               	.LCFI19:
 749               		.cfi_def_cfa_offset 7
 750               		.cfi_offset 29, -6
 751               	/* prologue: function */
 752               	/* frame size = 0 */
 753               	/* stack size = 5 */
 754               	.L__stack_usage = 5
 755 0204 EC01      		movw r28,r24
 756 0206 162F      		mov r17,r22
 333:setup.c       **** 	// Set bank 1
 334:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 757               		.loc 1 334 0
 758 0208 FF24      		clr r15
 759 020a FA94      		dec r15
 760 020c F4BA      		out 0x14,r15
 761               	.LVL59:
 762               	.LBB102:
 763               	.LBB103:
 181:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 764               		.loc 1 181 0
 765 020e 01E2      		ldi r16,lo8(33)
 766 0210 0BBB      		out 0x1b,r16
 182:setup.c       **** }
 767               		.loc 1 182 0
 768 0212 18BA      		out 0x18,__zero_reg__
 769               	.LVL60:
 770               	.LBE103:
 771               	.LBE102:
 335:setup.c       **** 	set_16bit_address(0x2100);
 336:setup.c       **** 	PORT_DATA7_0 = 1;
 772               		.loc 1 336 0
 773 0214 81E0      		ldi r24,lo8(1)
 774               	.LVL61:
 775 0216 85BB      		out 0x15,r24
 337:setup.c       **** 	wrPin_low; // Pulse WR
 776               		.loc 1 337 0
 777 0218 9698      		cbi 0x12,6
 338:setup.c       **** 	asm volatile("nop");
 778               		.loc 1 338 0
 779               	/* #APP */
 780               	 ;  338 "setup.c" 1
 781 021a 0000      		nop
 782               	 ;  0 "" 2
 339:setup.c       **** 	asm volatile("nop");
 783               		.loc 1 339 0
 784               	 ;  339 "setup.c" 1
 785 021c 0000      		nop
 786               	 ;  0 "" 2
 340:setup.c       **** 	wrPin_high;
 787               		.loc 1 340 0
 788               	/* #NOAPP */
 789 021e 969A      		sbi 0x12,6
 341:setup.c       **** 	
 342:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 790               		.loc 1 342 0
 791 0220 6091 0000 		lds r22,flashWriteCycle+2
 792               	.LVL62:
 793 0224 8091 0000 		lds r24,flashWriteCycle
 794 0228 9091 0000 		lds r25,flashWriteCycle+1
 795 022c 00D0      		rcall gb_flash_write_bus_cycle
 796               	.LVL63:
 343:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 797               		.loc 1 343 0
 798 022e 6091 0000 		lds r22,flashWriteCycle+6
 799 0232 8091 0000 		lds r24,flashWriteCycle+4
 800 0236 9091 0000 		lds r25,flashWriteCycle+4+1
 801 023a 00D0      		rcall gb_flash_write_bus_cycle
 802               	.LVL64:
 344:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 803               		.loc 1 344 0
 804 023c 6091 0000 		lds r22,flashWriteCycle+10
 805 0240 8091 0000 		lds r24,flashWriteCycle+8
 806 0244 9091 0000 		lds r25,flashWriteCycle+8+1
 807 0248 00D0      		rcall gb_flash_write_bus_cycle
 808               	.LVL65:
 345:setup.c       **** 	
 346:setup.c       **** 	
 347:setup.c       **** 	// Set bank back
 348:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 809               		.loc 1 348 0
 810 024a F4BA      		out 0x14,r15
 811               	.LVL66:
 812               	.LBB104:
 813               	.LBB105:
 181:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 814               		.loc 1 181 0
 815 024c 0BBB      		out 0x1b,r16
 182:setup.c       **** }
 816               		.loc 1 182 0
 817 024e 18BA      		out 0x18,__zero_reg__
 818               	.LVL67:
 819               	.LBE105:
 820               	.LBE104:
 349:setup.c       **** 	set_16bit_address(0x2100);
 350:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 821               		.loc 1 350 0
 822 0250 8091 0000 		lds r24,lastBankAccessed
 823 0254 85BB      		out 0x15,r24
 351:setup.c       **** 	wrPin_low; // Pulse WR
 824               		.loc 1 351 0
 825 0256 9698      		cbi 0x12,6
 352:setup.c       **** 	asm volatile("nop");
 826               		.loc 1 352 0
 827               	/* #APP */
 828               	 ;  352 "setup.c" 1
 829 0258 0000      		nop
 830               	 ;  0 "" 2
 353:setup.c       **** 	asm volatile("nop");
 831               		.loc 1 353 0
 832               	 ;  353 "setup.c" 1
 833 025a 0000      		nop
 834               	 ;  0 "" 2
 354:setup.c       **** 	wrPin_high;
 835               		.loc 1 354 0
 836               	/* #NOAPP */
 837 025c 969A      		sbi 0x12,6
 355:setup.c       **** 	
 356:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 838               		.loc 1 356 0
 839 025e 612F      		mov r22,r17
 840 0260 CE01      		movw r24,r28
 841 0262 00D0      		rcall gb_flash_write_bus_cycle
 842               	.LVL68:
 843               	.LBB106:
 844               	.LBB107:
 845               		.loc 2 276 0
 846 0264 85E3      		ldi r24,lo8(53)
 847 0266 8A95      	1:	dec r24
 848 0268 01F4      		brne 1b
 849 026a 0000      		nop
 850               	.LVL69:
 851               	.LBE107:
 852               	.LBE106:
 357:setup.c       **** 	_delay_us(10); // Wait byte program time
 358:setup.c       **** 	
 359:setup.c       **** 	// Set data pins inputs
 360:setup.c       **** 	PORT_DATA7_0 = 0;
 853               		.loc 1 360 0
 854 026c 15BA      		out 0x15,__zero_reg__
 361:setup.c       **** 	DDR_DATA7_0 = 0;
 855               		.loc 1 361 0
 856 026e 14BA      		out 0x14,__zero_reg__
 362:setup.c       **** 	
 363:setup.c       **** 	// Verify data
 364:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 857               		.loc 1 364 0
 858 0270 CE01      		movw r24,r28
 859 0272 00D0      		rcall gb_flash_read_byte
 860               	.LVL70:
 861               	.L34:
 365:setup.c       **** 	while (data != dataVerify) {
 862               		.loc 1 365 0
 863 0274 8117      		cp r24,r17
 864 0276 01F0      		breq .L36
 366:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 865               		.loc 1 366 0
 866 0278 CE01      		movw r24,r28
 867               	.LVL71:
 868 027a 00D0      		rcall gb_flash_read_byte
 869               	.LVL72:
 870               	.LBB108:
 871               	.LBB109:
 872               		.loc 2 276 0
 873 027c 9AE1      		ldi r25,lo8(26)
 874 027e 9A95      	1:	dec r25
 875 0280 01F4      		brne 1b
 876 0282 00C0      		rjmp .
 877 0284 00C0      		rjmp .L34
 878               	.LVL73:
 879               	.L36:
 880               	/* epilogue start */
 881               	.LBE109:
 882               	.LBE108:
 367:setup.c       **** 		_delay_us(5);
 368:setup.c       **** 	}
 369:setup.c       **** }
 883               		.loc 1 369 0
 884 0286 DF91      		pop r29
 885 0288 CF91      		pop r28
 886               	.LVL74:
 887 028a 1F91      		pop r17
 888               	.LVL75:
 889 028c 0F91      		pop r16
 890 028e FF90      		pop r15
 891 0290 0895      		ret
 892               		.cfi_endproc
 893               	.LFE25:
 895               	.global	setup
 897               	setup:
 898               	.LFB26:
 370:setup.c       **** 
 371:setup.c       **** 
 372:setup.c       **** // Setup
 373:setup.c       **** void setup(void) {
 899               		.loc 1 373 0
 900               		.cfi_startproc
 901               	/* prologue: function */
 902               	/* frame size = 0 */
 903               	/* stack size = 0 */
 904               	.L__stack_usage = 0
 374:setup.c       **** 	// Turn off watchdog
 375:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 905               		.loc 1 375 0
 906 0292 84B7      		in r24,0x34
 907 0294 877F      		andi r24,lo8(-9)
 908 0296 84BF      		out 0x34,r24
 376:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 909               		.loc 1 376 0
 910 0298 88E1      		ldi r24,lo8(24)
 911 029a 81BD      		out 0x21,r24
 377:setup.c       **** 	WDTCR = 0;
 912               		.loc 1 377 0
 913 029c 11BC      		out 0x21,__zero_reg__
 378:setup.c       **** 	
 379:setup.c       **** 	// Reset common lines
 380:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 914               		.loc 1 380 0
 915 029e 00D0      		rcall rd_wr_csmreq_cs2_reset
 916               	.LVL76:
 381:setup.c       **** 	
 382:setup.c       **** 	// Set outputs
 383:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN);
 917               		.loc 1 383 0
 918 02a0 81B3      		in r24,0x11
 919 02a2 8867      		ori r24,lo8(120)
 920 02a4 81BB      		out 0x11,r24
 384:setup.c       **** 	DDRE |= (1<<CS2_PIN);
 921               		.loc 1 384 0
 922 02a6 329A      		sbi 0x6,2
 385:setup.c       **** 	
 386:setup.c       **** 	// Pull ups
 387:setup.c       **** 	PORTE |= (1<<PE0);
 923               		.loc 1 387 0
 924 02a8 389A      		sbi 0x7,0
 388:setup.c       **** 	PORTD |= (1<<PD7) | (1<<PD2);
 925               		.loc 1 388 0
 926 02aa 82B3      		in r24,0x12
 927 02ac 8468      		ori r24,lo8(-124)
 928 02ae 82BB      		out 0x12,r24
 389:setup.c       **** 	
 390:setup.c       **** 	// Set all pins as inputs
 391:setup.c       **** 	PORT_DATA7_0 = 0;
 929               		.loc 1 391 0
 930 02b0 15BA      		out 0x15,__zero_reg__
 392:setup.c       **** 	DDR_DATA7_0 = 0;
 931               		.loc 1 392 0
 932 02b2 14BA      		out 0x14,__zero_reg__
 393:setup.c       **** 	PORT_ADDR7_0 = 0;
 933               		.loc 1 393 0
 934 02b4 18BA      		out 0x18,__zero_reg__
 394:setup.c       **** 	DDR_ADDR7_0 = 0;
 935               		.loc 1 394 0
 936 02b6 17BA      		out 0x17,__zero_reg__
 395:setup.c       **** 	PORT_ADDR15_8 = 0;
 937               		.loc 1 395 0
 938 02b8 1BBA      		out 0x1b,__zero_reg__
 396:setup.c       **** 	DDR_ADDR15_8 = 0;
 939               		.loc 1 396 0
 940 02ba 1ABA      		out 0x1a,__zero_reg__
 397:setup.c       **** 	
 398:setup.c       **** 	// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 399:setup.c       **** 	cs2Pin_low;
 941               		.loc 1 399 0
 942 02bc 3A98      		cbi 0x7,2
 943               	.LVL77:
 944               	.LBB110:
 945               	.LBB111:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 946               		.loc 2 187 0
 947 02be 2FEF      		ldi r18,lo8(159999)
 948 02c0 80E7      		ldi r24,hi8(159999)
 949 02c2 92E0      		ldi r25,hlo8(159999)
 950 02c4 2150      	1:	subi r18,1
 951 02c6 8040      		sbci r24,0
 952 02c8 9040      		sbci r25,0
 953 02ca 01F4      		brne 1b
 954 02cc 00C0      		rjmp .
 955 02ce 0000      		nop
 956               	.LVL78:
 957               	.LBE111:
 958               	.LBE110:
 400:setup.c       **** 	_delay_ms(50);
 401:setup.c       **** 	cs2Pin_high;
 959               		.loc 1 401 0
 960 02d0 3A9A      		sbi 0x7,2
 402:setup.c       **** 	
 403:setup.c       **** 	// Light LED
 404:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 961               		.loc 1 404 0
 962 02d2 939A      		sbi 0x12,3
 963               	.LVL79:
 964               	.LBB112:
 965               	.LBB113:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 966               		.loc 2 187 0
 967 02d4 2FEF      		ldi r18,lo8(1599999)
 968 02d6 89E6      		ldi r24,hi8(1599999)
 969 02d8 98E1      		ldi r25,hlo8(1599999)
 970 02da 2150      	1:	subi r18,1
 971 02dc 8040      		sbci r24,0
 972 02de 9040      		sbci r25,0
 973 02e0 01F4      		brne 1b
 974 02e2 00C0      		rjmp .
 975 02e4 0000      		nop
 976               	.LVL80:
 977               	.LBE113:
 978               	.LBE112:
 405:setup.c       **** 	_delay_ms(500);
 406:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 979               		.loc 1 406 0
 980 02e6 9398      		cbi 0x12,3
 407:setup.c       **** 	
 408:setup.c       **** 	// Setup USART
 409:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 981               		.loc 1 409 0
 982 02e8 19B8      		out 0x9,__zero_reg__
 410:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 983               		.loc 1 410 0
 984 02ea 539A      		sbi 0xa,3
 411:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 985               		.loc 1 411 0
 986 02ec 549A      		sbi 0xa,4
 412:setup.c       **** 	
 413:setup.c       **** 	// Turn on interrupts
 414:setup.c       **** 	sei();
 987               		.loc 1 414 0
 988               	/* #APP */
 989               	 ;  414 "setup.c" 1
 990 02ee 7894      		sei
 991               	 ;  0 "" 2
 992               	/* #NOAPP */
 993 02f0 0895      		ret
 994               		.cfi_endproc
 995               	.LFE26:
 997               		.section	.text.startup,"ax",@progbits
 998               	.global	main
 1000               	main:
 1001               	.LFB27:
 1002               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW Mini
   3:main.c        ****  PCB version: 1.0
   4:main.c        ****  Firmware version: R17
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 3/07/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW Mini allows you to dump your Gameboy/Gameboy Colour games ROM, save the RAM, write to t
  10:main.c        ****  write to certain Gameboy flash carts. GBA carts are not supported, please check out the non-Mini v
  11:main.c        ****  
  12:main.c        ****  The ATmega8515 talks to the cartridge and interfaces with the CH340G serial to USB converter with 
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 16MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BO
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart Mini RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** 
  47:main.c        **** 
  48:main.c        **** #define F_CPU 16000000 // 16 MHz
  49:main.c        **** #define PCB_VERSION 100 // Mini v1.0
  50:main.c        **** #define FIRMWARE_VERSION 17
  51:main.c        **** 
  52:main.c        **** #include <avr/io.h>
  53:main.c        **** #include <avr/wdt.h>
  54:main.c        **** #include <avr/eeprom.h>
  55:main.c        **** #include <avr/interrupt.h>
  56:main.c        **** #include <avr/sleep.h>
  57:main.c        **** #include <util/delay.h>
  58:main.c        **** #include <stdlib.h>
  59:main.c        **** #include <string.h>
  60:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** int main(void) {
 1003               		.loc 3 63 0
 1004               		.cfi_startproc
 1005               	/* prologue: function */
 1006               	/* frame size = 0 */
 1007               	/* stack size = 0 */
 1008               	.L__stack_usage = 0
  64:main.c        **** 	setup();
 1009               		.loc 3 64 0
 1010 0000 00D0      		rcall setup
 1011               	.LVL81:
  65:main.c        **** 	
  66:main.c        **** 	uint32_t address = 0;
  67:main.c        **** 	uint8_t resetCommonLines = 1;
 1012               		.loc 3 67 0
 1013 0002 5524      		clr r5
 1014 0004 5394      		inc r5
  66:main.c        **** 	uint8_t resetCommonLines = 1;
 1015               		.loc 3 66 0
 1016 0006 C12C      		mov r12,__zero_reg__
 1017 0008 D12C      		mov r13,__zero_reg__
 1018 000a 7601      		movw r14,r12
 1019               	.LBB114:
 1020               	.LBB115:
 1021               	.LBB116:
 1022               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 1023               		.loc 4 105 0
 1024 000c 2224      		clr r2
 1025 000e 2A94      		dec r2
 1026 0010 322C      		mov r3,r2
 1027               	.LBE116:
 1028               	.LBE115:
 1029               	.LBE114:
 1030               	.LBB119:
  68:main.c        **** 	
  69:main.c        **** 	while(1) {
  70:main.c        **** 		if (resetCommonLines == 1) {
  71:main.c        **** 			rd_wr_csmreq_cs2_reset();
  72:main.c        **** 		}
  73:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  74:main.c        **** 		
  75:main.c        **** 		
  76:main.c        **** 		// Return the cart mode in use
  77:main.c        **** 		if (receivedChar == CART_MODE) {
  78:main.c        **** 			USART_Transmit(cartMode);
  79:main.c        **** 		}
  80:main.c        **** 		
  81:main.c        **** 		// Change to GB mode or GBA mode if requested
  82:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  83:main.c        **** 			gb_mode();
  84:main.c        **** 		}
  85:main.c        **** 		
  86:main.c        **** 		// Set address
  87:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
  88:main.c        **** 			usart_read_chars(); // Read start address
  89:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		
  93:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  94:main.c        **** 		
  95:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  96:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
  97:main.c        **** 			gb_mode();
  98:main.c        **** 			receivedChar = '1';
  99:main.c        **** 			while (receivedChar == '1') {
 100:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 101:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 102:main.c        **** 					USART_Transmit(read_8bit_data(address));
 103:main.c        **** 					address++;
 104:main.c        **** 				}
 105:main.c        **** 				
 106:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 107:main.c        **** 				receivedChar = USART_Receive();
 108:main.c        **** 			}
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 112:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 113:main.c        **** 			gb_mode();
 114:main.c        **** 			
 115:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 116:main.c        **** 			usart_read_bytes(64);
 117:main.c        **** 			
 118:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 121:main.c        **** 				address++;
 122:main.c        **** 			}
 123:main.c        **** 			
 124:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 126:main.c        **** 		}
 127:main.c        **** 		
 128:main.c        **** 		// Set bank address and write a byte
 129:main.c        **** 		else if (receivedChar == SET_BANK) {
 130:main.c        **** 			gb_mode();
 131:main.c        **** 			
 132:main.c        **** 			usart_read_chars(); // Read start address
 133:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 134:main.c        **** 			
 135:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 136:main.c        **** 			if (receivedChar == 'B') {
 137:main.c        **** 				usart_read_chars(); // Read data
 138:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 139:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 140:main.c        **** 				
 141:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 142:main.c        **** 			}
 143:main.c        **** 		}
 144:main.c        **** 		
 145:main.c        **** 		
 146:main.c        **** 		// ---------- GB FLASH CARTS ----------
 147:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 148:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 149:main.c        **** 			flashWriteWePin = USART_Receive();
 150:main.c        **** 			
 151:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 152:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 153:main.c        **** 				audioPin_high;
 154:main.c        **** 			}
 155:main.c        **** 		}
 156:main.c        **** 		
 157:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 158:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 159:main.c        **** 			flashBank1CommandWrites = 1;
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		// Load the program method to use
 163:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 164:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 165:main.c        **** 				usart_read_chars(); // Address
 166:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 167:main.c        **** 				USART_Transmit(SEND_ACK);
 168:main.c        **** 				
 169:main.c        **** 				usart_read_chars(); // Data
 170:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 171:main.c        **** 				USART_Transmit(SEND_ACK);
 172:main.c        **** 			}
 173:main.c        **** 		}
 174:main.c        **** 		
 175:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 176:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 177:main.c        **** 			usart_read_chars(); // Read address
 178:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 179:main.c        **** 			
 180:main.c        **** 			usart_read_chars(); // Read data byte
 181:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 182:main.c        **** 			
 183:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 184:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 185:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 186:main.c        **** 			
 187:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 188:main.c        **** 		}
 189:main.c        **** 		
 190:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 191:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 192:main.c        **** 			usart_read_bytes(64);
 193:main.c        **** 			
 194:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 195:main.c        **** 			if (flashBank1CommandWrites == 0) {
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 197:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 198:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 199:main.c        **** 					}
 200:main.c        **** 					address++;
 201:main.c        **** 				}
 202:main.c        **** 			}
 203:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 206:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 207:main.c        **** 					}
 208:main.c        **** 					address++;
 209:main.c        **** 				}
 210:main.c        **** 			}
 211:main.c        **** 			
 212:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 213:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 217:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 218:main.c        **** 			usart_read_bytes(32);
 219:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 220:main.c        **** 			
 221:main.c        **** 			// Setup buffered write
 222:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 223:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 224:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 225:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 226:main.c        **** 			_delay_us(1);
 227:main.c        **** 			
 228:main.c        **** 			// Write data
 229:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 230:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 231:main.c        **** 				address++;
 232:main.c        **** 			}
 233:main.c        **** 			
 234:main.c        **** 			// Write buffer to flash
 235:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 236:main.c        **** 			_delay_us(200);
 237:main.c        **** 			
 238:main.c        **** 			// Verify last byte written
 239:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 240:main.c        **** 			uint8_t verifyCount = 0;
 241:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 242:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 243:main.c        **** 				_delay_us(5);
 244:main.c        **** 				verifyCount++;
 245:main.c        **** 				if (verifyCount >= 200) {
 246:main.c        **** 					_delay_ms(500);
 247:main.c        **** 					break;
 248:main.c        **** 				}
 249:main.c        **** 			}
 250:main.c        **** 			
 251:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 252:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 253:main.c        **** 		}
 254:main.c        **** 		
 255:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 256:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 257:main.c        **** 			usart_read_bytes(64);
 258:main.c        **** 			
 259:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 260:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 261:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 262:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 263:main.c        **** 				}
 264:main.c        **** 				address++;
 265:main.c        **** 			}
 266:main.c        **** 			
 267:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 268:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 269:main.c        **** 		}
 270:main.c        **** 		
 271:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 272:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 273:main.c        **** 			usart_read_bytes(256);
 274:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 275:main.c        **** 			
 276:main.c        **** 			// Setup buffered write
 277:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 278:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 279:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 280:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 281:main.c        **** 			_delay_us(50);
 282:main.c        **** 			
 283:main.c        **** 			// Write data
 284:main.c        **** 			for (int x = 0; x < 256; x++) {
 285:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 286:main.c        **** 				address++;
 287:main.c        **** 			}
 288:main.c        **** 			
 289:main.c        **** 			// Write buffer to flash
 290:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 291:main.c        **** 			
 292:main.c        **** 			// Verify last byte written
 293:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 294:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 295:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 296:main.c        **** 				_delay_us(5);
 297:main.c        **** 			}
 298:main.c        **** 			
 299:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 300:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 301:main.c        **** 		}
 302:main.c        **** 		
 303:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 304:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 305:main.c        **** 			usart_read_bytes(128);
 306:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 307:main.c        **** 			
 308:main.c        **** 			// Enable flash chip access
 309:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 310:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 311:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 312:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 313:main.c        **** 			_delay_us(5);
 314:main.c        **** 			
 315:main.c        **** 			// Re-Enable writes to MBC registers
 316:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 317:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 318:main.c        **** 			_delay_us(5);
 319:main.c        **** 			
 320:main.c        **** 			// Bank 1 for commands
 321:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 322:main.c        **** 			_delay_us(5);
 323:main.c        **** 			
 324:main.c        **** 			
 325:main.c        **** 			// Write setup
 326:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 327:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 328:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 329:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 330:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 331:main.c        **** 			_delay_us(5);
 332:main.c        **** 			
 333:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 334:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 335:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 336:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 337:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 338:main.c        **** 			_delay_us(5);
 339:main.c        **** 			
 340:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 341:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 342:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 343:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 344:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 345:main.c        **** 			_delay_us(5);
 346:main.c        **** 			
 347:main.c        **** 			// Set bank back
 348:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 349:main.c        **** 			_delay_us(5);
 350:main.c        **** 			
 351:main.c        **** 			// Disable writes to MBC registers
 352:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 353:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 354:main.c        **** 			_delay_us(5);
 355:main.c        **** 			
 356:main.c        **** 			// Undo Wakeup
 357:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 358:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 359:main.c        **** 			_delay_us(5);
 360:main.c        **** 			
 361:main.c        **** 			
 362:main.c        **** 			// Write data
 363:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 364:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 365:main.c        **** 				_delay_us(5);
 366:main.c        **** 				address++;
 367:main.c        **** 			}
 368:main.c        **** 			
 369:main.c        **** 			// Write buffer to flash
 370:main.c        **** 			address--;
 371:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 372:main.c        **** 			address++;
 373:main.c        **** 			_delay_ms(10);
 374:main.c        **** 			
 375:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 376:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 377:main.c        **** 		}
 378:main.c        **** 		
 379:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 380:main.c        **** 		// Intel chips such as 28F640J5
 381:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 382:main.c        **** 			usart_read_bytes(32);
 383:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 384:main.c        **** 			
 385:main.c        **** 			// Setup buffered write
 386:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 387:main.c        **** 			
 388:main.c        **** 			// Wait until ready
 389:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 390:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 391:main.c        **** 			
 392:main.c        **** 			// Set buffer size
 393:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 394:main.c        **** 			
 395:main.c        **** 			// Write data to buffer
 396:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 397:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 398:main.c        **** 				address++;
 399:main.c        **** 			}
 400:main.c        **** 			
 401:main.c        **** 			// Write buffer to flash
 402:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 403:main.c        **** 			_delay_us(196);
 404:main.c        **** 			
 405:main.c        **** 			// Wait until ready
 406:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 407:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 408:main.c        **** 			
 409:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 410:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 411:main.c        **** 		}
 412:main.c        **** 		
 413:main.c        **** 		
 414:main.c        **** 		// ---------- General commands ----------
 415:main.c        **** 		// Set any pin as input/output
 416:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 417:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 418:main.c        **** 			char portChar = USART_Receive();
 419:main.c        **** 			usart_read_chars();
 420:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 421:main.c        **** 			
 422:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 423:main.c        **** 			if (receivedChar == SET_INPUT) {
 424:main.c        **** 				if (portChar == 'A') {
 425:main.c        **** 					DDRA &= ~(setValue);
 426:main.c        **** 				}
 427:main.c        **** 				else if (portChar == 'B') {
 428:main.c        **** 					DDRB &= ~(setValue);
 429:main.c        **** 				}
 430:main.c        **** 				else if (portChar == 'C') {
 431:main.c        **** 					DDRC &= ~(setValue);
 432:main.c        **** 				}
 433:main.c        **** 				else if (portChar == 'D') {
 434:main.c        **** 					DDRD &= ~(setValue);
 435:main.c        **** 				}
 436:main.c        **** 				else if (portChar == 'E') {
 437:main.c        **** 					DDRE &= ~(setValue);
 438:main.c        **** 				}
 439:main.c        **** 			}
 440:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 441:main.c        **** 				if (portChar == 'A') {
 442:main.c        **** 					DDRA |= (setValue);
 443:main.c        **** 				}
 444:main.c        **** 				else if (portChar == 'B') {
 445:main.c        **** 					DDRB |= (setValue);
 446:main.c        **** 				}
 447:main.c        **** 				else if (portChar == 'C') {
 448:main.c        **** 					DDRC |= (setValue);
 449:main.c        **** 				}
 450:main.c        **** 				else if (portChar == 'D') {
 451:main.c        **** 					DDRD |= (setValue);
 452:main.c        **** 				}
 453:main.c        **** 				else if (portChar == 'E') {
 454:main.c        **** 					DDRE |= (setValue);
 455:main.c        **** 				}
 456:main.c        **** 			}
 457:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 458:main.c        **** 		}
 459:main.c        **** 		
 460:main.c        **** 		// Set pin output as low
 461:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 462:main.c        **** 			char portChar = USART_Receive();			
 463:main.c        **** 			usart_read_chars();
 464:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 465:main.c        **** 			
 466:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 467:main.c        **** 			if (portChar == 'A') {
 468:main.c        **** 				PORTA &= ~(setValue);
 469:main.c        **** 			}
 470:main.c        **** 			else if (portChar == 'B') {
 471:main.c        **** 				PORTB &= ~(setValue);
 472:main.c        **** 			}
 473:main.c        **** 			else if (portChar == 'C') {
 474:main.c        **** 				PORTC &= ~(setValue);
 475:main.c        **** 			}
 476:main.c        **** 			else if (portChar == 'D') {
 477:main.c        **** 				PORTD &= ~(setValue);
 478:main.c        **** 			}
 479:main.c        **** 			else if (portChar == 'E') {
 480:main.c        **** 				PORTE &= ~(setValue);
 481:main.c        **** 			}
 482:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 483:main.c        **** 		}
 484:main.c        **** 		
 485:main.c        **** 		// Set pin output as high
 486:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 487:main.c        **** 			char portChar = USART_Receive();			
 488:main.c        **** 			usart_read_chars();
 489:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 490:main.c        **** 			
 491:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 492:main.c        **** 			if (portChar == 'A') {
 493:main.c        **** 				PORTA |= (setValue);
 494:main.c        **** 			}
 495:main.c        **** 			else if (portChar == 'B') {
 496:main.c        **** 				PORTB |= (setValue);
 497:main.c        **** 			}
 498:main.c        **** 			else if (portChar == 'C') {
 499:main.c        **** 				PORTC |= (setValue);
 500:main.c        **** 			}
 501:main.c        **** 			else if (portChar == 'D') {
 502:main.c        **** 				PORTD |= (setValue);
 503:main.c        **** 			}
 504:main.c        **** 			else if (portChar == 'E') {
 505:main.c        **** 				PORTE |= (setValue);
 506:main.c        **** 			}
 507:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 508:main.c        **** 		}
 509:main.c        **** 		
 510:main.c        **** 		// Read all pins of a PORT and return the value
 511:main.c        **** 		else if (receivedChar == READ_INPUT) {
 512:main.c        **** 			char portChar = USART_Receive();			
 513:main.c        **** 			
 514:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 515:main.c        **** 			if (portChar == 'A') {
 516:main.c        **** 				USART_Transmit(PINA);
 517:main.c        **** 			}
 518:main.c        **** 			else if (portChar == 'B') {
 519:main.c        **** 				USART_Transmit(PINB);
 520:main.c        **** 			}
 521:main.c        **** 			else if (portChar == 'C') {
 522:main.c        **** 				USART_Transmit(PINC);
 523:main.c        **** 			}
 524:main.c        **** 			else if (portChar == 'D') {
 525:main.c        **** 				USART_Transmit(PIND);
 526:main.c        **** 			}
 527:main.c        **** 			else if (portChar == 'E') {
 528:main.c        **** 				USART_Transmit(PINE);
 529:main.c        **** 			}
 530:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 531:main.c        **** 		}
 532:main.c        **** 		
 533:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 534:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 535:main.c        **** 			char commonChar = USART_Receive();
 536:main.c        **** 			if (commonChar == '1') {
 537:main.c        **** 				resetCommonLines = 1;
 1031               		.loc 3 537 0
 1032 0012 4424      		clr r4
 1033 0014 4394      		inc r4
 1034 0016 20E0      		ldi r18,lo8(receivedBuffer+128)
 1035 0018 622E      		mov r6,r18
 1036 001a 20E0      		ldi r18,hi8(receivedBuffer+128)
 1037 001c 722E      		mov r7,r18
 1038               	.LVL82:
 1039               	.L39:
 1040               	.LBE119:
  70:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1041               		.loc 3 70 0
 1042 001e 21E0      		ldi r18,lo8(1)
 1043 0020 5212      		cpse r5,r18
 1044 0022 00C0      		rjmp .L40
 1045               	.LVL83:
 1046               	.L141:
  71:main.c        **** 		}
 1047               		.loc 3 71 0
 1048 0024 00D0      		rcall rd_wr_csmreq_cs2_reset
 1049               	.LVL84:
 1050               	.L40:
  73:main.c        **** 		
 1051               		.loc 3 73 0
 1052 0026 00D0      		rcall USART_Receive
 1053               	.LVL85:
 1054 0028 8093 0000 		sts receivedChar,r24
  77:main.c        **** 			USART_Transmit(cartMode);
 1055               		.loc 3 77 0
 1056 002c 8334      		cpi r24,lo8(67)
 1057 002e 01F4      		brne .L41
  78:main.c        **** 		}
 1058               		.loc 3 78 0
 1059 0030 8091 0000 		lds r24,cartMode
 1060 0034 00C0      		rjmp .L142
 1061               	.L41:
  82:main.c        **** 			gb_mode();
 1062               		.loc 3 82 0
 1063 0036 8734      		cpi r24,lo8(71)
 1064 0038 01F4      		brne .L43
  83:main.c        **** 		}
 1065               		.loc 3 83 0
 1066 003a 00D0      		rcall gb_mode
 1067               	.LVL86:
 1068 003c 00C0      		rjmp .L39
 1069               	.L43:
  87:main.c        **** 			usart_read_chars(); // Read start address
 1070               		.loc 3 87 0
 1071 003e 8134      		cpi r24,lo8(65)
 1072 0040 01F4      		brne .L44
  88:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1073               		.loc 3 88 0
 1074 0042 00D0      		rcall usart_read_chars
 1075               	.LVL87:
  89:main.c        **** 		}
 1076               		.loc 3 89 0
 1077 0044 40E1      		ldi r20,lo8(16)
 1078 0046 50E0      		ldi r21,0
 1079 0048 60E0      		ldi r22,0
 1080 004a 70E0      		ldi r23,0
 1081 004c 80E0      		ldi r24,lo8(receivedBuffer)
 1082 004e 90E0      		ldi r25,hi8(receivedBuffer)
 1083 0050 00D0      		rcall strtol
 1084               	.LVL88:
 1085 0052 6B01      		movw r12,r22
 1086 0054 7C01      		movw r14,r24
 1087               	.LVL89:
 1088 0056 00C0      		rjmp .L39
 1089               	.L44:
  96:main.c        **** 			gb_mode();
 1090               		.loc 3 96 0
 1091 0058 8235      		cpi r24,lo8(82)
 1092 005a 01F4      		brne .L45
  97:main.c        **** 			receivedChar = '1';
 1093               		.loc 3 97 0
 1094 005c 00D0      		rcall gb_mode
 1095               	.LVL90:
  98:main.c        **** 			while (receivedChar == '1') {
 1096               		.loc 3 98 0
 1097 005e 81E3      		ldi r24,lo8(49)
 1098               	.LVL91:
 1099               	.L144:
 107:main.c        **** 			}
 1100               		.loc 3 107 0
 1101 0060 8093 0000 		sts receivedChar,r24
 1102               	.LVL92:
  99:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 1103               		.loc 3 99 0
 1104 0064 8091 0000 		lds r24,receivedChar
 1105 0068 8133      		cpi r24,lo8(49)
 1106 006a 01F4      		brne .L39
 100:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1107               		.loc 3 100 0
 1108 006c 939A      		sbi 0x12,3
 1109               	.LVL93:
 1110 006e C0E0      		ldi r28,0
 1111 0070 D0E0      		ldi r29,0
 1112               	.LVL94:
 1113               	.L47:
 1114               	.LBB120:
 102:main.c        **** 					address++;
 1115               		.loc 3 102 0 discriminator 3
 1116 0072 CE01      		movw r24,r28
 1117 0074 8C0D      		add r24,r12
 1118 0076 9D1D      		adc r25,r13
 1119 0078 00D0      		rcall read_8bit_data
 1120               	.LVL95:
 1121 007a 00D0      		rcall USART_Transmit
 1122               	.LVL96:
 1123 007c 2196      		adiw r28,1
 1124               	.LVL97:
 101:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1125               		.loc 3 101 0 discriminator 3
 1126 007e C034      		cpi r28,64
 1127 0080 D105      		cpc r29,__zero_reg__
 1128 0082 01F4      		brne .L47
 1129 0084 80E4      		ldi r24,64
 1130 0086 C80E      		add r12,r24
 1131 0088 D11C      		adc r13,__zero_reg__
 1132 008a E11C      		adc r14,__zero_reg__
 1133 008c F11C      		adc r15,__zero_reg__
 1134               	.LBE120:
 106:main.c        **** 				receivedChar = USART_Receive();
 1135               		.loc 3 106 0
 1136 008e 9398      		cbi 0x12,3
 107:main.c        **** 			}
 1137               		.loc 3 107 0
 1138 0090 00D0      		rcall USART_Receive
 1139               	.LVL98:
 1140 0092 00C0      		rjmp .L144
 1141               	.LVL99:
 1142               	.L45:
 112:main.c        **** 			gb_mode();
 1143               		.loc 3 112 0
 1144 0094 8735      		cpi r24,lo8(87)
 1145 0096 01F4      		brne .L49
 113:main.c        **** 			
 1146               		.loc 3 113 0
 1147 0098 00D0      		rcall gb_mode
 1148               	.LVL100:
 116:main.c        **** 			
 1149               		.loc 3 116 0
 1150 009a 80E4      		ldi r24,lo8(64)
 1151 009c 90E0      		ldi r25,0
 1152 009e 00D0      		rcall usart_read_bytes
 1153               	.LVL101:
 118:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1154               		.loc 3 118 0
 1155 00a0 939A      		sbi 0x12,3
 1156               	.LVL102:
 1157 00a2 00E0      		ldi r16,lo8(receivedBuffer)
 1158 00a4 10E0      		ldi r17,hi8(receivedBuffer)
 1159 00a6 C0E0      		ldi r28,0
 1160 00a8 D0E0      		ldi r29,0
 1161               	.LVL103:
 1162               	.L50:
 1163               	.LBB121:
 120:main.c        **** 				address++;
 1164               		.loc 3 120 0 discriminator 3
 1165 00aa F801      		movw r30,r16
 1166 00ac 6191      		ld r22,Z+
 1167 00ae 8F01      		movw r16,r30
 1168 00b0 CE01      		movw r24,r28
 1169 00b2 8C0D      		add r24,r12
 1170 00b4 9D1D      		adc r25,r13
 1171 00b6 41E0      		ldi r20,lo8(1)
 1172 00b8 00D0      		rcall write_8bit_data
 1173               	.LVL104:
 1174 00ba 2196      		adiw r28,1
 1175               	.LVL105:
 119:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1176               		.loc 3 119 0 discriminator 3
 1177 00bc C034      		cpi r28,64
 1178 00be D105      		cpc r29,__zero_reg__
 1179 00c0 01F4      		brne .L50
 1180 00c2 F0E4      		ldi r31,64
 1181 00c4 CF0E      		add r12,r31
 1182 00c6 D11C      		adc r13,__zero_reg__
 1183 00c8 E11C      		adc r14,__zero_reg__
 1184 00ca F11C      		adc r15,__zero_reg__
 1185 00cc 00C0      		rjmp .L157
 1186               	.LVL106:
 1187               	.L49:
 1188               	.LBE121:
 129:main.c        **** 			gb_mode();
 1189               		.loc 3 129 0
 1190 00ce 8234      		cpi r24,lo8(66)
 1191 00d0 01F4      		brne .L51
 1192               	.LBB122:
 130:main.c        **** 			
 1193               		.loc 3 130 0
 1194 00d2 00D0      		rcall gb_mode
 1195               	.LVL107:
 132:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1196               		.loc 3 132 0
 1197 00d4 00D0      		rcall usart_read_chars
 1198               	.LVL108:
 133:main.c        **** 			
 1199               		.loc 3 133 0
 1200 00d6 40E1      		ldi r20,lo8(16)
 1201 00d8 50E0      		ldi r21,0
 1202 00da 60E0      		ldi r22,0
 1203 00dc 70E0      		ldi r23,0
 1204 00de 80E0      		ldi r24,lo8(receivedBuffer)
 1205 00e0 90E0      		ldi r25,hi8(receivedBuffer)
 1206 00e2 00D0      		rcall strtol
 1207               	.LVL109:
 1208 00e4 4B01      		movw r8,r22
 1209 00e6 5C01      		movw r10,r24
 1210               	.LVL110:
 135:main.c        **** 			if (receivedChar == 'B') {
 1211               		.loc 3 135 0
 1212 00e8 00D0      		rcall USART_Receive
 1213               	.LVL111:
 1214 00ea 8093 0000 		sts receivedChar,r24
 136:main.c        **** 				usart_read_chars(); // Read data
 1215               		.loc 3 136 0
 1216 00ee 8234      		cpi r24,lo8(66)
 1217 00f0 01F0      		breq .+2
 1218 00f2 00C0      		rjmp .L39
 1219               	.LBB123:
 137:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1220               		.loc 3 137 0
 1221 00f4 00D0      		rcall usart_read_chars
 1222               	.LVL112:
 138:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 1223               		.loc 3 138 0
 1224 00f6 80E0      		ldi r24,lo8(receivedBuffer)
 1225 00f8 90E0      		ldi r25,hi8(receivedBuffer)
 1226 00fa 00D0      		rcall atoi
 1227               	.LVL113:
 139:main.c        **** 				
 1228               		.loc 3 139 0
 1229 00fc 8093 0000 		sts lastBankAccessed,r24
 141:main.c        **** 			}
 1230               		.loc 3 141 0
 1231 0100 40E0      		ldi r20,0
 1232 0102 682F      		mov r22,r24
 1233 0104 C401      		movw r24,r8
 1234               	.LVL114:
 1235 0106 00D0      		rcall write_8bit_data
 1236               	.LVL115:
 1237 0108 00C0      		rjmp .L39
 1238               	.LVL116:
 1239               	.L51:
 1240               	.LBE123:
 1241               	.LBE122:
 148:main.c        **** 			flashWriteWePin = USART_Receive();
 1242               		.loc 3 148 0
 1243 010a 8035      		cpi r24,lo8(80)
 1244 010c 01F4      		brne .L52
 149:main.c        **** 			
 1245               		.loc 3 149 0
 1246 010e 00D0      		rcall USART_Receive
 1247               	.LVL117:
 1248 0110 8093 0000 		sts flashWriteWePin,r24
 151:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 1249               		.loc 3 151 0
 1250 0114 8134      		cpi r24,lo8(65)
 1251 0116 01F0      		breq .+2
 1252 0118 00C0      		rjmp .L39
 152:main.c        **** 				audioPin_high;
 1253               		.loc 3 152 0
 1254 011a 319A      		sbi 0x6,1
 153:main.c        **** 			}
 1255               		.loc 3 153 0
 1256 011c 399A      		sbi 0x7,1
 1257 011e 00C0      		rjmp .L39
 1258               	.L52:
 158:main.c        **** 			flashBank1CommandWrites = 1;
 1259               		.loc 3 158 0
 1260 0120 8E34      		cpi r24,lo8(78)
 1261 0122 01F4      		brne .L53
 159:main.c        **** 		}
 1262               		.loc 3 159 0
 1263 0124 4092 0000 		sts flashBank1CommandWrites,r4
 1264 0128 00C0      		rjmp .L39
 1265               	.L53:
 163:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 1266               		.loc 3 163 0
 1267 012a 8534      		cpi r24,lo8(69)
 1268 012c 01F4      		brne .L54
 1269 012e C0E0      		ldi r28,lo8(flashWriteCycle)
 1270 0130 D0E0      		ldi r29,hi8(flashWriteCycle)
 1271               	.L55:
 1272               	.LBB124:
 165:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 1273               		.loc 3 165 0 discriminator 3
 1274 0132 00D0      		rcall usart_read_chars
 1275               	.LVL118:
 166:main.c        **** 				USART_Transmit(SEND_ACK);
 1276               		.loc 3 166 0 discriminator 3
 1277 0134 40E1      		ldi r20,lo8(16)
 1278 0136 50E0      		ldi r21,0
 1279 0138 60E0      		ldi r22,0
 1280 013a 70E0      		ldi r23,0
 1281 013c 80E0      		ldi r24,lo8(receivedBuffer)
 1282 013e 90E0      		ldi r25,hi8(receivedBuffer)
 1283 0140 00D0      		rcall strtol
 1284               	.LVL119:
 1285 0142 7983      		std Y+1,r23
 1286 0144 6883      		st Y,r22
 167:main.c        **** 				
 1287               		.loc 3 167 0 discriminator 3
 1288 0146 81E3      		ldi r24,lo8(49)
 1289 0148 00D0      		rcall USART_Transmit
 1290               	.LVL120:
 169:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 1291               		.loc 3 169 0 discriminator 3
 1292 014a 00D0      		rcall usart_read_chars
 1293               	.LVL121:
 170:main.c        **** 				USART_Transmit(SEND_ACK);
 1294               		.loc 3 170 0 discriminator 3
 1295 014c 40E1      		ldi r20,lo8(16)
 1296 014e 50E0      		ldi r21,0
 1297 0150 60E0      		ldi r22,0
 1298 0152 70E0      		ldi r23,0
 1299 0154 80E0      		ldi r24,lo8(receivedBuffer)
 1300 0156 90E0      		ldi r25,hi8(receivedBuffer)
 1301 0158 00D0      		rcall strtol
 1302               	.LVL122:
 1303 015a 7B83      		std Y+3,r23
 1304 015c 6A83      		std Y+2,r22
 171:main.c        **** 			}
 1305               		.loc 3 171 0 discriminator 3
 1306 015e 81E3      		ldi r24,lo8(49)
 1307 0160 00D0      		rcall USART_Transmit
 1308               	.LVL123:
 1309 0162 2496      		adiw r28,4
 164:main.c        **** 				usart_read_chars(); // Address
 1310               		.loc 3 164 0 discriminator 3
 1311 0164 80E0      		ldi r24,lo8(flashWriteCycle+12)
 1312 0166 90E0      		ldi r25,hi8(flashWriteCycle+12)
 1313 0168 8C17      		cp r24,r28
 1314 016a 9D07      		cpc r25,r29
 1315 016c 01F4      		brne .L55
 1316 016e 00C0      		rjmp .L39
 1317               	.L54:
 1318               	.LBE124:
 176:main.c        **** 			usart_read_chars(); // Read address
 1319               		.loc 3 176 0
 1320 0170 8634      		cpi r24,lo8(70)
 1321 0172 01F4      		brne .L56
 1322               	.LBB125:
 177:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 1323               		.loc 3 177 0
 1324 0174 00D0      		rcall usart_read_chars
 1325               	.LVL124:
 178:main.c        **** 			
 1326               		.loc 3 178 0
 1327 0176 40E1      		ldi r20,lo8(16)
 1328 0178 50E0      		ldi r21,0
 1329 017a 60E0      		ldi r22,0
 1330 017c 70E0      		ldi r23,0
 1331 017e 80E0      		ldi r24,lo8(receivedBuffer)
 1332 0180 90E0      		ldi r25,hi8(receivedBuffer)
 1333 0182 00D0      		rcall strtol
 1334               	.LVL125:
 1335 0184 4B01      		movw r8,r22
 1336 0186 5C01      		movw r10,r24
 1337               	.LVL126:
 180:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 1338               		.loc 3 180 0
 1339 0188 00D0      		rcall usart_read_chars
 1340               	.LVL127:
 181:main.c        **** 			
 1341               		.loc 3 181 0
 1342 018a 40E1      		ldi r20,lo8(16)
 1343 018c 50E0      		ldi r21,0
 1344 018e 60E0      		ldi r22,0
 1345 0190 70E0      		ldi r23,0
 1346 0192 80E0      		ldi r24,lo8(receivedBuffer)
 1347 0194 90E0      		ldi r25,hi8(receivedBuffer)
 1348 0196 00D0      		rcall strtol
 1349               	.LVL128:
 183:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 1350               		.loc 3 183 0
 1351 0198 939A      		sbi 0x12,3
 184:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1352               		.loc 3 184 0
 1353 019a C401      		movw r24,r8
 1354 019c 00D0      		rcall gb_flash_write_bus_cycle
 1355               	.LVL129:
 1356               	.L157:
 185:main.c        **** 			
 1357               		.loc 3 185 0
 1358 019e 9398      		cbi 0x12,3
 187:main.c        **** 		}
 1359               		.loc 3 187 0
 1360 01a0 81E3      		ldi r24,lo8(49)
 1361 01a2 00C0      		rjmp .L142
 1362               	.LVL130:
 1363               	.L56:
 1364               	.LBE125:
 191:main.c        **** 			usart_read_bytes(64);
 1365               		.loc 3 191 0
 1366 01a4 8435      		cpi r24,lo8(84)
 1367 01a6 01F4      		brne .L57
 192:main.c        **** 			
 1368               		.loc 3 192 0
 1369 01a8 80E4      		ldi r24,lo8(64)
 1370 01aa 90E0      		ldi r25,0
 1371 01ac 00D0      		rcall usart_read_bytes
 1372               	.LVL131:
 194:main.c        **** 			if (flashBank1CommandWrites == 0) {
 1373               		.loc 3 194 0
 1374 01ae 939A      		sbi 0x12,3
 195:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1375               		.loc 3 195 0
 1376 01b0 8091 0000 		lds r24,flashBank1CommandWrites
 1377 01b4 00E0      		ldi r16,lo8(receivedBuffer)
 1378 01b6 10E0      		ldi r17,hi8(receivedBuffer)
 1379 01b8 C0E0      		ldi r28,0
 1380 01ba D0E0      		ldi r29,0
 1381 01bc 8111      		cpse r24,__zero_reg__
 1382 01be 00C0      		rjmp .L63
 1383               	.LVL132:
 1384               	.L60:
 1385               	.LBB126:
 197:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 1386               		.loc 3 197 0
 1387 01c0 F801      		movw r30,r16
 1388 01c2 6191      		ld r22,Z+
 1389 01c4 8F01      		movw r16,r30
 1390 01c6 6F3F      		cpi r22,lo8(-1)
 1391 01c8 01F0      		breq .L59
 198:main.c        **** 					}
 1392               		.loc 3 198 0
 1393 01ca CE01      		movw r24,r28
 1394 01cc 8C0D      		add r24,r12
 1395 01ce 9D1D      		adc r25,r13
 1396 01d0 00D0      		rcall gb_flash_write_byte
 1397               	.LVL133:
 1398               	.L59:
 1399 01d2 2196      		adiw r28,1
 1400               	.LVL134:
 196:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1401               		.loc 3 196 0 discriminator 2
 1402 01d4 C034      		cpi r28,64
 1403 01d6 D105      		cpc r29,__zero_reg__
 1404 01d8 01F4      		brne .L60
 1405 01da 00C0      		rjmp .L158
 1406               	.LVL135:
 1407               	.L62:
 1408 01dc 2196      		adiw r28,1
 1409               	.LVL136:
 1410               	.LBE126:
 1411               	.LBB127:
 204:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1412               		.loc 3 204 0 discriminator 2
 1413 01de C034      		cpi r28,64
 1414 01e0 D105      		cpc r29,__zero_reg__
 1415 01e2 01F4      		brne .+2
 1416 01e4 00C0      		rjmp .L158
 1417               	.LVL137:
 1418               	.L63:
 205:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 1419               		.loc 3 205 0
 1420 01e6 F801      		movw r30,r16
 1421 01e8 6191      		ld r22,Z+
 1422 01ea 8F01      		movw r16,r30
 1423 01ec 6F3F      		cpi r22,lo8(-1)
 1424 01ee 01F0      		breq .L62
 206:main.c        **** 					}
 1425               		.loc 3 206 0
 1426 01f0 CE01      		movw r24,r28
 1427 01f2 8C0D      		add r24,r12
 1428 01f4 9D1D      		adc r25,r13
 1429 01f6 00D0      		rcall gb_flash_write_byte_bank1_commands
 1430               	.LVL138:
 1431 01f8 00C0      		rjmp .L62
 1432               	.LVL139:
 1433               	.L57:
 1434               	.LBE127:
 217:main.c        **** 			usart_read_bytes(32);
 1435               		.loc 3 217 0
 1436 01fa 8935      		cpi r24,lo8(89)
 1437 01fc 01F0      		breq .+2
 1438 01fe 00C0      		rjmp .L64
 1439               	.LBB128:
 218:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1440               		.loc 3 218 0
 1441 0200 80E2      		ldi r24,lo8(32)
 1442 0202 90E0      		ldi r25,0
 1443 0204 00D0      		rcall usart_read_bytes
 1444               	.LVL140:
 219:main.c        **** 			
 1445               		.loc 3 219 0
 1446 0206 939A      		sbi 0x12,3
 222:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 1447               		.loc 3 222 0
 1448 0208 6AEA      		ldi r22,lo8(-86)
 1449 020a 8AEA      		ldi r24,lo8(-86)
 1450 020c 9AE0      		ldi r25,lo8(10)
 1451 020e 00D0      		rcall gb_flash_write_bus_cycle
 1452               	.LVL141:
 223:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 1453               		.loc 3 223 0
 1454 0210 65E5      		ldi r22,lo8(85)
 1455 0212 85E5      		ldi r24,lo8(85)
 1456 0214 95E0      		ldi r25,lo8(5)
 1457 0216 00D0      		rcall gb_flash_write_bus_cycle
 1458               	.LVL142:
 224:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 1459               		.loc 3 224 0
 1460 0218 5601      		movw r10,r12
 1461 021a 65E2      		ldi r22,lo8(37)
 1462 021c C601      		movw r24,r12
 1463 021e 00D0      		rcall gb_flash_write_bus_cycle
 1464               	.LVL143:
 225:main.c        **** 			_delay_us(1);
 1465               		.loc 3 225 0
 1466 0220 6FE1      		ldi r22,lo8(31)
 1467 0222 C601      		movw r24,r12
 1468 0224 00D0      		rcall gb_flash_write_bus_cycle
 1469               	.LVL144:
 1470               	.LBB129:
 1471               	.LBB130:
 1472               		.loc 2 276 0
 1473 0226 25E0      		ldi r18,lo8(5)
 1474 0228 2A95      	1:	dec r18
 1475 022a 01F4      		brne 1b
 1476 022c 0000      		nop
 1477               	.LVL145:
 1478 022e 00E0      		ldi r16,lo8(receivedBuffer)
 1479 0230 10E0      		ldi r17,hi8(receivedBuffer)
 1480 0232 C0E0      		ldi r28,0
 1481 0234 D0E0      		ldi r29,0
 1482               	.LVL146:
 1483               	.L65:
 1484               	.LBE130:
 1485               	.LBE129:
 1486               	.LBB131:
 230:main.c        **** 				address++;
 1487               		.loc 3 230 0 discriminator 3
 1488 0236 F801      		movw r30,r16
 1489 0238 6191      		ld r22,Z+
 1490 023a 8F01      		movw r16,r30
 1491 023c CE01      		movw r24,r28
 1492 023e 8A0D      		add r24,r10
 1493 0240 9B1D      		adc r25,r11
 1494 0242 00D0      		rcall gb_flash_write_bus_cycle
 1495               	.LVL147:
 1496 0244 2196      		adiw r28,1
 1497               	.LVL148:
 229:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1498               		.loc 3 229 0 discriminator 3
 1499 0246 C032      		cpi r28,32
 1500 0248 D105      		cpc r29,__zero_reg__
 1501 024a 01F4      		brne .L65
 1502 024c F0E2      		ldi r31,32
 1503 024e CF0E      		add r12,r31
 1504 0250 D11C      		adc r13,__zero_reg__
 1505 0252 E11C      		adc r14,__zero_reg__
 1506 0254 F11C      		adc r15,__zero_reg__
 1507               	.LBE131:
 235:main.c        **** 			_delay_us(200);
 1508               		.loc 3 235 0
 1509 0256 C601      		movw r24,r12
 1510 0258 8097      		sbiw r24,32
 1511 025a 69E2      		ldi r22,lo8(41)
 1512 025c 00D0      		rcall gb_flash_write_bus_cycle
 1513               	.LVL149:
 1514               	.LBB132:
 1515               	.LBB133:
 1516               		.loc 2 276 0
 1517 025e 8FE1      		ldi r24,lo8(799)
 1518 0260 93E0      		ldi r25,hi8(799)
 1519 0262 0197      	1:	sbiw r24,1
 1520 0264 01F4      		brne 1b
 1521 0266 00C0      		rjmp .
 1522 0268 0000      		nop
 1523               	.LVL150:
 1524               	.LBE133:
 1525               	.LBE132:
 239:main.c        **** 			uint8_t verifyCount = 0;
 1526               		.loc 3 239 0
 1527 026a E601      		movw r28,r12
 1528               	.LVL151:
 1529 026c 2197      		sbiw r28,1
 1530 026e CE01      		movw r24,r28
 1531 0270 00D0      		rcall gb_flash_read_byte
 1532               	.LVL152:
 241:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1533               		.loc 3 241 0
 1534 0272 18EC      		ldi r17,lo8(-56)
 1535               	.LVL153:
 1536               	.L66:
 1537 0274 9091 0000 		lds r25,receivedBuffer+31
 1538 0278 8917      		cp r24,r25
 1539 027a 01F4      		brne .+2
 1540 027c 00C0      		rjmp .L146
 242:main.c        **** 				_delay_us(5);
 1541               		.loc 3 242 0
 1542 027e CE01      		movw r24,r28
 1543               	.LVL154:
 1544 0280 00D0      		rcall gb_flash_read_byte
 1545               	.LVL155:
 1546               	.LBB134:
 1547               	.LBB135:
 1548               		.loc 2 276 0
 1549 0282 9AE1      		ldi r25,lo8(26)
 1550 0284 9A95      	1:	dec r25
 1551 0286 01F4      		brne 1b
 1552 0288 00C0      		rjmp .
 1553               	.LVL156:
 1554 028a 1150      		subi r17,lo8(-(-1))
 1555               	.LVL157:
 1556               	.LBE135:
 1557               	.LBE134:
 245:main.c        **** 					_delay_ms(500);
 1558               		.loc 3 245 0
 1559 028c 01F4      		brne .L66
 1560               	.LVL158:
 1561               	.LBB136:
 1562               	.LBB137:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1563               		.loc 2 187 0
 1564 028e EFEF      		ldi r30,lo8(1599999)
 1565 0290 F9E6      		ldi r31,hi8(1599999)
 1566 0292 28E1      		ldi r18,hlo8(1599999)
 1567 0294 E150      	1:	subi r30,1
 1568 0296 F040      		sbci r31,0
 1569 0298 2040      		sbci r18,0
 1570 029a 01F4      		brne 1b
 1571 029c 00C0      		rjmp .L159
 1572               	.LVL159:
 1573               	.L64:
 1574               	.LBE137:
 1575               	.LBE136:
 1576               	.LBE128:
 256:main.c        **** 			usart_read_bytes(64);
 1577               		.loc 3 256 0
 1578 029e 8A34      		cpi r24,lo8(74)
 1579 02a0 01F4      		brne .L69
 257:main.c        **** 			
 1580               		.loc 3 257 0
 1581 02a2 80E4      		ldi r24,lo8(64)
 1582 02a4 90E0      		ldi r25,0
 1583 02a6 00D0      		rcall usart_read_bytes
 1584               	.LVL160:
 259:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1585               		.loc 3 259 0
 1586 02a8 939A      		sbi 0x12,3
 1587               	.LVL161:
 1588 02aa 00E0      		ldi r16,lo8(receivedBuffer)
 1589 02ac 10E0      		ldi r17,hi8(receivedBuffer)
 1590 02ae C0E0      		ldi r28,0
 1591 02b0 D0E0      		ldi r29,0
 1592               	.LVL162:
 1593               	.L71:
 1594               	.LBB138:
 261:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 1595               		.loc 3 261 0
 1596 02b2 F801      		movw r30,r16
 1597 02b4 6191      		ld r22,Z+
 1598 02b6 8F01      		movw r16,r30
 1599 02b8 6F3F      		cpi r22,lo8(-1)
 1600 02ba 01F0      		breq .L70
 262:main.c        **** 				}
 1601               		.loc 3 262 0
 1602 02bc CE01      		movw r24,r28
 1603 02be 8C0D      		add r24,r12
 1604 02c0 9D1D      		adc r25,r13
 1605 02c2 00D0      		rcall gb_flash_write_byte_special
 1606               	.LVL163:
 1607               	.L70:
 1608 02c4 2196      		adiw r28,1
 1609               	.LVL164:
 260:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 1610               		.loc 3 260 0 discriminator 2
 1611 02c6 C034      		cpi r28,64
 1612 02c8 D105      		cpc r29,__zero_reg__
 1613 02ca 01F4      		brne .L71
 1614               	.LVL165:
 1615               	.L158:
 1616 02cc F0E4      		ldi r31,64
 1617 02ce CF0E      		add r12,r31
 1618 02d0 D11C      		adc r13,__zero_reg__
 1619 02d2 E11C      		adc r14,__zero_reg__
 1620 02d4 F11C      		adc r15,__zero_reg__
 1621 02d6 00C0      		rjmp .L146
 1622               	.LVL166:
 1623               	.L69:
 1624               	.LBE138:
 272:main.c        **** 			usart_read_bytes(256);
 1625               		.loc 3 272 0
 1626 02d8 8835      		cpi r24,lo8(88)
 1627 02da 01F0      		breq .+2
 1628 02dc 00C0      		rjmp .L72
 1629               	.LBB139:
 273:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1630               		.loc 3 273 0
 1631 02de 80E0      		ldi r24,0
 1632 02e0 91E0      		ldi r25,lo8(1)
 1633 02e2 00D0      		rcall usart_read_bytes
 1634               	.LVL167:
 274:main.c        **** 			
 1635               		.loc 3 274 0
 1636 02e4 939A      		sbi 0x12,3
 277:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 1637               		.loc 3 277 0
 1638 02e6 69EA      		ldi r22,lo8(-87)
 1639 02e8 8AEA      		ldi r24,lo8(-86)
 1640 02ea 9AE0      		ldi r25,lo8(10)
 1641 02ec 00D0      		rcall gb_flash_write_bus_cycle
 1642               	.LVL168:
 278:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 1643               		.loc 3 278 0
 1644 02ee 66E5      		ldi r22,lo8(86)
 1645 02f0 85E5      		ldi r24,lo8(85)
 1646 02f2 95E0      		ldi r25,lo8(5)
 1647 02f4 00D0      		rcall gb_flash_write_bus_cycle
 1648               	.LVL169:
 279:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 1649               		.loc 3 279 0
 1650 02f6 5601      		movw r10,r12
 1651 02f8 66E2      		ldi r22,lo8(38)
 1652 02fa C601      		movw r24,r12
 1653 02fc 00D0      		rcall gb_flash_write_bus_cycle
 1654               	.LVL170:
 280:main.c        **** 			_delay_us(50);
 1655               		.loc 3 280 0
 1656 02fe 6FEF      		ldi r22,lo8(-1)
 1657 0300 C601      		movw r24,r12
 1658 0302 00D0      		rcall gb_flash_write_bus_cycle
 1659               	.LVL171:
 1660               	.LBB140:
 1661               	.LBB141:
 1662               		.loc 2 276 0
 1663 0304 87EC      		ldi r24,lo8(199)
 1664 0306 90E0      		ldi r25,hi8(199)
 1665 0308 0197      	1:	sbiw r24,1
 1666 030a 01F4      		brne 1b
 1667 030c 00C0      		rjmp .
 1668 030e 0000      		nop
 1669               	.LVL172:
 1670 0310 00E0      		ldi r16,lo8(receivedBuffer)
 1671 0312 10E0      		ldi r17,hi8(receivedBuffer)
 1672               	.LBE141:
 1673               	.LBE140:
 1674               	.LBB142:
 284:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1675               		.loc 3 284 0
 1676 0314 C0E0      		ldi r28,0
 1677 0316 D0E0      		ldi r29,0
 1678               	.LVL173:
 1679               	.L73:
 285:main.c        **** 				address++;
 1680               		.loc 3 285 0 discriminator 3
 1681 0318 F801      		movw r30,r16
 1682 031a 6191      		ld r22,Z+
 1683 031c 8F01      		movw r16,r30
 1684 031e CE01      		movw r24,r28
 1685 0320 8A0D      		add r24,r10
 1686 0322 9B1D      		adc r25,r11
 1687 0324 00D0      		rcall gb_flash_write_bus_cycle
 1688               	.LVL174:
 284:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1689               		.loc 3 284 0 discriminator 3
 1690 0326 2196      		adiw r28,1
 1691               	.LVL175:
 1692 0328 C115      		cp r28,__zero_reg__
 1693 032a F1E0      		ldi r31,1
 1694 032c DF07      		cpc r29,r31
 1695 032e 01F4      		brne .L73
 1696 0330 2FEF      		ldi r18,-1
 1697 0332 D21A      		sub r13,r18
 1698 0334 E20A      		sbc r14,r18
 1699 0336 F20A      		sbc r15,r18
 1700               	.LBE142:
 290:main.c        **** 			
 1701               		.loc 3 290 0
 1702 0338 C601      		movw r24,r12
 1703 033a 9A95      		dec r25
 1704 033c 6AE2      		ldi r22,lo8(42)
 1705 033e 00D0      		rcall gb_flash_write_bus_cycle
 1706               	.LVL176:
 293:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 1707               		.loc 3 293 0
 1708 0340 E601      		movw r28,r12
 1709               	.LVL177:
 1710 0342 2197      		sbiw r28,1
 1711 0344 CE01      		movw r24,r28
 1712 0346 00D0      		rcall gb_flash_read_byte
 1713               	.LVL178:
 1714               	.L74:
 294:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1715               		.loc 3 294 0
 1716 0348 9091 0000 		lds r25,receivedBuffer+255
 1717 034c 8917      		cp r24,r25
 1718 034e 01F4      		brne .+2
 1719 0350 00C0      		rjmp .L146
 295:main.c        **** 				_delay_us(5);
 1720               		.loc 3 295 0
 1721 0352 CE01      		movw r24,r28
 1722               	.LVL179:
 1723 0354 00D0      		rcall gb_flash_read_byte
 1724               	.LVL180:
 1725               	.LBB143:
 1726               	.LBB144:
 1727               		.loc 2 276 0
 1728 0356 9AE1      		ldi r25,lo8(26)
 1729 0358 9A95      	1:	dec r25
 1730 035a 01F4      		brne 1b
 1731 035c 00C0      		rjmp .
 1732 035e 00C0      		rjmp .L74
 1733               	.LVL181:
 1734               	.L72:
 1735               	.LBE144:
 1736               	.LBE143:
 1737               	.LBE139:
 304:main.c        **** 			usart_read_bytes(128);
 1738               		.loc 3 304 0
 1739 0360 8A35      		cpi r24,lo8(90)
 1740 0362 01F0      		breq .+2
 1741 0364 00C0      		rjmp .L76
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1742               		.loc 3 305 0
 1743 0366 80E8      		ldi r24,lo8(-128)
 1744 0368 90E0      		ldi r25,0
 1745 036a 00D0      		rcall usart_read_bytes
 1746               	.LVL182:
 306:main.c        **** 			
 1747               		.loc 3 306 0
 1748 036c 939A      		sbi 0x12,3
 309:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 1749               		.loc 3 309 0
 1750 036e 69E0      		ldi r22,lo8(9)
 1751 0370 80E2      		ldi r24,lo8(32)
 1752 0372 91E0      		ldi r25,lo8(1)
 1753 0374 00D0      		rcall gb_flash_write_bus_cycle
 1754               	.LVL183:
 310:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 1755               		.loc 3 310 0
 1756 0376 6AEA      		ldi r22,lo8(-86)
 1757 0378 81E2      		ldi r24,lo8(33)
 1758 037a 91E0      		ldi r25,lo8(1)
 1759 037c 00D0      		rcall gb_flash_write_bus_cycle
 1760               	.LVL184:
 311:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1761               		.loc 3 311 0
 1762 037e 65E5      		ldi r22,lo8(85)
 1763 0380 82E2      		ldi r24,lo8(34)
 1764 0382 91E0      		ldi r25,lo8(1)
 1765 0384 00D0      		rcall gb_flash_write_bus_cycle
 1766               	.LVL185:
 312:main.c        **** 			_delay_us(5);
 1767               		.loc 3 312 0
 1768 0386 65EA      		ldi r22,lo8(-91)
 1769 0388 8FE3      		ldi r24,lo8(63)
 1770 038a 91E0      		ldi r25,lo8(1)
 1771 038c 00D0      		rcall gb_flash_write_bus_cycle
 1772               	.LVL186:
 1773               	.LBB145:
 1774               	.LBB146:
 1775               		.loc 2 276 0
 1776 038e EAE1      		ldi r30,lo8(26)
 1777 0390 EA95      	1:	dec r30
 1778 0392 01F4      		brne 1b
 1779 0394 00C0      		rjmp .
 1780               	.LVL187:
 1781               	.LBE146:
 1782               	.LBE145:
 316:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1783               		.loc 3 316 0
 1784 0396 61E1      		ldi r22,lo8(17)
 1785 0398 80E2      		ldi r24,lo8(32)
 1786 039a 91E0      		ldi r25,lo8(1)
 1787 039c 00D0      		rcall gb_flash_write_bus_cycle
 1788               	.LVL188:
 317:main.c        **** 			_delay_us(5);
 1789               		.loc 3 317 0
 1790 039e 65EA      		ldi r22,lo8(-91)
 1791 03a0 8FE3      		ldi r24,lo8(63)
 1792 03a2 91E0      		ldi r25,lo8(1)
 1793 03a4 00D0      		rcall gb_flash_write_bus_cycle
 1794               	.LVL189:
 1795               	.LBB147:
 1796               	.LBB148:
 1797               		.loc 2 276 0
 1798 03a6 FAE1      		ldi r31,lo8(26)
 1799 03a8 FA95      	1:	dec r31
 1800 03aa 01F4      		brne 1b
 1801 03ac 00C0      		rjmp .
 1802               	.LVL190:
 1803               	.LBE148:
 1804               	.LBE147:
 321:main.c        **** 			_delay_us(5);
 1805               		.loc 3 321 0
 1806 03ae 61E0      		ldi r22,lo8(1)
 1807 03b0 80E0      		ldi r24,0
 1808 03b2 91E2      		ldi r25,lo8(33)
 1809 03b4 00D0      		rcall gb_flash_write_bus_cycle
 1810               	.LVL191:
 1811               	.LBB149:
 1812               	.LBB150:
 1813               		.loc 2 276 0
 1814 03b6 2AE1      		ldi r18,lo8(26)
 1815 03b8 2A95      	1:	dec r18
 1816 03ba 01F4      		brne 1b
 1817 03bc 00C0      		rjmp .
 1818               	.LVL192:
 1819               	.LBE150:
 1820               	.LBE149:
 326:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1821               		.loc 3 326 0
 1822 03be 6FE0      		ldi r22,lo8(15)
 1823 03c0 80E2      		ldi r24,lo8(32)
 1824 03c2 91E0      		ldi r25,lo8(1)
 1825 03c4 00D0      		rcall gb_flash_write_bus_cycle
 1826               	.LVL193:
 327:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1827               		.loc 3 327 0
 1828 03c6 65E5      		ldi r22,lo8(85)
 1829 03c8 85E2      		ldi r24,lo8(37)
 1830 03ca 91E0      		ldi r25,lo8(1)
 1831 03cc 00D0      		rcall gb_flash_write_bus_cycle
 1832               	.LVL194:
 328:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 1833               		.loc 3 328 0
 1834 03ce 65E5      		ldi r22,lo8(85)
 1835 03d0 86E2      		ldi r24,lo8(38)
 1836 03d2 91E0      		ldi r25,lo8(1)
 1837 03d4 00D0      		rcall gb_flash_write_bus_cycle
 1838               	.LVL195:
 329:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1839               		.loc 3 329 0
 1840 03d6 6AEA      		ldi r22,lo8(-86)
 1841 03d8 87E2      		ldi r24,lo8(39)
 1842 03da 91E0      		ldi r25,lo8(1)
 1843 03dc 00D0      		rcall gb_flash_write_bus_cycle
 1844               	.LVL196:
 330:main.c        **** 			_delay_us(5);
 1845               		.loc 3 330 0
 1846 03de 65EA      		ldi r22,lo8(-91)
 1847 03e0 8FE3      		ldi r24,lo8(63)
 1848 03e2 91E0      		ldi r25,lo8(1)
 1849 03e4 00D0      		rcall gb_flash_write_bus_cycle
 1850               	.LVL197:
 1851               	.LBB151:
 1852               	.LBB152:
 1853               		.loc 2 276 0
 1854 03e6 8AE1      		ldi r24,lo8(26)
 1855 03e8 8A95      	1:	dec r24
 1856 03ea 01F4      		brne 1b
 1857 03ec 00C0      		rjmp .
 1858               	.LVL198:
 1859               	.LBE152:
 1860               	.LBE151:
 333:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 1861               		.loc 3 333 0
 1862 03ee 6FE0      		ldi r22,lo8(15)
 1863 03f0 80E2      		ldi r24,lo8(32)
 1864 03f2 91E0      		ldi r25,lo8(1)
 1865 03f4 00D0      		rcall gb_flash_write_bus_cycle
 1866               	.LVL199:
 334:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 1867               		.loc 3 334 0
 1868 03f6 6AE2      		ldi r22,lo8(42)
 1869 03f8 85E2      		ldi r24,lo8(37)
 1870 03fa 91E0      		ldi r25,lo8(1)
 1871 03fc 00D0      		rcall gb_flash_write_bus_cycle
 1872               	.LVL200:
 335:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 1873               		.loc 3 335 0
 1874 03fe 6AEA      		ldi r22,lo8(-86)
 1875 0400 86E2      		ldi r24,lo8(38)
 1876 0402 91E0      		ldi r25,lo8(1)
 1877 0404 00D0      		rcall gb_flash_write_bus_cycle
 1878               	.LVL201:
 336:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1879               		.loc 3 336 0
 1880 0406 65E5      		ldi r22,lo8(85)
 1881 0408 87E2      		ldi r24,lo8(39)
 1882 040a 91E0      		ldi r25,lo8(1)
 1883 040c 00D0      		rcall gb_flash_write_bus_cycle
 1884               	.LVL202:
 337:main.c        **** 			_delay_us(5);
 1885               		.loc 3 337 0
 1886 040e 65EA      		ldi r22,lo8(-91)
 1887 0410 8FE3      		ldi r24,lo8(63)
 1888 0412 91E0      		ldi r25,lo8(1)
 1889 0414 00D0      		rcall gb_flash_write_bus_cycle
 1890               	.LVL203:
 1891               	.LBB153:
 1892               	.LBB154:
 1893               		.loc 2 276 0
 1894 0416 9AE1      		ldi r25,lo8(26)
 1895 0418 9A95      	1:	dec r25
 1896 041a 01F4      		brne 1b
 1897 041c 00C0      		rjmp .
 1898               	.LVL204:
 1899               	.LBE154:
 1900               	.LBE153:
 340:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1901               		.loc 3 340 0
 1902 041e 6FE0      		ldi r22,lo8(15)
 1903 0420 80E2      		ldi r24,lo8(32)
 1904 0422 91E0      		ldi r25,lo8(1)
 1905 0424 00D0      		rcall gb_flash_write_bus_cycle
 1906               	.LVL205:
 341:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1907               		.loc 3 341 0
 1908 0426 65E5      		ldi r22,lo8(85)
 1909 0428 85E2      		ldi r24,lo8(37)
 1910 042a 91E0      		ldi r25,lo8(1)
 1911 042c 00D0      		rcall gb_flash_write_bus_cycle
 1912               	.LVL206:
 342:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 1913               		.loc 3 342 0
 1914 042e 65E5      		ldi r22,lo8(85)
 1915 0430 86E2      		ldi r24,lo8(38)
 1916 0432 91E0      		ldi r25,lo8(1)
 1917 0434 00D0      		rcall gb_flash_write_bus_cycle
 1918               	.LVL207:
 343:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1919               		.loc 3 343 0
 1920 0436 60EA      		ldi r22,lo8(-96)
 1921 0438 87E2      		ldi r24,lo8(39)
 1922 043a 91E0      		ldi r25,lo8(1)
 1923 043c 00D0      		rcall gb_flash_write_bus_cycle
 1924               	.LVL208:
 344:main.c        **** 			_delay_us(5);
 1925               		.loc 3 344 0
 1926 043e 65EA      		ldi r22,lo8(-91)
 1927 0440 8FE3      		ldi r24,lo8(63)
 1928 0442 91E0      		ldi r25,lo8(1)
 1929 0444 00D0      		rcall gb_flash_write_bus_cycle
 1930               	.LVL209:
 1931               	.LBB155:
 1932               	.LBB156:
 1933               		.loc 2 276 0
 1934 0446 EAE1      		ldi r30,lo8(26)
 1935 0448 EA95      	1:	dec r30
 1936 044a 01F4      		brne 1b
 1937 044c 00C0      		rjmp .
 1938               	.LVL210:
 1939               	.LBE156:
 1940               	.LBE155:
 348:main.c        **** 			_delay_us(5);
 1941               		.loc 3 348 0
 1942 044e 40E0      		ldi r20,0
 1943 0450 6091 0000 		lds r22,lastBankAccessed
 1944 0454 80E0      		ldi r24,0
 1945 0456 91E2      		ldi r25,lo8(33)
 1946 0458 00D0      		rcall write_8bit_data
 1947               	.LVL211:
 1948               	.LBB157:
 1949               	.LBB158:
 1950               		.loc 2 276 0
 1951 045a FAE1      		ldi r31,lo8(26)
 1952 045c FA95      	1:	dec r31
 1953 045e 01F4      		brne 1b
 1954 0460 00C0      		rjmp .
 1955               	.LVL212:
 1956               	.LBE158:
 1957               	.LBE157:
 352:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1958               		.loc 3 352 0
 1959 0462 60E1      		ldi r22,lo8(16)
 1960 0464 80E2      		ldi r24,lo8(32)
 1961 0466 91E0      		ldi r25,lo8(1)
 1962 0468 00D0      		rcall gb_flash_write_bus_cycle
 1963               	.LVL213:
 353:main.c        **** 			_delay_us(5);
 1964               		.loc 3 353 0
 1965 046a 65EA      		ldi r22,lo8(-91)
 1966 046c 8FE3      		ldi r24,lo8(63)
 1967 046e 91E0      		ldi r25,lo8(1)
 1968 0470 00D0      		rcall gb_flash_write_bus_cycle
 1969               	.LVL214:
 1970               	.LBB159:
 1971               	.LBB160:
 1972               		.loc 2 276 0
 1973 0472 2AE1      		ldi r18,lo8(26)
 1974 0474 2A95      	1:	dec r18
 1975 0476 01F4      		brne 1b
 1976 0478 00C0      		rjmp .
 1977               	.LVL215:
 1978               	.LBE160:
 1979               	.LBE159:
 357:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1980               		.loc 3 357 0
 1981 047a 68E0      		ldi r22,lo8(8)
 1982 047c 80E2      		ldi r24,lo8(32)
 1983 047e 91E0      		ldi r25,lo8(1)
 1984 0480 00D0      		rcall gb_flash_write_bus_cycle
 1985               	.LVL216:
 358:main.c        **** 			_delay_us(5);
 1986               		.loc 3 358 0
 1987 0482 65EA      		ldi r22,lo8(-91)
 1988 0484 8FE3      		ldi r24,lo8(63)
 1989 0486 91E0      		ldi r25,lo8(1)
 1990 0488 00D0      		rcall gb_flash_write_bus_cycle
 1991               	.LVL217:
 1992               	.LBB161:
 1993               	.LBB162:
 1994               		.loc 2 276 0
 1995 048a 8AE1      		ldi r24,lo8(26)
 1996 048c 8A95      	1:	dec r24
 1997 048e 01F4      		brne 1b
 1998 0490 00C0      		rjmp .
 1999               	.LVL218:
 2000 0492 C0E0      		ldi r28,lo8(receivedBuffer)
 2001 0494 D0E0      		ldi r29,hi8(receivedBuffer)
 2002               	.L77:
 2003               	.LBE162:
 2004               	.LBE161:
 2005               	.LBB163:
 363:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2006               		.loc 3 363 0 discriminator 1
 2007 0496 6C16      		cp r6,r28
 2008 0498 7D06      		cpc r7,r29
 2009 049a 01F0      		breq .L160
 364:main.c        **** 				_delay_us(5);
 2010               		.loc 3 364 0 discriminator 3
 2011 049c 6991      		ld r22,Y+
 2012 049e C601      		movw r24,r12
 2013 04a0 00D0      		rcall gb_flash_write_bus_cycle
 2014               	.LVL219:
 2015               	.LBB164:
 2016               	.LBB165:
 2017               		.loc 2 276 0 discriminator 3
 2018 04a2 9AE1      		ldi r25,lo8(26)
 2019 04a4 9A95      	1:	dec r25
 2020 04a6 01F4      		brne 1b
 2021 04a8 00C0      		rjmp .
 2022               	.LVL220:
 2023               	.LBE165:
 2024               	.LBE164:
 366:main.c        **** 			}
 2025               		.loc 3 366 0 discriminator 3
 2026 04aa EFEF      		ldi r30,-1
 2027 04ac CE1A      		sub r12,r30
 2028 04ae DE0A      		sbc r13,r30
 2029 04b0 EE0A      		sbc r14,r30
 2030 04b2 FE0A      		sbc r15,r30
 2031               	.LVL221:
 2032 04b4 00C0      		rjmp .L77
 2033               	.L160:
 2034               	.LVL222:
 2035               	.LBE163:
 371:main.c        **** 			address++;
 2036               		.loc 3 371 0
 2037 04b6 6FEF      		ldi r22,lo8(-1)
 2038 04b8 D701      		movw r26,r14
 2039 04ba C601      		movw r24,r12
 2040 04bc 0197      		sbiw r24,1
 2041 04be A109      		sbc r26,__zero_reg__
 2042 04c0 B109      		sbc r27,__zero_reg__
 2043               	.LVL223:
 2044 04c2 00D0      		rcall gb_flash_write_bus_cycle
 2045               	.LVL224:
 2046               	.LBB166:
 2047               	.LBB167:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2048               		.loc 2 187 0
 2049 04c4 8FE3      		ldi r24,lo8(-25537)
 2050 04c6 9CE9      		ldi r25,hi8(-25537)
 2051 04c8 0197      	1:	sbiw r24,1
 2052 04ca 01F4      		brne 1b
 2053               	.LVL225:
 2054               	.L159:
 2055 04cc 00C0      		rjmp .
 2056 04ce 0000      		nop
 2057 04d0 00C0      		rjmp .L146
 2058               	.LVL226:
 2059               	.L76:
 2060               	.LBE167:
 2061               	.LBE166:
 381:main.c        **** 			usart_read_bytes(32);
 2062               		.loc 3 381 0
 2063 04d2 8937      		cpi r24,lo8(121)
 2064 04d4 01F4      		brne .L79
 382:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2065               		.loc 3 382 0
 2066 04d6 80E2      		ldi r24,lo8(32)
 2067 04d8 90E0      		ldi r25,0
 2068 04da 00D0      		rcall usart_read_bytes
 2069               	.LVL227:
 383:main.c        **** 			
 2070               		.loc 3 383 0
 2071 04dc 939A      		sbi 0x12,3
 386:main.c        **** 			
 2072               		.loc 3 386 0
 2073 04de 8601      		movw r16,r12
 2074 04e0 68EE      		ldi r22,lo8(-24)
 2075 04e2 C601      		movw r24,r12
 2076 04e4 00D0      		rcall gb_flash_write_bus_cycle
 2077               	.LVL228:
 2078               	.L80:
 390:main.c        **** 			
 2079               		.loc 3 390 0 discriminator 1
 2080 04e6 C801      		movw r24,r16
 2081 04e8 00D0      		rcall gb_flash_read_byte
 2082               	.LVL229:
 2083 04ea 8038      		cpi r24,lo8(-128)
 2084 04ec 01F4      		brne .L80
 393:main.c        **** 			
 2085               		.loc 3 393 0
 2086 04ee 6FE1      		ldi r22,lo8(31)
 2087 04f0 C801      		movw r24,r16
 2088 04f2 00D0      		rcall gb_flash_write_bus_cycle
 2089               	.LVL230:
 2090 04f4 80E0      		ldi r24,lo8(receivedBuffer)
 2091 04f6 A82E      		mov r10,r24
 2092 04f8 80E0      		ldi r24,hi8(receivedBuffer)
 2093 04fa B82E      		mov r11,r24
 2094 04fc C0E0      		ldi r28,0
 2095 04fe D0E0      		ldi r29,0
 2096               	.LVL231:
 2097               	.L81:
 2098               	.LBB168:
 397:main.c        **** 				address++;
 2099               		.loc 3 397 0 discriminator 3
 2100 0500 F501      		movw r30,r10
 2101 0502 6191      		ld r22,Z+
 2102 0504 5F01      		movw r10,r30
 2103 0506 CE01      		movw r24,r28
 2104 0508 800F      		add r24,r16
 2105 050a 911F      		adc r25,r17
 2106 050c 00D0      		rcall gb_flash_write_bus_cycle
 2107               	.LVL232:
 2108 050e 2196      		adiw r28,1
 2109               	.LVL233:
 396:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2110               		.loc 3 396 0 discriminator 3
 2111 0510 C032      		cpi r28,32
 2112 0512 D105      		cpc r29,__zero_reg__
 2113 0514 01F4      		brne .L81
 2114 0516 F0E2      		ldi r31,32
 2115 0518 CF0E      		add r12,r31
 2116 051a D11C      		adc r13,__zero_reg__
 2117 051c E11C      		adc r14,__zero_reg__
 2118 051e F11C      		adc r15,__zero_reg__
 2119               	.LBE168:
 402:main.c        **** 			_delay_us(196);
 2120               		.loc 3 402 0
 2121 0520 E601      		movw r28,r12
 2122               	.LVL234:
 2123 0522 A097      		sbiw r28,32
 2124 0524 60ED      		ldi r22,lo8(-48)
 2125 0526 CE01      		movw r24,r28
 2126 0528 00D0      		rcall gb_flash_write_bus_cycle
 2127               	.LVL235:
 2128               	.LBB169:
 2129               	.LBB170:
 2130               		.loc 2 276 0
 2131 052a 8FE0      		ldi r24,lo8(783)
 2132 052c 93E0      		ldi r25,hi8(783)
 2133 052e 0197      	1:	sbiw r24,1
 2134 0530 01F4      		brne 1b
 2135 0532 00C0      		rjmp .
 2136 0534 0000      		nop
 2137               	.L82:
 2138               	.LBE170:
 2139               	.LBE169:
 407:main.c        **** 			
 2140               		.loc 3 407 0 discriminator 1
 2141 0536 CE01      		movw r24,r28
 2142 0538 00D0      		rcall gb_flash_read_byte
 2143               	.LVL236:
 2144 053a 8038      		cpi r24,lo8(-128)
 2145 053c 01F4      		brne .L82
 2146               	.LVL237:
 2147               	.L146:
 409:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2148               		.loc 3 409 0
 2149 053e 81E3      		ldi r24,lo8(49)
 2150 0540 00C0      		rjmp .L143
 2151               	.LVL238:
 2152               	.L79:
 417:main.c        **** 			char portChar = USART_Receive();
 2153               		.loc 3 417 0
 2154 0542 8934      		cpi r24,lo8(73)
 2155 0544 01F0      		breq .L83
 417:main.c        **** 			char portChar = USART_Receive();
 2156               		.loc 3 417 0 is_stmt 0 discriminator 1
 2157 0546 8F34      		cpi r24,lo8(79)
 2158 0548 01F0      		breq .+2
 2159 054a 00C0      		rjmp .L84
 2160               	.L83:
 2161               	.LBB171:
 418:main.c        **** 			usart_read_chars();
 2162               		.loc 3 418 0 is_stmt 1
 2163 054c 00D0      		rcall USART_Receive
 2164               	.LVL239:
 2165 054e C82F      		mov r28,r24
 2166               	.LVL240:
 419:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2167               		.loc 3 419 0
 2168 0550 00D0      		rcall usart_read_chars
 2169               	.LVL241:
 420:main.c        **** 			
 2170               		.loc 3 420 0
 2171 0552 40E1      		ldi r20,lo8(16)
 2172 0554 50E0      		ldi r21,0
 2173 0556 60E0      		ldi r22,0
 2174 0558 70E0      		ldi r23,0
 2175 055a 80E0      		ldi r24,lo8(receivedBuffer)
 2176 055c 90E0      		ldi r25,hi8(receivedBuffer)
 2177 055e 00D0      		rcall strtol
 2178               	.LVL242:
 422:main.c        **** 			if (receivedChar == SET_INPUT) {
 2179               		.loc 3 422 0
 2180 0560 939A      		sbi 0x12,3
 423:main.c        **** 				if (portChar == 'A') {
 2181               		.loc 3 423 0
 2182 0562 8091 0000 		lds r24,receivedChar
 2183 0566 8934      		cpi r24,lo8(73)
 2184 0568 01F4      		brne .L85
 424:main.c        **** 					DDRA &= ~(setValue);
 2185               		.loc 3 424 0
 2186 056a C134      		cpi r28,lo8(65)
 2187 056c 01F4      		brne .L86
 425:main.c        **** 				}
 2188               		.loc 3 425 0
 2189 056e 8AB3      		in r24,0x1a
 2190 0570 6095      		com r22
 2191               	.LVL243:
 2192 0572 6823      		and r22,r24
 2193               	.LVL244:
 2194 0574 00C0      		rjmp .L148
 2195               	.LVL245:
 2196               	.L86:
 427:main.c        **** 					DDRB &= ~(setValue);
 2197               		.loc 3 427 0
 2198 0576 C234      		cpi r28,lo8(66)
 2199 0578 01F4      		brne .L88
 428:main.c        **** 				}
 2200               		.loc 3 428 0
 2201 057a 87B3      		in r24,0x17
 2202 057c 6095      		com r22
 2203               	.LVL246:
 2204 057e 6823      		and r22,r24
 2205               	.LVL247:
 2206 0580 00C0      		rjmp .L149
 2207               	.LVL248:
 2208               	.L88:
 430:main.c        **** 					DDRC &= ~(setValue);
 2209               		.loc 3 430 0
 2210 0582 C334      		cpi r28,lo8(67)
 2211 0584 01F4      		brne .L89
 431:main.c        **** 				}
 2212               		.loc 3 431 0
 2213 0586 84B3      		in r24,0x14
 2214 0588 6095      		com r22
 2215               	.LVL249:
 2216 058a 6823      		and r22,r24
 2217               	.LVL250:
 2218 058c 00C0      		rjmp .L154
 2219               	.LVL251:
 2220               	.L89:
 433:main.c        **** 					DDRD &= ~(setValue);
 2221               		.loc 3 433 0
 2222 058e C434      		cpi r28,lo8(68)
 2223 0590 01F4      		brne .L90
 434:main.c        **** 				}
 2224               		.loc 3 434 0
 2225 0592 81B3      		in r24,0x11
 2226 0594 6095      		com r22
 2227               	.LVL252:
 2228 0596 6823      		and r22,r24
 2229               	.LVL253:
 2230 0598 00C0      		rjmp .L155
 2231               	.LVL254:
 2232               	.L90:
 436:main.c        **** 					DDRE &= ~(setValue);
 2233               		.loc 3 436 0
 2234 059a C534      		cpi r28,lo8(69)
 2235 059c 01F0      		breq .+2
 2236 059e 00C0      		rjmp .L109
 437:main.c        **** 				}
 2237               		.loc 3 437 0
 2238 05a0 86B1      		in r24,0x6
 2239 05a2 6095      		com r22
 2240               	.LVL255:
 2241 05a4 6823      		and r22,r24
 2242               	.LVL256:
 2243 05a6 00C0      		rjmp .L156
 2244               	.LVL257:
 2245               	.L85:
 440:main.c        **** 				if (portChar == 'A') {
 2246               		.loc 3 440 0
 2247 05a8 8F34      		cpi r24,lo8(79)
 2248 05aa 01F0      		breq .+2
 2249 05ac 00C0      		rjmp .L109
 441:main.c        **** 					DDRA |= (setValue);
 2250               		.loc 3 441 0
 2251 05ae C134      		cpi r28,lo8(65)
 2252 05b0 01F4      		brne .L91
 442:main.c        **** 				}
 2253               		.loc 3 442 0
 2254 05b2 8AB3      		in r24,0x1a
 2255 05b4 682B      		or r22,r24
 2256               	.LVL258:
 2257               	.L148:
 2258 05b6 6ABB      		out 0x1a,r22
 2259 05b8 00C0      		rjmp .L109
 2260               	.LVL259:
 2261               	.L91:
 444:main.c        **** 					DDRB |= (setValue);
 2262               		.loc 3 444 0
 2263 05ba C234      		cpi r28,lo8(66)
 2264 05bc 01F4      		brne .L92
 445:main.c        **** 				}
 2265               		.loc 3 445 0
 2266 05be 87B3      		in r24,0x17
 2267 05c0 682B      		or r22,r24
 2268               	.LVL260:
 2269               	.L149:
 2270 05c2 67BB      		out 0x17,r22
 2271 05c4 00C0      		rjmp .L109
 2272               	.LVL261:
 2273               	.L92:
 447:main.c        **** 					DDRC |= (setValue);
 2274               		.loc 3 447 0
 2275 05c6 C334      		cpi r28,lo8(67)
 2276 05c8 01F4      		brne .L93
 448:main.c        **** 				}
 2277               		.loc 3 448 0
 2278 05ca 84B3      		in r24,0x14
 2279 05cc 682B      		or r22,r24
 2280               	.LVL262:
 2281               	.L154:
 2282 05ce 64BB      		out 0x14,r22
 2283 05d0 00C0      		rjmp .L109
 2284               	.LVL263:
 2285               	.L93:
 450:main.c        **** 					DDRD |= (setValue);
 2286               		.loc 3 450 0
 2287 05d2 C434      		cpi r28,lo8(68)
 2288 05d4 01F4      		brne .L94
 451:main.c        **** 				}
 2289               		.loc 3 451 0
 2290 05d6 81B3      		in r24,0x11
 2291 05d8 682B      		or r22,r24
 2292               	.LVL264:
 2293               	.L155:
 2294 05da 61BB      		out 0x11,r22
 2295 05dc 00C0      		rjmp .L109
 2296               	.LVL265:
 2297               	.L94:
 453:main.c        **** 					DDRE |= (setValue);
 2298               		.loc 3 453 0
 2299 05de C534      		cpi r28,lo8(69)
 2300 05e0 01F0      		breq .+2
 2301 05e2 00C0      		rjmp .L109
 454:main.c        **** 				}
 2302               		.loc 3 454 0
 2303 05e4 86B1      		in r24,0x6
 2304 05e6 682B      		or r22,r24
 2305               	.LVL266:
 2306               	.L156:
 2307 05e8 66B9      		out 0x6,r22
 2308 05ea 00C0      		rjmp .L109
 2309               	.LVL267:
 2310               	.L84:
 2311               	.LBE171:
 461:main.c        **** 			char portChar = USART_Receive();			
 2312               		.loc 3 461 0
 2313 05ec 8C34      		cpi r24,lo8(76)
 2314 05ee 01F4      		brne .L95
 2315               	.LBB172:
 462:main.c        **** 			usart_read_chars();
 2316               		.loc 3 462 0
 2317 05f0 00D0      		rcall USART_Receive
 2318               	.LVL268:
 2319 05f2 C82F      		mov r28,r24
 2320               	.LVL269:
 463:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2321               		.loc 3 463 0
 2322 05f4 00D0      		rcall usart_read_chars
 2323               	.LVL270:
 464:main.c        **** 			
 2324               		.loc 3 464 0
 2325 05f6 40E1      		ldi r20,lo8(16)
 2326 05f8 50E0      		ldi r21,0
 2327 05fa 60E0      		ldi r22,0
 2328 05fc 70E0      		ldi r23,0
 2329 05fe 80E0      		ldi r24,lo8(receivedBuffer)
 2330 0600 90E0      		ldi r25,hi8(receivedBuffer)
 2331 0602 00D0      		rcall strtol
 2332               	.LVL271:
 466:main.c        **** 			if (portChar == 'A') {
 2333               		.loc 3 466 0
 2334 0604 939A      		sbi 0x12,3
 467:main.c        **** 				PORTA &= ~(setValue);
 2335               		.loc 3 467 0
 2336 0606 C134      		cpi r28,lo8(65)
 2337 0608 01F4      		brne .L96
 468:main.c        **** 			}
 2338               		.loc 3 468 0
 2339 060a 8BB3      		in r24,0x1b
 2340 060c 6095      		com r22
 2341               	.LVL272:
 2342 060e 6823      		and r22,r24
 2343               	.LVL273:
 2344 0610 00C0      		rjmp .L153
 2345               	.LVL274:
 2346               	.L96:
 470:main.c        **** 				PORTB &= ~(setValue);
 2347               		.loc 3 470 0
 2348 0612 C234      		cpi r28,lo8(66)
 2349 0614 01F4      		brne .L98
 471:main.c        **** 			}
 2350               		.loc 3 471 0
 2351 0616 88B3      		in r24,0x18
 2352 0618 6095      		com r22
 2353               	.LVL275:
 2354 061a 6823      		and r22,r24
 2355               	.LVL276:
 2356 061c 00C0      		rjmp .L152
 2357               	.LVL277:
 2358               	.L98:
 473:main.c        **** 				PORTC &= ~(setValue);
 2359               		.loc 3 473 0
 2360 061e C334      		cpi r28,lo8(67)
 2361 0620 01F4      		brne .L99
 474:main.c        **** 			}
 2362               		.loc 3 474 0
 2363 0622 85B3      		in r24,0x15
 2364 0624 6095      		com r22
 2365               	.LVL278:
 2366 0626 6823      		and r22,r24
 2367               	.LVL279:
 2368 0628 00C0      		rjmp .L151
 2369               	.LVL280:
 2370               	.L99:
 476:main.c        **** 				PORTD &= ~(setValue);
 2371               		.loc 3 476 0
 2372 062a C434      		cpi r28,lo8(68)
 2373 062c 01F4      		brne .L100
 477:main.c        **** 			}
 2374               		.loc 3 477 0
 2375 062e 82B3      		in r24,0x12
 2376 0630 6095      		com r22
 2377               	.LVL281:
 2378 0632 6823      		and r22,r24
 2379               	.LVL282:
 2380 0634 00C0      		rjmp .L150
 2381               	.LVL283:
 2382               	.L100:
 479:main.c        **** 				PORTE &= ~(setValue);
 2383               		.loc 3 479 0
 2384 0636 C534      		cpi r28,lo8(69)
 2385 0638 01F0      		breq .+2
 2386 063a 00C0      		rjmp .L109
 480:main.c        **** 			}
 2387               		.loc 3 480 0
 2388 063c 87B1      		in r24,0x7
 2389 063e 6095      		com r22
 2390               	.LVL284:
 2391 0640 6823      		and r22,r24
 2392               	.LVL285:
 2393 0642 00C0      		rjmp .L147
 2394               	.LVL286:
 2395               	.L95:
 2396               	.LBE172:
 486:main.c        **** 			char portChar = USART_Receive();			
 2397               		.loc 3 486 0
 2398 0644 8834      		cpi r24,lo8(72)
 2399 0646 01F4      		brne .L101
 2400               	.LBB173:
 487:main.c        **** 			usart_read_chars();
 2401               		.loc 3 487 0
 2402 0648 00D0      		rcall USART_Receive
 2403               	.LVL287:
 2404 064a C82F      		mov r28,r24
 2405               	.LVL288:
 488:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2406               		.loc 3 488 0
 2407 064c 00D0      		rcall usart_read_chars
 2408               	.LVL289:
 489:main.c        **** 			
 2409               		.loc 3 489 0
 2410 064e 40E1      		ldi r20,lo8(16)
 2411 0650 50E0      		ldi r21,0
 2412 0652 60E0      		ldi r22,0
 2413 0654 70E0      		ldi r23,0
 2414 0656 80E0      		ldi r24,lo8(receivedBuffer)
 2415 0658 90E0      		ldi r25,hi8(receivedBuffer)
 2416 065a 00D0      		rcall strtol
 2417               	.LVL290:
 491:main.c        **** 			if (portChar == 'A') {
 2418               		.loc 3 491 0
 2419 065c 939A      		sbi 0x12,3
 492:main.c        **** 				PORTA |= (setValue);
 2420               		.loc 3 492 0
 2421 065e C134      		cpi r28,lo8(65)
 2422 0660 01F4      		brne .L102
 493:main.c        **** 			}
 2423               		.loc 3 493 0
 2424 0662 8BB3      		in r24,0x1b
 2425 0664 682B      		or r22,r24
 2426               	.LVL291:
 2427               	.L153:
 2428 0666 6BBB      		out 0x1b,r22
 2429 0668 00C0      		rjmp .L109
 2430               	.LVL292:
 2431               	.L102:
 495:main.c        **** 				PORTB |= (setValue);
 2432               		.loc 3 495 0
 2433 066a C234      		cpi r28,lo8(66)
 2434 066c 01F4      		brne .L104
 496:main.c        **** 			}
 2435               		.loc 3 496 0
 2436 066e 88B3      		in r24,0x18
 2437 0670 682B      		or r22,r24
 2438               	.LVL293:
 2439               	.L152:
 2440 0672 68BB      		out 0x18,r22
 2441 0674 00C0      		rjmp .L109
 2442               	.LVL294:
 2443               	.L104:
 498:main.c        **** 				PORTC |= (setValue);
 2444               		.loc 3 498 0
 2445 0676 C334      		cpi r28,lo8(67)
 2446 0678 01F4      		brne .L105
 499:main.c        **** 			}
 2447               		.loc 3 499 0
 2448 067a 85B3      		in r24,0x15
 2449 067c 682B      		or r22,r24
 2450               	.LVL295:
 2451               	.L151:
 2452 067e 65BB      		out 0x15,r22
 2453 0680 00C0      		rjmp .L109
 2454               	.LVL296:
 2455               	.L105:
 501:main.c        **** 				PORTD |= (setValue);
 2456               		.loc 3 501 0
 2457 0682 C434      		cpi r28,lo8(68)
 2458 0684 01F4      		brne .L106
 502:main.c        **** 			}
 2459               		.loc 3 502 0
 2460 0686 82B3      		in r24,0x12
 2461 0688 682B      		or r22,r24
 2462               	.LVL297:
 2463               	.L150:
 2464 068a 62BB      		out 0x12,r22
 2465 068c 00C0      		rjmp .L109
 2466               	.LVL298:
 2467               	.L106:
 504:main.c        **** 				PORTE |= (setValue);
 2468               		.loc 3 504 0
 2469 068e C534      		cpi r28,lo8(69)
 2470 0690 01F4      		brne .L109
 505:main.c        **** 			}
 2471               		.loc 3 505 0
 2472 0692 87B1      		in r24,0x7
 2473 0694 682B      		or r22,r24
 2474               	.LVL299:
 2475               	.L147:
 2476 0696 67B9      		out 0x7,r22
 2477 0698 00C0      		rjmp .L109
 2478               	.L101:
 2479               	.LBE173:
 511:main.c        **** 			char portChar = USART_Receive();			
 2480               		.loc 3 511 0
 2481 069a 8434      		cpi r24,lo8(68)
 2482 069c 01F4      		brne .L107
 2483               	.LBB174:
 512:main.c        **** 			
 2484               		.loc 3 512 0
 2485 069e 00D0      		rcall USART_Receive
 2486               	.LVL300:
 514:main.c        **** 			if (portChar == 'A') {
 2487               		.loc 3 514 0
 2488 06a0 939A      		sbi 0x12,3
 515:main.c        **** 				USART_Transmit(PINA);
 2489               		.loc 3 515 0
 2490 06a2 8134      		cpi r24,lo8(65)
 2491 06a4 01F4      		brne .L108
 516:main.c        **** 			}
 2492               		.loc 3 516 0
 2493 06a6 89B3      		in r24,0x19
 2494               	.LVL301:
 2495 06a8 00C0      		rjmp .L143
 2496               	.LVL302:
 2497               	.L108:
 518:main.c        **** 				USART_Transmit(PINB);
 2498               		.loc 3 518 0
 2499 06aa 8234      		cpi r24,lo8(66)
 2500 06ac 01F4      		brne .L110
 519:main.c        **** 			}
 2501               		.loc 3 519 0
 2502 06ae 86B3      		in r24,0x16
 2503               	.LVL303:
 2504 06b0 00C0      		rjmp .L143
 2505               	.LVL304:
 2506               	.L110:
 521:main.c        **** 				USART_Transmit(PINC);
 2507               		.loc 3 521 0
 2508 06b2 8334      		cpi r24,lo8(67)
 2509 06b4 01F4      		brne .L111
 522:main.c        **** 			}
 2510               		.loc 3 522 0
 2511 06b6 83B3      		in r24,0x13
 2512               	.LVL305:
 2513 06b8 00C0      		rjmp .L143
 2514               	.LVL306:
 2515               	.L111:
 524:main.c        **** 				USART_Transmit(PIND);
 2516               		.loc 3 524 0
 2517 06ba 8434      		cpi r24,lo8(68)
 2518 06bc 01F4      		brne .L112
 525:main.c        **** 			}
 2519               		.loc 3 525 0
 2520 06be 80B3      		in r24,0x10
 2521               	.LVL307:
 2522 06c0 00C0      		rjmp .L143
 2523               	.LVL308:
 2524               	.L112:
 527:main.c        **** 				USART_Transmit(PINE);
 2525               		.loc 3 527 0
 2526 06c2 8534      		cpi r24,lo8(69)
 2527 06c4 01F4      		brne .L109
 528:main.c        **** 			}
 2528               		.loc 3 528 0
 2529 06c6 85B1      		in r24,0x5
 2530               	.LVL309:
 2531               	.L143:
 2532 06c8 00D0      		rcall USART_Transmit
 2533               	.LVL310:
 2534               	.L109:
 530:main.c        **** 		}
 2535               		.loc 3 530 0
 2536 06ca 9398      		cbi 0x12,3
 2537               	.LBE174:
 2538 06cc 00C0      		rjmp .L39
 2539               	.LVL311:
 2540               	.L107:
 534:main.c        **** 			char commonChar = USART_Receive();
 2541               		.loc 3 534 0
 2542 06ce 8D34      		cpi r24,lo8(77)
 2543 06d0 01F4      		brne .L113
 2544               	.LBB175:
 535:main.c        **** 			if (commonChar == '1') {
 2545               		.loc 3 535 0
 2546 06d2 00D0      		rcall USART_Receive
 2547               	.LVL312:
 536:main.c        **** 				resetCommonLines = 1;
 2548               		.loc 3 536 0
 2549 06d4 8133      		cpi r24,lo8(49)
 2550 06d6 01F4      		brne .L161
 2551               		.loc 3 537 0
 2552 06d8 5524      		clr r5
 2553 06da 5394      		inc r5
 2554 06dc 00C0      		rjmp .L141
 2555               	.L161:
 538:main.c        **** 			}
 539:main.c        **** 			else if (commonChar == '0') {
 2556               		.loc 3 539 0
 2557 06de 8033      		cpi r24,lo8(48)
 2558 06e0 01F0      		breq .+2
 2559 06e2 00C0      		rjmp .L39
 540:main.c        **** 				resetCommonLines = 0;
 2560               		.loc 3 540 0
 2561 06e4 512C      		mov r5,__zero_reg__
 2562 06e6 00C0      		rjmp .L40
 2563               	.LVL313:
 2564               	.L113:
 2565               	.LBE175:
 541:main.c        **** 			}
 542:main.c        **** 		}
 543:main.c        **** 		
 544:main.c        **** 		// Send back the PCB version number
 545:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2566               		.loc 3 545 0
 2567 06e8 8836      		cpi r24,lo8(104)
 2568 06ea 01F4      		brne .L114
 546:main.c        **** 			USART_Transmit(PCB_VERSION);
 2569               		.loc 3 546 0
 2570 06ec 84E6      		ldi r24,lo8(100)
 2571 06ee 00C0      		rjmp .L142
 2572               	.L114:
 547:main.c        **** 		}
 548:main.c        **** 		
 549:main.c        **** 		// Send back the firmware version number
 550:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2573               		.loc 3 550 0
 2574 06f0 8635      		cpi r24,lo8(86)
 2575 06f2 01F4      		brne .L115
 551:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2576               		.loc 3 551 0
 2577 06f4 81E1      		ldi r24,lo8(17)
 2578               	.LVL314:
 2579               	.L142:
 2580 06f6 00D0      		rcall USART_Transmit
 2581               	.LVL315:
 2582 06f8 00C0      		rjmp .L39
 2583               	.LVL316:
 2584               	.L115:
 552:main.c        **** 		}
 553:main.c        **** 		
 554:main.c        **** 		// Reset the AVR if it matches the number
 555:main.c        **** 		else if (receivedChar == RESET_AVR) {
 2585               		.loc 3 555 0
 2586 06fa 8A32      		cpi r24,lo8(42)
 2587 06fc 01F0      		breq .+2
 2588 06fe 00C0      		rjmp .L39
 2589               	.LBB176:
 556:main.c        **** 			usart_read_chars();
 2590               		.loc 3 556 0
 2591 0700 00D0      		rcall usart_read_chars
 2592               	.LVL317:
 557:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 2593               		.loc 3 557 0
 2594 0702 40E1      		ldi r20,lo8(16)
 2595 0704 50E0      		ldi r21,0
 2596 0706 60E0      		ldi r22,0
 2597 0708 70E0      		ldi r23,0
 2598 070a 80E0      		ldi r24,lo8(receivedBuffer)
 2599 070c 90E0      		ldi r25,hi8(receivedBuffer)
 2600 070e 00D0      		rcall strtol
 2601               	.LVL318:
 558:main.c        **** 			if (resetValue == RESET_VALUE) {
 2602               		.loc 3 558 0
 2603 0710 613E      		cpi r22,-31
 2604 0712 754E      		sbci r23,-27
 2605 0714 8740      		sbci r24,7
 2606 0716 9105      		cpc r25,__zero_reg__
 2607 0718 01F0      		breq .+2
 2608 071a 00C0      		rjmp .L39
 559:main.c        **** 				// Clear watchdog flag
 560:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 2609               		.loc 3 560 0
 2610 071c 84B7      		in r24,0x34
 2611 071e 877F      		andi r24,lo8(-9)
 2612 0720 84BF      		out 0x34,r24
 561:main.c        **** 				
 562:main.c        **** 				// Start timed sequence
 563:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 2613               		.loc 3 563 0
 2614 0722 F8E1      		ldi r31,lo8(24)
 2615 0724 F1BD      		out 0x21,r31
 564:main.c        **** 				
 565:main.c        **** 				// Reset in 250 ms
 566:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 2616               		.loc 3 566 0
 2617 0726 2CE0      		ldi r18,lo8(12)
 2618 0728 21BD      		out 0x21,r18
 2619               	.LVL319:
 2620               	.LBB118:
 2621               	.LBB117:
 2622               		.loc 4 105 0
 2623 072a C101      		movw r24,r2
 2624               	/* #APP */
 2625               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 2626 072c 0197      		1: sbiw r24,1
 2627 072e 01F4      		brne 1b
 2628               	 ;  0 "" 2
 2629               	.LVL320:
 2630               	/* #NOAPP */
 2631 0730 00C0      		rjmp .L39
 2632               	.LBE117:
 2633               	.LBE118:
 2634               	.LBE176:
 2635               		.cfi_endproc
 2636               	.LFE27:
 2638               	.global	cartMode
 2639               		.data
 2642               	cartMode:
 2643 0000 01        		.byte	1
 2644               	.global	lastBankAccessed
 2645               		.section .bss
 2648               	lastBankAccessed:
 2649 0000 00        		.zero	1
 2650               	.global	flashBank1CommandWrites
 2653               	flashBank1CommandWrites:
 2654 0001 00        		.zero	1
 2655               		.comm	flashWriteCycle,12,1
 2656               		.comm	flashWriteWePin,1,1
 2657               		.comm	receivedChar,1,1
 2658               		.comm	receivedBuffer,256,1
 2659               		.text
 2660               	.Letext0:
 2661               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2662               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:274    .text:00000086 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:343    .text:000000b4 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:391    .text:000000ca gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:494    .text:00000108 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:595    .text:0000016c gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:2653   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:2648   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:726    .text:000001fa gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:897    .text:00000292 setup
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:1000   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccMR2498.s:2642   .data:00000000 cartMode

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
