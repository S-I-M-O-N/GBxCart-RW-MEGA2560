   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R17
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 21/01/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define WRITE_RAM 'W'
 109:setup.c       **** #define SET_BANK 'B'
 110:setup.c       **** #define GB_CART_MODE 'G'
 111:setup.c       **** 
 112:setup.c       **** // GBA commands
 113:setup.c       **** #define GBA_READ_ROM 'r'
 114:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 115:setup.c       **** #define GBA_READ_SRAM 'm'
 116:setup.c       **** #define GBA_WRITE_SRAM 'w'
 117:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 118:setup.c       **** #define GBA_CART_MODE 'g'
 119:setup.c       **** 
 120:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 121:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 122:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 123:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 124:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 125:setup.c       **** 
 126:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 127:setup.c       **** #define GBA_READ_EEPROM 'e'
 128:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 129:setup.c       **** 
 130:setup.c       **** // Flash Cart commands
 131:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 132:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 133:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 134:setup.c       **** 
 135:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 136:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 137:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 141:setup.c       **** 
 142:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 143:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 144:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 145:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 146:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 147:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 148:setup.c       **** 
 149:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 150:setup.c       **** 
 151:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 152:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 153:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 154:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 155:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 156:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 157:setup.c       **** 
 158:setup.c       **** #define D0D1_NOT_SWAPPED 0
 159:setup.c       **** #define D0D1_SWAPPED 1
 160:setup.c       **** 
 161:setup.c       **** // General commands
 162:setup.c       **** #define SEND_ACK '1'
 163:setup.c       **** #define CART_MODE 'C'
 164:setup.c       **** #define SET_INPUT 'I'
 165:setup.c       **** #define SET_OUTPUT 'O'
 166:setup.c       **** #define SET_OUTPUT_LOW 'L'
 167:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 168:setup.c       **** #define READ_INPUT 'D'
 169:setup.c       **** #define RESET_COMMON_LINES 'M'
 170:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 171:setup.c       **** #define READ_PCB_VERSION 'h'
 172:setup.c       **** 
 173:setup.c       **** #define RESET_AVR '*'
 174:setup.c       **** #define RESET_VALUE 0x7E5E1
 175:setup.c       **** 
 176:setup.c       **** 
 177:setup.c       **** char receivedBuffer[256];
 178:setup.c       **** char receivedChar;
 179:setup.c       **** uint8_t eepromBuffer[8];
 180:setup.c       **** uint8_t flashChipIdBuffer[2];
 181:setup.c       **** 
 182:setup.c       **** char flashWriteWePin;
 183:setup.c       **** uint16_t flashWriteCycle[3][2];
 184:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 185:setup.c       **** uint8_t lastBankAccessed = 0;
 186:setup.c       **** 
 187:setup.c       **** 
 188:setup.c       **** // Receive USART data
 189:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 189 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 190:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 190 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 191:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 191 0
  26 0004 8CB1      		in r24,0xc
 192:setup.c       **** }
  27               		.loc 1 192 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 193:setup.c       **** 
 194:setup.c       **** // Transmit USART data
 195:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 195 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 196:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 196 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 197:setup.c       **** 	UDR = data;
  47               		.loc 1 197 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 198:setup.c       **** }
 199:setup.c       **** 
 200:setup.c       **** // Read 1-256 bytes from the USART 
 201:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 201 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB137:
 202:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 202 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 202 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 203:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 203 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE137:
 204:setup.c       **** 	}
 205:setup.c       **** }
 106               		.loc 1 205 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 206:setup.c       **** 
 207:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 208:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 208 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 209:setup.c       **** 	int x = 0;
 210:setup.c       **** 	while (1) {
 211:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 211 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 212:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 212 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 213:setup.c       **** 			break;
 214:setup.c       **** 		}
 215:setup.c       **** 		x++;
 216:setup.c       **** 	}
 217:setup.c       **** }
 148               		.loc 1 217 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 218:setup.c       **** 
 219:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 220:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 220 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 221:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 221 0
 167 0050 3A9A      		sbi 0x7,2
 222:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 222 0
 169 0052 949A      		sbi 0x12,4
 223:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 223 0
 171 0054 959A      		sbi 0x12,5
 224:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 224 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 225:setup.c       **** }
 226:setup.c       **** 
 227:setup.c       **** 
 228:setup.c       **** 
 229:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 230:setup.c       **** 
 231:setup.c       **** // Set Gameboy mode
 232:setup.c       **** void gb_mode(void) {
 182               		.loc 1 232 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 233:setup.c       **** 	// Set inputs
 234:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 234 0
 189 005a 15BA      		out 0x15,__zero_reg__
 235:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 235 0
 191 005c 14BA      		out 0x14,__zero_reg__
 236:setup.c       **** 	
 237:setup.c       **** 	// Set outputs
 238:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 238 0
 193 005e 18BA      		out 0x18,__zero_reg__
 239:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 239 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 240:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 240 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 241:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 241 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 242:setup.c       **** }
 243:setup.c       **** 
 244:setup.c       **** // Set the 16 bit address on A15-0
 245:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 245 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 246:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 246 0
 217 006a 9BBB      		out 0x1b,r25
 247:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 247 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 248:setup.c       **** }
 249:setup.c       **** 
 250:setup.c       **** // Set the address and read a byte from the 8 bit data line
 251:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 251 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 252:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 252 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 253:setup.c       **** 	
 254:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 254 0
 239 0072 9498      		cbi 0x12,4
 255:setup.c       **** 	rdPin_low;
 240               		.loc 1 255 0
 241 0074 9598      		cbi 0x12,5
 256:setup.c       **** 	
 257:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 257 0
 243               	/* #APP */
 244               	 ;  257 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 258:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 258 0
 248               	 ;  258 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 259:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 259 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 260:setup.c       **** 	
 261:setup.c       **** 	rdPin_high;
 255               		.loc 1 261 0
 256 007c 959A      		sbi 0x12,5
 262:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 262 0
 258 007e 949A      		sbi 0x12,4
 263:setup.c       **** 	
 264:setup.c       **** 	return data;
 265:setup.c       **** }
 259               		.loc 1 265 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 266:setup.c       **** 
 267:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 268:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 268 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 269:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 269 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 270:setup.c       **** 	
 271:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 271 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 272:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 272 0
 292 0090 D5BB      		out 0x15,r29
 273:setup.c       **** 	
 274:setup.c       **** 	// Pulse WR and mREQ if the type matches
 275:setup.c       **** 	wrPin_low;
 293               		.loc 1 275 0
 294 0092 9698      		cbi 0x12,6
 276:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 276 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 277:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 277 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 278:setup.c       **** 	}
 279:setup.c       **** 	
 280:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 280 0
 302               	/* #APP */
 303               	 ;  280 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 281:setup.c       **** 	
 282:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 282 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 283:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 283 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 284:setup.c       **** 	}
 285:setup.c       **** 	wrPin_high;
 313               		.loc 1 285 0
 314 00a2 969A      		sbi 0x12,6
 286:setup.c       **** 	
 287:setup.c       **** 	// Clear data outputs and set data pins as inputs
 288:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 288 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 289:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 289 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 290:setup.c       **** }
 320               		.loc 1 290 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 291:setup.c       **** 
 292:setup.c       **** 
 293:setup.c       **** 
 294:setup.c       **** // ****** Gameboy Advance functions ****** 
 295:setup.c       **** 
 296:setup.c       **** // Set GBA mode
 297:setup.c       **** void gba_mode(void) {
 333               		.loc 1 297 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 298:setup.c       **** 	// Set outputs for reading ROM addresses as default
 299:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 299 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 300:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 300 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 301:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 301 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 302:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 302 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 303:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 303 0
 349 00b8 8ABB      		out 0x1a,r24
 304:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 304 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 305:setup.c       **** }
 306:setup.c       **** 
 307:setup.c       **** // Set the 24 bit address on A23-0
 308:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 308 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 309:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 309 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 310:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 310 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 311:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 311 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 312:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 312 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 313:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 313 0
 385 00cc 2ABB      		out 0x1a,r18
 314:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 314 0
 387 00ce 27BB      		out 0x17,r18
 315:setup.c       **** 	
 316:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 316 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 317:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 317 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 318:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 318 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 319:setup.c       **** }
 402               		.loc 1 319 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 320:setup.c       **** 
 321:setup.c       **** 
 322:setup.c       **** 
 323:setup.c       **** // ---------- ROM/SRAM ----------
 324:setup.c       **** 
 325:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 326:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 326 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 327:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 327 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 328:setup.c       **** 	
 329:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 329 0
 424 00ec 9498      		cbi 0x12,4
 330:setup.c       **** 	
 331:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 331 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 332:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 332 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 333:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 333 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 334:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 334 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 335:setup.c       **** 	
 336:setup.c       **** 	rdPin_low;
 433               		.loc 1 336 0
 434 00f6 9598      		cbi 0x12,5
 337:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 337 0
 436               	/* #APP */
 437               	 ;  337 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 338:setup.c       **** 	
 339:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 339 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 340:setup.c       **** 	
 341:setup.c       **** 	rdPin_high;
 445               		.loc 1 341 0
 446 00fe 959A      		sbi 0x12,5
 342:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 342 0
 448 0100 949A      		sbi 0x12,4
 343:setup.c       **** 	
 344:setup.c       **** 	return data;
 449               		.loc 1 344 0
 450 0102 90E0      		ldi r25,0
 345:setup.c       **** }
 451               		.loc 1 345 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 346:setup.c       **** 
 347:setup.c       **** // Set the address and read a byte from the 8 bit data line
 348:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 348 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 349:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 349 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 350:setup.c       **** 	
 351:setup.c       **** 	rdPin_low;
 471               		.loc 1 351 0
 472 010a 9598      		cbi 0x12,5
 352:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 473               		.loc 1 352 0
 474 010c 3A98      		cbi 0x7,2
 353:setup.c       **** 	
 354:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 354 0
 476               	/* #APP */
 477               	 ;  354 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 355:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 355 0
 481               	 ;  355 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 356:setup.c       **** 	
 357:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 357 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 358:setup.c       **** 	
 359:setup.c       **** 	cs2Pin_high;
 488               		.loc 1 359 0
 489 0114 3A9A      		sbi 0x7,2
 360:setup.c       **** 	rdPin_high;
 490               		.loc 1 360 0
 491 0116 959A      		sbi 0x12,5
 361:setup.c       **** 	
 362:setup.c       **** 	return data;
 363:setup.c       **** }
 492               		.loc 1 363 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 364:setup.c       **** 
 365:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 366:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 366 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 367:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 367 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 368:setup.c       **** 	
 369:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 369 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 370:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 370 0
 520 0124 C5BB      		out 0x15,r28
 371:setup.c       **** 	
 372:setup.c       **** 	// Pulse WR
 373:setup.c       **** 	wrPin_low;
 521               		.loc 1 373 0
 522 0126 9698      		cbi 0x12,6
 374:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 523               		.loc 1 374 0
 524 0128 3A98      		cbi 0x7,2
 375:setup.c       **** 	
 376:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 376 0
 526               	/* #APP */
 527               	 ;  376 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 377:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 377 0
 531               	 ;  377 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 378:setup.c       **** 	
 379:setup.c       **** 	cs2Pin_high;
 534               		.loc 1 379 0
 535               	/* #NOAPP */
 536 012e 3A9A      		sbi 0x7,2
 380:setup.c       **** 	wrPin_high;
 537               		.loc 1 380 0
 538 0130 969A      		sbi 0x12,6
 381:setup.c       **** 	
 382:setup.c       **** 	// Clear data outputs and set data pins as inputs
 383:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 383 0
 540 0132 15BA      		out 0x15,__zero_reg__
 384:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 384 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 385:setup.c       **** }
 544               		.loc 1 385 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 386:setup.c       **** 
 387:setup.c       **** 
 388:setup.c       **** 
 389:setup.c       **** // ---------- EEPROM ----------
 390:setup.c       **** 
 391:setup.c       **** // Set address/data all high (includes AD0/A23)
 392:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 392 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 393:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 393 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 394:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 394 0
 565 013e 8ABB      		out 0x1a,r24
 395:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 395 0
 567 0140 84BB      		out 0x14,r24
 396:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 396 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 397:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 397 0
 572 0146 8BBB      		out 0x1b,r24
 398:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 398 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 399:setup.c       **** }
 400:setup.c       **** 
 401:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 402:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 402 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 403:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 403 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 404:setup.c       **** 	
 405:setup.c       **** 	int8_t x = 0;
 406:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 406 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 407:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 407 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 408:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 408 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 409:setup.c       **** 		}
 410:setup.c       **** 		else {
 411:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 412:setup.c       **** 		}
 413:setup.c       **** 		x = 15;
 603               		.loc 1 413 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 414:setup.c       **** 	}
 415:setup.c       **** 	else {
 416:setup.c       **** 		if (command == EEPROM_READ) {
 417:setup.c       **** 			address |= (1<<7) | (1<<6);
 418:setup.c       **** 		}
 419:setup.c       **** 		else {
 420:setup.c       **** 			address |= (1<<7);
 421:setup.c       **** 		}
 422:setup.c       **** 		x = 7;
 423:setup.c       **** 	}
 424:setup.c       **** 	
 425:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 426:setup.c       **** 	while (x >= 0) {
 427:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 427 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 411:setup.c       **** 		}
 613               		.loc 1 411 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 416:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 416 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 417:setup.c       **** 		}
 621               		.loc 1 417 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 420:setup.c       **** 		}
 626               		.loc 1 420 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 422:setup.c       **** 	}
 630               		.loc 1 422 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 428:setup.c       **** 			ad0Pin_high;
 429:setup.c       **** 		}
 430:setup.c       **** 		else {
 431:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 431 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 432:setup.c       **** 		}
 433:setup.c       **** 		
 434:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 434 0
 639 0174 9698      		cbi 0x12,6
 435:setup.c       **** 		asm ("nop");
 640               		.loc 1 435 0
 641               	/* #APP */
 642               	 ;  435 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 436:setup.c       **** 		asm ("nop");
 645               		.loc 1 436 0
 646               	 ;  436 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 437:setup.c       **** 		wrPin_high; 
 649               		.loc 1 437 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 438:setup.c       **** 		asm ("nop");
 652               		.loc 1 438 0
 653               	/* #APP */
 654               	 ;  438 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 439:setup.c       **** 		asm ("nop");
 657               		.loc 1 439 0
 658               	 ;  439 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 426:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 426 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 427:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 427 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 428:setup.c       **** 		}
 682               		.loc 1 428 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 440:setup.c       **** 		
 441:setup.c       **** 		x--;
 442:setup.c       **** 	}
 443:setup.c       **** 	
 444:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 445:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 445 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 446:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 446 0
 690 01a4 C098      		cbi 0x18,0
 447:setup.c       **** 		asm ("nop");
 691               		.loc 1 447 0
 692               	/* #APP */
 693               	 ;  447 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 448:setup.c       **** 		wrPin_low;
 696               		.loc 1 448 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 449:setup.c       **** 		asm ("nop");
 699               		.loc 1 449 0
 700               	/* #APP */
 701               	 ;  449 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 450:setup.c       **** 		asm ("nop");
 704               		.loc 1 450 0
 705               	 ;  450 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 451:setup.c       **** 		
 452:setup.c       **** 		wrPin_high;
 708               		.loc 1 452 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 453:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 453 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 454:setup.c       **** 	}
 455:setup.c       **** }
 456:setup.c       **** 
 457:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 458:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 458 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 459:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 459 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 460:setup.c       **** 	
 461:setup.c       **** 	// Set AD0 pin as input
 462:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 462 0
 734 01b8 C098      		cbi 0x18,0
 463:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 463 0
 736 01ba B898      		cbi 0x17,0
 464:setup.c       **** 	
 465:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 465 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB138:
 466:setup.c       **** 	
 467:setup.c       **** 	// Ignore first 4 bits
 468:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 469:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 469 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 470:setup.c       **** 		asm ("nop");
 746               		.loc 1 470 0 discriminator 3
 747               	/* #APP */
 748               	 ;  470 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 471:setup.c       **** 		asm ("nop");
 751               		.loc 1 471 0 discriminator 3
 752               	 ;  471 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 472:setup.c       **** 		rdPin_high; 
 755               		.loc 1 472 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 473:setup.c       **** 		asm ("nop");
 758               		.loc 1 473 0 discriminator 3
 759               	/* #APP */
 760               	 ;  473 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 474:setup.c       **** 		asm ("nop");
 763               		.loc 1 474 0 discriminator 3
 764               	 ;  474 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 468:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 468 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE138:
 776               	.LBB139:
 777               	.LBB140:
 778               	.LBB141:
 475:setup.c       **** 	}
 476:setup.c       **** 	
 477:setup.c       **** 	// Read out 64 bits
 478:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 479:setup.c       **** 		uint8_t data = 0;
 480:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 481:setup.c       **** 			rdPin_low; // CLK
 482:setup.c       **** 			asm ("nop");
 483:setup.c       **** 			asm ("nop");
 484:setup.c       **** 			rdPin_high;
 485:setup.c       **** 			
 486:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 487:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 487 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE141:
 785               	.LBE140:
 786               	.LBE139:
 465:setup.c       **** 	
 787               		.loc 1 465 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB144:
 794               	.LBB143:
 795               	.LBB142:
 481:setup.c       **** 			asm ("nop");
 796               		.loc 1 481 0
 797 01de 9598      		cbi 0x12,5
 482:setup.c       **** 			asm ("nop");
 798               		.loc 1 482 0
 799               	/* #APP */
 800               	 ;  482 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 483:setup.c       **** 			rdPin_high;
 803               		.loc 1 483 0
 804               	 ;  483 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 484:setup.c       **** 			
 807               		.loc 1 484 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 486:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 486 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 487 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE142:
 488:setup.c       **** 			}
 489:setup.c       **** 		}
 490:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 490 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE143:
 478:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 478 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE144:
 491:setup.c       **** 	}
 492:setup.c       **** 	
 493:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 493 0
 841 0206 949A      		sbi 0x12,4
 494:setup.c       **** 	
 495:setup.c       **** 	// Set AD0 pin as output
 496:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 496 0
 843 0208 C09A      		sbi 0x18,0
 497:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 497 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 498:setup.c       **** }
 499:setup.c       **** 
 500:setup.c       **** // Write 8 bytes to the EEPROM address
 501:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 501 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 502:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 502 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 501:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 501 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB145:
 876               	.LBB146:
 503:setup.c       **** 	
 504:setup.c       **** 	// Write 64 bits
 505:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 506:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 507:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 507 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 508:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 508 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 509:setup.c       **** 			}
 510:setup.c       **** 			else {
 511:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 511 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 512:setup.c       **** 			}
 513:setup.c       **** 			
 514:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 514 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 515:setup.c       **** 			asm ("nop");
 899               		.loc 1 515 0 discriminator 2
 900               	/* #APP */
 901               	 ;  515 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 516:setup.c       **** 			asm ("nop");
 904               		.loc 1 516 0 discriminator 2
 905               	 ;  516 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 517:setup.c       **** 			wrPin_high; 
 908               		.loc 1 517 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 518:setup.c       **** 			asm ("nop");
 911               		.loc 1 518 0 discriminator 2
 912               	/* #APP */
 913               	 ;  518 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 519:setup.c       **** 			asm ("nop");
 916               		.loc 1 519 0 discriminator 2
 917               	 ;  519 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE146:
 505:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 505 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE145:
 520:setup.c       **** 		}
 521:setup.c       **** 	}
 522:setup.c       **** 	
 523:setup.c       **** 	// Last bit low
 524:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 524 0
 935 0250 C098      		cbi 0x18,0
 525:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 525 0
 937 0252 9698      		cbi 0x12,6
 526:setup.c       **** 	asm ("nop");
 938               		.loc 1 526 0
 939               	/* #APP */
 940               	 ;  526 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 527:setup.c       **** 	asm ("nop");
 943               		.loc 1 527 0
 944               	 ;  527 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 528:setup.c       **** 	wrPin_high; 
 947               		.loc 1 528 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 529:setup.c       **** 	asm ("nop");
 950               		.loc 1 529 0
 951               	/* #APP */
 952               	 ;  529 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 530:setup.c       **** 	asm ("nop");
 955               		.loc 1 530 0
 956               	 ;  530 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 531:setup.c       **** 	
 532:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 532 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 533:setup.c       **** }
 534:setup.c       **** 
 535:setup.c       **** 
 536:setup.c       **** 
 537:setup.c       **** // ---------- FLASH ----------
 538:setup.c       **** 
 539:setup.c       **** // Set the address and data for the write byte cycle to the flash
 540:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 540 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 541:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 541 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 542:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 542 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 543:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 543 0
 989 026c C5BB      		out 0x15,r28
 544:setup.c       **** 	
 545:setup.c       **** 	wrPin_low;
 990               		.loc 1 545 0
 991 026e 9698      		cbi 0x12,6
 546:setup.c       **** 	cs2Pin_low;
 992               		.loc 1 546 0
 993 0270 3A98      		cbi 0x7,2
 547:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 547 0
 995               	/* #APP */
 996               	 ;  547 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 548:setup.c       **** 	wrPin_high;
 999               		.loc 1 548 0
 1000               	/* #NOAPP */
 1001 0274 969A      		sbi 0x12,6
 549:setup.c       **** 	cs2Pin_high;
 1002               		.loc 1 549 0
 1003 0276 3A9A      		sbi 0x7,2
 1004               	/* epilogue start */
 550:setup.c       **** }
 1005               		.loc 1 550 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 551:setup.c       **** 
 552:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 553:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 553 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 554:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 554 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 555:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 555 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 556:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 556 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB147:
 1049               	.LBB148:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE148:
 1060               	.LBE147:
 557:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 558:setup.c       **** 	
 559:setup.c       **** 	// Set data as inputs
 560:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 560 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 561:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 561 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 562:setup.c       **** 	
 563:setup.c       **** 	// Read and transmit the 2 bytes
 564:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 564 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 565:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 565 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 566:setup.c       **** 	
 567:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 567 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 568:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 568 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 569:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 569 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB149:
 1098               	.LBB150:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE150:
 1109               	.LBE149:
 570:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 571:setup.c       **** }
 1110               		.loc 1 571 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 572:setup.c       **** 
 573:setup.c       **** // Switch banks on the Flash
 574:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 574 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 575:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 575 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 576:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 576 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 577:setup.c       **** 	
 578:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 578 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 579:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 579 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 580:setup.c       **** }
 1157               		.loc 1 580 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 579:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 579 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 581:setup.c       **** 
 582:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 583:setup.c       **** // Takes 25ms after last command to erase sector
 584:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 584 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 585:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 585 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 586:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 586 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 587:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 587 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 588:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 588 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 589:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 589 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 590:setup.c       **** 	
 591:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 591 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB151:
 1222               	.LBB152:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE152:
 1233               	.LBE151:
 592:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 593:setup.c       **** }
 1234               		.loc 1 593 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 594:setup.c       **** 
 595:setup.c       **** // Write a single byte to the Flash address
 596:setup.c       **** // Takes 20us to program Flash
 597:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 597 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 598:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 598 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 599:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 599 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 600:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 600 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 601:setup.c       **** 	
 602:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 602 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB153:
 1292               	.LBB154:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE154:
 1301               	.LBE153:
 603:setup.c       **** 	_delay_us(20); // Wait byte program time
 604:setup.c       **** }
 1302               		.loc 1 604 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 605:setup.c       **** 
 606:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 607:setup.c       **** // Takes 20ms for write cycle
 608:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 608 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 609:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 609 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 610:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 610 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 611:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 611 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB155:
 612:setup.c       **** 	
 613:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 614:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 615:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 615 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 615 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 614:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 614 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE155:
 1400               	.LBB156:
 1401               	.LBB157:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE157:
 1412               	.LBE156:
 616:setup.c       **** 	}
 617:setup.c       **** 	_delay_ms(20); // Wait sector program time
 618:setup.c       **** }
 1413               		.loc 1 618 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 619:setup.c       **** 
 620:setup.c       **** 
 621:setup.c       **** 
 622:setup.c       **** // ---------- GB FLASH CARTS ----------
 623:setup.c       **** 
 624:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 625:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 625 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 626:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 626 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 627:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 627 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 628:setup.c       **** 	
 629:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 629 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 630:setup.c       **** 	
 631:setup.c       **** 	rdPin_low;
 1443               		.loc 1 631 0
 1444 03fe 9598      		cbi 0x12,5
 632:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 632 0
 1446               	/* #APP */
 1447               	 ;  632 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 633:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 633 0
 1451               	 ;  633 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 634:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 634 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 635:setup.c       **** 	rdPin_high;
 1458               		.loc 1 635 0
 1459 0406 959A      		sbi 0x12,5
 636:setup.c       **** 	
 637:setup.c       **** 	return data;
 638:setup.c       **** }
 1460               		.loc 1 638 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_write_bus_cycle
 1467               	gb_flash_write_bus_cycle:
 1468               	.LFB37:
 639:setup.c       **** 
 640:setup.c       **** // Set the address and data for the write byte cycle to the flash
 641:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1469               		.loc 1 641 0
 1470               		.cfi_startproc
 1471               	.LVL116:
 1472 040a CF93      		push r28
 1473               	.LCFI25:
 1474               		.cfi_def_cfa_offset 3
 1475               		.cfi_offset 28, -2
 1476               	/* prologue: function */
 1477               	/* frame size = 0 */
 1478               	/* stack size = 1 */
 1479               	.L__stack_usage = 1
 1480 040c C62F      		mov r28,r22
 642:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1481               		.loc 1 642 0
 1482 040e 2FEF      		ldi r18,lo8(-1)
 1483 0410 24BB      		out 0x14,r18
 643:setup.c       **** 	set_16bit_address(address);
 1484               		.loc 1 643 0
 1485 0412 00D0      		rcall set_16bit_address
 1486               	.LVL117:
 644:setup.c       **** 	PORT_DATA7_0 = data;
 1487               		.loc 1 644 0
 1488 0414 C5BB      		out 0x15,r28
 645:setup.c       **** 	
 646:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1489               		.loc 1 646 0
 1490 0416 8091 0000 		lds r24,flashWriteWePin
 1491 041a 8134      		cpi r24,lo8(65)
 1492 041c 01F4      		brne .L70
 647:setup.c       **** 		audioPin_low; // WE low
 1493               		.loc 1 647 0
 1494 041e 3998      		cbi 0x7,1
 648:setup.c       **** 		asm volatile("nop");
 1495               		.loc 1 648 0
 1496               	/* #APP */
 1497               	 ;  648 "setup.c" 1
 1498 0420 0000      		nop
 1499               	 ;  0 "" 2
 649:setup.c       **** 		asm volatile("nop");
 1500               		.loc 1 649 0
 1501               	 ;  649 "setup.c" 1
 1502 0422 0000      		nop
 1503               	 ;  0 "" 2
 650:setup.c       **** 		asm volatile("nop");
 1504               		.loc 1 650 0
 1505               	 ;  650 "setup.c" 1
 1506 0424 0000      		nop
 1507               	 ;  0 "" 2
 651:setup.c       **** 		audioPin_high; // WE high
 1508               		.loc 1 651 0
 1509               	/* #NOAPP */
 1510 0426 399A      		sbi 0x7,1
 1511 0428 00C0      		rjmp .L71
 1512               	.L70:
 652:setup.c       **** 	}
 653:setup.c       **** 	else { // WR pin
 654:setup.c       **** 		wrPin_low; // WE low
 1513               		.loc 1 654 0
 1514 042a 9698      		cbi 0x12,6
 655:setup.c       **** 		asm volatile("nop");
 1515               		.loc 1 655 0
 1516               	/* #APP */
 1517               	 ;  655 "setup.c" 1
 1518 042c 0000      		nop
 1519               	 ;  0 "" 2
 656:setup.c       **** 		asm volatile("nop");
 1520               		.loc 1 656 0
 1521               	 ;  656 "setup.c" 1
 1522 042e 0000      		nop
 1523               	 ;  0 "" 2
 657:setup.c       **** 		asm volatile("nop");
 1524               		.loc 1 657 0
 1525               	 ;  657 "setup.c" 1
 1526 0430 0000      		nop
 1527               	 ;  0 "" 2
 658:setup.c       **** 		wrPin_high; // WE high
 1528               		.loc 1 658 0
 1529               	/* #NOAPP */
 1530 0432 969A      		sbi 0x12,6
 1531               	.L71:
 659:setup.c       **** 	}
 660:setup.c       **** 	
 661:setup.c       **** 	// Clear data outputs and set data pins as inputs
 662:setup.c       **** 	PORT_DATA7_0 = 0;
 1532               		.loc 1 662 0
 1533 0434 15BA      		out 0x15,__zero_reg__
 663:setup.c       **** 	DDR_DATA7_0 = 0;
 1534               		.loc 1 663 0
 1535 0436 14BA      		out 0x14,__zero_reg__
 1536               	/* epilogue start */
 664:setup.c       **** }
 1537               		.loc 1 664 0
 1538 0438 CF91      		pop r28
 1539               	.LVL118:
 1540 043a 0895      		ret
 1541               		.cfi_endproc
 1542               	.LFE37:
 1544               	.global	gb_flash_write_byte
 1546               	gb_flash_write_byte:
 1547               	.LFB38:
 665:setup.c       **** 
 666:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 667:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1548               		.loc 1 667 0
 1549               		.cfi_startproc
 1550               	.LVL119:
 1551 043c 1F93      		push r17
 1552               	.LCFI26:
 1553               		.cfi_def_cfa_offset 3
 1554               		.cfi_offset 17, -2
 1555 043e CF93      		push r28
 1556               	.LCFI27:
 1557               		.cfi_def_cfa_offset 4
 1558               		.cfi_offset 28, -3
 1559 0440 DF93      		push r29
 1560               	.LCFI28:
 1561               		.cfi_def_cfa_offset 5
 1562               		.cfi_offset 29, -4
 1563               	/* prologue: function */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 3 */
 1566               	.L__stack_usage = 3
 1567 0442 EC01      		movw r28,r24
 1568 0444 162F      		mov r17,r22
 668:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1569               		.loc 1 668 0
 1570 0446 6091 0000 		lds r22,flashWriteCycle+2
 1571               	.LVL120:
 1572 044a 8091 0000 		lds r24,flashWriteCycle
 1573 044e 9091 0000 		lds r25,flashWriteCycle+1
 1574               	.LVL121:
 1575 0452 00D0      		rcall gb_flash_write_bus_cycle
 1576               	.LVL122:
 669:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1577               		.loc 1 669 0
 1578 0454 6091 0000 		lds r22,flashWriteCycle+6
 1579 0458 8091 0000 		lds r24,flashWriteCycle+4
 1580 045c 9091 0000 		lds r25,flashWriteCycle+4+1
 1581 0460 00D0      		rcall gb_flash_write_bus_cycle
 1582               	.LVL123:
 670:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1583               		.loc 1 670 0
 1584 0462 6091 0000 		lds r22,flashWriteCycle+10
 1585 0466 8091 0000 		lds r24,flashWriteCycle+8
 1586 046a 9091 0000 		lds r25,flashWriteCycle+8+1
 1587 046e 00D0      		rcall gb_flash_write_bus_cycle
 1588               	.LVL124:
 671:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1589               		.loc 1 671 0
 1590 0470 612F      		mov r22,r17
 1591 0472 CE01      		movw r24,r28
 1592 0474 00D0      		rcall gb_flash_write_bus_cycle
 1593               	.LVL125:
 1594               	.LBB158:
 1595               	.LBB159:
 1596               		.loc 2 276 0
 1597 0476 8AE1      		ldi r24,lo8(26)
 1598 0478 8A95      	1:	dec r24
 1599 047a 01F4      		brne 1b
 1600 047c 00C0      		rjmp .
 1601               	.LVL126:
 1602               	.LBE159:
 1603               	.LBE158:
 672:setup.c       **** 	_delay_us(10); // Wait byte program time
 673:setup.c       **** 	
 674:setup.c       **** 	// Set data pins inputs
 675:setup.c       **** 	PORT_DATA7_0 = 0;
 1604               		.loc 1 675 0
 1605 047e 15BA      		out 0x15,__zero_reg__
 676:setup.c       **** 	DDR_DATA7_0 = 0;
 1606               		.loc 1 676 0
 1607 0480 14BA      		out 0x14,__zero_reg__
 677:setup.c       **** 	
 678:setup.c       **** 	// Verify data
 679:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1608               		.loc 1 679 0
 1609 0482 CE01      		movw r24,r28
 1610 0484 00D0      		rcall gb_flash_read_byte
 1611               	.LVL127:
 1612               	.L73:
 680:setup.c       **** 	while (data != dataVerify) {
 1613               		.loc 1 680 0
 1614 0486 8117      		cp r24,r17
 1615 0488 01F0      		breq .L75
 681:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1616               		.loc 1 681 0
 1617 048a CE01      		movw r24,r28
 1618               	.LVL128:
 1619 048c 00D0      		rcall gb_flash_read_byte
 1620               	.LVL129:
 1621               	.LBB160:
 1622               	.LBB161:
 1623               		.loc 2 276 0
 1624 048e 9DE0      		ldi r25,lo8(13)
 1625 0490 9A95      	1:	dec r25
 1626 0492 01F4      		brne 1b
 1627 0494 0000      		nop
 1628 0496 00C0      		rjmp .L73
 1629               	.LVL130:
 1630               	.L75:
 1631               	/* epilogue start */
 1632               	.LBE161:
 1633               	.LBE160:
 682:setup.c       **** 		_delay_us(5);
 683:setup.c       **** 	}
 684:setup.c       **** }
 1634               		.loc 1 684 0
 1635 0498 DF91      		pop r29
 1636 049a CF91      		pop r28
 1637               	.LVL131:
 1638 049c 1F91      		pop r17
 1639               	.LVL132:
 1640 049e 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE38:
 1644               	.global	gb_flash_write_byte_special
 1646               	gb_flash_write_byte_special:
 1647               	.LFB39:
 685:setup.c       **** 
 686:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 687:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1648               		.loc 1 687 0
 1649               		.cfi_startproc
 1650               	.LVL133:
 1651 04a0 1F93      		push r17
 1652               	.LCFI29:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 17, -2
 1655 04a2 CF93      		push r28
 1656               	.LCFI30:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 28, -3
 1659 04a4 DF93      		push r29
 1660               	.LCFI31:
 1661               		.cfi_def_cfa_offset 5
 1662               		.cfi_offset 29, -4
 1663               	/* prologue: function */
 1664               	/* frame size = 0 */
 1665               	/* stack size = 3 */
 1666               	.L__stack_usage = 3
 1667 04a6 EC01      		movw r28,r24
 1668 04a8 162F      		mov r17,r22
 688:setup.c       **** 	// Set bank back
 689:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1669               		.loc 1 689 0
 1670 04aa 8091 0000 		lds r24,flashBank1CommandWrites
 1671               	.LVL134:
 1672 04ae 8130      		cpi r24,lo8(1)
 1673 04b0 01F4      		brne .L77
 690:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1674               		.loc 1 690 0
 1675 04b2 40E0      		ldi r20,0
 1676 04b4 6091 0000 		lds r22,lastBankAccessed
 1677               	.LVL135:
 1678 04b8 80E0      		ldi r24,0
 1679 04ba 91E2      		ldi r25,lo8(33)
 1680 04bc 00D0      		rcall write_8bit_data
 1681               	.LVL136:
 1682               	.LBB162:
 1683               	.LBB163:
 1684               		.loc 2 276 0
 1685 04be 85E8      		ldi r24,lo8(-123)
 1686 04c0 8A95      	1:	dec r24
 1687 04c2 01F4      		brne 1b
 1688 04c4 0000      		nop
 1689               	.LVL137:
 1690               	.L77:
 1691               	.LBE163:
 1692               	.LBE162:
 691:setup.c       **** 		_delay_us(50);
 692:setup.c       **** 	}
 693:setup.c       **** 	
 694:setup.c       **** 	// Write
 695:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1693               		.loc 1 695 0
 1694 04c6 6091 0000 		lds r22,flashWriteCycle+2
 1695 04ca 8091 0000 		lds r24,flashWriteCycle
 1696 04ce 9091 0000 		lds r25,flashWriteCycle+1
 1697 04d2 00D0      		rcall gb_flash_write_bus_cycle
 1698               	.LVL138:
 696:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1699               		.loc 1 696 0
 1700 04d4 6091 0000 		lds r22,flashWriteCycle+6
 1701 04d8 8091 0000 		lds r24,flashWriteCycle+4
 1702 04dc 9091 0000 		lds r25,flashWriteCycle+4+1
 1703 04e0 00D0      		rcall gb_flash_write_bus_cycle
 1704               	.LVL139:
 697:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1705               		.loc 1 697 0
 1706 04e2 6091 0000 		lds r22,flashWriteCycle+10
 1707 04e6 8091 0000 		lds r24,flashWriteCycle+8
 1708 04ea 9091 0000 		lds r25,flashWriteCycle+8+1
 1709 04ee 00D0      		rcall gb_flash_write_bus_cycle
 1710               	.LVL140:
 698:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1711               		.loc 1 698 0
 1712 04f0 612F      		mov r22,r17
 1713 04f2 CE01      		movw r24,r28
 1714 04f4 00D0      		rcall gb_flash_write_bus_cycle
 1715               	.LVL141:
 1716               	.LBB164:
 1717               	.LBB165:
 1718               		.loc 2 276 0
 1719 04f6 83EF      		ldi r24,lo8(499)
 1720 04f8 91E0      		ldi r25,hi8(499)
 1721 04fa 0197      	1:	sbiw r24,1
 1722 04fc 01F4      		brne 1b
 1723 04fe 00C0      		rjmp .
 1724 0500 0000      		nop
 1725               	.LVL142:
 1726               	.LBE165:
 1727               	.LBE164:
 699:setup.c       **** 	_delay_us(250); // Wait byte program time
 700:setup.c       **** 	
 701:setup.c       **** 	// Set data pins inputs
 702:setup.c       **** 	PORT_DATA7_0 = 0;
 1728               		.loc 1 702 0
 1729 0502 15BA      		out 0x15,__zero_reg__
 703:setup.c       **** 	DDR_DATA7_0 = 0;
 1730               		.loc 1 703 0
 1731 0504 14BA      		out 0x14,__zero_reg__
 704:setup.c       **** 	
 705:setup.c       **** 	// Pulse reset
 706:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1732               		.loc 1 706 0
 1733 0506 3A98      		cbi 0x7,2
 1734               	.LVL143:
 1735               	.LBB166:
 1736               	.LBB167:
 1737               		.loc 2 276 0
 1738 0508 95E8      		ldi r25,lo8(-123)
 1739 050a 9A95      	1:	dec r25
 1740 050c 01F4      		brne 1b
 1741 050e 0000      		nop
 1742               	.LVL144:
 1743               	.LBE167:
 1744               	.LBE166:
 707:setup.c       **** 	_delay_us(50);
 708:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1745               		.loc 1 708 0
 1746 0510 3A9A      		sbi 0x7,2
 1747               	.LVL145:
 1748               	.LBB168:
 1749               	.LBB169:
 1750               		.loc 2 276 0
 1751 0512 85E8      		ldi r24,lo8(-123)
 1752 0514 8A95      	1:	dec r24
 1753 0516 01F4      		brne 1b
 1754 0518 0000      		nop
 1755               	.LVL146:
 1756               	/* epilogue start */
 1757               	.LBE169:
 1758               	.LBE168:
 709:setup.c       **** 	_delay_us(50);
 710:setup.c       **** }
 1759               		.loc 1 710 0
 1760 051a DF91      		pop r29
 1761 051c CF91      		pop r28
 1762               	.LVL147:
 1763 051e 1F91      		pop r17
 1764               	.LVL148:
 1765 0520 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE39:
 1769               	.global	gb_flash_write_byte_bank1_commands
 1771               	gb_flash_write_byte_bank1_commands:
 1772               	.LFB40:
 711:setup.c       **** 
 712:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 713:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 714:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1773               		.loc 1 714 0
 1774               		.cfi_startproc
 1775               	.LVL149:
 1776 0522 FF92      		push r15
 1777               	.LCFI32:
 1778               		.cfi_def_cfa_offset 3
 1779               		.cfi_offset 15, -2
 1780 0524 0F93      		push r16
 1781               	.LCFI33:
 1782               		.cfi_def_cfa_offset 4
 1783               		.cfi_offset 16, -3
 1784 0526 1F93      		push r17
 1785               	.LCFI34:
 1786               		.cfi_def_cfa_offset 5
 1787               		.cfi_offset 17, -4
 1788 0528 CF93      		push r28
 1789               	.LCFI35:
 1790               		.cfi_def_cfa_offset 6
 1791               		.cfi_offset 28, -5
 1792 052a DF93      		push r29
 1793               	.LCFI36:
 1794               		.cfi_def_cfa_offset 7
 1795               		.cfi_offset 29, -6
 1796               	/* prologue: function */
 1797               	/* frame size = 0 */
 1798               	/* stack size = 5 */
 1799               	.L__stack_usage = 5
 1800 052c EC01      		movw r28,r24
 1801 052e 162F      		mov r17,r22
 715:setup.c       **** 	// Set bank 1
 716:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1802               		.loc 1 716 0
 1803 0530 FF24      		clr r15
 1804 0532 FA94      		dec r15
 1805 0534 F4BA      		out 0x14,r15
 1806               	.LVL150:
 1807               	.LBB170:
 1808               	.LBB171:
 246:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1809               		.loc 1 246 0
 1810 0536 01E2      		ldi r16,lo8(33)
 1811 0538 0BBB      		out 0x1b,r16
 247:setup.c       **** }
 1812               		.loc 1 247 0
 1813 053a 18BA      		out 0x18,__zero_reg__
 1814               	.LVL151:
 1815               	.LBE171:
 1816               	.LBE170:
 717:setup.c       **** 	set_16bit_address(0x2100);
 718:setup.c       **** 	PORT_DATA7_0 = 1;
 1817               		.loc 1 718 0
 1818 053c 81E0      		ldi r24,lo8(1)
 1819               	.LVL152:
 1820 053e 85BB      		out 0x15,r24
 719:setup.c       **** 	wrPin_low; // Pulse WR
 1821               		.loc 1 719 0
 1822 0540 9698      		cbi 0x12,6
 720:setup.c       **** 	asm volatile("nop");
 1823               		.loc 1 720 0
 1824               	/* #APP */
 1825               	 ;  720 "setup.c" 1
 1826 0542 0000      		nop
 1827               	 ;  0 "" 2
 721:setup.c       **** 	wrPin_high;
 1828               		.loc 1 721 0
 1829               	/* #NOAPP */
 1830 0544 969A      		sbi 0x12,6
 722:setup.c       **** 	
 723:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1831               		.loc 1 723 0
 1832 0546 6091 0000 		lds r22,flashWriteCycle+2
 1833               	.LVL153:
 1834 054a 8091 0000 		lds r24,flashWriteCycle
 1835 054e 9091 0000 		lds r25,flashWriteCycle+1
 1836 0552 00D0      		rcall gb_flash_write_bus_cycle
 1837               	.LVL154:
 724:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1838               		.loc 1 724 0
 1839 0554 6091 0000 		lds r22,flashWriteCycle+6
 1840 0558 8091 0000 		lds r24,flashWriteCycle+4
 1841 055c 9091 0000 		lds r25,flashWriteCycle+4+1
 1842 0560 00D0      		rcall gb_flash_write_bus_cycle
 1843               	.LVL155:
 725:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1844               		.loc 1 725 0
 1845 0562 6091 0000 		lds r22,flashWriteCycle+10
 1846 0566 8091 0000 		lds r24,flashWriteCycle+8
 1847 056a 9091 0000 		lds r25,flashWriteCycle+8+1
 1848 056e 00D0      		rcall gb_flash_write_bus_cycle
 1849               	.LVL156:
 726:setup.c       **** 	
 727:setup.c       **** 	
 728:setup.c       **** 	// Set bank back
 729:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1850               		.loc 1 729 0
 1851 0570 F4BA      		out 0x14,r15
 1852               	.LVL157:
 1853               	.LBB172:
 1854               	.LBB173:
 246:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1855               		.loc 1 246 0
 1856 0572 0BBB      		out 0x1b,r16
 247:setup.c       **** }
 1857               		.loc 1 247 0
 1858 0574 18BA      		out 0x18,__zero_reg__
 1859               	.LVL158:
 1860               	.LBE173:
 1861               	.LBE172:
 730:setup.c       **** 	set_16bit_address(0x2100);
 731:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1862               		.loc 1 731 0
 1863 0576 8091 0000 		lds r24,lastBankAccessed
 1864 057a 85BB      		out 0x15,r24
 732:setup.c       **** 	wrPin_low; // Pulse WR
 1865               		.loc 1 732 0
 1866 057c 9698      		cbi 0x12,6
 733:setup.c       **** 	asm volatile("nop");
 1867               		.loc 1 733 0
 1868               	/* #APP */
 1869               	 ;  733 "setup.c" 1
 1870 057e 0000      		nop
 1871               	 ;  0 "" 2
 734:setup.c       **** 	wrPin_high;
 1872               		.loc 1 734 0
 1873               	/* #NOAPP */
 1874 0580 969A      		sbi 0x12,6
 735:setup.c       **** 	
 736:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1875               		.loc 1 736 0
 1876 0582 612F      		mov r22,r17
 1877 0584 CE01      		movw r24,r28
 1878 0586 00D0      		rcall gb_flash_write_bus_cycle
 1879               	.LVL159:
 1880               	.LBB174:
 1881               	.LBB175:
 1882               		.loc 2 276 0
 1883 0588 8AE1      		ldi r24,lo8(26)
 1884 058a 8A95      	1:	dec r24
 1885 058c 01F4      		brne 1b
 1886 058e 00C0      		rjmp .
 1887               	.LVL160:
 1888               	.LBE175:
 1889               	.LBE174:
 737:setup.c       **** 	_delay_us(10); // Wait byte program time
 738:setup.c       **** 	
 739:setup.c       **** 	// Set data pins inputs
 740:setup.c       **** 	PORT_DATA7_0 = 0;
 1890               		.loc 1 740 0
 1891 0590 15BA      		out 0x15,__zero_reg__
 741:setup.c       **** 	DDR_DATA7_0 = 0;
 1892               		.loc 1 741 0
 1893 0592 14BA      		out 0x14,__zero_reg__
 742:setup.c       **** 	
 743:setup.c       **** 	// Verify data
 744:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1894               		.loc 1 744 0
 1895 0594 CE01      		movw r24,r28
 1896 0596 00D0      		rcall gb_flash_read_byte
 1897               	.LVL161:
 1898               	.L79:
 745:setup.c       **** 	while (data != dataVerify) {
 1899               		.loc 1 745 0
 1900 0598 8117      		cp r24,r17
 1901 059a 01F0      		breq .L81
 746:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 1902               		.loc 1 746 0
 1903 059c CE01      		movw r24,r28
 1904               	.LVL162:
 1905 059e 00D0      		rcall gb_flash_read_byte
 1906               	.LVL163:
 1907               	.LBB176:
 1908               	.LBB177:
 1909               		.loc 2 276 0
 1910 05a0 9DE0      		ldi r25,lo8(13)
 1911 05a2 9A95      	1:	dec r25
 1912 05a4 01F4      		brne 1b
 1913 05a6 0000      		nop
 1914 05a8 00C0      		rjmp .L79
 1915               	.LVL164:
 1916               	.L81:
 1917               	/* epilogue start */
 1918               	.LBE177:
 1919               	.LBE176:
 747:setup.c       **** 		_delay_us(5);
 748:setup.c       **** 	}
 749:setup.c       **** }
 1920               		.loc 1 749 0
 1921 05aa DF91      		pop r29
 1922 05ac CF91      		pop r28
 1923               	.LVL165:
 1924 05ae 1F91      		pop r17
 1925               	.LVL166:
 1926 05b0 0F91      		pop r16
 1927 05b2 FF90      		pop r15
 1928 05b4 0895      		ret
 1929               		.cfi_endproc
 1930               	.LFE40:
 1932               	.global	gba_flash_write_bus_cycle
 1934               	gba_flash_write_bus_cycle:
 1935               	.LFB41:
 750:setup.c       **** 
 751:setup.c       **** 
 752:setup.c       **** 
 753:setup.c       **** // ---------- GBA FLASH CARTS ----------
 754:setup.c       **** 
 755:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 756:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 1936               		.loc 1 756 0
 1937               		.cfi_startproc
 1938               	.LVL167:
 1939 05b6 0F93      		push r16
 1940               	.LCFI37:
 1941               		.cfi_def_cfa_offset 3
 1942               		.cfi_offset 16, -2
 1943 05b8 1F93      		push r17
 1944               	.LCFI38:
 1945               		.cfi_def_cfa_offset 4
 1946               		.cfi_offset 17, -3
 1947               	/* prologue: function */
 1948               	/* frame size = 0 */
 1949               	/* stack size = 2 */
 1950               	.L__stack_usage = 2
 757:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 1951               		.loc 1 757 0
 1952 05ba 8C01      		movw r16,r24
 1953 05bc 2227      		clr r18
 1954 05be 3327      		clr r19
 1955 05c0 05BB      		out 0x15,r16
 758:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 1956               		.loc 1 758 0
 1957 05c2 072F      		mov r16,r23
 1958 05c4 182F      		mov r17,r24
 1959 05c6 292F      		mov r18,r25
 1960 05c8 3327      		clr r19
 1961 05ca 0BBB      		out 0x1b,r16
 759:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 1962               		.loc 1 759 0
 1963 05cc 68BB      		out 0x18,r22
 760:setup.c       **** 	
 761:setup.c       **** 	cs_mreqPin_low;
 1964               		.loc 1 761 0
 1965 05ce 9498      		cbi 0x12,4
 762:setup.c       **** 	
 763:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 1966               		.loc 1 763 0
 1967 05d0 5BBB      		out 0x1b,r21
 764:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 1968               		.loc 1 764 0
 1969 05d2 48BB      		out 0x18,r20
 765:setup.c       **** 	
 766:setup.c       **** 	wrPin_low;
 1970               		.loc 1 766 0
 1971 05d4 9698      		cbi 0x12,6
 767:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 767 0
 1973               	/* #APP */
 1974               	 ;  767 "setup.c" 1
 1975 05d6 0000      		nop
 1976               	 ;  0 "" 2
 768:setup.c       **** 	asm volatile("nop");
 1977               		.loc 1 768 0
 1978               	 ;  768 "setup.c" 1
 1979 05d8 0000      		nop
 1980               	 ;  0 "" 2
 769:setup.c       **** 	asm volatile("nop");
 1981               		.loc 1 769 0
 1982               	 ;  769 "setup.c" 1
 1983 05da 0000      		nop
 1984               	 ;  0 "" 2
 770:setup.c       **** 	wrPin_high;
 1985               		.loc 1 770 0
 1986               	/* #NOAPP */
 1987 05dc 969A      		sbi 0x12,6
 771:setup.c       **** 	cs_mreqPin_high;
 1988               		.loc 1 771 0
 1989 05de 949A      		sbi 0x12,4
 1990               	/* epilogue start */
 772:setup.c       **** }
 1991               		.loc 1 772 0
 1992 05e0 1F91      		pop r17
 1993 05e2 0F91      		pop r16
 1994 05e4 0895      		ret
 1995               		.cfi_endproc
 1996               	.LFE41:
 1998               	.global	gba_flash_write_cycle_start_swapped
 2000               	gba_flash_write_cycle_start_swapped:
 2001               	.LFB42:
 773:setup.c       **** 
 774:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 775:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2002               		.loc 1 775 0
 2003               		.cfi_startproc
 2004               	/* prologue: function */
 2005               	/* frame size = 0 */
 2006               	/* stack size = 0 */
 2007               	.L__stack_usage = 0
 776:setup.c       **** 	// Set outputs
 777:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2008               		.loc 1 777 0
 2009 05e6 8FEF      		ldi r24,lo8(-1)
 2010 05e8 84BB      		out 0x14,r24
 778:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2011               		.loc 1 778 0
 2012 05ea 8ABB      		out 0x1a,r24
 779:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2013               		.loc 1 779 0
 2014 05ec 87BB      		out 0x17,r24
 780:setup.c       **** 	
 781:setup.c       **** 	// 0x555, 0xA9
 782:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2015               		.loc 1 782 0
 2016 05ee 15BA      		out 0x15,__zero_reg__
 783:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2017               		.loc 1 783 0
 2018 05f0 95E0      		ldi r25,lo8(5)
 2019 05f2 9BBB      		out 0x1b,r25
 784:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2020               		.loc 1 784 0
 2021 05f4 85E5      		ldi r24,lo8(85)
 2022 05f6 88BB      		out 0x18,r24
 785:setup.c       **** 	cs_mreqPin_low;
 2023               		.loc 1 785 0
 2024 05f8 9498      		cbi 0x12,4
 786:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2025               		.loc 1 786 0
 2026 05fa 1BBA      		out 0x1b,__zero_reg__
 787:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2027               		.loc 1 787 0
 2028 05fc 29EA      		ldi r18,lo8(-87)
 2029 05fe 28BB      		out 0x18,r18
 788:setup.c       **** 	wrPin_low;
 2030               		.loc 1 788 0
 2031 0600 9698      		cbi 0x12,6
 789:setup.c       **** 	asm volatile("nop");
 2032               		.loc 1 789 0
 2033               	/* #APP */
 2034               	 ;  789 "setup.c" 1
 2035 0602 0000      		nop
 2036               	 ;  0 "" 2
 790:setup.c       **** 	asm volatile("nop");
 2037               		.loc 1 790 0
 2038               	 ;  790 "setup.c" 1
 2039 0604 0000      		nop
 2040               	 ;  0 "" 2
 791:setup.c       **** 	asm volatile("nop");
 2041               		.loc 1 791 0
 2042               	 ;  791 "setup.c" 1
 2043 0606 0000      		nop
 2044               	 ;  0 "" 2
 792:setup.c       **** 	wrPin_high;
 2045               		.loc 1 792 0
 2046               	/* #NOAPP */
 2047 0608 969A      		sbi 0x12,6
 793:setup.c       **** 	cs_mreqPin_high;
 2048               		.loc 1 793 0
 2049 060a 949A      		sbi 0x12,4
 794:setup.c       **** 	
 795:setup.c       **** 	// 0x2AA, 0x56
 796:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2050               		.loc 1 796 0
 2051 060c 15BA      		out 0x15,__zero_reg__
 797:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2052               		.loc 1 797 0
 2053 060e 22E0      		ldi r18,lo8(2)
 2054 0610 2BBB      		out 0x1b,r18
 798:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2055               		.loc 1 798 0
 2056 0612 2AEA      		ldi r18,lo8(-86)
 2057 0614 28BB      		out 0x18,r18
 799:setup.c       **** 	cs_mreqPin_low;
 2058               		.loc 1 799 0
 2059 0616 9498      		cbi 0x12,4
 800:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2060               		.loc 1 800 0
 2061 0618 1BBA      		out 0x1b,__zero_reg__
 801:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2062               		.loc 1 801 0
 2063 061a 26E5      		ldi r18,lo8(86)
 2064 061c 28BB      		out 0x18,r18
 802:setup.c       **** 	wrPin_low;
 2065               		.loc 1 802 0
 2066 061e 9698      		cbi 0x12,6
 803:setup.c       **** 	asm volatile("nop");
 2067               		.loc 1 803 0
 2068               	/* #APP */
 2069               	 ;  803 "setup.c" 1
 2070 0620 0000      		nop
 2071               	 ;  0 "" 2
 804:setup.c       **** 	asm volatile("nop");
 2072               		.loc 1 804 0
 2073               	 ;  804 "setup.c" 1
 2074 0622 0000      		nop
 2075               	 ;  0 "" 2
 805:setup.c       **** 	asm volatile("nop");
 2076               		.loc 1 805 0
 2077               	 ;  805 "setup.c" 1
 2078 0624 0000      		nop
 2079               	 ;  0 "" 2
 806:setup.c       **** 	wrPin_high;
 2080               		.loc 1 806 0
 2081               	/* #NOAPP */
 2082 0626 969A      		sbi 0x12,6
 807:setup.c       **** 	cs_mreqPin_high;
 2083               		.loc 1 807 0
 2084 0628 949A      		sbi 0x12,4
 808:setup.c       **** 	
 809:setup.c       **** 	// 0x555, 0xA0;
 810:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2085               		.loc 1 810 0
 2086 062a 15BA      		out 0x15,__zero_reg__
 811:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2087               		.loc 1 811 0
 2088 062c 9BBB      		out 0x1b,r25
 812:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2089               		.loc 1 812 0
 2090 062e 88BB      		out 0x18,r24
 813:setup.c       **** 	cs_mreqPin_low;
 2091               		.loc 1 813 0
 2092 0630 9498      		cbi 0x12,4
 814:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2093               		.loc 1 814 0
 2094 0632 1BBA      		out 0x1b,__zero_reg__
 815:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2095               		.loc 1 815 0
 2096 0634 80EA      		ldi r24,lo8(-96)
 2097 0636 88BB      		out 0x18,r24
 816:setup.c       **** 	wrPin_low;
 2098               		.loc 1 816 0
 2099 0638 9698      		cbi 0x12,6
 817:setup.c       **** 	asm volatile("nop");
 2100               		.loc 1 817 0
 2101               	/* #APP */
 2102               	 ;  817 "setup.c" 1
 2103 063a 0000      		nop
 2104               	 ;  0 "" 2
 818:setup.c       **** 	asm volatile("nop");
 2105               		.loc 1 818 0
 2106               	 ;  818 "setup.c" 1
 2107 063c 0000      		nop
 2108               	 ;  0 "" 2
 819:setup.c       **** 	asm volatile("nop");
 2109               		.loc 1 819 0
 2110               	 ;  819 "setup.c" 1
 2111 063e 0000      		nop
 2112               	 ;  0 "" 2
 820:setup.c       **** 	wrPin_high;
 2113               		.loc 1 820 0
 2114               	/* #NOAPP */
 2115 0640 969A      		sbi 0x12,6
 821:setup.c       **** 	cs_mreqPin_high;
 2116               		.loc 1 821 0
 2117 0642 949A      		sbi 0x12,4
 2118 0644 0895      		ret
 2119               		.cfi_endproc
 2120               	.LFE42:
 2122               	.global	gba_flash_write_cycle_start
 2124               	gba_flash_write_cycle_start:
 2125               	.LFB43:
 822:setup.c       **** }
 823:setup.c       **** 
 824:setup.c       **** 
 825:setup.c       **** // Send the first 3 write cycles to the flash
 826:setup.c       **** void gba_flash_write_cycle_start(void) {
 2126               		.loc 1 826 0
 2127               		.cfi_startproc
 2128               	/* prologue: function */
 2129               	/* frame size = 0 */
 2130               	/* stack size = 0 */
 2131               	.L__stack_usage = 0
 827:setup.c       **** 	// Set outputs
 828:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2132               		.loc 1 828 0
 2133 0646 8FEF      		ldi r24,lo8(-1)
 2134 0648 84BB      		out 0x14,r24
 829:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2135               		.loc 1 829 0
 2136 064a 8ABB      		out 0x1a,r24
 830:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2137               		.loc 1 830 0
 2138 064c 87BB      		out 0x17,r24
 831:setup.c       **** 	
 832:setup.c       **** 	// 0x555, 0xAA
 833:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2139               		.loc 1 833 0
 2140 064e 15BA      		out 0x15,__zero_reg__
 834:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2141               		.loc 1 834 0
 2142 0650 95E0      		ldi r25,lo8(5)
 2143 0652 9BBB      		out 0x1b,r25
 835:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2144               		.loc 1 835 0
 2145 0654 85E5      		ldi r24,lo8(85)
 2146 0656 88BB      		out 0x18,r24
 836:setup.c       **** 	cs_mreqPin_low;
 2147               		.loc 1 836 0
 2148 0658 9498      		cbi 0x12,4
 837:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2149               		.loc 1 837 0
 2150 065a 1BBA      		out 0x1b,__zero_reg__
 838:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2151               		.loc 1 838 0
 2152 065c 2AEA      		ldi r18,lo8(-86)
 2153 065e 28BB      		out 0x18,r18
 839:setup.c       **** 	wrPin_low;
 2154               		.loc 1 839 0
 2155 0660 9698      		cbi 0x12,6
 840:setup.c       **** 	asm volatile("nop");
 2156               		.loc 1 840 0
 2157               	/* #APP */
 2158               	 ;  840 "setup.c" 1
 2159 0662 0000      		nop
 2160               	 ;  0 "" 2
 841:setup.c       **** 	asm volatile("nop");
 2161               		.loc 1 841 0
 2162               	 ;  841 "setup.c" 1
 2163 0664 0000      		nop
 2164               	 ;  0 "" 2
 842:setup.c       **** 	asm volatile("nop");
 2165               		.loc 1 842 0
 2166               	 ;  842 "setup.c" 1
 2167 0666 0000      		nop
 2168               	 ;  0 "" 2
 843:setup.c       **** 	wrPin_high;
 2169               		.loc 1 843 0
 2170               	/* #NOAPP */
 2171 0668 969A      		sbi 0x12,6
 844:setup.c       **** 	cs_mreqPin_high;
 2172               		.loc 1 844 0
 2173 066a 949A      		sbi 0x12,4
 845:setup.c       **** 	
 846:setup.c       **** 	// 0x2AA, 0x55
 847:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2174               		.loc 1 847 0
 2175 066c 15BA      		out 0x15,__zero_reg__
 848:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2176               		.loc 1 848 0
 2177 066e 32E0      		ldi r19,lo8(2)
 2178 0670 3BBB      		out 0x1b,r19
 849:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2179               		.loc 1 849 0
 2180 0672 28BB      		out 0x18,r18
 850:setup.c       **** 	cs_mreqPin_low;
 2181               		.loc 1 850 0
 2182 0674 9498      		cbi 0x12,4
 851:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2183               		.loc 1 851 0
 2184 0676 1BBA      		out 0x1b,__zero_reg__
 852:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2185               		.loc 1 852 0
 2186 0678 88BB      		out 0x18,r24
 853:setup.c       **** 	wrPin_low;
 2187               		.loc 1 853 0
 2188 067a 9698      		cbi 0x12,6
 854:setup.c       **** 	asm volatile("nop");
 2189               		.loc 1 854 0
 2190               	/* #APP */
 2191               	 ;  854 "setup.c" 1
 2192 067c 0000      		nop
 2193               	 ;  0 "" 2
 855:setup.c       **** 	asm volatile("nop");
 2194               		.loc 1 855 0
 2195               	 ;  855 "setup.c" 1
 2196 067e 0000      		nop
 2197               	 ;  0 "" 2
 856:setup.c       **** 	asm volatile("nop");
 2198               		.loc 1 856 0
 2199               	 ;  856 "setup.c" 1
 2200 0680 0000      		nop
 2201               	 ;  0 "" 2
 857:setup.c       **** 	wrPin_high;
 2202               		.loc 1 857 0
 2203               	/* #NOAPP */
 2204 0682 969A      		sbi 0x12,6
 858:setup.c       **** 	cs_mreqPin_high;
 2205               		.loc 1 858 0
 2206 0684 949A      		sbi 0x12,4
 859:setup.c       **** 	
 860:setup.c       **** 	// 0x555, 0xA0;
 861:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2207               		.loc 1 861 0
 2208 0686 15BA      		out 0x15,__zero_reg__
 862:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2209               		.loc 1 862 0
 2210 0688 9BBB      		out 0x1b,r25
 863:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2211               		.loc 1 863 0
 2212 068a 88BB      		out 0x18,r24
 864:setup.c       **** 	cs_mreqPin_low;
 2213               		.loc 1 864 0
 2214 068c 9498      		cbi 0x12,4
 865:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2215               		.loc 1 865 0
 2216 068e 1BBA      		out 0x1b,__zero_reg__
 866:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2217               		.loc 1 866 0
 2218 0690 80EA      		ldi r24,lo8(-96)
 2219 0692 88BB      		out 0x18,r24
 867:setup.c       **** 	wrPin_low;
 2220               		.loc 1 867 0
 2221 0694 9698      		cbi 0x12,6
 868:setup.c       **** 	asm volatile("nop");
 2222               		.loc 1 868 0
 2223               	/* #APP */
 2224               	 ;  868 "setup.c" 1
 2225 0696 0000      		nop
 2226               	 ;  0 "" 2
 869:setup.c       **** 	asm volatile("nop");
 2227               		.loc 1 869 0
 2228               	 ;  869 "setup.c" 1
 2229 0698 0000      		nop
 2230               	 ;  0 "" 2
 870:setup.c       **** 	asm volatile("nop");
 2231               		.loc 1 870 0
 2232               	 ;  870 "setup.c" 1
 2233 069a 0000      		nop
 2234               	 ;  0 "" 2
 871:setup.c       **** 	wrPin_high;
 2235               		.loc 1 871 0
 2236               	/* #NOAPP */
 2237 069c 969A      		sbi 0x12,6
 872:setup.c       **** 	cs_mreqPin_high;
 2238               		.loc 1 872 0
 2239 069e 949A      		sbi 0x12,4
 2240 06a0 0895      		ret
 2241               		.cfi_endproc
 2242               	.LFE43:
 2244               	.global	gba_flash_write_byte
 2246               	gba_flash_write_byte:
 2247               	.LFB44:
 873:setup.c       **** }	
 874:setup.c       **** 
 875:setup.c       **** 
 876:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 877:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 878:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2248               		.loc 1 878 0
 2249               		.cfi_startproc
 2250               	.LVL168:
 2251 06a2 CF92      		push r12
 2252               	.LCFI39:
 2253               		.cfi_def_cfa_offset 3
 2254               		.cfi_offset 12, -2
 2255 06a4 DF92      		push r13
 2256               	.LCFI40:
 2257               		.cfi_def_cfa_offset 4
 2258               		.cfi_offset 13, -3
 2259 06a6 EF92      		push r14
 2260               	.LCFI41:
 2261               		.cfi_def_cfa_offset 5
 2262               		.cfi_offset 14, -4
 2263 06a8 FF92      		push r15
 2264               	.LCFI42:
 2265               		.cfi_def_cfa_offset 6
 2266               		.cfi_offset 15, -5
 2267 06aa CF93      		push r28
 2268               	.LCFI43:
 2269               		.cfi_def_cfa_offset 7
 2270               		.cfi_offset 28, -6
 2271 06ac DF93      		push r29
 2272               	.LCFI44:
 2273               		.cfi_def_cfa_offset 8
 2274               		.cfi_offset 29, -7
 2275               	/* prologue: function */
 2276               	/* frame size = 0 */
 2277               	/* stack size = 6 */
 2278               	.L__stack_usage = 6
 2279 06ae 6B01      		movw r12,r22
 2280 06b0 7C01      		movw r14,r24
 2281 06b2 EA01      		movw r28,r20
 879:setup.c       **** 	if (isD0D1Swapped == 0) {
 2282               		.loc 1 879 0
 2283 06b4 2111      		cpse r18,__zero_reg__
 2284 06b6 00C0      		rjmp .L86
 880:setup.c       **** 		gba_flash_write_cycle_start();
 2285               		.loc 1 880 0
 2286 06b8 00D0      		rcall gba_flash_write_cycle_start
 2287               	.LVL169:
 2288 06ba 00C0      		rjmp .L87
 2289               	.LVL170:
 2290               	.L86:
 881:setup.c       **** 	}
 882:setup.c       **** 	else {
 883:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2291               		.loc 1 883 0
 2292 06bc 00D0      		rcall gba_flash_write_cycle_start_swapped
 2293               	.LVL171:
 2294               	.L87:
 884:setup.c       **** 	}
 885:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2295               		.loc 1 885 0
 2296 06be AE01      		movw r20,r28
 2297 06c0 C701      		movw r24,r14
 2298 06c2 B601      		movw r22,r12
 2299 06c4 00D0      		rcall gba_flash_write_bus_cycle
 2300               	.LVL172:
 2301               	.LBB178:
 2302               	.LBB179:
 2303               		.loc 2 276 0
 2304 06c6 25E0      		ldi r18,lo8(5)
 2305 06c8 2A95      	1:	dec r18
 2306 06ca 01F4      		brne 1b
 2307 06cc 0000      		nop
 2308               	.LVL173:
 2309               	.LBE179:
 2310               	.LBE178:
 886:setup.c       **** 	_delay_us(2); // Wait byte program time
 887:setup.c       **** 	
 888:setup.c       **** 	// Verify data
 889:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2311               		.loc 1 889 0
 2312 06ce C701      		movw r24,r14
 2313 06d0 B601      		movw r22,r12
 2314 06d2 00D0      		rcall gba_read_16bit_data
 2315               	.LVL174:
 2316               	.L88:
 890:setup.c       **** 	while (data != dataVerify) {
 2317               		.loc 1 890 0
 2318 06d4 8C17      		cp r24,r28
 2319 06d6 9D07      		cpc r25,r29
 2320 06d8 01F0      		breq .L90
 891:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2321               		.loc 1 891 0
 2322 06da C701      		movw r24,r14
 2323 06dc B601      		movw r22,r12
 2324 06de 00D0      		rcall gba_read_16bit_data
 2325               	.LVL175:
 2326               	.LBB180:
 2327               	.LBB181:
 2328               		.loc 2 276 0
 2329 06e0 25E0      		ldi r18,lo8(5)
 2330 06e2 2A95      	1:	dec r18
 2331 06e4 01F4      		brne 1b
 2332 06e6 0000      		nop
 2333 06e8 00C0      		rjmp .L88
 2334               	.LVL176:
 2335               	.L90:
 2336               	/* epilogue start */
 2337               	.LBE181:
 2338               	.LBE180:
 892:setup.c       **** 		_delay_us(2);
 893:setup.c       **** 	}
 894:setup.c       **** }
 2339               		.loc 1 894 0
 2340 06ea DF91      		pop r29
 2341 06ec CF91      		pop r28
 2342               	.LVL177:
 2343 06ee FF90      		pop r15
 2344 06f0 EF90      		pop r14
 2345 06f2 DF90      		pop r13
 2346 06f4 CF90      		pop r12
 2347               	.LVL178:
 2348 06f6 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE44:
 2352               	.global	setup
 2354               	setup:
 2355               	.LFB45:
 895:setup.c       **** 
 896:setup.c       **** 
 897:setup.c       **** // Setup
 898:setup.c       **** void setup(void) {
 2356               		.loc 1 898 0
 2357               		.cfi_startproc
 2358               	/* prologue: function */
 2359               	/* frame size = 0 */
 2360               	/* stack size = 0 */
 2361               	.L__stack_usage = 0
 899:setup.c       **** 	// Turn off watchdog
 900:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2362               		.loc 1 900 0
 2363 06f8 84B7      		in r24,0x34
 2364 06fa 877F      		andi r24,lo8(-9)
 2365 06fc 84BF      		out 0x34,r24
 901:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2366               		.loc 1 901 0
 2367 06fe 88E1      		ldi r24,lo8(24)
 2368 0700 81BD      		out 0x21,r24
 902:setup.c       **** 	WDTCR = 0;
 2369               		.loc 1 902 0
 2370 0702 11BC      		out 0x21,__zero_reg__
 903:setup.c       **** 	
 904:setup.c       **** 	// Reset common lines
 905:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2371               		.loc 1 905 0
 2372 0704 00D0      		rcall rd_wr_csmreq_cs2_reset
 2373               	.LVL179:
 906:setup.c       **** 	
 907:setup.c       **** 	// Set outputs
 908:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2374               		.loc 1 908 0
 2375 0706 81B3      		in r24,0x11
 2376 0708 886F      		ori r24,lo8(-8)
 2377 070a 81BB      		out 0x11,r24
 909:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2378               		.loc 1 909 0
 2379 070c 86B1      		in r24,0x6
 2380 070e 8560      		ori r24,lo8(5)
 2381 0710 86B9      		out 0x6,r24
 910:setup.c       **** 	
 911:setup.c       **** 	// Set all pins as inputs
 912:setup.c       **** 	PORT_DATA7_0 = 0;
 2382               		.loc 1 912 0
 2383 0712 15BA      		out 0x15,__zero_reg__
 913:setup.c       **** 	DDR_DATA7_0 = 0;
 2384               		.loc 1 913 0
 2385 0714 14BA      		out 0x14,__zero_reg__
 914:setup.c       **** 	PORT_ADDR7_0 = 0;
 2386               		.loc 1 914 0
 2387 0716 18BA      		out 0x18,__zero_reg__
 915:setup.c       **** 	DDR_ADDR7_0 = 0;
 2388               		.loc 1 915 0
 2389 0718 17BA      		out 0x17,__zero_reg__
 916:setup.c       **** 	PORT_ADDR15_8 = 0;
 2390               		.loc 1 916 0
 2391 071a 1BBA      		out 0x1b,__zero_reg__
 917:setup.c       **** 	DDR_ADDR15_8 = 0;
 2392               		.loc 1 917 0
 2393 071c 1ABA      		out 0x1a,__zero_reg__
 918:setup.c       **** 	
 919:setup.c       **** 	// Light up 3.3V or 5V
 920:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2394               		.loc 1 920 0
 2395 071e 829B      		sbis 0x10,2
 2396 0720 00C0      		rjmp .L92
 921:setup.c       **** 		PORTD |= (1<<LED_5V);
 2397               		.loc 1 921 0
 2398 0722 979A      		sbi 0x12,7
 922:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2399               		.loc 1 922 0
 2400 0724 3898      		cbi 0x7,0
 923:setup.c       **** 		
 924:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 925:setup.c       **** 		cs2Pin_low;
 2401               		.loc 1 925 0
 2402 0726 3A98      		cbi 0x7,2
 2403               	.LVL180:
 2404               	.LBB182:
 2405               	.LBB183:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2406               		.loc 2 187 0
 2407 0728 2FE7      		ldi r18,lo8(79999)
 2408 072a 88E3      		ldi r24,hi8(79999)
 2409 072c 91E0      		ldi r25,hlo8(79999)
 2410 072e 2150      	1:	subi r18,1
 2411 0730 8040      		sbci r24,0
 2412 0732 9040      		sbci r25,0
 2413 0734 01F4      		brne 1b
 2414 0736 00C0      		rjmp .
 2415 0738 0000      		nop
 2416               	.LVL181:
 2417               	.LBE183:
 2418               	.LBE182:
 926:setup.c       **** 		_delay_ms(50);
 927:setup.c       **** 		cs2Pin_high;
 2419               		.loc 1 927 0
 2420 073a 3A9A      		sbi 0x7,2
 2421 073c 00C0      		rjmp .L93
 2422               	.L92:
 928:setup.c       **** 	}
 929:setup.c       **** 	else {
 930:setup.c       **** 		PORTE |= (1<<LED_3V);
 2423               		.loc 1 930 0
 2424 073e 389A      		sbi 0x7,0
 931:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2425               		.loc 1 931 0
 2426 0740 9798      		cbi 0x12,7
 2427               	.L93:
 932:setup.c       **** 	}
 933:setup.c       **** 	
 934:setup.c       **** 	// Light LED
 935:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2428               		.loc 1 935 0
 2429 0742 939A      		sbi 0x12,3
 2430               	.LVL182:
 2431               	.LBB184:
 2432               	.LBB185:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2433               		.loc 2 187 0
 2434 0744 2FEF      		ldi r18,lo8(799999)
 2435 0746 84E3      		ldi r24,hi8(799999)
 2436 0748 9CE0      		ldi r25,hlo8(799999)
 2437 074a 2150      	1:	subi r18,1
 2438 074c 8040      		sbci r24,0
 2439 074e 9040      		sbci r25,0
 2440 0750 01F4      		brne 1b
 2441 0752 00C0      		rjmp .
 2442 0754 0000      		nop
 2443               	.LVL183:
 2444               	.LBE185:
 2445               	.LBE184:
 936:setup.c       **** 	_delay_ms(500);
 937:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2446               		.loc 1 937 0
 2447 0756 9398      		cbi 0x12,3
 938:setup.c       **** 	
 939:setup.c       **** 	// Setup USART
 940:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2448               		.loc 1 940 0
 2449 0758 19B8      		out 0x9,__zero_reg__
 941:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2450               		.loc 1 941 0
 2451 075a 599A      		sbi 0xb,1
 942:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2452               		.loc 1 942 0
 2453 075c 539A      		sbi 0xa,3
 943:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2454               		.loc 1 943 0
 2455 075e 549A      		sbi 0xa,4
 944:setup.c       **** 	
 945:setup.c       **** 	// Turn on interrupts
 946:setup.c       **** 	sei();
 2456               		.loc 1 946 0
 2457               	/* #APP */
 2458               	 ;  946 "setup.c" 1
 2459 0760 7894      		sei
 2460               	 ;  0 "" 2
 2461               	/* #NOAPP */
 2462 0762 0895      		ret
 2463               		.cfi_endproc
 2464               	.LFE45:
 2466               		.section	.text.startup,"ax",@progbits
 2467               	.global	main
 2469               	main:
 2470               	.LFB46:
 2471               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R17
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 21/01/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.1_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** // 
  47:main.c        **** // Gameboy Advance
  48:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  49:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  50:main.c        **** 
  51:main.c        **** #define F_CPU 8000000 // 8 MHz
  52:main.c        **** #define PCB_VERSION 2
  53:main.c        **** #define FIRMWARE_VERSION 16
  54:main.c        **** 
  55:main.c        **** #include <avr/io.h>
  56:main.c        **** #include <avr/wdt.h>
  57:main.c        **** #include <avr/eeprom.h>
  58:main.c        **** #include <avr/interrupt.h>
  59:main.c        **** #include <avr/sleep.h>
  60:main.c        **** #include <util/delay.h>
  61:main.c        **** #include <stdlib.h>
  62:main.c        **** #include <string.h>
  63:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** int main(void) {
 2472               		.loc 3 66 0
 2473               		.cfi_startproc
 2474               	/* prologue: function */
 2475               	/* frame size = 0 */
 2476               	/* stack size = 0 */
 2477               	.L__stack_usage = 0
  67:main.c        **** 	setup();
 2478               		.loc 3 67 0
 2479 0000 00D0      		rcall setup
 2480               	.LVL184:
  68:main.c        **** 	
  69:main.c        **** 	uint32_t address = 0;
  70:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  71:main.c        **** 	uint8_t cartMode = GB_MODE;
  72:main.c        **** 	uint8_t resetCommonLines = 1;
 2481               		.loc 3 72 0
 2482 0002 2224      		clr r2
 2483 0004 2394      		inc r2
  70:main.c        **** 	uint8_t cartMode = GB_MODE;
 2484               		.loc 3 70 0
 2485 0006 D1E0      		ldi r29,lo8(1)
  69:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2486               		.loc 3 69 0
 2487 0008 C12C      		mov r12,__zero_reg__
 2488 000a D12C      		mov r13,__zero_reg__
 2489 000c 7601      		movw r14,r12
 2490               	.LBB186:
  73:main.c        **** 	
  74:main.c        **** 	while(1) {
  75:main.c        **** 		if (resetCommonLines == 1) {
  76:main.c        **** 			rd_wr_csmreq_cs2_reset();
  77:main.c        **** 		}
  78:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  79:main.c        **** 		
  80:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  81:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
  82:main.c        **** 			cartMode = GB_MODE;
  83:main.c        **** 			PORTD |= (1<<LED_5V);
  84:main.c        **** 			PORTE &= ~(1<<LED_3V);
  85:main.c        **** 		}
  86:main.c        **** 		else {
  87:main.c        **** 			cartMode = GBA_MODE;
  88:main.c        **** 			PORTE |= (1<<LED_3V);
  89:main.c        **** 			PORTD &= ~(1<<LED_5V);
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		// Return the cart mode in use
  93:main.c        **** 		if (receivedChar == CART_MODE) {
  94:main.c        **** 			USART_Transmit(cartMode);
  95:main.c        **** 		}
  96:main.c        **** 		
  97:main.c        **** 		// Change to GB mode or GBA mode if requested
  98:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  99:main.c        **** 			gb_mode();
 100:main.c        **** 		}
 101:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 102:main.c        **** 			gba_mode();
 103:main.c        **** 		}
 104:main.c        **** 		
 105:main.c        **** 		// Set address
 106:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 107:main.c        **** 			usart_read_chars(); // Read start address
 108:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		
 112:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 113:main.c        **** 		
 114:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 115:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 116:main.c        **** 			gb_mode();
 117:main.c        **** 			receivedChar = '1';
 118:main.c        **** 			while (receivedChar == '1') {
 119:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 120:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 121:main.c        **** 					USART_Transmit(read_8bit_data(address));
 122:main.c        **** 					address++;
 123:main.c        **** 				}
 124:main.c        **** 				
 125:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 126:main.c        **** 				receivedChar = USART_Receive();
 127:main.c        **** 			}
 128:main.c        **** 		}
 129:main.c        **** 		
 130:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 131:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 132:main.c        **** 			gb_mode();
 133:main.c        **** 			
 134:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 135:main.c        **** 			usart_read_bytes(64);
 136:main.c        **** 			
 137:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 138:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 139:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 140:main.c        **** 				address++;
 141:main.c        **** 			}
 142:main.c        **** 			
 143:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 144:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 145:main.c        **** 		}
 146:main.c        **** 		
 147:main.c        **** 		// Set bank address and write a byte
 148:main.c        **** 		else if (receivedChar == SET_BANK) {
 149:main.c        **** 			gb_mode();
 150:main.c        **** 			
 151:main.c        **** 			usart_read_chars(); // Read start address
 152:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 153:main.c        **** 			
 154:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 155:main.c        **** 			if (receivedChar == 'B') {
 156:main.c        **** 				usart_read_chars(); // Read data
 157:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 158:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 159:main.c        **** 				
 160:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 161:main.c        **** 			}
 162:main.c        **** 		}
 163:main.c        **** 		
 164:main.c        **** 		
 165:main.c        **** 		// ****** Gameboy Advance ******
 166:main.c        **** 		
 167:main.c        **** 		// ---------- ROM ----------
 168:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 169:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 170:main.c        **** 			gba_mode();
 171:main.c        **** 			
 172:main.c        **** 			uint8_t readEnd = 32;
 173:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 174:main.c        **** 				readEnd = 128;
 175:main.c        **** 			}
 176:main.c        **** 			
 177:main.c        **** 			receivedChar = '1';
 2491               		.loc 3 177 0
 2492 000e 81E3      		ldi r24,lo8(49)
 2493 0010 382E      		mov r3,r24
 2494               	.LBE186:
 2495               	.LBB189:
 2496               	.LBB190:
 178:main.c        **** 			while (receivedChar == '1') {
 179:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 180:main.c        **** 				
 181:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 182:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 183:main.c        **** 					
 184:main.c        **** 					// Low byte & High byte
 185:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 186:main.c        **** 					USART_Transmit(dataRead >> 8);
 187:main.c        **** 					
 188:main.c        **** 					address++;
 189:main.c        **** 				}
 190:main.c        **** 				
 191:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 192:main.c        **** 				receivedChar = USART_Receive();
 193:main.c        **** 			}
 194:main.c        **** 		}
 195:main.c        **** 		
 196:main.c        **** 		// ---------- SRAM ----------
 197:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 198:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 199:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 200:main.c        **** 			
 201:main.c        **** 			receivedChar = '1';
 202:main.c        **** 			while (receivedChar == '1') {
 203:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 206:main.c        **** 					address++;
 207:main.c        **** 				}
 208:main.c        **** 				
 209:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 210:main.c        **** 				receivedChar = USART_Receive();
 211:main.c        **** 			}
 212:main.c        **** 			
 213:main.c        **** 			gba_mode(); // Set back
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 217:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 218:main.c        **** 			gb_mode();
 219:main.c        **** 			
 220:main.c        **** 			usart_read_bytes(64);
 221:main.c        **** 			
 222:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 223:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 224:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 225:main.c        **** 				address++;
 226:main.c        **** 			}
 227:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 228:main.c        **** 			
 229:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 230:main.c        **** 			gba_mode(); // Set back
 231:main.c        **** 		}
 232:main.c        **** 		
 233:main.c        **** 		// Write 1 byte to SRAM address
 234:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 235:main.c        **** 			gb_mode();
 236:main.c        **** 			
 237:main.c        **** 			uint8_t data = USART_Receive();
 238:main.c        **** 			gba_write_ram_8bit_data(address, data);
 239:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 240:main.c        **** 			
 241:main.c        **** 			gba_mode(); // Set back
 242:main.c        **** 		}
 243:main.c        **** 		
 244:main.c        **** 		
 245:main.c        **** 		// ---------- FLASH ----------
 246:main.c        **** 		// Read the Flash Manufacturer and Device ID
 247:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 248:main.c        **** 			gb_mode();
 249:main.c        **** 			
 250:main.c        **** 			flash_read_chip_id();
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 252:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 253:main.c        **** 			
 254:main.c        **** 			gba_mode(); // Set back
 255:main.c        **** 		}
 256:main.c        **** 		
 257:main.c        **** 		// Change bank
 258:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 259:main.c        **** 			usart_read_chars(); // Read data
 260:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 261:main.c        **** 			
 262:main.c        **** 			gb_mode();
 263:main.c        **** 			flash_switch_bank(bank);
 264:main.c        **** 			
 265:main.c        **** 			gba_mode(); // Set back
 266:main.c        **** 		}
 267:main.c        **** 		
 268:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 269:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 270:main.c        **** 			gb_mode();
 271:main.c        **** 			
 272:main.c        **** 			usart_read_chars(); // Read sector
 273:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 274:main.c        **** 			
 275:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 276:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 277:main.c        **** 			
 278:main.c        **** 			gba_mode(); // Set back
 279:main.c        **** 		}
 280:main.c        **** 		
 281:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 282:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 283:main.c        **** 			gb_mode();
 284:main.c        **** 			
 285:main.c        **** 			usart_read_bytes(64);
 286:main.c        **** 			
 287:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 288:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 289:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 293:main.c        **** 			
 294:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 300:main.c        **** 			gb_mode();
 301:main.c        **** 			
 302:main.c        **** 			usart_read_bytes(128);
 303:main.c        **** 			
 304:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 305:main.c        **** 			flash_write_sector(address); // Address used as sector number
 306:main.c        **** 			address++;
 307:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 308:main.c        **** 			
 309:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 310:main.c        **** 			gba_mode(); // Set back
 311:main.c        **** 		}
 312:main.c        **** 		
 313:main.c        **** 		
 314:main.c        **** 		// ---------- EEPROM ----------
 315:main.c        **** 		// Set EEPROM size
 316:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 317:main.c        **** 			usart_read_chars(); // Read size
 318:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 319:main.c        **** 		}
 320:main.c        **** 		
 321:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 322:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 323:main.c        **** 			gba_eeprom_mode();
 324:main.c        **** 			
 325:main.c        **** 			receivedChar = '1';
 326:main.c        **** 			while (receivedChar == '1') {
 327:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 328:main.c        **** 				gba_eeprom_read(address, eepromSize);
 329:main.c        **** 				
 330:main.c        **** 				// Send back the 8 bytes of data
 331:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 332:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 333:main.c        **** 				}
 334:main.c        **** 				address++; // Increment to next 8 bytes
 335:main.c        **** 				
 336:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 337:main.c        **** 				receivedChar = USART_Receive();
 338:main.c        **** 			}
 339:main.c        **** 			
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 344:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 345:main.c        **** 			gba_eeprom_mode();
 346:main.c        **** 			
 347:main.c        **** 			// Read 8 bytes from USART and place in buffer
 348:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 349:main.c        **** 				eepromBuffer[x] = USART_Receive();
 350:main.c        **** 			}
 351:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 352:main.c        **** 			
 353:main.c        **** 			gba_eeprom_write(address, eepromSize);
 354:main.c        **** 			address++;
 355:main.c        **** 			
 356:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 357:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 358:main.c        **** 			
 359:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 360:main.c        **** 			gba_mode(); // Set back
 361:main.c        **** 		}
 362:main.c        **** 		
 363:main.c        **** 		
 364:main.c        **** 		// ---------- GB FLASH CARTS ----------
 365:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 366:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 367:main.c        **** 			flashWriteWePin = USART_Receive();
 368:main.c        **** 			
 369:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 370:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 371:main.c        **** 				audioPin_high;
 372:main.c        **** 			}
 373:main.c        **** 		}
 374:main.c        **** 		
 375:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 376:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 377:main.c        **** 			flashBank1CommandWrites = 1;
 378:main.c        **** 		}
 379:main.c        **** 		
 380:main.c        **** 		// Load the program method to use
 381:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 382:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 383:main.c        **** 				usart_read_chars(); // Address
 384:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 385:main.c        **** 				USART_Transmit(SEND_ACK);
 386:main.c        **** 				
 387:main.c        **** 				usart_read_chars(); // Data
 388:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 389:main.c        **** 				USART_Transmit(SEND_ACK);
 390:main.c        **** 			}
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 394:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 395:main.c        **** 			usart_read_chars(); // Read address
 396:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 397:main.c        **** 			
 398:main.c        **** 			usart_read_chars(); // Read data byte
 399:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 400:main.c        **** 			
 401:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 402:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 403:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 404:main.c        **** 			
 405:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 409:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 410:main.c        **** 			usart_read_bytes(64);
 411:main.c        **** 			
 412:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 413:main.c        **** 			if (flashBank1CommandWrites == 0) {
 414:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 415:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 416:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 417:main.c        **** 					}
 418:main.c        **** 					address++;
 419:main.c        **** 				}
 420:main.c        **** 			}
 421:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 422:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 423:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 424:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 425:main.c        **** 					}
 426:main.c        **** 					address++;
 427:main.c        **** 				}
 428:main.c        **** 			}
 429:main.c        **** 			
 430:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 431:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 432:main.c        **** 		}
 433:main.c        **** 		
 434:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 435:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 436:main.c        **** 			usart_read_bytes(32);
 437:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 438:main.c        **** 			
 439:main.c        **** 			// Setup buffered write
 440:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 441:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 442:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 443:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 444:main.c        **** 			_delay_us(1);
 445:main.c        **** 			
 446:main.c        **** 			// Write data
 447:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 448:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 449:main.c        **** 				address++;
 450:main.c        **** 			}
 451:main.c        **** 			
 452:main.c        **** 			// Write buffer to flash
 453:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 454:main.c        **** 			_delay_us(200);
 455:main.c        **** 			
 456:main.c        **** 			// Verify last byte written
 457:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 458:main.c        **** 			uint8_t verifyCount = 0;
 459:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 460:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 461:main.c        **** 				_delay_us(5);
 462:main.c        **** 				verifyCount++;
 463:main.c        **** 				
 464:main.c        **** 				if (verifyCount >= 200) {
 465:main.c        **** 					_delay_ms(500);
 466:main.c        **** 					break;
 467:main.c        **** 				}
 468:main.c        **** 			}
 469:main.c        **** 			
 470:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 471:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 472:main.c        **** 		}
 473:main.c        **** 		
 474:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 475:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 476:main.c        **** 			usart_read_bytes(64);
 477:main.c        **** 			
 478:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 479:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 480:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 481:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 482:main.c        **** 				}
 483:main.c        **** 				address++;
 484:main.c        **** 			}
 485:main.c        **** 			
 486:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 487:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 488:main.c        **** 		}
 489:main.c        **** 		
 490:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 491:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 492:main.c        **** 			usart_read_bytes(256);
 493:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 494:main.c        **** 			
 495:main.c        **** 			// Setup buffered write
 496:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 497:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 498:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 499:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 500:main.c        **** 			_delay_us(50);
 501:main.c        **** 			
 502:main.c        **** 			// Write data
 503:main.c        **** 			for (int x = 0; x < 256; x++) {
 504:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 505:main.c        **** 				address++;
 506:main.c        **** 			}
 507:main.c        **** 			
 508:main.c        **** 			// Write buffer to flash
 509:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 510:main.c        **** 			
 511:main.c        **** 			// Verify last byte written
 512:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 513:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 514:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 515:main.c        **** 				_delay_us(5);
 516:main.c        **** 			}
 517:main.c        **** 			
 518:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 519:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 520:main.c        **** 		}
 521:main.c        **** 		
 522:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 523:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 524:main.c        **** 			usart_read_bytes(128);
 525:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 526:main.c        **** 			
 527:main.c        **** 			// Enable flash chip access
 528:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 529:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 530:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 531:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 532:main.c        **** 			_delay_us(5);
 533:main.c        **** 			
 534:main.c        **** 			// Re-Enable writes to MBC registers
 535:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 536:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 537:main.c        **** 			_delay_us(5);
 538:main.c        **** 			
 539:main.c        **** 			// Bank 1 for commands
 540:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 541:main.c        **** 			_delay_us(5);
 542:main.c        **** 			
 543:main.c        **** 			
 544:main.c        **** 			// Write setup
 545:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 546:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 547:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 548:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 549:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 550:main.c        **** 			_delay_us(5);
 551:main.c        **** 			
 552:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 553:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 554:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 555:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 556:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 557:main.c        **** 			_delay_us(5);
 558:main.c        **** 			
 559:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 560:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 561:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 562:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 563:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 564:main.c        **** 			_delay_us(5);
 565:main.c        **** 			
 566:main.c        **** 			// Set bank back
 567:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 568:main.c        **** 			_delay_us(5);
 569:main.c        **** 			
 570:main.c        **** 			// Disable writes to MBC registers
 571:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 572:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 573:main.c        **** 			_delay_us(5);
 574:main.c        **** 			
 575:main.c        **** 			// Undo Wakeup
 576:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 577:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 578:main.c        **** 			_delay_us(5);
 579:main.c        **** 			
 580:main.c        **** 			
 581:main.c        **** 			// Write data
 582:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 583:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 584:main.c        **** 				_delay_us(5);
 585:main.c        **** 				address++;
 586:main.c        **** 			}
 587:main.c        **** 			
 588:main.c        **** 			// Write buffer to flash
 589:main.c        **** 			address--;
 590:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 591:main.c        **** 			address++;
 592:main.c        **** 			_delay_ms(10);
 593:main.c        **** 			
 594:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 595:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 596:main.c        **** 		}
 597:main.c        **** 		
 598:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 599:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 600:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 601:main.c        **** 			usart_read_chars(); // Read address
 602:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 603:main.c        **** 			
 604:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 605:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 606:main.c        **** 				usart_read_chars(); // Read data
 607:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 608:main.c        **** 				
 609:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 610:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 611:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 612:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 613:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 614:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 615:main.c        **** 				
 616:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 617:main.c        **** 			}
 618:main.c        **** 		}
 619:main.c        **** 		
 620:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 621:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 622:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 623:main.c        **** 			
 624:main.c        **** 			int readLength = 64;
 625:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 626:main.c        **** 				readLength = 256;
 627:main.c        **** 			}
 628:main.c        **** 			usart_read_bytes(readLength);
 629:main.c        **** 			
 630:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 631:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 632:main.c        **** 				if (combinedBytes != 0xFFFF) {
 633:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 634:main.c        **** 				}
 635:main.c        **** 				address++;
 636:main.c        **** 			}
 637:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 638:main.c        **** 			
 639:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 640:main.c        **** 		}
 641:main.c        **** 		
 642:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 643:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 644:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 645:main.c        **** 			
 646:main.c        **** 			int readLength = 256;
 647:main.c        **** 			usart_read_bytes(readLength);
 648:main.c        **** 			
 649:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 650:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 651:main.c        **** 				if (combinedBytes != 0xFFFF) {
 652:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 653:main.c        **** 				}
 654:main.c        **** 				address++;
 655:main.c        **** 			}
 656:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 657:main.c        **** 			
 658:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 659:main.c        **** 		}
 660:main.c        **** 		
 661:main.c        **** 		// Intel flash command based chips
 662:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 663:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 664:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 665:main.c        **** 			usart_read_bytes(64);
 666:main.c        **** 			
 667:main.c        **** 			// Set address lines as outputs
 668:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 669:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 670:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 671:main.c        **** 			
 672:main.c        **** 			// Unlock
 673:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 674:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 675:main.c        **** 			
 676:main.c        **** 			// Buffered write command
 677:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 678:main.c        **** 			_delay_us(50);
 679:main.c        **** 			
 680:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 681:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 682:main.c        **** 			while (dataVerify != 0x0080) {
 683:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 684:main.c        **** 				_delay_us(50);
 685:main.c        **** 			}
 686:main.c        **** 			
 687:main.c        **** 			
 688:main.c        **** 			// Set address lines as outputs
 689:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 690:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 691:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 692:main.c        **** 			
 693:main.c        **** 			// Set length
 694:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 695:main.c        **** 			
 696:main.c        **** 			// Write data
 697:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 698:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 699:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 700:main.c        **** 				address++;
 701:main.c        **** 			}
 702:main.c        **** 			
 703:main.c        **** 			// Write buffer to flash
 704:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 705:main.c        **** 			_delay_us(440);
 706:main.c        **** 			
 707:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 708:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 709:main.c        **** 			while (dataVerify != 0x0080) {
 710:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 711:main.c        **** 				_delay_us(50);
 712:main.c        **** 			}
 713:main.c        **** 			
 714:main.c        **** 			
 715:main.c        **** 			// Set address lines as outputs
 716:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 717:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 718:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 719:main.c        **** 			
 720:main.c        **** 			// Back to reading mode
 721:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 722:main.c        **** 			
 723:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 724:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 725:main.c        **** 		}
 726:main.c        **** 		
 727:main.c        **** 		// Intel word programming
 728:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 729:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 730:main.c        **** 			usart_read_bytes(64);
 731:main.c        **** 			
 732:main.c        **** 			// Write data
 733:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 734:main.c        **** 				// Set address lines as outputs
 735:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2497               		.loc 3 735 0
 2498 0012 CFEF      		ldi r28,lo8(-1)
 2499               	.LVL185:
 2500               	.L95:
 2501               	.LBE190:
 2502               	.LBE189:
  75:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2503               		.loc 3 75 0
 2504 0014 21E0      		ldi r18,lo8(1)
 2505 0016 2212      		cpse r2,r18
 2506 0018 00C0      		rjmp .L96
 2507               	.LVL186:
 2508               	.L262:
  76:main.c        **** 		}
 2509               		.loc 3 76 0
 2510 001a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2511               	.LVL187:
 2512               	.L96:
  78:main.c        **** 		
 2513               		.loc 3 78 0
 2514 001c 00D0      		rcall USART_Receive
 2515               	.LVL188:
 2516 001e 8093 0000 		sts receivedChar,r24
  81:main.c        **** 			cartMode = GB_MODE;
 2517               		.loc 3 81 0
 2518 0022 829B      		sbis 0x10,2
 2519 0024 00C0      		rjmp .L97
 2520               	.LVL189:
  83:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2521               		.loc 3 83 0
 2522 0026 979A      		sbi 0x12,7
  84:main.c        **** 		}
 2523               		.loc 3 84 0
 2524 0028 3898      		cbi 0x7,0
  82:main.c        **** 			PORTD |= (1<<LED_5V);
 2525               		.loc 3 82 0
 2526 002a 81E0      		ldi r24,lo8(1)
 2527 002c 00C0      		rjmp .L98
 2528               	.LVL190:
 2529               	.L97:
  88:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2530               		.loc 3 88 0
 2531 002e 389A      		sbi 0x7,0
  89:main.c        **** 		}
 2532               		.loc 3 89 0
 2533 0030 9798      		cbi 0x12,7
  87:main.c        **** 			PORTE |= (1<<LED_3V);
 2534               		.loc 3 87 0
 2535 0032 82E0      		ldi r24,lo8(2)
 2536               	.LVL191:
 2537               	.L98:
  93:main.c        **** 			USART_Transmit(cartMode);
 2538               		.loc 3 93 0
 2539 0034 9091 0000 		lds r25,receivedChar
 2540 0038 9334      		cpi r25,lo8(67)
 2541 003a 01F4      		brne .+2
 2542 003c 00C0      		rjmp .L263
  98:main.c        **** 			gb_mode();
 2543               		.loc 3 98 0
 2544 003e 9734      		cpi r25,lo8(71)
 2545 0040 01F4      		brne .L101
  99:main.c        **** 		}
 2546               		.loc 3 99 0
 2547 0042 00D0      		rcall gb_mode
 2548               	.LVL192:
 2549 0044 00C0      		rjmp .L95
 2550               	.LVL193:
 2551               	.L101:
 101:main.c        **** 			gba_mode();
 2552               		.loc 3 101 0
 2553 0046 9736      		cpi r25,lo8(103)
 2554 0048 01F4      		brne .+2
 2555 004a 00C0      		rjmp .L265
 106:main.c        **** 			usart_read_chars(); // Read start address
 2556               		.loc 3 106 0
 2557 004c 9134      		cpi r25,lo8(65)
 2558 004e 01F4      		brne .L103
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2559               		.loc 3 107 0
 2560 0050 00D0      		rcall usart_read_chars
 2561               	.LVL194:
 108:main.c        **** 		}
 2562               		.loc 3 108 0
 2563 0052 40E1      		ldi r20,lo8(16)
 2564 0054 50E0      		ldi r21,0
 2565 0056 60E0      		ldi r22,0
 2566 0058 70E0      		ldi r23,0
 2567 005a 80E0      		ldi r24,lo8(receivedBuffer)
 2568 005c 90E0      		ldi r25,hi8(receivedBuffer)
 2569 005e 00D0      		rcall strtol
 2570               	.LVL195:
 2571 0060 6B01      		movw r12,r22
 2572 0062 7C01      		movw r14,r24
 2573               	.LVL196:
 2574 0064 00C0      		rjmp .L95
 2575               	.LVL197:
 2576               	.L103:
 115:main.c        **** 			gb_mode();
 2577               		.loc 3 115 0
 2578 0066 9235      		cpi r25,lo8(82)
 2579 0068 01F4      		brne .L104
 116:main.c        **** 			receivedChar = '1';
 2580               		.loc 3 116 0
 2581 006a 00D0      		rcall gb_mode
 2582               	.LVL198:
 117:main.c        **** 			while (receivedChar == '1') {
 2583               		.loc 3 117 0
 2584 006c 3092 0000 		sts receivedChar,r3
 2585               	.LVL199:
 2586               	.L105:
 118:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2587               		.loc 3 118 0
 2588 0070 8091 0000 		lds r24,receivedChar
 2589 0074 8133      		cpi r24,lo8(49)
 2590 0076 01F4      		brne .L95
 119:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2591               		.loc 3 119 0
 2592 0078 939A      		sbi 0x12,3
 2593               	.LVL200:
 2594 007a 00E0      		ldi r16,0
 2595 007c 10E0      		ldi r17,0
 2596               	.LVL201:
 2597               	.L106:
 2598               	.LBB194:
 121:main.c        **** 					address++;
 2599               		.loc 3 121 0 discriminator 3
 2600 007e C801      		movw r24,r16
 2601 0080 8C0D      		add r24,r12
 2602 0082 9D1D      		adc r25,r13
 2603 0084 00D0      		rcall read_8bit_data
 2604               	.LVL202:
 2605 0086 00D0      		rcall USART_Transmit
 2606               	.LVL203:
 2607 0088 0F5F      		subi r16,-1
 2608 008a 1F4F      		sbci r17,-1
 2609               	.LVL204:
 120:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2610               		.loc 3 120 0 discriminator 3
 2611 008c 0034      		cpi r16,64
 2612 008e 1105      		cpc r17,__zero_reg__
 2613 0090 01F4      		brne .L106
 2614 0092 80E4      		ldi r24,64
 2615 0094 C80E      		add r12,r24
 2616 0096 D11C      		adc r13,__zero_reg__
 2617 0098 E11C      		adc r14,__zero_reg__
 2618 009a F11C      		adc r15,__zero_reg__
 2619               	.LBE194:
 125:main.c        **** 				receivedChar = USART_Receive();
 2620               		.loc 3 125 0
 2621 009c 9398      		cbi 0x12,3
 126:main.c        **** 			}
 2622               		.loc 3 126 0
 2623 009e 00D0      		rcall USART_Receive
 2624               	.LVL205:
 2625 00a0 8093 0000 		sts receivedChar,r24
 2626 00a4 00C0      		rjmp .L105
 2627               	.LVL206:
 2628               	.L104:
 131:main.c        **** 			gb_mode();
 2629               		.loc 3 131 0
 2630 00a6 9735      		cpi r25,lo8(87)
 2631 00a8 01F4      		brne .L108
 132:main.c        **** 			
 2632               		.loc 3 132 0
 2633 00aa 00D0      		rcall gb_mode
 2634               	.LVL207:
 135:main.c        **** 			
 2635               		.loc 3 135 0
 2636 00ac 80E4      		ldi r24,lo8(64)
 2637 00ae 90E0      		ldi r25,0
 2638 00b0 00D0      		rcall usart_read_bytes
 2639               	.LVL208:
 137:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2640               		.loc 3 137 0
 2641 00b2 939A      		sbi 0x12,3
 2642               	.LVL209:
 2643 00b4 00E0      		ldi r16,lo8(receivedBuffer)
 2644 00b6 A02E      		mov r10,r16
 2645 00b8 00E0      		ldi r16,hi8(receivedBuffer)
 2646 00ba B02E      		mov r11,r16
 2647 00bc 00E0      		ldi r16,0
 2648 00be 10E0      		ldi r17,0
 2649               	.LVL210:
 2650               	.L109:
 2651               	.LBB195:
 139:main.c        **** 				address++;
 2652               		.loc 3 139 0 discriminator 3
 2653 00c0 F501      		movw r30,r10
 2654 00c2 6191      		ld r22,Z+
 2655 00c4 5F01      		movw r10,r30
 2656 00c6 C801      		movw r24,r16
 2657 00c8 8C0D      		add r24,r12
 2658 00ca 9D1D      		adc r25,r13
 2659 00cc 41E0      		ldi r20,lo8(1)
 2660 00ce 00D0      		rcall write_8bit_data
 2661               	.LVL211:
 2662 00d0 0F5F      		subi r16,-1
 2663 00d2 1F4F      		sbci r17,-1
 2664               	.LVL212:
 138:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2665               		.loc 3 138 0 discriminator 3
 2666 00d4 0034      		cpi r16,64
 2667 00d6 1105      		cpc r17,__zero_reg__
 2668 00d8 01F4      		brne .L109
 2669 00da F0E4      		ldi r31,64
 2670 00dc CF0E      		add r12,r31
 2671 00de D11C      		adc r13,__zero_reg__
 2672 00e0 E11C      		adc r14,__zero_reg__
 2673 00e2 F11C      		adc r15,__zero_reg__
 2674 00e4 00C0      		rjmp .L283
 2675               	.LVL213:
 2676               	.L108:
 2677               	.LBE195:
 148:main.c        **** 			gb_mode();
 2678               		.loc 3 148 0
 2679 00e6 9234      		cpi r25,lo8(66)
 2680 00e8 01F4      		brne .L110
 2681               	.LBB196:
 149:main.c        **** 			
 2682               		.loc 3 149 0
 2683 00ea 00D0      		rcall gb_mode
 2684               	.LVL214:
 151:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2685               		.loc 3 151 0
 2686 00ec 00D0      		rcall usart_read_chars
 2687               	.LVL215:
 152:main.c        **** 			
 2688               		.loc 3 152 0
 2689 00ee 40E1      		ldi r20,lo8(16)
 2690 00f0 50E0      		ldi r21,0
 2691 00f2 60E0      		ldi r22,0
 2692 00f4 70E0      		ldi r23,0
 2693 00f6 80E0      		ldi r24,lo8(receivedBuffer)
 2694 00f8 90E0      		ldi r25,hi8(receivedBuffer)
 2695 00fa 00D0      		rcall strtol
 2696               	.LVL216:
 2697 00fc 4B01      		movw r8,r22
 2698 00fe 5C01      		movw r10,r24
 2699               	.LVL217:
 154:main.c        **** 			if (receivedChar == 'B') {
 2700               		.loc 3 154 0
 2701 0100 00D0      		rcall USART_Receive
 2702               	.LVL218:
 2703 0102 8093 0000 		sts receivedChar,r24
 155:main.c        **** 				usart_read_chars(); // Read data
 2704               		.loc 3 155 0
 2705 0106 8234      		cpi r24,lo8(66)
 2706 0108 01F0      		breq .+2
 2707 010a 00C0      		rjmp .L95
 2708               	.LBB197:
 156:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2709               		.loc 3 156 0
 2710 010c 00D0      		rcall usart_read_chars
 2711               	.LVL219:
 157:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2712               		.loc 3 157 0
 2713 010e 80E0      		ldi r24,lo8(receivedBuffer)
 2714 0110 90E0      		ldi r25,hi8(receivedBuffer)
 2715 0112 00D0      		rcall atoi
 2716               	.LVL220:
 158:main.c        **** 				
 2717               		.loc 3 158 0
 2718 0114 8093 0000 		sts lastBankAccessed,r24
 160:main.c        **** 			}
 2719               		.loc 3 160 0
 2720 0118 40E0      		ldi r20,0
 2721 011a 682F      		mov r22,r24
 2722 011c C401      		movw r24,r8
 2723               	.LVL221:
 2724 011e 00D0      		rcall write_8bit_data
 2725               	.LVL222:
 2726 0120 00C0      		rjmp .L95
 2727               	.LVL223:
 2728               	.L110:
 2729               	.LBE197:
 2730               	.LBE196:
 169:main.c        **** 			gba_mode();
 2731               		.loc 3 169 0
 2732 0122 9237      		cpi r25,lo8(114)
 2733 0124 01F0      		breq .L111
 169:main.c        **** 			gba_mode();
 2734               		.loc 3 169 0 is_stmt 0 discriminator 1
 2735 0126 9A36      		cpi r25,lo8(106)
 2736 0128 01F4      		brne .L112
 2737               	.L111:
 2738               	.LBB198:
 170:main.c        **** 			
 2739               		.loc 3 170 0 is_stmt 1
 2740 012a 00D0      		rcall gba_mode
 2741               	.LVL224:
 173:main.c        **** 				readEnd = 128;
 2742               		.loc 3 173 0
 2743 012c 8091 0000 		lds r24,receivedChar
 2744 0130 8A36      		cpi r24,lo8(106)
 2745 0132 01F4      		brne .L216
 174:main.c        **** 			}
 2746               		.loc 3 174 0
 2747 0134 10E8      		ldi r17,lo8(-128)
 2748 0136 00C0      		rjmp .L113
 2749               	.L216:
 172:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2750               		.loc 3 172 0
 2751 0138 10E2      		ldi r17,lo8(32)
 2752               	.L113:
 2753               	.LVL225:
 177:main.c        **** 			while (receivedChar == '1') {
 2754               		.loc 3 177 0
 2755 013a 3092 0000 		sts receivedChar,r3
 2756 013e 8824      		clr r8
 2757 0140 8A94      		dec r8
 2758 0142 810E      		add r8,r17
 2759 0144 912C      		mov r9,__zero_reg__
 2760 0146 A12C      		mov r10,__zero_reg__
 2761 0148 B12C      		mov r11,__zero_reg__
 2762 014a 2FEF      		ldi r18,-1
 2763 014c 821A      		sub r8,r18
 2764 014e 920A      		sbc r9,r18
 2765 0150 A20A      		sbc r10,r18
 2766 0152 B20A      		sbc r11,r18
 2767               	.LVL226:
 2768               	.L114:
 178:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2769               		.loc 3 178 0
 2770 0154 8091 0000 		lds r24,receivedChar
 2771 0158 8133      		cpi r24,lo8(49)
 2772 015a 01F0      		breq .+2
 2773 015c 00C0      		rjmp .L95
 179:main.c        **** 				
 2774               		.loc 3 179 0
 2775 015e 939A      		sbi 0x12,3
 2776               	.LVL227:
 2777 0160 2601      		movw r4,r12
 2778 0162 3701      		movw r6,r14
 2779               	.LVL228:
 2780               	.L115:
 2781               	.LBB187:
 2782               	.LBB188:
 182:main.c        **** 					
 2783               		.loc 3 182 0 discriminator 3
 2784 0164 C301      		movw r24,r6
 2785 0166 B201      		movw r22,r4
 2786 0168 00D0      		rcall gba_read_16bit_data
 2787               	.LVL229:
 2788 016a 092F      		mov r16,r25
 2789               	.LVL230:
 185:main.c        **** 					USART_Transmit(dataRead >> 8);
 2790               		.loc 3 185 0 discriminator 3
 2791 016c 00D0      		rcall USART_Transmit
 2792               	.LVL231:
 186:main.c        **** 					
 2793               		.loc 3 186 0 discriminator 3
 2794 016e 802F      		mov r24,r16
 2795 0170 00D0      		rcall USART_Transmit
 2796               	.LVL232:
 188:main.c        **** 				}
 2797               		.loc 3 188 0 discriminator 3
 2798 0172 8FEF      		ldi r24,-1
 2799 0174 481A      		sub r4,r24
 2800 0176 580A      		sbc r5,r24
 2801 0178 680A      		sbc r6,r24
 2802 017a 780A      		sbc r7,r24
 2803               	.LVL233:
 2804               	.LBE188:
 181:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 2805               		.loc 3 181 0 discriminator 3
 2806 017c 842D      		mov r24,r4
 2807 017e 8C19      		sub r24,r12
 2808 0180 8117      		cp r24,r17
 2809 0182 00F0      		brlo .L115
 2810 0184 C80C      		add r12,r8
 2811 0186 D91C      		adc r13,r9
 2812 0188 EA1C      		adc r14,r10
 2813 018a FB1C      		adc r15,r11
 2814               	.LVL234:
 2815               	.LBE187:
 191:main.c        **** 				receivedChar = USART_Receive();
 2816               		.loc 3 191 0
 2817 018c 9398      		cbi 0x12,3
 192:main.c        **** 			}
 2818               		.loc 3 192 0
 2819 018e 00D0      		rcall USART_Receive
 2820               	.LVL235:
 2821 0190 8093 0000 		sts receivedChar,r24
 2822 0194 00C0      		rjmp .L114
 2823               	.LVL236:
 2824               	.L112:
 2825               	.LBE198:
 198:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 2826               		.loc 3 198 0
 2827 0196 9D36      		cpi r25,lo8(109)
 2828 0198 01F4      		brne .L117
 199:main.c        **** 			
 2829               		.loc 3 199 0
 2830 019a 00D0      		rcall gb_mode
 2831               	.LVL237:
 201:main.c        **** 			while (receivedChar == '1') {
 2832               		.loc 3 201 0
 2833 019c 3092 0000 		sts receivedChar,r3
 2834               	.LVL238:
 2835               	.L118:
 202:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2836               		.loc 3 202 0
 2837 01a0 8091 0000 		lds r24,receivedChar
 2838 01a4 8133      		cpi r24,lo8(49)
 2839 01a6 01F4      		brne .L265
 203:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2840               		.loc 3 203 0
 2841 01a8 939A      		sbi 0x12,3
 2842               	.LVL239:
 2843 01aa 00E0      		ldi r16,0
 2844 01ac 10E0      		ldi r17,0
 2845               	.LVL240:
 2846               	.L119:
 2847               	.LBB199:
 205:main.c        **** 					address++;
 2848               		.loc 3 205 0 discriminator 3
 2849 01ae C801      		movw r24,r16
 2850 01b0 8C0D      		add r24,r12
 2851 01b2 9D1D      		adc r25,r13
 2852 01b4 00D0      		rcall gba_read_ram_8bit_data
 2853               	.LVL241:
 2854 01b6 00D0      		rcall USART_Transmit
 2855               	.LVL242:
 2856 01b8 0F5F      		subi r16,-1
 2857 01ba 1F4F      		sbci r17,-1
 2858               	.LVL243:
 204:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 2859               		.loc 3 204 0 discriminator 3
 2860 01bc 0034      		cpi r16,64
 2861 01be 1105      		cpc r17,__zero_reg__
 2862 01c0 01F4      		brne .L119
 2863 01c2 90E4      		ldi r25,64
 2864 01c4 C90E      		add r12,r25
 2865 01c6 D11C      		adc r13,__zero_reg__
 2866 01c8 E11C      		adc r14,__zero_reg__
 2867 01ca F11C      		adc r15,__zero_reg__
 2868               	.LBE199:
 209:main.c        **** 				receivedChar = USART_Receive();
 2869               		.loc 3 209 0
 2870 01cc 9398      		cbi 0x12,3
 210:main.c        **** 			}
 2871               		.loc 3 210 0
 2872 01ce 00D0      		rcall USART_Receive
 2873               	.LVL244:
 2874 01d0 8093 0000 		sts receivedChar,r24
 2875 01d4 00C0      		rjmp .L118
 2876               	.LVL245:
 2877               	.L117:
 217:main.c        **** 			gb_mode();
 2878               		.loc 3 217 0
 2879 01d6 9737      		cpi r25,lo8(119)
 2880 01d8 01F4      		brne .L121
 218:main.c        **** 			
 2881               		.loc 3 218 0
 2882 01da 00D0      		rcall gb_mode
 2883               	.LVL246:
 220:main.c        **** 			
 2884               		.loc 3 220 0
 2885 01dc 80E4      		ldi r24,lo8(64)
 2886 01de 90E0      		ldi r25,0
 2887 01e0 00D0      		rcall usart_read_bytes
 2888               	.LVL247:
 222:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2889               		.loc 3 222 0
 2890 01e2 939A      		sbi 0x12,3
 2891               	.LVL248:
 2892 01e4 10E0      		ldi r17,lo8(receivedBuffer)
 2893 01e6 A12E      		mov r10,r17
 2894 01e8 10E0      		ldi r17,hi8(receivedBuffer)
 2895 01ea B12E      		mov r11,r17
 2896 01ec 00E0      		ldi r16,0
 2897 01ee 10E0      		ldi r17,0
 2898               	.LVL249:
 2899               	.L122:
 2900               	.LBB200:
 224:main.c        **** 				address++;
 2901               		.loc 3 224 0 discriminator 3
 2902 01f0 F501      		movw r30,r10
 2903 01f2 6191      		ld r22,Z+
 2904 01f4 5F01      		movw r10,r30
 2905 01f6 C801      		movw r24,r16
 2906 01f8 8C0D      		add r24,r12
 2907 01fa 9D1D      		adc r25,r13
 2908 01fc 00D0      		rcall gba_write_ram_8bit_data
 2909               	.LVL250:
 2910 01fe 0F5F      		subi r16,-1
 2911 0200 1F4F      		sbci r17,-1
 2912               	.LVL251:
 223:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 2913               		.loc 3 223 0 discriminator 3
 2914 0202 0034      		cpi r16,64
 2915 0204 1105      		cpc r17,__zero_reg__
 2916 0206 01F4      		brne .L122
 2917               	.LVL252:
 2918               	.L268:
 2919 0208 F0E4      		ldi r31,64
 2920 020a CF0E      		add r12,r31
 2921 020c D11C      		adc r13,__zero_reg__
 2922 020e E11C      		adc r14,__zero_reg__
 2923 0210 F11C      		adc r15,__zero_reg__
 2924               	.L267:
 2925               	.LBE200:
 227:main.c        **** 			
 2926               		.loc 3 227 0
 2927 0212 81E3      		ldi r24,lo8(49)
 2928 0214 00D0      		rcall USART_Transmit
 2929               	.LVL253:
 229:main.c        **** 			gba_mode(); // Set back
 2930               		.loc 3 229 0
 2931 0216 9398      		cbi 0x12,3
 2932               	.L265:
 230:main.c        **** 		}
 2933               		.loc 3 230 0
 2934 0218 00D0      		rcall gba_mode
 2935               	.LVL254:
 2936 021a 00C0      		rjmp .L95
 2937               	.LVL255:
 2938               	.L121:
 234:main.c        **** 			gb_mode();
 2939               		.loc 3 234 0
 2940 021c 9F36      		cpi r25,lo8(111)
 2941 021e 01F4      		brne .L123
 2942               	.LBB201:
 235:main.c        **** 			
 2943               		.loc 3 235 0
 2944 0220 00D0      		rcall gb_mode
 2945               	.LVL256:
 237:main.c        **** 			gba_write_ram_8bit_data(address, data);
 2946               		.loc 3 237 0
 2947 0222 00D0      		rcall USART_Receive
 2948               	.LVL257:
 238:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 2949               		.loc 3 238 0
 2950 0224 682F      		mov r22,r24
 2951 0226 C601      		movw r24,r12
 2952               	.LVL258:
 2953 0228 00D0      		rcall gba_write_ram_8bit_data
 2954               	.LVL259:
 2955 022a 00C0      		rjmp .L270
 2956               	.LVL260:
 2957               	.L123:
 2958               	.LBE201:
 247:main.c        **** 			gb_mode();
 2959               		.loc 3 247 0
 2960 022c 9936      		cpi r25,lo8(105)
 2961 022e 01F4      		brne .L124
 248:main.c        **** 			
 2962               		.loc 3 248 0
 2963 0230 00D0      		rcall gb_mode
 2964               	.LVL261:
 250:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 2965               		.loc 3 250 0
 2966 0232 00D0      		rcall flash_read_chip_id
 2967               	.LVL262:
 251:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 2968               		.loc 3 251 0
 2969 0234 8091 0000 		lds r24,flashChipIdBuffer
 2970 0238 00D0      		rcall USART_Transmit
 2971               	.LVL263:
 252:main.c        **** 			
 2972               		.loc 3 252 0
 2973 023a 8091 0000 		lds r24,flashChipIdBuffer+1
 2974               	.L269:
 2975 023e 00D0      		rcall USART_Transmit
 2976               	.LVL264:
 2977 0240 00C0      		rjmp .L265
 2978               	.LVL265:
 2979               	.L124:
 258:main.c        **** 			usart_read_chars(); // Read data
 2980               		.loc 3 258 0
 2981 0242 9B36      		cpi r25,lo8(107)
 2982 0244 01F4      		brne .L125
 2983               	.LBB202:
 259:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 2984               		.loc 3 259 0
 2985 0246 00D0      		rcall usart_read_chars
 2986               	.LVL266:
 260:main.c        **** 			
 2987               		.loc 3 260 0
 2988 0248 80E0      		ldi r24,lo8(receivedBuffer)
 2989 024a 90E0      		ldi r25,hi8(receivedBuffer)
 2990 024c 00D0      		rcall atoi
 2991               	.LVL267:
 2992 024e 182F      		mov r17,r24
 2993               	.LVL268:
 262:main.c        **** 			flash_switch_bank(bank);
 2994               		.loc 3 262 0
 2995 0250 00D0      		rcall gb_mode
 2996               	.LVL269:
 263:main.c        **** 			
 2997               		.loc 3 263 0
 2998 0252 812F      		mov r24,r17
 2999 0254 00D0      		rcall flash_switch_bank
 3000               	.LVL270:
 3001 0256 00C0      		rjmp .L265
 3002               	.LVL271:
 3003               	.L125:
 3004               	.LBE202:
 269:main.c        **** 			gb_mode();
 3005               		.loc 3 269 0
 3006 0258 9337      		cpi r25,lo8(115)
 3007 025a 01F4      		brne .L126
 3008               	.LBB203:
 270:main.c        **** 			
 3009               		.loc 3 270 0
 3010 025c 00D0      		rcall gb_mode
 3011               	.LVL272:
 272:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3012               		.loc 3 272 0
 3013 025e 00D0      		rcall usart_read_chars
 3014               	.LVL273:
 273:main.c        **** 			
 3015               		.loc 3 273 0
 3016 0260 40E1      		ldi r20,lo8(16)
 3017 0262 50E0      		ldi r21,0
 3018 0264 60E0      		ldi r22,0
 3019 0266 70E0      		ldi r23,0
 3020 0268 80E0      		ldi r24,lo8(receivedBuffer)
 3021 026a 90E0      		ldi r25,hi8(receivedBuffer)
 3022 026c 00D0      		rcall strtol
 3023               	.LVL274:
 3024 026e 862F      		mov r24,r22
 3025               	.LVL275:
 275:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3026               		.loc 3 275 0
 3027 0270 00D0      		rcall flash_erase_4k_sector
 3028               	.LVL276:
 3029               	.L270:
 276:main.c        **** 			
 3030               		.loc 3 276 0
 3031 0272 81E3      		ldi r24,lo8(49)
 3032 0274 00C0      		rjmp .L269
 3033               	.LVL277:
 3034               	.L126:
 3035               	.LBE203:
 282:main.c        **** 			gb_mode();
 3036               		.loc 3 282 0
 3037 0276 9236      		cpi r25,lo8(98)
 3038 0278 01F4      		brne .L127
 283:main.c        **** 			
 3039               		.loc 3 283 0
 3040 027a 00D0      		rcall gb_mode
 3041               	.LVL278:
 285:main.c        **** 			
 3042               		.loc 3 285 0
 3043 027c 80E4      		ldi r24,lo8(64)
 3044 027e 90E0      		ldi r25,0
 3045 0280 00D0      		rcall usart_read_bytes
 3046               	.LVL279:
 287:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3047               		.loc 3 287 0
 3048 0282 939A      		sbi 0x12,3
 3049               	.LVL280:
 3050 0284 B0E0      		ldi r27,lo8(receivedBuffer)
 3051 0286 AB2E      		mov r10,r27
 3052 0288 B0E0      		ldi r27,hi8(receivedBuffer)
 3053 028a BB2E      		mov r11,r27
 3054 028c 00E0      		ldi r16,0
 3055 028e 10E0      		ldi r17,0
 3056               	.LVL281:
 3057               	.L128:
 3058               	.LBB204:
 289:main.c        **** 				address++;
 3059               		.loc 3 289 0 discriminator 3
 3060 0290 F501      		movw r30,r10
 3061 0292 6191      		ld r22,Z+
 3062 0294 5F01      		movw r10,r30
 3063 0296 C801      		movw r24,r16
 3064 0298 8C0D      		add r24,r12
 3065 029a 9D1D      		adc r25,r13
 3066 029c 00D0      		rcall flash_write_byte
 3067               	.LVL282:
 3068 029e 0F5F      		subi r16,-1
 3069 02a0 1F4F      		sbci r17,-1
 3070               	.LVL283:
 288:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3071               		.loc 3 288 0 discriminator 3
 3072 02a2 0034      		cpi r16,64
 3073 02a4 1105      		cpc r17,__zero_reg__
 3074 02a6 01F4      		brne .L128
 3075 02a8 00C0      		rjmp .L268
 3076               	.LVL284:
 3077               	.L127:
 3078               	.LBE204:
 299:main.c        **** 			gb_mode();
 3079               		.loc 3 299 0
 3080 02aa 9136      		cpi r25,lo8(97)
 3081 02ac 01F4      		brne .L129
 300:main.c        **** 			
 3082               		.loc 3 300 0
 3083 02ae 00D0      		rcall gb_mode
 3084               	.LVL285:
 302:main.c        **** 			
 3085               		.loc 3 302 0
 3086 02b0 80E8      		ldi r24,lo8(-128)
 3087 02b2 90E0      		ldi r25,0
 3088 02b4 00D0      		rcall usart_read_bytes
 3089               	.LVL286:
 304:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3090               		.loc 3 304 0
 3091 02b6 939A      		sbi 0x12,3
 305:main.c        **** 			address++;
 3092               		.loc 3 305 0
 3093 02b8 C601      		movw r24,r12
 3094 02ba 00D0      		rcall flash_write_sector
 3095               	.LVL287:
 306:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3096               		.loc 3 306 0
 3097 02bc 2FEF      		ldi r18,-1
 3098 02be C21A      		sub r12,r18
 3099 02c0 D20A      		sbc r13,r18
 3100 02c2 E20A      		sbc r14,r18
 3101 02c4 F20A      		sbc r15,r18
 3102               	.LVL288:
 3103 02c6 00C0      		rjmp .L267
 3104               	.LVL289:
 3105               	.L129:
 316:main.c        **** 			usart_read_chars(); // Read size
 3106               		.loc 3 316 0
 3107 02c8 9335      		cpi r25,lo8(83)
 3108 02ca 01F4      		brne .L130
 317:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3109               		.loc 3 317 0
 3110 02cc 00D0      		rcall usart_read_chars
 3111               	.LVL290:
 318:main.c        **** 		}
 3112               		.loc 3 318 0
 3113 02ce 40E1      		ldi r20,lo8(16)
 3114 02d0 50E0      		ldi r21,0
 3115 02d2 60E0      		ldi r22,0
 3116 02d4 70E0      		ldi r23,0
 3117 02d6 80E0      		ldi r24,lo8(receivedBuffer)
 3118 02d8 90E0      		ldi r25,hi8(receivedBuffer)
 3119 02da 00D0      		rcall strtol
 3120               	.LVL291:
 3121 02dc D62F      		mov r29,r22
 3122               	.LVL292:
 3123 02de 00C0      		rjmp .L95
 3124               	.LVL293:
 3125               	.L130:
 322:main.c        **** 			gba_eeprom_mode();
 3126               		.loc 3 322 0
 3127 02e0 9536      		cpi r25,lo8(101)
 3128 02e2 01F4      		brne .L131
 323:main.c        **** 			
 3129               		.loc 3 323 0
 3130 02e4 00D0      		rcall gba_eeprom_mode
 3131               	.LVL294:
 325:main.c        **** 			while (receivedChar == '1') {
 3132               		.loc 3 325 0
 3133 02e6 3092 0000 		sts receivedChar,r3
 3134               	.L132:
 326:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3135               		.loc 3 326 0
 3136 02ea 8091 0000 		lds r24,receivedChar
 3137 02ee 8133      		cpi r24,lo8(49)
 3138 02f0 01F0      		breq .+2
 3139 02f2 00C0      		rjmp .L265
 327:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3140               		.loc 3 327 0
 3141 02f4 939A      		sbi 0x12,3
 328:main.c        **** 				
 3142               		.loc 3 328 0
 3143 02f6 6D2F      		mov r22,r29
 3144 02f8 C601      		movw r24,r12
 3145 02fa 00D0      		rcall gba_eeprom_read
 3146               	.LVL295:
 3147 02fc 00E0      		ldi r16,lo8(eepromBuffer)
 3148 02fe 10E0      		ldi r17,hi8(eepromBuffer)
 3149               	.LVL296:
 3150               	.L133:
 3151               	.LBB205:
 332:main.c        **** 				}
 3152               		.loc 3 332 0 discriminator 3
 3153 0300 F801      		movw r30,r16
 3154 0302 8191      		ld r24,Z+
 3155 0304 8F01      		movw r16,r30
 3156               	.LVL297:
 3157 0306 00D0      		rcall USART_Transmit
 3158               	.LVL298:
 331:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3159               		.loc 3 331 0 discriminator 3
 3160 0308 80E0      		ldi r24,lo8(eepromBuffer+8)
 3161 030a 90E0      		ldi r25,hi8(eepromBuffer+8)
 3162 030c 8017      		cp r24,r16
 3163 030e 9107      		cpc r25,r17
 3164 0310 01F4      		brne .L133
 3165               	.LBE205:
 334:main.c        **** 				
 3166               		.loc 3 334 0
 3167 0312 9FEF      		ldi r25,-1
 3168 0314 C91A      		sub r12,r25
 3169 0316 D90A      		sbc r13,r25
 3170 0318 E90A      		sbc r14,r25
 3171 031a F90A      		sbc r15,r25
 3172               	.LVL299:
 336:main.c        **** 				receivedChar = USART_Receive();
 3173               		.loc 3 336 0
 3174 031c 9398      		cbi 0x12,3
 337:main.c        **** 			}
 3175               		.loc 3 337 0
 3176 031e 00D0      		rcall USART_Receive
 3177               	.LVL300:
 3178 0320 8093 0000 		sts receivedChar,r24
 3179 0324 00C0      		rjmp .L132
 3180               	.LVL301:
 3181               	.L131:
 344:main.c        **** 			gba_eeprom_mode();
 3182               		.loc 3 344 0
 3183 0326 9037      		cpi r25,lo8(112)
 3184 0328 01F4      		brne .L135
 345:main.c        **** 			
 3185               		.loc 3 345 0
 3186 032a 00D0      		rcall gba_eeprom_mode
 3187               	.LVL302:
 3188 032c 00E0      		ldi r16,lo8(eepromBuffer)
 3189 032e 10E0      		ldi r17,hi8(eepromBuffer)
 3190               	.LVL303:
 3191               	.L136:
 3192               	.LBB206:
 349:main.c        **** 			}
 3193               		.loc 3 349 0 discriminator 3
 3194 0330 00D0      		rcall USART_Receive
 3195               	.LVL304:
 3196 0332 F801      		movw r30,r16
 3197 0334 8193      		st Z+,r24
 3198 0336 8F01      		movw r16,r30
 3199               	.LVL305:
 348:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3200               		.loc 3 348 0 discriminator 3
 3201 0338 80E0      		ldi r24,lo8(eepromBuffer+8)
 3202 033a 90E0      		ldi r25,hi8(eepromBuffer+8)
 3203 033c 8E17      		cp r24,r30
 3204 033e 9F07      		cpc r25,r31
 3205 0340 01F4      		brne .L136
 3206               	.LBE206:
 351:main.c        **** 			
 3207               		.loc 3 351 0
 3208 0342 939A      		sbi 0x12,3
 353:main.c        **** 			address++;
 3209               		.loc 3 353 0
 3210 0344 6D2F      		mov r22,r29
 3211 0346 C601      		movw r24,r12
 3212 0348 00D0      		rcall gba_eeprom_write
 3213               	.LVL306:
 354:main.c        **** 			
 3214               		.loc 3 354 0
 3215 034a 9FEF      		ldi r25,-1
 3216 034c C91A      		sub r12,r25
 3217 034e D90A      		sbc r13,r25
 3218 0350 E90A      		sbc r14,r25
 3219 0352 F90A      		sbc r15,r25
 3220               	.LVL307:
 3221               	.LBB207:
 3222               	.LBB208:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3223               		.loc 2 187 0
 3224 0354 EFE7      		ldi r30,lo8(15999)
 3225 0356 FEE3      		ldi r31,hi8(15999)
 3226 0358 3197      	1:	sbiw r30,1
 3227 035a 01F4      		brne 1b
 3228 035c 00C0      		rjmp .
 3229 035e 0000      		nop
 3230               	.LVL308:
 3231 0360 00C0      		rjmp .L267
 3232               	.LVL309:
 3233               	.L135:
 3234               	.LBE208:
 3235               	.LBE207:
 366:main.c        **** 			flashWriteWePin = USART_Receive();
 3236               		.loc 3 366 0
 3237 0362 9035      		cpi r25,lo8(80)
 3238 0364 01F4      		brne .L137
 367:main.c        **** 			
 3239               		.loc 3 367 0
 3240 0366 00D0      		rcall USART_Receive
 3241               	.LVL310:
 3242 0368 8093 0000 		sts flashWriteWePin,r24
 369:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3243               		.loc 3 369 0
 3244 036c 8134      		cpi r24,lo8(65)
 3245 036e 01F0      		breq .+2
 3246 0370 00C0      		rjmp .L95
 370:main.c        **** 				audioPin_high;
 3247               		.loc 3 370 0
 3248 0372 319A      		sbi 0x6,1
 371:main.c        **** 			}
 3249               		.loc 3 371 0
 3250 0374 399A      		sbi 0x7,1
 3251 0376 00C0      		rjmp .L95
 3252               	.LVL311:
 3253               	.L137:
 376:main.c        **** 			flashBank1CommandWrites = 1;
 3254               		.loc 3 376 0
 3255 0378 9E34      		cpi r25,lo8(78)
 3256 037a 01F4      		brne .L138
 377:main.c        **** 		}
 3257               		.loc 3 377 0
 3258 037c F1E0      		ldi r31,lo8(1)
 3259 037e F093 0000 		sts flashBank1CommandWrites,r31
 3260 0382 00C0      		rjmp .L95
 3261               	.L138:
 381:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3262               		.loc 3 381 0
 3263 0384 9534      		cpi r25,lo8(69)
 3264 0386 01F4      		brne .L139
 3265 0388 00E0      		ldi r16,lo8(flashWriteCycle)
 3266 038a 10E0      		ldi r17,hi8(flashWriteCycle)
 3267               	.LVL312:
 3268               	.L140:
 3269               	.LBB209:
 383:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3270               		.loc 3 383 0 discriminator 3
 3271 038c 00D0      		rcall usart_read_chars
 3272               	.LVL313:
 384:main.c        **** 				USART_Transmit(SEND_ACK);
 3273               		.loc 3 384 0 discriminator 3
 3274 038e 40E1      		ldi r20,lo8(16)
 3275 0390 50E0      		ldi r21,0
 3276 0392 60E0      		ldi r22,0
 3277 0394 70E0      		ldi r23,0
 3278 0396 80E0      		ldi r24,lo8(receivedBuffer)
 3279 0398 90E0      		ldi r25,hi8(receivedBuffer)
 3280 039a 00D0      		rcall strtol
 3281               	.LVL314:
 3282 039c F801      		movw r30,r16
 3283 039e 7183      		std Z+1,r23
 3284 03a0 6083      		st Z,r22
 385:main.c        **** 				
 3285               		.loc 3 385 0 discriminator 3
 3286 03a2 81E3      		ldi r24,lo8(49)
 3287 03a4 00D0      		rcall USART_Transmit
 3288               	.LVL315:
 387:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3289               		.loc 3 387 0 discriminator 3
 3290 03a6 00D0      		rcall usart_read_chars
 3291               	.LVL316:
 388:main.c        **** 				USART_Transmit(SEND_ACK);
 3292               		.loc 3 388 0 discriminator 3
 3293 03a8 40E1      		ldi r20,lo8(16)
 3294 03aa 50E0      		ldi r21,0
 3295 03ac 60E0      		ldi r22,0
 3296 03ae 70E0      		ldi r23,0
 3297 03b0 80E0      		ldi r24,lo8(receivedBuffer)
 3298 03b2 90E0      		ldi r25,hi8(receivedBuffer)
 3299 03b4 00D0      		rcall strtol
 3300               	.LVL317:
 3301 03b6 F801      		movw r30,r16
 3302 03b8 7383      		std Z+3,r23
 3303 03ba 6283      		std Z+2,r22
 389:main.c        **** 			}
 3304               		.loc 3 389 0 discriminator 3
 3305 03bc 81E3      		ldi r24,lo8(49)
 3306 03be 00D0      		rcall USART_Transmit
 3307               	.LVL318:
 3308 03c0 0C5F      		subi r16,-4
 3309 03c2 1F4F      		sbci r17,-1
 382:main.c        **** 				usart_read_chars(); // Address
 3310               		.loc 3 382 0 discriminator 3
 3311 03c4 F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3312 03c6 0030      		cpi r16,lo8(flashWriteCycle+12)
 3313 03c8 1F07      		cpc r17,r31
 3314 03ca 01F4      		brne .L140
 3315 03cc 00C0      		rjmp .L95
 3316               	.LVL319:
 3317               	.L139:
 3318               	.LBE209:
 394:main.c        **** 			usart_read_chars(); // Read address
 3319               		.loc 3 394 0
 3320 03ce 9634      		cpi r25,lo8(70)
 3321 03d0 01F4      		brne .L141
 3322               	.LBB210:
 395:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3323               		.loc 3 395 0
 3324 03d2 00D0      		rcall usart_read_chars
 3325               	.LVL320:
 396:main.c        **** 			
 3326               		.loc 3 396 0
 3327 03d4 40E1      		ldi r20,lo8(16)
 3328 03d6 50E0      		ldi r21,0
 3329 03d8 60E0      		ldi r22,0
 3330 03da 70E0      		ldi r23,0
 3331 03dc 80E0      		ldi r24,lo8(receivedBuffer)
 3332 03de 90E0      		ldi r25,hi8(receivedBuffer)
 3333 03e0 00D0      		rcall strtol
 3334               	.LVL321:
 3335 03e2 4B01      		movw r8,r22
 3336 03e4 5C01      		movw r10,r24
 3337               	.LVL322:
 398:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3338               		.loc 3 398 0
 3339 03e6 00D0      		rcall usart_read_chars
 3340               	.LVL323:
 399:main.c        **** 			
 3341               		.loc 3 399 0
 3342 03e8 40E1      		ldi r20,lo8(16)
 3343 03ea 50E0      		ldi r21,0
 3344 03ec 60E0      		ldi r22,0
 3345 03ee 70E0      		ldi r23,0
 3346 03f0 80E0      		ldi r24,lo8(receivedBuffer)
 3347 03f2 90E0      		ldi r25,hi8(receivedBuffer)
 3348 03f4 00D0      		rcall strtol
 3349               	.LVL324:
 401:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3350               		.loc 3 401 0
 3351 03f6 939A      		sbi 0x12,3
 402:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3352               		.loc 3 402 0
 3353 03f8 C401      		movw r24,r8
 3354 03fa 00D0      		rcall gb_flash_write_bus_cycle
 3355               	.LVL325:
 3356 03fc 00C0      		rjmp .L283
 3357               	.LVL326:
 3358               	.L141:
 3359               	.LBE210:
 409:main.c        **** 			usart_read_bytes(64);
 3360               		.loc 3 409 0
 3361 03fe 9435      		cpi r25,lo8(84)
 3362 0400 01F4      		brne .L142
 410:main.c        **** 			
 3363               		.loc 3 410 0
 3364 0402 80E4      		ldi r24,lo8(64)
 3365 0404 90E0      		ldi r25,0
 3366               	.LVL327:
 3367 0406 00D0      		rcall usart_read_bytes
 3368               	.LVL328:
 412:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3369               		.loc 3 412 0
 3370 0408 939A      		sbi 0x12,3
 413:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3371               		.loc 3 413 0
 3372 040a 8091 0000 		lds r24,flashBank1CommandWrites
 3373 040e A0E0      		ldi r26,lo8(receivedBuffer)
 3374 0410 AA2E      		mov r10,r26
 3375 0412 A0E0      		ldi r26,hi8(receivedBuffer)
 3376 0414 BA2E      		mov r11,r26
 3377 0416 00E0      		ldi r16,0
 3378 0418 10E0      		ldi r17,0
 3379 041a 8111      		cpse r24,__zero_reg__
 3380 041c 00C0      		rjmp .L148
 3381               	.LVL329:
 3382               	.L145:
 3383               	.LBB211:
 415:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3384               		.loc 3 415 0
 3385 041e F501      		movw r30,r10
 3386 0420 6191      		ld r22,Z+
 3387 0422 5F01      		movw r10,r30
 3388 0424 6F3F      		cpi r22,lo8(-1)
 3389 0426 01F0      		breq .L144
 416:main.c        **** 					}
 3390               		.loc 3 416 0
 3391 0428 C801      		movw r24,r16
 3392 042a 8C0D      		add r24,r12
 3393 042c 9D1D      		adc r25,r13
 3394 042e 00D0      		rcall gb_flash_write_byte
 3395               	.LVL330:
 3396               	.L144:
 3397 0430 0F5F      		subi r16,-1
 3398 0432 1F4F      		sbci r17,-1
 3399               	.LVL331:
 414:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3400               		.loc 3 414 0 discriminator 2
 3401 0434 0034      		cpi r16,64
 3402 0436 1105      		cpc r17,__zero_reg__
 3403 0438 01F4      		brne .L145
 3404 043a 00C0      		rjmp .L284
 3405               	.LVL332:
 3406               	.L147:
 3407 043c 0F5F      		subi r16,-1
 3408 043e 1F4F      		sbci r17,-1
 3409               	.LVL333:
 3410               	.LBE211:
 3411               	.LBB212:
 422:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3412               		.loc 3 422 0 discriminator 2
 3413 0440 0034      		cpi r16,64
 3414 0442 1105      		cpc r17,__zero_reg__
 3415 0444 01F4      		brne .+2
 3416 0446 00C0      		rjmp .L284
 3417               	.LVL334:
 3418               	.L148:
 423:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3419               		.loc 3 423 0
 3420 0448 F501      		movw r30,r10
 3421 044a 6191      		ld r22,Z+
 3422 044c 5F01      		movw r10,r30
 3423 044e 6F3F      		cpi r22,lo8(-1)
 3424 0450 01F0      		breq .L147
 424:main.c        **** 					}
 3425               		.loc 3 424 0
 3426 0452 C801      		movw r24,r16
 3427 0454 8C0D      		add r24,r12
 3428 0456 9D1D      		adc r25,r13
 3429 0458 00D0      		rcall gb_flash_write_byte_bank1_commands
 3430               	.LVL335:
 3431 045a 00C0      		rjmp .L147
 3432               	.LVL336:
 3433               	.L142:
 3434               	.LBE212:
 435:main.c        **** 			usart_read_bytes(32);
 3435               		.loc 3 435 0
 3436 045c 9935      		cpi r25,lo8(89)
 3437 045e 01F0      		breq .+2
 3438 0460 00C0      		rjmp .L149
 3439               	.LBB213:
 436:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3440               		.loc 3 436 0
 3441 0462 80E2      		ldi r24,lo8(32)
 3442 0464 90E0      		ldi r25,0
 3443               	.LVL337:
 3444 0466 00D0      		rcall usart_read_bytes
 3445               	.LVL338:
 437:main.c        **** 			
 3446               		.loc 3 437 0
 3447 0468 939A      		sbi 0x12,3
 440:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3448               		.loc 3 440 0
 3449 046a 6AEA      		ldi r22,lo8(-86)
 3450 046c 8AEA      		ldi r24,lo8(-86)
 3451 046e 9AE0      		ldi r25,lo8(10)
 3452 0470 00D0      		rcall gb_flash_write_bus_cycle
 3453               	.LVL339:
 441:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3454               		.loc 3 441 0
 3455 0472 65E5      		ldi r22,lo8(85)
 3456 0474 85E5      		ldi r24,lo8(85)
 3457 0476 95E0      		ldi r25,lo8(5)
 3458 0478 00D0      		rcall gb_flash_write_bus_cycle
 3459               	.LVL340:
 442:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3460               		.loc 3 442 0
 3461 047a 5601      		movw r10,r12
 3462 047c 65E2      		ldi r22,lo8(37)
 3463 047e C601      		movw r24,r12
 3464 0480 00D0      		rcall gb_flash_write_bus_cycle
 3465               	.LVL341:
 443:main.c        **** 			_delay_us(1);
 3466               		.loc 3 443 0
 3467 0482 6FE1      		ldi r22,lo8(31)
 3468 0484 C601      		movw r24,r12
 3469 0486 00D0      		rcall gb_flash_write_bus_cycle
 3470               	.LVL342:
 3471               	.LBB214:
 3472               	.LBB215:
 3473               		.loc 2 276 0
 3474 0488 22E0      		ldi r18,lo8(2)
 3475 048a 2A95      	1:	dec r18
 3476 048c 01F4      		brne 1b
 3477 048e 00C0      		rjmp .
 3478               	.LVL343:
 3479 0490 00E0      		ldi r16,lo8(receivedBuffer)
 3480 0492 10E0      		ldi r17,hi8(receivedBuffer)
 3481 0494 812C      		mov r8,__zero_reg__
 3482 0496 912C      		mov r9,__zero_reg__
 3483               	.LVL344:
 3484               	.L150:
 3485               	.LBE215:
 3486               	.LBE214:
 3487               	.LBB216:
 448:main.c        **** 				address++;
 3488               		.loc 3 448 0 discriminator 3
 3489 0498 F801      		movw r30,r16
 3490 049a 6191      		ld r22,Z+
 3491 049c 8F01      		movw r16,r30
 3492 049e C401      		movw r24,r8
 3493 04a0 8A0D      		add r24,r10
 3494 04a2 9B1D      		adc r25,r11
 3495 04a4 00D0      		rcall gb_flash_write_bus_cycle
 3496               	.LVL345:
 3497 04a6 FFEF      		ldi r31,-1
 3498 04a8 8F1A      		sub r8,r31
 3499 04aa 9F0A      		sbc r9,r31
 3500               	.LVL346:
 447:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3501               		.loc 3 447 0 discriminator 3
 3502 04ac 20E2      		ldi r18,32
 3503 04ae 8216      		cp r8,r18
 3504 04b0 9104      		cpc r9,__zero_reg__
 3505 04b2 01F4      		brne .L150
 3506 04b4 80E2      		ldi r24,32
 3507 04b6 C80E      		add r12,r24
 3508 04b8 D11C      		adc r13,__zero_reg__
 3509 04ba E11C      		adc r14,__zero_reg__
 3510 04bc F11C      		adc r15,__zero_reg__
 3511               	.LBE216:
 453:main.c        **** 			_delay_us(200);
 3512               		.loc 3 453 0
 3513 04be C601      		movw r24,r12
 3514 04c0 8097      		sbiw r24,32
 3515 04c2 69E2      		ldi r22,lo8(41)
 3516 04c4 00D0      		rcall gb_flash_write_bus_cycle
 3517               	.LVL347:
 3518               	.LBB217:
 3519               	.LBB218:
 3520               		.loc 2 276 0
 3521 04c6 EFE8      		ldi r30,lo8(399)
 3522 04c8 F1E0      		ldi r31,hi8(399)
 3523 04ca 3197      	1:	sbiw r30,1
 3524 04cc 01F4      		brne 1b
 3525 04ce 00C0      		rjmp .
 3526 04d0 0000      		nop
 3527               	.LVL348:
 3528               	.LBE218:
 3529               	.LBE217:
 457:main.c        **** 			uint8_t verifyCount = 0;
 3530               		.loc 3 457 0
 3531 04d2 8601      		movw r16,r12
 3532 04d4 0150      		subi r16,1
 3533 04d6 1109      		sbc r17,__zero_reg__
 3534 04d8 C801      		movw r24,r16
 3535 04da 00D0      		rcall gb_flash_read_byte
 3536               	.LVL349:
 459:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3537               		.loc 3 459 0
 3538 04dc F8EC      		ldi r31,lo8(-56)
 3539 04de BF2E      		mov r11,r31
 3540               	.LVL350:
 3541               	.L151:
 3542 04e0 9091 0000 		lds r25,receivedBuffer+31
 3543 04e4 8917      		cp r24,r25
 3544 04e6 01F4      		brne .+2
 3545 04e8 00C0      		rjmp .L272
 460:main.c        **** 				_delay_us(5);
 3546               		.loc 3 460 0
 3547 04ea C801      		movw r24,r16
 3548               	.LVL351:
 3549 04ec 00D0      		rcall gb_flash_read_byte
 3550               	.LVL352:
 3551               	.LBB219:
 3552               	.LBB220:
 3553               		.loc 2 276 0
 3554 04ee FDE0      		ldi r31,lo8(13)
 3555 04f0 FA95      	1:	dec r31
 3556 04f2 01F4      		brne 1b
 3557 04f4 0000      		nop
 3558               	.LVL353:
 3559 04f6 BA94      		dec r11
 3560               	.LVL354:
 3561               	.LBE220:
 3562               	.LBE219:
 464:main.c        **** 					_delay_ms(500);
 3563               		.loc 3 464 0
 3564 04f8 B110      		cpse r11,__zero_reg__
 3565 04fa 00C0      		rjmp .L151
 3566               	.LVL355:
 3567               	.LBB221:
 3568               	.LBB222:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3569               		.loc 2 187 0
 3570 04fc 2FEF      		ldi r18,lo8(799999)
 3571 04fe 84E3      		ldi r24,hi8(799999)
 3572 0500 9CE0      		ldi r25,hlo8(799999)
 3573 0502 2150      	1:	subi r18,1
 3574 0504 8040      		sbci r24,0
 3575 0506 9040      		sbci r25,0
 3576 0508 01F4      		brne 1b
 3577               	.LVL356:
 3578 050a 00C0      		rjmp .L285
 3579               	.LVL357:
 3580               	.L149:
 3581               	.LBE222:
 3582               	.LBE221:
 3583               	.LBE213:
 475:main.c        **** 			usart_read_bytes(64);
 3584               		.loc 3 475 0
 3585 050c 9A34      		cpi r25,lo8(74)
 3586 050e 01F4      		brne .L154
 476:main.c        **** 			
 3587               		.loc 3 476 0
 3588 0510 80E4      		ldi r24,lo8(64)
 3589 0512 90E0      		ldi r25,0
 3590               	.LVL358:
 3591 0514 00D0      		rcall usart_read_bytes
 3592               	.LVL359:
 478:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3593               		.loc 3 478 0
 3594 0516 939A      		sbi 0x12,3
 3595               	.LVL360:
 3596 0518 E0E0      		ldi r30,lo8(receivedBuffer)
 3597 051a AE2E      		mov r10,r30
 3598 051c E0E0      		ldi r30,hi8(receivedBuffer)
 3599 051e BE2E      		mov r11,r30
 3600 0520 00E0      		ldi r16,0
 3601 0522 10E0      		ldi r17,0
 3602               	.LVL361:
 3603               	.L156:
 3604               	.LBB223:
 480:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3605               		.loc 3 480 0
 3606 0524 F501      		movw r30,r10
 3607 0526 6191      		ld r22,Z+
 3608 0528 5F01      		movw r10,r30
 3609 052a 6F3F      		cpi r22,lo8(-1)
 3610 052c 01F0      		breq .L155
 481:main.c        **** 				}
 3611               		.loc 3 481 0
 3612 052e C801      		movw r24,r16
 3613 0530 8C0D      		add r24,r12
 3614 0532 9D1D      		adc r25,r13
 3615 0534 00D0      		rcall gb_flash_write_byte_special
 3616               	.LVL362:
 3617               	.L155:
 3618 0536 0F5F      		subi r16,-1
 3619 0538 1F4F      		sbci r17,-1
 3620               	.LVL363:
 479:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 3621               		.loc 3 479 0 discriminator 2
 3622 053a 0034      		cpi r16,64
 3623 053c 1105      		cpc r17,__zero_reg__
 3624 053e 01F4      		brne .L156
 3625               	.LVL364:
 3626               	.L284:
 3627 0540 F0E4      		ldi r31,64
 3628 0542 CF0E      		add r12,r31
 3629 0544 D11C      		adc r13,__zero_reg__
 3630 0546 E11C      		adc r14,__zero_reg__
 3631 0548 F11C      		adc r15,__zero_reg__
 3632 054a 00C0      		rjmp .L272
 3633               	.LVL365:
 3634               	.L154:
 3635               	.LBE223:
 491:main.c        **** 			usart_read_bytes(256);
 3636               		.loc 3 491 0
 3637 054c 9835      		cpi r25,lo8(88)
 3638 054e 01F0      		breq .+2
 3639 0550 00C0      		rjmp .L157
 3640               	.LBB224:
 492:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3641               		.loc 3 492 0
 3642 0552 80E0      		ldi r24,0
 3643 0554 91E0      		ldi r25,lo8(1)
 3644               	.LVL366:
 3645 0556 00D0      		rcall usart_read_bytes
 3646               	.LVL367:
 493:main.c        **** 			
 3647               		.loc 3 493 0
 3648 0558 939A      		sbi 0x12,3
 496:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3649               		.loc 3 496 0
 3650 055a 69EA      		ldi r22,lo8(-87)
 3651 055c 8AEA      		ldi r24,lo8(-86)
 3652 055e 9AE0      		ldi r25,lo8(10)
 3653 0560 00D0      		rcall gb_flash_write_bus_cycle
 3654               	.LVL368:
 497:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3655               		.loc 3 497 0
 3656 0562 66E5      		ldi r22,lo8(86)
 3657 0564 85E5      		ldi r24,lo8(85)
 3658 0566 95E0      		ldi r25,lo8(5)
 3659 0568 00D0      		rcall gb_flash_write_bus_cycle
 3660               	.LVL369:
 498:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3661               		.loc 3 498 0
 3662 056a 5601      		movw r10,r12
 3663 056c 66E2      		ldi r22,lo8(38)
 3664 056e C601      		movw r24,r12
 3665 0570 00D0      		rcall gb_flash_write_bus_cycle
 3666               	.LVL370:
 499:main.c        **** 			_delay_us(50);
 3667               		.loc 3 499 0
 3668 0572 6FEF      		ldi r22,lo8(-1)
 3669 0574 C601      		movw r24,r12
 3670 0576 00D0      		rcall gb_flash_write_bus_cycle
 3671               	.LVL371:
 3672               	.LBB225:
 3673               	.LBB226:
 3674               		.loc 2 276 0
 3675 0578 25E8      		ldi r18,lo8(-123)
 3676 057a 2A95      	1:	dec r18
 3677 057c 01F4      		brne 1b
 3678 057e 0000      		nop
 3679               	.LVL372:
 3680 0580 00E0      		ldi r16,lo8(receivedBuffer)
 3681 0582 10E0      		ldi r17,hi8(receivedBuffer)
 3682               	.LBE226:
 3683               	.LBE225:
 3684               	.LBB227:
 503:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3685               		.loc 3 503 0
 3686 0584 812C      		mov r8,__zero_reg__
 3687 0586 912C      		mov r9,__zero_reg__
 3688               	.LVL373:
 3689               	.L158:
 504:main.c        **** 				address++;
 3690               		.loc 3 504 0 discriminator 3
 3691 0588 F801      		movw r30,r16
 3692 058a 6191      		ld r22,Z+
 3693 058c 8F01      		movw r16,r30
 3694 058e C401      		movw r24,r8
 3695 0590 8A0D      		add r24,r10
 3696 0592 9B1D      		adc r25,r11
 3697 0594 00D0      		rcall gb_flash_write_bus_cycle
 3698               	.LVL374:
 503:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3699               		.loc 3 503 0 discriminator 3
 3700 0596 FFEF      		ldi r31,-1
 3701 0598 8F1A      		sub r8,r31
 3702 059a 9F0A      		sbc r9,r31
 3703               	.LVL375:
 3704 059c 8114      		cp r8,__zero_reg__
 3705 059e 21E0      		ldi r18,1
 3706 05a0 9206      		cpc r9,r18
 3707 05a2 01F4      		brne .L158
 3708 05a4 8FEF      		ldi r24,-1
 3709 05a6 D81A      		sub r13,r24
 3710 05a8 E80A      		sbc r14,r24
 3711 05aa F80A      		sbc r15,r24
 3712               	.LBE227:
 509:main.c        **** 			
 3713               		.loc 3 509 0
 3714 05ac C601      		movw r24,r12
 3715 05ae 9A95      		dec r25
 3716 05b0 6AE2      		ldi r22,lo8(42)
 3717 05b2 00D0      		rcall gb_flash_write_bus_cycle
 3718               	.LVL376:
 512:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 3719               		.loc 3 512 0
 3720 05b4 8601      		movw r16,r12
 3721 05b6 0150      		subi r16,1
 3722 05b8 1109      		sbc r17,__zero_reg__
 3723 05ba C801      		movw r24,r16
 3724 05bc 00D0      		rcall gb_flash_read_byte
 3725               	.LVL377:
 3726               	.L159:
 513:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3727               		.loc 3 513 0
 3728 05be 9091 0000 		lds r25,receivedBuffer+255
 3729 05c2 8917      		cp r24,r25
 3730 05c4 01F4      		brne .+2
 3731 05c6 00C0      		rjmp .L272
 514:main.c        **** 				_delay_us(5);
 3732               		.loc 3 514 0
 3733 05c8 C801      		movw r24,r16
 3734               	.LVL378:
 3735 05ca 00D0      		rcall gb_flash_read_byte
 3736               	.LVL379:
 3737               	.LBB228:
 3738               	.LBB229:
 3739               		.loc 2 276 0
 3740 05cc 9DE0      		ldi r25,lo8(13)
 3741 05ce 9A95      	1:	dec r25
 3742 05d0 01F4      		brne 1b
 3743 05d2 0000      		nop
 3744 05d4 00C0      		rjmp .L159
 3745               	.LVL380:
 3746               	.L157:
 3747               	.LBE229:
 3748               	.LBE228:
 3749               	.LBE224:
 523:main.c        **** 			usart_read_bytes(128);
 3750               		.loc 3 523 0
 3751 05d6 9A35      		cpi r25,lo8(90)
 3752 05d8 01F0      		breq .+2
 3753 05da 00C0      		rjmp .L161
 524:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3754               		.loc 3 524 0
 3755 05dc 80E8      		ldi r24,lo8(-128)
 3756 05de 90E0      		ldi r25,0
 3757               	.LVL381:
 3758 05e0 00D0      		rcall usart_read_bytes
 3759               	.LVL382:
 525:main.c        **** 			
 3760               		.loc 3 525 0
 3761 05e2 939A      		sbi 0x12,3
 528:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 3762               		.loc 3 528 0
 3763 05e4 69E0      		ldi r22,lo8(9)
 3764 05e6 80E2      		ldi r24,lo8(32)
 3765 05e8 91E0      		ldi r25,lo8(1)
 3766 05ea 00D0      		rcall gb_flash_write_bus_cycle
 3767               	.LVL383:
 529:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 3768               		.loc 3 529 0
 3769 05ec 6AEA      		ldi r22,lo8(-86)
 3770 05ee 81E2      		ldi r24,lo8(33)
 3771 05f0 91E0      		ldi r25,lo8(1)
 3772 05f2 00D0      		rcall gb_flash_write_bus_cycle
 3773               	.LVL384:
 530:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3774               		.loc 3 530 0
 3775 05f4 65E5      		ldi r22,lo8(85)
 3776 05f6 82E2      		ldi r24,lo8(34)
 3777 05f8 91E0      		ldi r25,lo8(1)
 3778 05fa 00D0      		rcall gb_flash_write_bus_cycle
 3779               	.LVL385:
 531:main.c        **** 			_delay_us(5);
 3780               		.loc 3 531 0
 3781 05fc 65EA      		ldi r22,lo8(-91)
 3782 05fe 8FE3      		ldi r24,lo8(63)
 3783 0600 91E0      		ldi r25,lo8(1)
 3784 0602 00D0      		rcall gb_flash_write_bus_cycle
 3785               	.LVL386:
 3786               	.LBB230:
 3787               	.LBB231:
 3788               		.loc 2 276 0
 3789 0604 EDE0      		ldi r30,lo8(13)
 3790 0606 EA95      	1:	dec r30
 3791 0608 01F4      		brne 1b
 3792 060a 0000      		nop
 3793               	.LVL387:
 3794               	.LBE231:
 3795               	.LBE230:
 535:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3796               		.loc 3 535 0
 3797 060c 61E1      		ldi r22,lo8(17)
 3798 060e 80E2      		ldi r24,lo8(32)
 3799 0610 91E0      		ldi r25,lo8(1)
 3800 0612 00D0      		rcall gb_flash_write_bus_cycle
 3801               	.LVL388:
 536:main.c        **** 			_delay_us(5);
 3802               		.loc 3 536 0
 3803 0614 65EA      		ldi r22,lo8(-91)
 3804 0616 8FE3      		ldi r24,lo8(63)
 3805 0618 91E0      		ldi r25,lo8(1)
 3806 061a 00D0      		rcall gb_flash_write_bus_cycle
 3807               	.LVL389:
 3808               	.LBB232:
 3809               	.LBB233:
 3810               		.loc 2 276 0
 3811 061c FDE0      		ldi r31,lo8(13)
 3812 061e FA95      	1:	dec r31
 3813 0620 01F4      		brne 1b
 3814 0622 0000      		nop
 3815               	.LVL390:
 3816               	.LBE233:
 3817               	.LBE232:
 540:main.c        **** 			_delay_us(5);
 3818               		.loc 3 540 0
 3819 0624 61E0      		ldi r22,lo8(1)
 3820 0626 80E0      		ldi r24,0
 3821 0628 91E2      		ldi r25,lo8(33)
 3822 062a 00D0      		rcall gb_flash_write_bus_cycle
 3823               	.LVL391:
 3824               	.LBB234:
 3825               	.LBB235:
 3826               		.loc 2 276 0
 3827 062c 2DE0      		ldi r18,lo8(13)
 3828 062e 2A95      	1:	dec r18
 3829 0630 01F4      		brne 1b
 3830 0632 0000      		nop
 3831               	.LVL392:
 3832               	.LBE235:
 3833               	.LBE234:
 545:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3834               		.loc 3 545 0
 3835 0634 6FE0      		ldi r22,lo8(15)
 3836 0636 80E2      		ldi r24,lo8(32)
 3837 0638 91E0      		ldi r25,lo8(1)
 3838 063a 00D0      		rcall gb_flash_write_bus_cycle
 3839               	.LVL393:
 546:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3840               		.loc 3 546 0
 3841 063c 65E5      		ldi r22,lo8(85)
 3842 063e 85E2      		ldi r24,lo8(37)
 3843 0640 91E0      		ldi r25,lo8(1)
 3844 0642 00D0      		rcall gb_flash_write_bus_cycle
 3845               	.LVL394:
 547:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 3846               		.loc 3 547 0
 3847 0644 65E5      		ldi r22,lo8(85)
 3848 0646 86E2      		ldi r24,lo8(38)
 3849 0648 91E0      		ldi r25,lo8(1)
 3850 064a 00D0      		rcall gb_flash_write_bus_cycle
 3851               	.LVL395:
 548:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3852               		.loc 3 548 0
 3853 064c 6AEA      		ldi r22,lo8(-86)
 3854 064e 87E2      		ldi r24,lo8(39)
 3855 0650 91E0      		ldi r25,lo8(1)
 3856 0652 00D0      		rcall gb_flash_write_bus_cycle
 3857               	.LVL396:
 549:main.c        **** 			_delay_us(5);
 3858               		.loc 3 549 0
 3859 0654 65EA      		ldi r22,lo8(-91)
 3860 0656 8FE3      		ldi r24,lo8(63)
 3861 0658 91E0      		ldi r25,lo8(1)
 3862 065a 00D0      		rcall gb_flash_write_bus_cycle
 3863               	.LVL397:
 3864               	.LBB236:
 3865               	.LBB237:
 3866               		.loc 2 276 0
 3867 065c 8DE0      		ldi r24,lo8(13)
 3868 065e 8A95      	1:	dec r24
 3869 0660 01F4      		brne 1b
 3870 0662 0000      		nop
 3871               	.LVL398:
 3872               	.LBE237:
 3873               	.LBE236:
 552:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 3874               		.loc 3 552 0
 3875 0664 6FE0      		ldi r22,lo8(15)
 3876 0666 80E2      		ldi r24,lo8(32)
 3877 0668 91E0      		ldi r25,lo8(1)
 3878 066a 00D0      		rcall gb_flash_write_bus_cycle
 3879               	.LVL399:
 553:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 3880               		.loc 3 553 0
 3881 066c 6AE2      		ldi r22,lo8(42)
 3882 066e 85E2      		ldi r24,lo8(37)
 3883 0670 91E0      		ldi r25,lo8(1)
 3884 0672 00D0      		rcall gb_flash_write_bus_cycle
 3885               	.LVL400:
 554:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 3886               		.loc 3 554 0
 3887 0674 6AEA      		ldi r22,lo8(-86)
 3888 0676 86E2      		ldi r24,lo8(38)
 3889 0678 91E0      		ldi r25,lo8(1)
 3890 067a 00D0      		rcall gb_flash_write_bus_cycle
 3891               	.LVL401:
 555:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3892               		.loc 3 555 0
 3893 067c 65E5      		ldi r22,lo8(85)
 3894 067e 87E2      		ldi r24,lo8(39)
 3895 0680 91E0      		ldi r25,lo8(1)
 3896 0682 00D0      		rcall gb_flash_write_bus_cycle
 3897               	.LVL402:
 556:main.c        **** 			_delay_us(5);
 3898               		.loc 3 556 0
 3899 0684 65EA      		ldi r22,lo8(-91)
 3900 0686 8FE3      		ldi r24,lo8(63)
 3901 0688 91E0      		ldi r25,lo8(1)
 3902 068a 00D0      		rcall gb_flash_write_bus_cycle
 3903               	.LVL403:
 3904               	.LBB238:
 3905               	.LBB239:
 3906               		.loc 2 276 0
 3907 068c 9DE0      		ldi r25,lo8(13)
 3908 068e 9A95      	1:	dec r25
 3909 0690 01F4      		brne 1b
 3910 0692 0000      		nop
 3911               	.LVL404:
 3912               	.LBE239:
 3913               	.LBE238:
 559:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 3914               		.loc 3 559 0
 3915 0694 6FE0      		ldi r22,lo8(15)
 3916 0696 80E2      		ldi r24,lo8(32)
 3917 0698 91E0      		ldi r25,lo8(1)
 3918 069a 00D0      		rcall gb_flash_write_bus_cycle
 3919               	.LVL405:
 560:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 3920               		.loc 3 560 0
 3921 069c 65E5      		ldi r22,lo8(85)
 3922 069e 85E2      		ldi r24,lo8(37)
 3923 06a0 91E0      		ldi r25,lo8(1)
 3924 06a2 00D0      		rcall gb_flash_write_bus_cycle
 3925               	.LVL406:
 561:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 3926               		.loc 3 561 0
 3927 06a4 65E5      		ldi r22,lo8(85)
 3928 06a6 86E2      		ldi r24,lo8(38)
 3929 06a8 91E0      		ldi r25,lo8(1)
 3930 06aa 00D0      		rcall gb_flash_write_bus_cycle
 3931               	.LVL407:
 562:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 3932               		.loc 3 562 0
 3933 06ac 60EA      		ldi r22,lo8(-96)
 3934 06ae 87E2      		ldi r24,lo8(39)
 3935 06b0 91E0      		ldi r25,lo8(1)
 3936 06b2 00D0      		rcall gb_flash_write_bus_cycle
 3937               	.LVL408:
 563:main.c        **** 			_delay_us(5);
 3938               		.loc 3 563 0
 3939 06b4 65EA      		ldi r22,lo8(-91)
 3940 06b6 8FE3      		ldi r24,lo8(63)
 3941 06b8 91E0      		ldi r25,lo8(1)
 3942 06ba 00D0      		rcall gb_flash_write_bus_cycle
 3943               	.LVL409:
 3944               	.LBB240:
 3945               	.LBB241:
 3946               		.loc 2 276 0
 3947 06bc EDE0      		ldi r30,lo8(13)
 3948 06be EA95      	1:	dec r30
 3949 06c0 01F4      		brne 1b
 3950 06c2 0000      		nop
 3951               	.LVL410:
 3952               	.LBE241:
 3953               	.LBE240:
 567:main.c        **** 			_delay_us(5);
 3954               		.loc 3 567 0
 3955 06c4 40E0      		ldi r20,0
 3956 06c6 6091 0000 		lds r22,lastBankAccessed
 3957 06ca 80E0      		ldi r24,0
 3958 06cc 91E2      		ldi r25,lo8(33)
 3959 06ce 00D0      		rcall write_8bit_data
 3960               	.LVL411:
 3961               	.LBB242:
 3962               	.LBB243:
 3963               		.loc 2 276 0
 3964 06d0 FDE0      		ldi r31,lo8(13)
 3965 06d2 FA95      	1:	dec r31
 3966 06d4 01F4      		brne 1b
 3967 06d6 0000      		nop
 3968               	.LVL412:
 3969               	.LBE243:
 3970               	.LBE242:
 571:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3971               		.loc 3 571 0
 3972 06d8 60E1      		ldi r22,lo8(16)
 3973 06da 80E2      		ldi r24,lo8(32)
 3974 06dc 91E0      		ldi r25,lo8(1)
 3975 06de 00D0      		rcall gb_flash_write_bus_cycle
 3976               	.LVL413:
 572:main.c        **** 			_delay_us(5);
 3977               		.loc 3 572 0
 3978 06e0 65EA      		ldi r22,lo8(-91)
 3979 06e2 8FE3      		ldi r24,lo8(63)
 3980 06e4 91E0      		ldi r25,lo8(1)
 3981 06e6 00D0      		rcall gb_flash_write_bus_cycle
 3982               	.LVL414:
 3983               	.LBB244:
 3984               	.LBB245:
 3985               		.loc 2 276 0
 3986 06e8 2DE0      		ldi r18,lo8(13)
 3987 06ea 2A95      	1:	dec r18
 3988 06ec 01F4      		brne 1b
 3989 06ee 0000      		nop
 3990               	.LVL415:
 3991               	.LBE245:
 3992               	.LBE244:
 576:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 3993               		.loc 3 576 0
 3994 06f0 68E0      		ldi r22,lo8(8)
 3995 06f2 80E2      		ldi r24,lo8(32)
 3996 06f4 91E0      		ldi r25,lo8(1)
 3997 06f6 00D0      		rcall gb_flash_write_bus_cycle
 3998               	.LVL416:
 577:main.c        **** 			_delay_us(5);
 3999               		.loc 3 577 0
 4000 06f8 65EA      		ldi r22,lo8(-91)
 4001 06fa 8FE3      		ldi r24,lo8(63)
 4002 06fc 91E0      		ldi r25,lo8(1)
 4003 06fe 00D0      		rcall gb_flash_write_bus_cycle
 4004               	.LVL417:
 4005               	.LBB246:
 4006               	.LBB247:
 4007               		.loc 2 276 0
 4008 0700 8DE0      		ldi r24,lo8(13)
 4009 0702 8A95      	1:	dec r24
 4010 0704 01F4      		brne 1b
 4011 0706 0000      		nop
 4012               	.LVL418:
 4013 0708 00E0      		ldi r16,lo8(receivedBuffer)
 4014 070a 10E0      		ldi r17,hi8(receivedBuffer)
 4015               	.L162:
 4016               	.LBE247:
 4017               	.LBE246:
 4018               	.LBB248:
 582:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4019               		.loc 3 582 0 discriminator 1
 4020 070c 80E0      		ldi r24,lo8(receivedBuffer+128)
 4021 070e 90E0      		ldi r25,hi8(receivedBuffer+128)
 4022 0710 8017      		cp r24,r16
 4023 0712 9107      		cpc r25,r17
 4024 0714 01F0      		breq .L286
 583:main.c        **** 				_delay_us(5);
 4025               		.loc 3 583 0 discriminator 3
 4026 0716 F801      		movw r30,r16
 4027 0718 6191      		ld r22,Z+
 4028 071a 8F01      		movw r16,r30
 4029 071c C601      		movw r24,r12
 4030 071e 00D0      		rcall gb_flash_write_bus_cycle
 4031               	.LVL419:
 4032               	.LBB249:
 4033               	.LBB250:
 4034               		.loc 2 276 0 discriminator 3
 4035 0720 FDE0      		ldi r31,lo8(13)
 4036 0722 FA95      	1:	dec r31
 4037 0724 01F4      		brne 1b
 4038 0726 0000      		nop
 4039               	.LVL420:
 4040               	.LBE250:
 4041               	.LBE249:
 585:main.c        **** 			}
 4042               		.loc 3 585 0 discriminator 3
 4043 0728 2FEF      		ldi r18,-1
 4044 072a C21A      		sub r12,r18
 4045 072c D20A      		sbc r13,r18
 4046 072e E20A      		sbc r14,r18
 4047 0730 F20A      		sbc r15,r18
 4048               	.LVL421:
 4049 0732 00C0      		rjmp .L162
 4050               	.L286:
 4051               	.LVL422:
 4052               	.LBE248:
 590:main.c        **** 			address++;
 4053               		.loc 3 590 0
 4054 0734 6FEF      		ldi r22,lo8(-1)
 4055 0736 D701      		movw r26,r14
 4056 0738 C601      		movw r24,r12
 4057 073a 0197      		sbiw r24,1
 4058 073c A109      		sbc r26,__zero_reg__
 4059 073e B109      		sbc r27,__zero_reg__
 4060               	.LVL423:
 4061 0740 00D0      		rcall gb_flash_write_bus_cycle
 4062               	.LVL424:
 4063               	.LBB251:
 4064               	.LBB252:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4065               		.loc 2 187 0
 4066 0742 EFE1      		ldi r30,lo8(19999)
 4067 0744 FEE4      		ldi r31,hi8(19999)
 4068 0746 3197      	1:	sbiw r30,1
 4069 0748 01F4      		brne 1b
 4070               	.LVL425:
 4071               	.L285:
 4072 074a 00C0      		rjmp .
 4073 074c 0000      		nop
 4074 074e 00C0      		rjmp .L272
 4075               	.LVL426:
 4076               	.L161:
 4077               	.LBE252:
 4078               	.LBE251:
 600:main.c        **** 			usart_read_chars(); // Read address
 4079               		.loc 3 600 0
 4080 0750 9E36      		cpi r25,lo8(110)
 4081 0752 01F4      		brne .L164
 4082               	.LBB253:
 601:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4083               		.loc 3 601 0
 4084 0754 00D0      		rcall usart_read_chars
 4085               	.LVL427:
 602:main.c        **** 			
 4086               		.loc 3 602 0
 4087 0756 40E1      		ldi r20,lo8(16)
 4088 0758 50E0      		ldi r21,0
 4089 075a 60E0      		ldi r22,0
 4090 075c 70E0      		ldi r23,0
 4091 075e 80E0      		ldi r24,lo8(receivedBuffer)
 4092 0760 90E0      		ldi r25,hi8(receivedBuffer)
 4093 0762 00D0      		rcall strtol
 4094               	.LVL428:
 4095 0764 4B01      		movw r8,r22
 4096 0766 5C01      		movw r10,r24
 4097               	.LVL429:
 604:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4098               		.loc 3 604 0
 4099 0768 00D0      		rcall USART_Receive
 4100               	.LVL430:
 4101 076a 8093 0000 		sts receivedChar,r24
 605:main.c        **** 				usart_read_chars(); // Read data
 4102               		.loc 3 605 0
 4103 076e 8E36      		cpi r24,lo8(110)
 4104 0770 01F0      		breq .+2
 4105 0772 00C0      		rjmp .L95
 4106               	.LBB254:
 606:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4107               		.loc 3 606 0
 4108 0774 00D0      		rcall usart_read_chars
 4109               	.LVL431:
 607:main.c        **** 				
 4110               		.loc 3 607 0
 4111 0776 40E1      		ldi r20,lo8(16)
 4112 0778 50E0      		ldi r21,0
 4113 077a 60E0      		ldi r22,0
 4114 077c 70E0      		ldi r23,0
 4115 077e 80E0      		ldi r24,lo8(receivedBuffer)
 4116 0780 90E0      		ldi r25,hi8(receivedBuffer)
 4117 0782 00D0      		rcall strtol
 4118               	.LVL432:
 609:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4119               		.loc 3 609 0
 4120 0784 939A      		sbi 0x12,3
 610:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4121               		.loc 3 610 0
 4122 0786 C4BB      		out 0x14,r28
 611:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4123               		.loc 3 611 0
 4124 0788 CABB      		out 0x1a,r28
 612:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4125               		.loc 3 612 0
 4126 078a C7BB      		out 0x17,r28
 613:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4127               		.loc 3 613 0
 4128 078c AB01      		movw r20,r22
 4129 078e C501      		movw r24,r10
 4130 0790 B401      		movw r22,r8
 4131               	.LVL433:
 4132 0792 00D0      		rcall gba_flash_write_bus_cycle
 4133               	.LVL434:
 4134               	.L283:
 614:main.c        **** 				
 4135               		.loc 3 614 0
 4136 0794 9398      		cbi 0x12,3
 616:main.c        **** 			}
 4137               		.loc 3 616 0
 4138 0796 81E3      		ldi r24,lo8(49)
 4139 0798 00C0      		rjmp .L263
 4140               	.LVL435:
 4141               	.L164:
 4142               	.LBE254:
 4143               	.LBE253:
 621:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4144               		.loc 3 621 0
 4145 079a 9137      		cpi r25,lo8(113)
 4146 079c 01F0      		breq .L165
 621:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4147               		.loc 3 621 0 is_stmt 0 discriminator 1
 4148 079e 9437      		cpi r25,lo8(116)
 4149 07a0 01F4      		brne .L166
 4150               	.L165:
 4151               	.LBB255:
 622:main.c        **** 			
 4152               		.loc 3 622 0 is_stmt 1
 4153 07a2 939A      		sbi 0x12,3
 4154               	.LVL436:
 625:main.c        **** 				readLength = 256;
 4155               		.loc 3 625 0
 4156 07a4 8091 0000 		lds r24,receivedChar
 4157               	.LVL437:
 4158 07a8 8437      		cpi r24,lo8(116)
 4159 07aa 01F4      		brne .L217
 626:main.c        **** 			}
 4160               		.loc 3 626 0
 4161 07ac 00E0      		ldi r16,0
 4162 07ae 11E0      		ldi r17,lo8(1)
 4163 07b0 00C0      		rjmp .L167
 4164               	.L217:
 624:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4165               		.loc 3 624 0
 4166 07b2 00E4      		ldi r16,lo8(64)
 4167 07b4 10E0      		ldi r17,0
 4168               	.L167:
 4169               	.LVL438:
 628:main.c        **** 			
 4170               		.loc 3 628 0
 4171 07b6 C801      		movw r24,r16
 4172 07b8 00D0      		rcall usart_read_bytes
 4173               	.LVL439:
 4174 07ba 70E0      		ldi r23,lo8(receivedBuffer)
 4175 07bc A72E      		mov r10,r23
 4176 07be 70E0      		ldi r23,hi8(receivedBuffer)
 4177 07c0 B72E      		mov r11,r23
 4178 07c2 2601      		movw r4,r12
 4179 07c4 3701      		movw r6,r14
 4180               	.LVL440:
 4181               	.L169:
 4182               	.LBB256:
 4183               	.LBB257:
 631:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4184               		.loc 3 631 0
 4185 07c6 F501      		movw r30,r10
 4186 07c8 4181      		ldd r20,Z+1
 4187 07ca 50E0      		ldi r21,0
 4188 07cc 542F      		mov r21,r20
 4189 07ce 4427      		clr r20
 4190 07d0 8081      		ld r24,Z
 4191 07d2 482B      		or r20,r24
 4192               	.LVL441:
 632:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4193               		.loc 3 632 0
 4194 07d4 4F3F      		cpi r20,-1
 4195 07d6 FFEF      		ldi r31,-1
 4196 07d8 5F07      		cpc r21,r31
 4197 07da 01F0      		breq .L168
 633:main.c        **** 				}
 4198               		.loc 3 633 0
 4199 07dc 21E0      		ldi r18,lo8(1)
 4200 07de C301      		movw r24,r6
 4201 07e0 B201      		movw r22,r4
 4202 07e2 00D0      		rcall gba_flash_write_byte
 4203               	.LVL442:
 4204               	.L168:
 635:main.c        **** 			}
 4205               		.loc 3 635 0 discriminator 2
 4206 07e4 2FEF      		ldi r18,-1
 4207 07e6 421A      		sub r4,r18
 4208 07e8 520A      		sbc r5,r18
 4209 07ea 620A      		sbc r6,r18
 4210 07ec 720A      		sbc r7,r18
 4211               	.LVL443:
 4212 07ee 82E0      		ldi r24,2
 4213 07f0 A80E      		add r10,r24
 4214 07f2 B11C      		adc r11,__zero_reg__
 4215               	.LVL444:
 4216               	.LBE257:
 630:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4217               		.loc 3 630 0 discriminator 2
 4218 07f4 C501      		movw r24,r10
 4219 07f6 8050      		subi r24,lo8(receivedBuffer)
 4220 07f8 9040      		sbci r25,hi8(receivedBuffer)
 4221 07fa 8017      		cp r24,r16
 4222 07fc 9107      		cpc r25,r17
 4223 07fe 04F0      		brlt .L169
 4224 0800 9FEF      		ldi r25,-1
 4225 0802 C91A      		sub r12,r25
 4226 0804 D90A      		sbc r13,r25
 4227 0806 E90A      		sbc r14,r25
 4228 0808 F90A      		sbc r15,r25
 4229 080a 0150      		subi r16,1
 4230 080c 1109      		sbc r17,__zero_reg__
 4231               	.LVL445:
 4232 080e 1695      		lsr r17
 4233 0810 0795      		ror r16
 4234               	.LVL446:
 4235 0812 C00E      		add r12,r16
 4236 0814 D11E      		adc r13,r17
 4237 0816 E11C      		adc r14,__zero_reg__
 4238 0818 F11C      		adc r15,__zero_reg__
 4239 081a 00C0      		rjmp .L272
 4240               	.LVL447:
 4241               	.L166:
 4242               	.LBE256:
 4243               	.LBE255:
 643:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4244               		.loc 3 643 0
 4245 081c 9636      		cpi r25,lo8(102)
 4246 081e 01F4      		brne .L170
 4247               	.LBB258:
 644:main.c        **** 			
 4248               		.loc 3 644 0
 4249 0820 939A      		sbi 0x12,3
 4250               	.LVL448:
 647:main.c        **** 			
 4251               		.loc 3 647 0
 4252 0822 80E0      		ldi r24,0
 4253 0824 91E0      		ldi r25,lo8(1)
 4254               	.LVL449:
 4255 0826 00D0      		rcall usart_read_bytes
 4256               	.LVL450:
 4257 0828 00E0      		ldi r16,lo8(receivedBuffer)
 4258 082a 10E0      		ldi r17,hi8(receivedBuffer)
 4259 082c 4601      		movw r8,r12
 4260 082e 5701      		movw r10,r14
 4261               	.LVL451:
 4262               	.L172:
 4263               	.LBB259:
 4264               	.LBB260:
 650:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4265               		.loc 3 650 0
 4266 0830 F801      		movw r30,r16
 4267 0832 4181      		ldd r20,Z+1
 4268 0834 50E0      		ldi r21,0
 4269 0836 542F      		mov r21,r20
 4270 0838 4427      		clr r20
 4271 083a 8081      		ld r24,Z
 4272 083c 482B      		or r20,r24
 4273               	.LVL452:
 651:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4274               		.loc 3 651 0
 4275 083e 4F3F      		cpi r20,-1
 4276 0840 FFEF      		ldi r31,-1
 4277 0842 5F07      		cpc r21,r31
 4278 0844 01F0      		breq .L171
 652:main.c        **** 				}
 4279               		.loc 3 652 0
 4280 0846 20E0      		ldi r18,0
 4281 0848 C501      		movw r24,r10
 4282 084a B401      		movw r22,r8
 4283 084c 00D0      		rcall gba_flash_write_byte
 4284               	.LVL453:
 4285               	.L171:
 654:main.c        **** 			}
 4286               		.loc 3 654 0 discriminator 2
 4287 084e 2FEF      		ldi r18,-1
 4288 0850 821A      		sub r8,r18
 4289 0852 920A      		sbc r9,r18
 4290 0854 A20A      		sbc r10,r18
 4291 0856 B20A      		sbc r11,r18
 4292               	.LVL454:
 4293 0858 0E5F      		subi r16,-2
 4294 085a 1F4F      		sbci r17,-1
 4295               	.LVL455:
 4296               	.LBE260:
 649:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4297               		.loc 3 649 0 discriminator 2
 4298 085c 80E0      		ldi r24,hi8(receivedBuffer+256)
 4299 085e 0030      		cpi r16,lo8(receivedBuffer+256)
 4300 0860 1807      		cpc r17,r24
 4301 0862 01F4      		brne .L172
 4302 0864 90E8      		ldi r25,-128
 4303 0866 C90E      		add r12,r25
 4304 0868 D11C      		adc r13,__zero_reg__
 4305 086a E11C      		adc r14,__zero_reg__
 4306 086c F11C      		adc r15,__zero_reg__
 4307 086e 00C0      		rjmp .L272
 4308               	.LVL456:
 4309               	.L170:
 4310               	.LBE259:
 4311               	.LBE258:
 663:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4312               		.loc 3 663 0
 4313 0870 9C36      		cpi r25,lo8(108)
 4314 0872 01F0      		breq .+2
 4315 0874 00C0      		rjmp .L173
 4316               	.LBB261:
 664:main.c        **** 			usart_read_bytes(64);
 4317               		.loc 3 664 0
 4318 0876 939A      		sbi 0x12,3
 665:main.c        **** 			
 4319               		.loc 3 665 0
 4320 0878 80E4      		ldi r24,lo8(64)
 4321 087a 90E0      		ldi r25,0
 4322               	.LVL457:
 4323 087c 00D0      		rcall usart_read_bytes
 4324               	.LVL458:
 668:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4325               		.loc 3 668 0
 4326 087e C4BB      		out 0x14,r28
 669:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4327               		.loc 3 669 0
 4328 0880 CABB      		out 0x1a,r28
 670:main.c        **** 			
 4329               		.loc 3 670 0
 4330 0882 C7BB      		out 0x17,r28
 673:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4331               		.loc 3 673 0
 4332 0884 40E6      		ldi r20,lo8(96)
 4333 0886 50E0      		ldi r21,0
 4334 0888 C701      		movw r24,r14
 4335 088a B601      		movw r22,r12
 4336 088c 00D0      		rcall gba_flash_write_bus_cycle
 4337               	.LVL459:
 674:main.c        **** 			
 4338               		.loc 3 674 0
 4339 088e 40ED      		ldi r20,lo8(-48)
 4340 0890 50E0      		ldi r21,0
 4341 0892 C701      		movw r24,r14
 4342 0894 B601      		movw r22,r12
 4343 0896 00D0      		rcall gba_flash_write_bus_cycle
 4344               	.LVL460:
 677:main.c        **** 			_delay_us(50);
 4345               		.loc 3 677 0
 4346 0898 48EE      		ldi r20,lo8(-24)
 4347 089a 50E0      		ldi r21,0
 4348 089c C701      		movw r24,r14
 4349 089e B601      		movw r22,r12
 4350 08a0 00D0      		rcall gba_flash_write_bus_cycle
 4351               	.LVL461:
 4352               	.LBB262:
 4353               	.LBB263:
 4354               		.loc 2 276 0
 4355 08a2 E5E8      		ldi r30,lo8(-123)
 4356 08a4 EA95      	1:	dec r30
 4357 08a6 01F4      		brne 1b
 4358 08a8 0000      		nop
 4359               	.LVL462:
 4360               	.LBE263:
 4361               	.LBE262:
 681:main.c        **** 			while (dataVerify != 0x0080) {
 4362               		.loc 3 681 0
 4363 08aa C701      		movw r24,r14
 4364 08ac B601      		movw r22,r12
 4365 08ae 00D0      		rcall gba_read_16bit_data
 4366               	.LVL463:
 4367               	.L174:
 682:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4368               		.loc 3 682 0
 4369 08b0 8038      		cpi r24,-128
 4370 08b2 9105      		cpc r25,__zero_reg__
 4371 08b4 01F0      		breq .L287
 683:main.c        **** 				_delay_us(50);
 4372               		.loc 3 683 0
 4373 08b6 C701      		movw r24,r14
 4374 08b8 B601      		movw r22,r12
 4375 08ba 00D0      		rcall gba_read_16bit_data
 4376               	.LVL464:
 4377               	.LBB264:
 4378               	.LBB265:
 4379               		.loc 2 276 0
 4380 08bc F5E8      		ldi r31,lo8(-123)
 4381 08be FA95      	1:	dec r31
 4382 08c0 01F4      		brne 1b
 4383 08c2 0000      		nop
 4384 08c4 00C0      		rjmp .L174
 4385               	.LVL465:
 4386               	.L287:
 4387               	.LBE265:
 4388               	.LBE264:
 689:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4389               		.loc 3 689 0
 4390 08c6 C4BB      		out 0x14,r28
 690:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4391               		.loc 3 690 0
 4392 08c8 CABB      		out 0x1a,r28
 691:main.c        **** 			
 4393               		.loc 3 691 0
 4394 08ca C7BB      		out 0x17,r28
 694:main.c        **** 			
 4395               		.loc 3 694 0
 4396 08cc 4FE1      		ldi r20,lo8(31)
 4397 08ce 50E0      		ldi r21,0
 4398 08d0 C701      		movw r24,r14
 4399 08d2 B601      		movw r22,r12
 4400 08d4 00D0      		rcall gba_flash_write_bus_cycle
 4401               	.LVL466:
 4402 08d6 00E0      		ldi r16,lo8(receivedBuffer)
 4403 08d8 10E0      		ldi r17,hi8(receivedBuffer)
 4404 08da 4601      		movw r8,r12
 4405 08dc 5701      		movw r10,r14
 4406               	.LVL467:
 4407               	.L176:
 4408               	.LBB266:
 4409               	.LBB267:
 699:main.c        **** 				address++;
 4410               		.loc 3 699 0 discriminator 3
 4411 08de F801      		movw r30,r16
 4412 08e0 4181      		ldd r20,Z+1
 4413 08e2 50E0      		ldi r21,0
 4414 08e4 542F      		mov r21,r20
 4415 08e6 4427      		clr r20
 4416 08e8 8081      		ld r24,Z
 4417 08ea 482B      		or r20,r24
 4418 08ec C501      		movw r24,r10
 4419 08ee B401      		movw r22,r8
 4420 08f0 00D0      		rcall gba_flash_write_bus_cycle
 4421               	.LVL468:
 700:main.c        **** 			}
 4422               		.loc 3 700 0 discriminator 3
 4423 08f2 FFEF      		ldi r31,-1
 4424 08f4 8F1A      		sub r8,r31
 4425 08f6 9F0A      		sbc r9,r31
 4426 08f8 AF0A      		sbc r10,r31
 4427 08fa BF0A      		sbc r11,r31
 4428               	.LVL469:
 4429 08fc 0E5F      		subi r16,-2
 4430 08fe 1F4F      		sbci r17,-1
 4431               	.LVL470:
 4432               	.LBE267:
 697:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4433               		.loc 3 697 0 discriminator 3
 4434 0900 20E0      		ldi r18,hi8(receivedBuffer+64)
 4435 0902 0030      		cpi r16,lo8(receivedBuffer+64)
 4436 0904 1207      		cpc r17,r18
 4437 0906 01F4      		brne .L176
 4438 0908 80E2      		ldi r24,32
 4439 090a C80E      		add r12,r24
 4440 090c D11C      		adc r13,__zero_reg__
 4441 090e E11C      		adc r14,__zero_reg__
 4442 0910 F11C      		adc r15,__zero_reg__
 4443               	.LBE266:
 704:main.c        **** 			_delay_us(440);
 4444               		.loc 3 704 0
 4445 0912 40ED      		ldi r20,lo8(-48)
 4446 0914 50E0      		ldi r21,0
 4447 0916 C701      		movw r24,r14
 4448 0918 B601      		movw r22,r12
 4449 091a 00D0      		rcall gba_flash_write_bus_cycle
 4450               	.LVL471:
 4451               	.LBB268:
 4452               	.LBB269:
 4453               		.loc 2 276 0
 4454 091c EFE6      		ldi r30,lo8(879)
 4455 091e F3E0      		ldi r31,hi8(879)
 4456 0920 3197      	1:	sbiw r30,1
 4457 0922 01F4      		brne 1b
 4458 0924 00C0      		rjmp .
 4459 0926 0000      		nop
 4460               	.LVL472:
 4461               	.LBE269:
 4462               	.LBE268:
 708:main.c        **** 			while (dataVerify != 0x0080) {
 4463               		.loc 3 708 0
 4464 0928 C701      		movw r24,r14
 4465 092a B601      		movw r22,r12
 4466 092c 00D0      		rcall gba_read_16bit_data
 4467               	.LVL473:
 4468               	.L177:
 709:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4469               		.loc 3 709 0
 4470 092e 8038      		cpi r24,-128
 4471 0930 9105      		cpc r25,__zero_reg__
 4472 0932 01F0      		breq .L288
 710:main.c        **** 				_delay_us(50);
 4473               		.loc 3 710 0
 4474 0934 C701      		movw r24,r14
 4475 0936 B601      		movw r22,r12
 4476 0938 00D0      		rcall gba_read_16bit_data
 4477               	.LVL474:
 4478               	.LBB270:
 4479               	.LBB271:
 4480               		.loc 2 276 0
 4481 093a F5E8      		ldi r31,lo8(-123)
 4482 093c FA95      	1:	dec r31
 4483 093e 01F4      		brne 1b
 4484 0940 0000      		nop
 4485 0942 00C0      		rjmp .L177
 4486               	.LVL475:
 4487               	.L288:
 4488               	.LBE271:
 4489               	.LBE270:
 716:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4490               		.loc 3 716 0
 4491 0944 C4BB      		out 0x14,r28
 717:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4492               		.loc 3 717 0
 4493 0946 CABB      		out 0x1a,r28
 718:main.c        **** 			
 4494               		.loc 3 718 0
 4495 0948 C7BB      		out 0x17,r28
 721:main.c        **** 			
 4496               		.loc 3 721 0
 4497 094a 4FEF      		ldi r20,lo8(-1)
 4498 094c 50E0      		ldi r21,0
 4499 094e C701      		movw r24,r14
 4500 0950 B601      		movw r22,r12
 4501 0952 00D0      		rcall gba_flash_write_bus_cycle
 4502               	.LVL476:
 4503 0954 00C0      		rjmp .L272
 4504               	.LVL477:
 4505               	.L173:
 4506               	.LBE261:
 728:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4507               		.loc 3 728 0
 4508 0956 9537      		cpi r25,lo8(117)
 4509 0958 01F4      		brne .L179
 729:main.c        **** 			usart_read_bytes(64);
 4510               		.loc 3 729 0
 4511 095a 939A      		sbi 0x12,3
 730:main.c        **** 			
 4512               		.loc 3 730 0
 4513 095c 80E4      		ldi r24,lo8(64)
 4514 095e 90E0      		ldi r25,0
 4515               	.LVL478:
 4516 0960 00D0      		rcall usart_read_bytes
 4517               	.LVL479:
 4518 0962 90E0      		ldi r25,lo8(receivedBuffer)
 4519 0964 A92E      		mov r10,r25
 4520 0966 90E0      		ldi r25,hi8(receivedBuffer)
 4521 0968 B92E      		mov r11,r25
 4522 096a 2601      		movw r4,r12
 4523 096c 3701      		movw r6,r14
 4524               	.LVL480:
 4525               	.L182:
 4526               	.LBB272:
 4527               	.LBB193:
 4528               		.loc 3 735 0
 4529 096e C4BB      		out 0x14,r28
 736:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4530               		.loc 3 736 0
 4531 0970 CABB      		out 0x1a,r28
 737:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4532               		.loc 3 737 0
 4533 0972 C7BB      		out 0x17,r28
 738:main.c        **** 				
 739:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4534               		.loc 3 739 0
 4535 0974 F501      		movw r30,r10
 4536 0976 0181      		ldd r16,Z+1
 4537 0978 10E0      		ldi r17,0
 4538 097a 102F      		mov r17,r16
 4539 097c 0027      		clr r16
 4540 097e 8081      		ld r24,Z
 4541 0980 082B      		or r16,r24
 4542               	.LVL481:
 740:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4543               		.loc 3 740 0
 4544 0982 40E4      		ldi r20,lo8(64)
 4545 0984 50E0      		ldi r21,0
 4546 0986 C301      		movw r24,r6
 4547 0988 B201      		movw r22,r4
 4548 098a 00D0      		rcall gba_flash_write_bus_cycle
 4549               	.LVL482:
 741:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4550               		.loc 3 741 0
 4551 098c A801      		movw r20,r16
 4552 098e C301      		movw r24,r6
 4553 0990 B201      		movw r22,r4
 4554 0992 00D0      		rcall gba_flash_write_bus_cycle
 4555               	.LVL483:
 742:main.c        **** 				
 743:main.c        **** 				// Verify status ok
 744:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4556               		.loc 3 744 0
 4557 0994 C301      		movw r24,r6
 4558 0996 B201      		movw r22,r4
 4559 0998 00D0      		rcall gba_read_16bit_data
 4560               	.LVL484:
 4561               	.L180:
 745:main.c        **** 				while ((status & 0x80) == 0) {
 4562               		.loc 3 745 0
 4563 099a 87FD      		sbrc r24,7
 4564 099c 00C0      		rjmp .L289
 746:main.c        **** 					status = gba_read_16bit_data(address);
 4565               		.loc 3 746 0
 4566 099e C301      		movw r24,r6
 4567 09a0 B201      		movw r22,r4
 4568 09a2 00D0      		rcall gba_read_16bit_data
 4569               	.LVL485:
 4570               	.LBB191:
 4571               	.LBB192:
 4572               		.loc 2 276 0
 4573 09a4 F5E0      		ldi r31,lo8(5)
 4574 09a6 FA95      	1:	dec r31
 4575 09a8 01F4      		brne 1b
 4576 09aa 0000      		nop
 4577 09ac 00C0      		rjmp .L180
 4578               	.LVL486:
 4579               	.L289:
 4580               	.LBE192:
 4581               	.LBE191:
 747:main.c        **** 					_delay_us(2);
 748:main.c        **** 				}
 749:main.c        **** 				address++;
 4582               		.loc 3 749 0 discriminator 2
 4583 09ae 2FEF      		ldi r18,-1
 4584 09b0 421A      		sub r4,r18
 4585 09b2 520A      		sbc r5,r18
 4586 09b4 620A      		sbc r6,r18
 4587 09b6 720A      		sbc r7,r18
 4588               	.LVL487:
 4589 09b8 82E0      		ldi r24,2
 4590 09ba A80E      		add r10,r24
 4591 09bc B11C      		adc r11,__zero_reg__
 4592               	.LVL488:
 4593               	.LBE193:
 733:main.c        **** 				// Set address lines as outputs
 4594               		.loc 3 733 0 discriminator 2
 4595 09be 90E0      		ldi r25,lo8(receivedBuffer+64)
 4596 09c0 A916      		cp r10,r25
 4597 09c2 90E0      		ldi r25,hi8(receivedBuffer+64)
 4598 09c4 B906      		cpc r11,r25
 4599 09c6 01F4      		brne .L182
 4600 09c8 E0E2      		ldi r30,32
 4601 09ca CE0E      		add r12,r30
 4602 09cc D11C      		adc r13,__zero_reg__
 4603 09ce E11C      		adc r14,__zero_reg__
 4604 09d0 F11C      		adc r15,__zero_reg__
 4605               	.LVL489:
 4606               	.L272:
 4607               	.LBE272:
 750:main.c        **** 			}
 751:main.c        **** 			
 752:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4608               		.loc 3 752 0
 4609 09d2 81E3      		ldi r24,lo8(49)
 4610 09d4 00C0      		rjmp .L266
 4611               	.LVL490:
 4612               	.L179:
 753:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 754:main.c        **** 		}
 755:main.c        **** 		
 756:main.c        **** 		
 757:main.c        **** 		// ---------- General commands ----------
 758:main.c        **** 		// Set any pin as input/output
 759:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 760:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 4613               		.loc 3 760 0
 4614 09d6 9934      		cpi r25,lo8(73)
 4615 09d8 01F0      		breq .L183
 4616               		.loc 3 760 0 is_stmt 0 discriminator 1
 4617 09da 9F34      		cpi r25,lo8(79)
 4618 09dc 01F0      		breq .+2
 4619 09de 00C0      		rjmp .L184
 4620               	.L183:
 4621               	.LBB273:
 761:main.c        **** 			char portChar = USART_Receive();
 4622               		.loc 3 761 0 is_stmt 1
 4623 09e0 00D0      		rcall USART_Receive
 4624               	.LVL491:
 4625 09e2 182F      		mov r17,r24
 4626               	.LVL492:
 762:main.c        **** 			usart_read_chars();
 4627               		.loc 3 762 0
 4628 09e4 00D0      		rcall usart_read_chars
 4629               	.LVL493:
 763:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4630               		.loc 3 763 0
 4631 09e6 40E1      		ldi r20,lo8(16)
 4632 09e8 50E0      		ldi r21,0
 4633 09ea 60E0      		ldi r22,0
 4634 09ec 70E0      		ldi r23,0
 4635 09ee 80E0      		ldi r24,lo8(receivedBuffer)
 4636 09f0 90E0      		ldi r25,hi8(receivedBuffer)
 4637 09f2 00D0      		rcall strtol
 4638               	.LVL494:
 764:main.c        **** 			
 765:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4639               		.loc 3 765 0
 4640 09f4 939A      		sbi 0x12,3
 766:main.c        **** 			if (receivedChar == SET_INPUT) {
 4641               		.loc 3 766 0
 4642 09f6 8091 0000 		lds r24,receivedChar
 4643 09fa 8934      		cpi r24,lo8(73)
 4644 09fc 01F4      		brne .L185
 767:main.c        **** 				if (portChar == 'A') {
 4645               		.loc 3 767 0
 4646 09fe 1134      		cpi r17,lo8(65)
 4647 0a00 01F4      		brne .L186
 768:main.c        **** 					DDRA &= ~(setValue);
 4648               		.loc 3 768 0
 4649 0a02 8AB3      		in r24,0x1a
 4650 0a04 6095      		com r22
 4651               	.LVL495:
 4652 0a06 6823      		and r22,r24
 4653               	.LVL496:
 4654 0a08 00C0      		rjmp .L274
 4655               	.LVL497:
 4656               	.L186:
 769:main.c        **** 				}
 770:main.c        **** 				else if (portChar == 'B') {
 4657               		.loc 3 770 0
 4658 0a0a 1234      		cpi r17,lo8(66)
 4659 0a0c 01F4      		brne .L188
 771:main.c        **** 					DDRB &= ~(setValue);
 4660               		.loc 3 771 0
 4661 0a0e 87B3      		in r24,0x17
 4662 0a10 6095      		com r22
 4663               	.LVL498:
 4664 0a12 6823      		and r22,r24
 4665               	.LVL499:
 4666 0a14 00C0      		rjmp .L275
 4667               	.LVL500:
 4668               	.L188:
 772:main.c        **** 				}
 773:main.c        **** 				else if (portChar == 'C') {
 4669               		.loc 3 773 0
 4670 0a16 1334      		cpi r17,lo8(67)
 4671 0a18 01F4      		brne .L189
 774:main.c        **** 					DDRC &= ~(setValue);
 4672               		.loc 3 774 0
 4673 0a1a 84B3      		in r24,0x14
 4674 0a1c 6095      		com r22
 4675               	.LVL501:
 4676 0a1e 6823      		and r22,r24
 4677               	.LVL502:
 4678 0a20 00C0      		rjmp .L280
 4679               	.LVL503:
 4680               	.L189:
 775:main.c        **** 				}
 776:main.c        **** 				else if (portChar == 'D') {
 4681               		.loc 3 776 0
 4682 0a22 1434      		cpi r17,lo8(68)
 4683 0a24 01F4      		brne .L190
 777:main.c        **** 					DDRD &= ~(setValue);
 4684               		.loc 3 777 0
 4685 0a26 81B3      		in r24,0x11
 4686 0a28 6095      		com r22
 4687               	.LVL504:
 4688 0a2a 6823      		and r22,r24
 4689               	.LVL505:
 4690 0a2c 00C0      		rjmp .L281
 4691               	.LVL506:
 4692               	.L190:
 778:main.c        **** 				}
 779:main.c        **** 				else if (portChar == 'E') {
 4693               		.loc 3 779 0
 4694 0a2e 1534      		cpi r17,lo8(69)
 4695 0a30 01F0      		breq .+2
 4696 0a32 00C0      		rjmp .L209
 780:main.c        **** 					DDRE &= ~(setValue);
 4697               		.loc 3 780 0
 4698 0a34 86B1      		in r24,0x6
 4699 0a36 6095      		com r22
 4700               	.LVL507:
 4701 0a38 6823      		and r22,r24
 4702               	.LVL508:
 4703 0a3a 00C0      		rjmp .L282
 4704               	.LVL509:
 4705               	.L185:
 781:main.c        **** 				}
 782:main.c        **** 			}
 783:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 4706               		.loc 3 783 0
 4707 0a3c 8F34      		cpi r24,lo8(79)
 4708 0a3e 01F0      		breq .+2
 4709 0a40 00C0      		rjmp .L209
 784:main.c        **** 				if (portChar == 'A') {
 4710               		.loc 3 784 0
 4711 0a42 1134      		cpi r17,lo8(65)
 4712 0a44 01F4      		brne .L191
 785:main.c        **** 					DDRA |= (setValue);
 4713               		.loc 3 785 0
 4714 0a46 8AB3      		in r24,0x1a
 4715 0a48 682B      		or r22,r24
 4716               	.LVL510:
 4717               	.L274:
 4718 0a4a 6ABB      		out 0x1a,r22
 4719 0a4c 00C0      		rjmp .L209
 4720               	.LVL511:
 4721               	.L191:
 786:main.c        **** 				}
 787:main.c        **** 				else if (portChar == 'B') {
 4722               		.loc 3 787 0
 4723 0a4e 1234      		cpi r17,lo8(66)
 4724 0a50 01F4      		brne .L192
 788:main.c        **** 					DDRB |= (setValue);
 4725               		.loc 3 788 0
 4726 0a52 87B3      		in r24,0x17
 4727 0a54 682B      		or r22,r24
 4728               	.LVL512:
 4729               	.L275:
 4730 0a56 67BB      		out 0x17,r22
 4731 0a58 00C0      		rjmp .L209
 4732               	.LVL513:
 4733               	.L192:
 789:main.c        **** 				}
 790:main.c        **** 				else if (portChar == 'C') {
 4734               		.loc 3 790 0
 4735 0a5a 1334      		cpi r17,lo8(67)
 4736 0a5c 01F4      		brne .L193
 791:main.c        **** 					DDRC |= (setValue);
 4737               		.loc 3 791 0
 4738 0a5e 84B3      		in r24,0x14
 4739 0a60 682B      		or r22,r24
 4740               	.LVL514:
 4741               	.L280:
 4742 0a62 64BB      		out 0x14,r22
 4743 0a64 00C0      		rjmp .L209
 4744               	.LVL515:
 4745               	.L193:
 792:main.c        **** 				}
 793:main.c        **** 				else if (portChar == 'D') {
 4746               		.loc 3 793 0
 4747 0a66 1434      		cpi r17,lo8(68)
 4748 0a68 01F4      		brne .L194
 794:main.c        **** 					DDRD |= (setValue);
 4749               		.loc 3 794 0
 4750 0a6a 81B3      		in r24,0x11
 4751 0a6c 682B      		or r22,r24
 4752               	.LVL516:
 4753               	.L281:
 4754 0a6e 61BB      		out 0x11,r22
 4755 0a70 00C0      		rjmp .L209
 4756               	.LVL517:
 4757               	.L194:
 795:main.c        **** 				}
 796:main.c        **** 				else if (portChar == 'E') {
 4758               		.loc 3 796 0
 4759 0a72 1534      		cpi r17,lo8(69)
 4760 0a74 01F0      		breq .+2
 4761 0a76 00C0      		rjmp .L209
 797:main.c        **** 					DDRE |= (setValue);
 4762               		.loc 3 797 0
 4763 0a78 86B1      		in r24,0x6
 4764 0a7a 682B      		or r22,r24
 4765               	.LVL518:
 4766               	.L282:
 4767 0a7c 66B9      		out 0x6,r22
 4768 0a7e 00C0      		rjmp .L209
 4769               	.LVL519:
 4770               	.L184:
 4771               	.LBE273:
 798:main.c        **** 				}
 799:main.c        **** 			}
 800:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 801:main.c        **** 		}
 802:main.c        **** 		
 803:main.c        **** 		// Set pin output as low
 804:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 4772               		.loc 3 804 0
 4773 0a80 9C34      		cpi r25,lo8(76)
 4774 0a82 01F4      		brne .L195
 4775               	.LBB274:
 805:main.c        **** 			char portChar = USART_Receive();			
 4776               		.loc 3 805 0
 4777 0a84 00D0      		rcall USART_Receive
 4778               	.LVL520:
 4779 0a86 182F      		mov r17,r24
 4780               	.LVL521:
 806:main.c        **** 			usart_read_chars();
 4781               		.loc 3 806 0
 4782 0a88 00D0      		rcall usart_read_chars
 4783               	.LVL522:
 807:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4784               		.loc 3 807 0
 4785 0a8a 40E1      		ldi r20,lo8(16)
 4786 0a8c 50E0      		ldi r21,0
 4787 0a8e 60E0      		ldi r22,0
 4788 0a90 70E0      		ldi r23,0
 4789 0a92 80E0      		ldi r24,lo8(receivedBuffer)
 4790 0a94 90E0      		ldi r25,hi8(receivedBuffer)
 4791 0a96 00D0      		rcall strtol
 4792               	.LVL523:
 808:main.c        **** 			
 809:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4793               		.loc 3 809 0
 4794 0a98 939A      		sbi 0x12,3
 810:main.c        **** 			if (portChar == 'A') {
 4795               		.loc 3 810 0
 4796 0a9a 1134      		cpi r17,lo8(65)
 4797 0a9c 01F4      		brne .L196
 811:main.c        **** 				PORTA &= ~(setValue);
 4798               		.loc 3 811 0
 4799 0a9e 8BB3      		in r24,0x1b
 4800 0aa0 6095      		com r22
 4801               	.LVL524:
 4802 0aa2 6823      		and r22,r24
 4803               	.LVL525:
 4804 0aa4 00C0      		rjmp .L279
 4805               	.LVL526:
 4806               	.L196:
 812:main.c        **** 			}
 813:main.c        **** 			else if (portChar == 'B') {
 4807               		.loc 3 813 0
 4808 0aa6 1234      		cpi r17,lo8(66)
 4809 0aa8 01F4      		brne .L198
 814:main.c        **** 				PORTB &= ~(setValue);
 4810               		.loc 3 814 0
 4811 0aaa 88B3      		in r24,0x18
 4812 0aac 6095      		com r22
 4813               	.LVL527:
 4814 0aae 6823      		and r22,r24
 4815               	.LVL528:
 4816 0ab0 00C0      		rjmp .L278
 4817               	.LVL529:
 4818               	.L198:
 815:main.c        **** 			}
 816:main.c        **** 			else if (portChar == 'C') {
 4819               		.loc 3 816 0
 4820 0ab2 1334      		cpi r17,lo8(67)
 4821 0ab4 01F4      		brne .L199
 817:main.c        **** 				PORTC &= ~(setValue);
 4822               		.loc 3 817 0
 4823 0ab6 85B3      		in r24,0x15
 4824 0ab8 6095      		com r22
 4825               	.LVL530:
 4826 0aba 6823      		and r22,r24
 4827               	.LVL531:
 4828 0abc 00C0      		rjmp .L277
 4829               	.LVL532:
 4830               	.L199:
 818:main.c        **** 			}
 819:main.c        **** 			else if (portChar == 'D') {
 4831               		.loc 3 819 0
 4832 0abe 1434      		cpi r17,lo8(68)
 4833 0ac0 01F4      		brne .L200
 820:main.c        **** 				PORTD &= ~(setValue);
 4834               		.loc 3 820 0
 4835 0ac2 82B3      		in r24,0x12
 4836 0ac4 6095      		com r22
 4837               	.LVL533:
 4838 0ac6 6823      		and r22,r24
 4839               	.LVL534:
 4840 0ac8 00C0      		rjmp .L276
 4841               	.LVL535:
 4842               	.L200:
 821:main.c        **** 			}
 822:main.c        **** 			else if (portChar == 'E') {
 4843               		.loc 3 822 0
 4844 0aca 1534      		cpi r17,lo8(69)
 4845 0acc 01F0      		breq .+2
 4846 0ace 00C0      		rjmp .L209
 823:main.c        **** 				PORTE &= ~(setValue);
 4847               		.loc 3 823 0
 4848 0ad0 87B1      		in r24,0x7
 4849 0ad2 6095      		com r22
 4850               	.LVL536:
 4851 0ad4 6823      		and r22,r24
 4852               	.LVL537:
 4853 0ad6 00C0      		rjmp .L273
 4854               	.LVL538:
 4855               	.L195:
 4856               	.LBE274:
 824:main.c        **** 			}
 825:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 826:main.c        **** 		}
 827:main.c        **** 		
 828:main.c        **** 		// Set pin output as high
 829:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 4857               		.loc 3 829 0
 4858 0ad8 9834      		cpi r25,lo8(72)
 4859 0ada 01F4      		brne .L201
 4860               	.LBB275:
 830:main.c        **** 			char portChar = USART_Receive();			
 4861               		.loc 3 830 0
 4862 0adc 00D0      		rcall USART_Receive
 4863               	.LVL539:
 4864 0ade 182F      		mov r17,r24
 4865               	.LVL540:
 831:main.c        **** 			usart_read_chars();
 4866               		.loc 3 831 0
 4867 0ae0 00D0      		rcall usart_read_chars
 4868               	.LVL541:
 832:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 4869               		.loc 3 832 0
 4870 0ae2 40E1      		ldi r20,lo8(16)
 4871 0ae4 50E0      		ldi r21,0
 4872 0ae6 60E0      		ldi r22,0
 4873 0ae8 70E0      		ldi r23,0
 4874 0aea 80E0      		ldi r24,lo8(receivedBuffer)
 4875 0aec 90E0      		ldi r25,hi8(receivedBuffer)
 4876 0aee 00D0      		rcall strtol
 4877               	.LVL542:
 833:main.c        **** 			
 834:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4878               		.loc 3 834 0
 4879 0af0 939A      		sbi 0x12,3
 835:main.c        **** 			if (portChar == 'A') {
 4880               		.loc 3 835 0
 4881 0af2 1134      		cpi r17,lo8(65)
 4882 0af4 01F4      		brne .L202
 836:main.c        **** 				PORTA |= (setValue);
 4883               		.loc 3 836 0
 4884 0af6 8BB3      		in r24,0x1b
 4885 0af8 682B      		or r22,r24
 4886               	.LVL543:
 4887               	.L279:
 4888 0afa 6BBB      		out 0x1b,r22
 4889 0afc 00C0      		rjmp .L209
 4890               	.LVL544:
 4891               	.L202:
 837:main.c        **** 			}
 838:main.c        **** 			else if (portChar == 'B') {
 4892               		.loc 3 838 0
 4893 0afe 1234      		cpi r17,lo8(66)
 4894 0b00 01F4      		brne .L204
 839:main.c        **** 				PORTB |= (setValue);
 4895               		.loc 3 839 0
 4896 0b02 88B3      		in r24,0x18
 4897 0b04 682B      		or r22,r24
 4898               	.LVL545:
 4899               	.L278:
 4900 0b06 68BB      		out 0x18,r22
 4901 0b08 00C0      		rjmp .L209
 4902               	.LVL546:
 4903               	.L204:
 840:main.c        **** 			}
 841:main.c        **** 			else if (portChar == 'C') {
 4904               		.loc 3 841 0
 4905 0b0a 1334      		cpi r17,lo8(67)
 4906 0b0c 01F4      		brne .L205
 842:main.c        **** 				PORTC |= (setValue);
 4907               		.loc 3 842 0
 4908 0b0e 85B3      		in r24,0x15
 4909 0b10 682B      		or r22,r24
 4910               	.LVL547:
 4911               	.L277:
 4912 0b12 65BB      		out 0x15,r22
 4913 0b14 00C0      		rjmp .L209
 4914               	.LVL548:
 4915               	.L205:
 843:main.c        **** 			}
 844:main.c        **** 			else if (portChar == 'D') {
 4916               		.loc 3 844 0
 4917 0b16 1434      		cpi r17,lo8(68)
 4918 0b18 01F4      		brne .L206
 845:main.c        **** 				PORTD |= (setValue);
 4919               		.loc 3 845 0
 4920 0b1a 82B3      		in r24,0x12
 4921 0b1c 682B      		or r22,r24
 4922               	.LVL549:
 4923               	.L276:
 4924 0b1e 62BB      		out 0x12,r22
 4925 0b20 00C0      		rjmp .L209
 4926               	.LVL550:
 4927               	.L206:
 846:main.c        **** 			}
 847:main.c        **** 			else if (portChar == 'E') {
 4928               		.loc 3 847 0
 4929 0b22 1534      		cpi r17,lo8(69)
 4930 0b24 01F4      		brne .L209
 848:main.c        **** 				PORTE |= (setValue);
 4931               		.loc 3 848 0
 4932 0b26 87B1      		in r24,0x7
 4933 0b28 682B      		or r22,r24
 4934               	.LVL551:
 4935               	.L273:
 4936 0b2a 67B9      		out 0x7,r22
 4937 0b2c 00C0      		rjmp .L209
 4938               	.LVL552:
 4939               	.L201:
 4940               	.LBE275:
 849:main.c        **** 			}
 850:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 851:main.c        **** 		}
 852:main.c        **** 		
 853:main.c        **** 		// Read all pins of a PORT and return the value
 854:main.c        **** 		else if (receivedChar == READ_INPUT) {
 4941               		.loc 3 854 0
 4942 0b2e 9434      		cpi r25,lo8(68)
 4943 0b30 01F4      		brne .L207
 4944               	.LBB276:
 855:main.c        **** 			char portChar = USART_Receive();			
 4945               		.loc 3 855 0
 4946 0b32 00D0      		rcall USART_Receive
 4947               	.LVL553:
 856:main.c        **** 			
 857:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4948               		.loc 3 857 0
 4949 0b34 939A      		sbi 0x12,3
 858:main.c        **** 			if (portChar == 'A') {
 4950               		.loc 3 858 0
 4951 0b36 8134      		cpi r24,lo8(65)
 4952 0b38 01F4      		brne .L208
 859:main.c        **** 				USART_Transmit(PINA);
 4953               		.loc 3 859 0
 4954 0b3a 89B3      		in r24,0x19
 4955               	.LVL554:
 4956 0b3c 00C0      		rjmp .L266
 4957               	.LVL555:
 4958               	.L208:
 860:main.c        **** 			}
 861:main.c        **** 			else if (portChar == 'B') {
 4959               		.loc 3 861 0
 4960 0b3e 8234      		cpi r24,lo8(66)
 4961 0b40 01F4      		brne .L210
 862:main.c        **** 				USART_Transmit(PINB);
 4962               		.loc 3 862 0
 4963 0b42 86B3      		in r24,0x16
 4964               	.LVL556:
 4965 0b44 00C0      		rjmp .L266
 4966               	.LVL557:
 4967               	.L210:
 863:main.c        **** 			}
 864:main.c        **** 			else if (portChar == 'C') {
 4968               		.loc 3 864 0
 4969 0b46 8334      		cpi r24,lo8(67)
 4970 0b48 01F4      		brne .L211
 865:main.c        **** 				USART_Transmit(PINC);
 4971               		.loc 3 865 0
 4972 0b4a 83B3      		in r24,0x13
 4973               	.LVL558:
 4974 0b4c 00C0      		rjmp .L266
 4975               	.LVL559:
 4976               	.L211:
 866:main.c        **** 			}
 867:main.c        **** 			else if (portChar == 'D') {
 4977               		.loc 3 867 0
 4978 0b4e 8434      		cpi r24,lo8(68)
 4979 0b50 01F4      		brne .L212
 868:main.c        **** 				USART_Transmit(PIND);
 4980               		.loc 3 868 0
 4981 0b52 80B3      		in r24,0x10
 4982               	.LVL560:
 4983 0b54 00C0      		rjmp .L266
 4984               	.LVL561:
 4985               	.L212:
 869:main.c        **** 			}
 870:main.c        **** 			else if (portChar == 'E') {
 4986               		.loc 3 870 0
 4987 0b56 8534      		cpi r24,lo8(69)
 4988 0b58 01F4      		brne .L209
 871:main.c        **** 				USART_Transmit(PINE);
 4989               		.loc 3 871 0
 4990 0b5a 85B1      		in r24,0x5
 4991               	.LVL562:
 4992               	.L266:
 4993 0b5c 00D0      		rcall USART_Transmit
 4994               	.LVL563:
 4995               	.L209:
 872:main.c        **** 			}
 873:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4996               		.loc 3 873 0
 4997 0b5e 9398      		cbi 0x12,3
 4998               	.LBE276:
 4999 0b60 00C0      		rjmp .L95
 5000               	.LVL564:
 5001               	.L207:
 874:main.c        **** 		}
 875:main.c        **** 		
 876:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 877:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5002               		.loc 3 877 0
 5003 0b62 9D34      		cpi r25,lo8(77)
 5004 0b64 01F4      		brne .L213
 5005               	.LBB277:
 878:main.c        **** 			char commonChar = USART_Receive();
 5006               		.loc 3 878 0
 5007 0b66 00D0      		rcall USART_Receive
 5008               	.LVL565:
 879:main.c        **** 			if (commonChar == '1') {
 5009               		.loc 3 879 0
 5010 0b68 8133      		cpi r24,lo8(49)
 5011 0b6a 01F4      		brne .L290
 880:main.c        **** 				resetCommonLines = 1;
 5012               		.loc 3 880 0
 5013 0b6c 2224      		clr r2
 5014 0b6e 2394      		inc r2
 5015 0b70 00C0      		rjmp .L262
 5016               	.L290:
 881:main.c        **** 			}
 882:main.c        **** 			else if (commonChar == '0') {
 5017               		.loc 3 882 0
 5018 0b72 8033      		cpi r24,lo8(48)
 5019 0b74 01F0      		breq .+2
 5020 0b76 00C0      		rjmp .L95
 883:main.c        **** 				resetCommonLines = 0;
 5021               		.loc 3 883 0
 5022 0b78 212C      		mov r2,__zero_reg__
 5023 0b7a 00C0      		rjmp .L96
 5024               	.LVL566:
 5025               	.L213:
 5026               	.LBE277:
 884:main.c        **** 			}
 885:main.c        **** 		}
 886:main.c        **** 		
 887:main.c        **** 		// Send back the PCB version number
 888:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5027               		.loc 3 888 0
 5028 0b7c 9836      		cpi r25,lo8(104)
 5029 0b7e 01F4      		brne .L214
 889:main.c        **** 			USART_Transmit(PCB_VERSION);
 5030               		.loc 3 889 0
 5031 0b80 82E0      		ldi r24,lo8(2)
 5032               	.LVL567:
 5033 0b82 00C0      		rjmp .L263
 5034               	.LVL568:
 5035               	.L214:
 890:main.c        **** 		}
 891:main.c        **** 		
 892:main.c        **** 		// Send back the firmware version number
 893:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5036               		.loc 3 893 0
 5037 0b84 9635      		cpi r25,lo8(86)
 5038 0b86 01F4      		brne .L215
 894:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5039               		.loc 3 894 0
 5040 0b88 80E1      		ldi r24,lo8(16)
 5041               	.LVL569:
 5042               	.L263:
 5043 0b8a 00D0      		rcall USART_Transmit
 5044               	.LVL570:
 5045 0b8c 00C0      		rjmp .L95
 5046               	.LVL571:
 5047               	.L215:
 895:main.c        **** 		}
 896:main.c        **** 		
 897:main.c        **** 		// Reset the AVR if it matches the number
 898:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5048               		.loc 3 898 0
 5049 0b8e 9A32      		cpi r25,lo8(42)
 5050 0b90 01F0      		breq .+2
 5051 0b92 00C0      		rjmp .L95
 5052               	.LBB278:
 899:main.c        **** 			usart_read_chars();
 5053               		.loc 3 899 0
 5054 0b94 00D0      		rcall usart_read_chars
 5055               	.LVL572:
 900:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5056               		.loc 3 900 0
 5057 0b96 40E1      		ldi r20,lo8(16)
 5058 0b98 50E0      		ldi r21,0
 5059 0b9a 60E0      		ldi r22,0
 5060 0b9c 70E0      		ldi r23,0
 5061 0b9e 80E0      		ldi r24,lo8(receivedBuffer)
 5062 0ba0 90E0      		ldi r25,hi8(receivedBuffer)
 5063 0ba2 00D0      		rcall strtol
 5064               	.LVL573:
 901:main.c        **** 			if (resetValue == RESET_VALUE) {
 5065               		.loc 3 901 0
 5066 0ba4 613E      		cpi r22,-31
 5067 0ba6 754E      		sbci r23,-27
 5068 0ba8 8740      		sbci r24,7
 5069 0baa 9105      		cpc r25,__zero_reg__
 5070 0bac 01F0      		breq .+2
 5071 0bae 00C0      		rjmp .L95
 902:main.c        **** 				// Clear watchdog flag
 903:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5072               		.loc 3 903 0
 5073 0bb0 84B7      		in r24,0x34
 5074 0bb2 877F      		andi r24,lo8(-9)
 5075 0bb4 84BF      		out 0x34,r24
 904:main.c        **** 				
 905:main.c        **** 				// Start timed sequence
 906:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5076               		.loc 3 906 0
 5077 0bb6 28E1      		ldi r18,lo8(24)
 5078 0bb8 21BD      		out 0x21,r18
 907:main.c        **** 				
 908:main.c        **** 				// Reset in 250 ms
 909:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5079               		.loc 3 909 0
 5080 0bba 8CE0      		ldi r24,lo8(12)
 5081 0bbc 81BD      		out 0x21,r24
 5082               	.LVL574:
 5083               	.LBB279:
 5084               	.LBB280:
 5085               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5086               		.loc 4 105 0
 5087 0bbe 8FEF      		ldi r24,lo8(-1)
 5088 0bc0 9FEF      		ldi r25,lo8(-1)
 5089               	/* #APP */
 5090               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5091 0bc2 0197      		1: sbiw r24,1
 5092 0bc4 01F4      		brne 1b
 5093               	 ;  0 "" 2
 5094               	.LVL575:
 5095               	/* #NOAPP */
 5096 0bc6 00C0      		rjmp .L95
 5097               	.LBE280:
 5098               	.LBE279:
 5099               	.LBE278:
 5100               		.cfi_endproc
 5101               	.LFE46:
 5103               	.global	lastBankAccessed
 5104               		.section .bss
 5107               	lastBankAccessed:
 5108 0000 00        		.zero	1
 5109               	.global	flashBank1CommandWrites
 5112               	flashBank1CommandWrites:
 5113 0001 00        		.zero	1
 5114               		.comm	flashWriteCycle,12,1
 5115               		.comm	flashWriteWePin,1,1
 5116               		.comm	flashChipIdBuffer,2,1
 5117               		.comm	eepromBuffer,8,1
 5118               		.comm	receivedChar,1,1
 5119               		.comm	receivedBuffer,256,1
 5120               		.text
 5121               	.Letext0:
 5122               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5123               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1467   .text:0000040a gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1546   .text:0000043c gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1646   .text:000004a0 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:5112   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:5107   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1771   .text:00000522 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:1934   .text:000005b6 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:2000   .text:000005e6 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:2124   .text:00000646 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:2246   .text:000006a2 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:2354   .text:000006f8 setup
C:\Users\Alex\AppData\Local\Temp\cccCAApV.s:2469   .text.startup:00000000 main
                            *COM*:00000001 receivedChar

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
