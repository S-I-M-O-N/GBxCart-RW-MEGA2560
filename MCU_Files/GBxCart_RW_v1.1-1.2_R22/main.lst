   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.1 or 1.2
   4:setup.c       ****  Firmware version: R22
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 24/10/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define SWITCH_DETECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define READ_ROM_4000H 'Q'
 109:setup.c       **** #define WRITE_RAM 'W'
 110:setup.c       **** #define SET_BANK 'B'
 111:setup.c       **** #define GB_CART_MODE 'G'
 112:setup.c       **** 
 113:setup.c       **** // GBA commands
 114:setup.c       **** #define GBA_READ_ROM 'r'
 115:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 116:setup.c       **** #define GBA_READ_ROM_8000H 'Z'
 117:setup.c       **** #define GBA_READ_SRAM 'm'
 118:setup.c       **** #define GBA_WRITE_SRAM 'w'
 119:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 120:setup.c       **** #define GBA_CART_MODE 'g'
 121:setup.c       **** 
 122:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 123:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 124:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 125:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 126:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 127:setup.c       **** 
 128:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 129:setup.c       **** #define GBA_READ_EEPROM 'e'
 130:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 131:setup.c       **** 
 132:setup.c       **** // Flash Cart commands
 133:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 134:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 135:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 136:setup.c       **** 
 137:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 141:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 142:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 143:setup.c       **** 
 144:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 145:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 146:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_256BYTE 'U'
 147:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 148:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 149:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 150:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'z'
 151:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
 152:setup.c       **** 
 153:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 154:setup.c       **** 
 155:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 156:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 157:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 158:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 159:setup.c       **** #define GBA_FLASH_WRITE_BUFFERED_256BYTE 'c'
 160:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 161:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 162:setup.c       **** #define GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE 'v'
 163:setup.c       **** #define GBA_FLASH_WRITE_SHARP_64BYTE 'x'
 164:setup.c       **** #define D0D1_NOT_SWAPPED 0
 165:setup.c       **** #define D0D1_SWAPPED 1
 166:setup.c       **** 
 167:setup.c       **** // General commands
 168:setup.c       **** #define SEND_ACK '1'
 169:setup.c       **** #define CART_MODE 'C'
 170:setup.c       **** #define SET_INPUT 'I'
 171:setup.c       **** #define SET_OUTPUT 'O'
 172:setup.c       **** #define SET_OUTPUT_LOW 'L'
 173:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 174:setup.c       **** #define READ_INPUT 'D'
 175:setup.c       **** #define RESET_COMMON_LINES 'M'
 176:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 177:setup.c       **** #define READ_PCB_VERSION 'h'
 178:setup.c       **** 
 179:setup.c       **** #define RESET_AVR '*'
 180:setup.c       **** #define RESET_VALUE 0x7E5E1
 181:setup.c       **** 
 182:setup.c       **** 
 183:setup.c       **** char receivedBuffer[256];
 184:setup.c       **** char receivedChar;
 185:setup.c       **** uint8_t eepromBuffer[8];
 186:setup.c       **** uint8_t flashChipIdBuffer[2];
 187:setup.c       **** 
 188:setup.c       **** char flashWriteWePin;
 189:setup.c       **** uint16_t flashWriteCycle[3][2];
 190:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 191:setup.c       **** uint8_t lastBankAccessed = 0;
 192:setup.c       **** volatile uint8_t writingTimedout = 0;
 193:setup.c       **** 
 194:setup.c       **** 
 195:setup.c       **** // Receive USART data
 196:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 196 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 197:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 197 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 198:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 198 0
  26 0004 8CB1      		in r24,0xc
 199:setup.c       **** }
  27               		.loc 1 199 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 200:setup.c       **** 
 201:setup.c       **** // Transmit USART data
 202:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 202 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 203:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 203 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 204:setup.c       **** 	UDR = data;
  47               		.loc 1 204 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 205:setup.c       **** }
 206:setup.c       **** 
 207:setup.c       **** // Read 1-256 bytes from the USART 
 208:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 208 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB166:
 209:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 209 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 209 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 210:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 210 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE166:
 211:setup.c       **** 	}
 212:setup.c       **** }
 106               		.loc 1 212 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 213:setup.c       **** 
 214:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 215:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 215 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 216:setup.c       **** 	int x = 0;
 217:setup.c       **** 	while (1) {
 218:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 218 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 219:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 219 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 220:setup.c       **** 			break;
 221:setup.c       **** 		}
 222:setup.c       **** 		x++;
 223:setup.c       **** 	}
 224:setup.c       **** }
 148               		.loc 1 224 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 225:setup.c       **** 
 226:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 227:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 227 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 228:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 228 0
 167 0050 3A9A      		sbi 0x7,2
 229:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 229 0
 169 0052 949A      		sbi 0x12,4
 230:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 230 0
 171 0054 959A      		sbi 0x12,5
 231:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 231 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 232:setup.c       **** }
 233:setup.c       **** 
 234:setup.c       **** 
 235:setup.c       **** 
 236:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 237:setup.c       **** 
 238:setup.c       **** // Set Gameboy mode
 239:setup.c       **** void gb_mode(void) {
 182               		.loc 1 239 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 240:setup.c       **** 	// Set inputs
 241:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 241 0
 189 005a 15BA      		out 0x15,__zero_reg__
 242:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 242 0
 191 005c 14BA      		out 0x14,__zero_reg__
 243:setup.c       **** 	
 244:setup.c       **** 	// Set outputs
 245:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 245 0
 193 005e 18BA      		out 0x18,__zero_reg__
 246:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 246 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 247:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 247 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 248:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 248 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 249:setup.c       **** }
 250:setup.c       **** 
 251:setup.c       **** // Set the 16 bit address on A15-0
 252:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 252 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 253:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 253 0
 217 006a 9BBB      		out 0x1b,r25
 254:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 254 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 255:setup.c       **** }
 256:setup.c       **** 
 257:setup.c       **** // Set the address and read a byte from the 8 bit data line
 258:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 258 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 259:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 259 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 260:setup.c       **** 	
 261:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 261 0
 239 0072 9498      		cbi 0x12,4
 262:setup.c       **** 	rdPin_low;
 240               		.loc 1 262 0
 241 0074 9598      		cbi 0x12,5
 263:setup.c       **** 	
 264:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 264 0
 243               	/* #APP */
 244               	 ;  264 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 265:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 265 0
 248               	 ;  265 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 266:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 266 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 267:setup.c       **** 	
 268:setup.c       **** 	rdPin_high;
 255               		.loc 1 268 0
 256 007c 959A      		sbi 0x12,5
 269:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 269 0
 258 007e 949A      		sbi 0x12,4
 270:setup.c       **** 	
 271:setup.c       **** 	return data;
 272:setup.c       **** }
 259               		.loc 1 272 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 273:setup.c       **** 
 274:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 275:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 275 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 276:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 276 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 277:setup.c       **** 	
 278:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 278 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 279:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 279 0
 292 0090 D5BB      		out 0x15,r29
 280:setup.c       **** 	
 281:setup.c       **** 	// Pulse WR and mREQ if the type matches
 282:setup.c       **** 	wrPin_low;
 293               		.loc 1 282 0
 294 0092 9698      		cbi 0x12,6
 283:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 283 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 284:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 284 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 285:setup.c       **** 	}
 286:setup.c       **** 	
 287:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 287 0
 302               	/* #APP */
 303               	 ;  287 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 288:setup.c       **** 	
 289:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 289 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 290:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 290 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 291:setup.c       **** 	}
 292:setup.c       **** 	wrPin_high;
 313               		.loc 1 292 0
 314 00a2 969A      		sbi 0x12,6
 293:setup.c       **** 	
 294:setup.c       **** 	// Clear data outputs and set data pins as inputs
 295:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 295 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 296:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 296 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 297:setup.c       **** }
 320               		.loc 1 297 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 298:setup.c       **** 
 299:setup.c       **** 
 300:setup.c       **** 
 301:setup.c       **** // ****** Gameboy Advance functions ****** 
 302:setup.c       **** 
 303:setup.c       **** // Set GBA mode
 304:setup.c       **** void gba_mode(void) {
 333               		.loc 1 304 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 305:setup.c       **** 	// Set outputs for reading ROM addresses as default
 306:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 306 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 307:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 307 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 308:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 308 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 309:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 309 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 310:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 310 0
 349 00b8 8ABB      		out 0x1a,r24
 311:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 311 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 312:setup.c       **** }
 313:setup.c       **** 
 314:setup.c       **** // Set the 24 bit address on A23-0
 315:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 315 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 316:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 316 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 317:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 317 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 318:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 318 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 319:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 319 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 320:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 320 0
 385 00cc 2ABB      		out 0x1a,r18
 321:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 321 0
 387 00ce 27BB      		out 0x17,r18
 322:setup.c       **** 	
 323:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 323 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 324:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 324 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 325:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 325 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 326:setup.c       **** }
 402               		.loc 1 326 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 327:setup.c       **** 
 328:setup.c       **** 
 329:setup.c       **** 
 330:setup.c       **** // ---------- ROM/SRAM ----------
 331:setup.c       **** 
 332:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 333:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 333 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 334:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 334 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 335:setup.c       **** 	
 336:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 336 0
 424 00ec 9498      		cbi 0x12,4
 337:setup.c       **** 	
 338:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 338 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 339:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 339 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 340:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 340 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 341:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 341 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 342:setup.c       **** 	
 343:setup.c       **** 	rdPin_low;
 433               		.loc 1 343 0
 434 00f6 9598      		cbi 0x12,5
 344:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 344 0
 436               	/* #APP */
 437               	 ;  344 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 345:setup.c       **** 	
 346:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 346 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 347:setup.c       **** 	
 348:setup.c       **** 	rdPin_high;
 445               		.loc 1 348 0
 446 00fe 959A      		sbi 0x12,5
 349:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 349 0
 448 0100 949A      		sbi 0x12,4
 350:setup.c       **** 	
 351:setup.c       **** 	return data;
 449               		.loc 1 351 0
 450 0102 90E0      		ldi r25,0
 352:setup.c       **** }
 451               		.loc 1 352 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 353:setup.c       **** 
 354:setup.c       **** // Set the address and read a byte from the 8 bit data line
 355:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 355 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 356:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 356 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 357:setup.c       **** 	
 358:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 471               		.loc 1 358 0
 472 010a 3A98      		cbi 0x7,2
 359:setup.c       **** 	rdPin_low;
 473               		.loc 1 359 0
 474 010c 9598      		cbi 0x12,5
 360:setup.c       **** 	
 361:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 361 0
 476               	/* #APP */
 477               	 ;  361 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 362:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 362 0
 481               	 ;  362 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 363:setup.c       **** 	
 364:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 364 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 365:setup.c       **** 	
 366:setup.c       **** 	rdPin_high;
 488               		.loc 1 366 0
 489 0114 959A      		sbi 0x12,5
 367:setup.c       **** 	cs2Pin_high;
 490               		.loc 1 367 0
 491 0116 3A9A      		sbi 0x7,2
 368:setup.c       **** 	
 369:setup.c       **** 	return data;
 370:setup.c       **** }
 492               		.loc 1 370 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 371:setup.c       **** 
 372:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 373:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 373 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 374:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 374 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 375:setup.c       **** 	
 376:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 376 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 377:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 377 0
 520 0124 C5BB      		out 0x15,r28
 378:setup.c       **** 	
 379:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 521               		.loc 1 379 0
 522 0126 3A98      		cbi 0x7,2
 380:setup.c       **** 	wrPin_low; // Pulse WR
 523               		.loc 1 380 0
 524 0128 9698      		cbi 0x12,6
 381:setup.c       **** 	
 382:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 382 0
 526               	/* #APP */
 527               	 ;  382 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 383:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 383 0
 531               	 ;  383 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 384:setup.c       **** 	
 385:setup.c       **** 	wrPin_high;
 534               		.loc 1 385 0
 535               	/* #NOAPP */
 536 012e 969A      		sbi 0x12,6
 386:setup.c       **** 	cs2Pin_high;
 537               		.loc 1 386 0
 538 0130 3A9A      		sbi 0x7,2
 387:setup.c       **** 	
 388:setup.c       **** 	// Clear data outputs and set data pins as inputs
 389:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 389 0
 540 0132 15BA      		out 0x15,__zero_reg__
 390:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 390 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 391:setup.c       **** }
 544               		.loc 1 391 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 392:setup.c       **** 
 393:setup.c       **** 
 394:setup.c       **** 
 395:setup.c       **** // ---------- EEPROM ----------
 396:setup.c       **** 
 397:setup.c       **** // Set address/data all high (includes AD0/A23)
 398:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 398 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 399:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 399 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 400:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 400 0
 565 013e 8ABB      		out 0x1a,r24
 401:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 401 0
 567 0140 84BB      		out 0x14,r24
 402:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 402 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 403:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 403 0
 572 0146 8BBB      		out 0x1b,r24
 404:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 404 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 405:setup.c       **** }
 406:setup.c       **** 
 407:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 408:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 408 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 409:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 409 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 410:setup.c       **** 	
 411:setup.c       **** 	int8_t x = 0;
 412:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 412 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 413:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 413 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 414:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 414 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 415:setup.c       **** 		}
 416:setup.c       **** 		else {
 417:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 418:setup.c       **** 		}
 419:setup.c       **** 		x = 15;
 603               		.loc 1 419 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 420:setup.c       **** 	}
 421:setup.c       **** 	else {
 422:setup.c       **** 		if (command == EEPROM_READ) {
 423:setup.c       **** 			address |= (1<<7) | (1<<6);
 424:setup.c       **** 		}
 425:setup.c       **** 		else {
 426:setup.c       **** 			address |= (1<<7);
 427:setup.c       **** 		}
 428:setup.c       **** 		x = 7;
 429:setup.c       **** 	}
 430:setup.c       **** 	
 431:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 432:setup.c       **** 	while (x >= 0) {
 433:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 433 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 417:setup.c       **** 		}
 613               		.loc 1 417 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 422:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 422 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 423:setup.c       **** 		}
 621               		.loc 1 423 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 426:setup.c       **** 		}
 626               		.loc 1 426 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 428:setup.c       **** 	}
 630               		.loc 1 428 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 434:setup.c       **** 			ad0Pin_high;
 435:setup.c       **** 		}
 436:setup.c       **** 		else {
 437:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 437 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 438:setup.c       **** 		}
 439:setup.c       **** 		
 440:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 440 0
 639 0174 9698      		cbi 0x12,6
 441:setup.c       **** 		asm ("nop");
 640               		.loc 1 441 0
 641               	/* #APP */
 642               	 ;  441 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 442:setup.c       **** 		asm ("nop");
 645               		.loc 1 442 0
 646               	 ;  442 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 443:setup.c       **** 		wrPin_high; 
 649               		.loc 1 443 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 444:setup.c       **** 		asm ("nop");
 652               		.loc 1 444 0
 653               	/* #APP */
 654               	 ;  444 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 445:setup.c       **** 		asm ("nop");
 657               		.loc 1 445 0
 658               	 ;  445 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 432:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 432 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 433:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 433 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 434:setup.c       **** 		}
 682               		.loc 1 434 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 446:setup.c       **** 		
 447:setup.c       **** 		x--;
 448:setup.c       **** 	}
 449:setup.c       **** 	
 450:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 451:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 451 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 452:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 452 0
 690 01a4 C098      		cbi 0x18,0
 453:setup.c       **** 		asm ("nop");
 691               		.loc 1 453 0
 692               	/* #APP */
 693               	 ;  453 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 454:setup.c       **** 		wrPin_low;
 696               		.loc 1 454 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 455:setup.c       **** 		asm ("nop");
 699               		.loc 1 455 0
 700               	/* #APP */
 701               	 ;  455 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 456:setup.c       **** 		asm ("nop");
 704               		.loc 1 456 0
 705               	 ;  456 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 457:setup.c       **** 		
 458:setup.c       **** 		wrPin_high;
 708               		.loc 1 458 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 459:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 459 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 460:setup.c       **** 	}
 461:setup.c       **** }
 462:setup.c       **** 
 463:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 464:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 464 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 465:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 465 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 466:setup.c       **** 	
 467:setup.c       **** 	// Set AD0 pin as input
 468:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 468 0
 734 01b8 C098      		cbi 0x18,0
 469:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 469 0
 736 01ba B898      		cbi 0x17,0
 470:setup.c       **** 	
 471:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 471 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB167:
 472:setup.c       **** 	
 473:setup.c       **** 	// Ignore first 4 bits
 474:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 475:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 475 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 476:setup.c       **** 		asm ("nop");
 746               		.loc 1 476 0 discriminator 3
 747               	/* #APP */
 748               	 ;  476 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 477:setup.c       **** 		asm ("nop");
 751               		.loc 1 477 0 discriminator 3
 752               	 ;  477 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 478:setup.c       **** 		rdPin_high; 
 755               		.loc 1 478 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 479:setup.c       **** 		asm ("nop");
 758               		.loc 1 479 0 discriminator 3
 759               	/* #APP */
 760               	 ;  479 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 480:setup.c       **** 		asm ("nop");
 763               		.loc 1 480 0 discriminator 3
 764               	 ;  480 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 474:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 474 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE167:
 776               	.LBB168:
 777               	.LBB169:
 778               	.LBB170:
 481:setup.c       **** 	}
 482:setup.c       **** 	
 483:setup.c       **** 	// Read out 64 bits
 484:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 485:setup.c       **** 		uint8_t data = 0;
 486:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 487:setup.c       **** 			rdPin_low; // CLK
 488:setup.c       **** 			asm ("nop");
 489:setup.c       **** 			asm ("nop");
 490:setup.c       **** 			rdPin_high;
 491:setup.c       **** 			
 492:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 493:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 493 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE170:
 785               	.LBE169:
 786               	.LBE168:
 471:setup.c       **** 	
 787               		.loc 1 471 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB173:
 794               	.LBB172:
 795               	.LBB171:
 487:setup.c       **** 			asm ("nop");
 796               		.loc 1 487 0
 797 01de 9598      		cbi 0x12,5
 488:setup.c       **** 			asm ("nop");
 798               		.loc 1 488 0
 799               	/* #APP */
 800               	 ;  488 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 489:setup.c       **** 			rdPin_high;
 803               		.loc 1 489 0
 804               	 ;  489 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 490:setup.c       **** 			
 807               		.loc 1 490 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 492:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 492 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 493 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE171:
 494:setup.c       **** 			}
 495:setup.c       **** 		}
 496:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 496 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE172:
 484:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 484 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE173:
 497:setup.c       **** 	}
 498:setup.c       **** 	
 499:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 499 0
 841 0206 949A      		sbi 0x12,4
 500:setup.c       **** 	
 501:setup.c       **** 	// Set AD0 pin as output
 502:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 502 0
 843 0208 C09A      		sbi 0x18,0
 503:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 503 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 504:setup.c       **** }
 505:setup.c       **** 
 506:setup.c       **** // Write 8 bytes to the EEPROM address
 507:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 507 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 508:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 508 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 507:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 507 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB174:
 876               	.LBB175:
 509:setup.c       **** 	
 510:setup.c       **** 	// Write 64 bits
 511:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 512:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 513:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 513 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 514:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 514 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 515:setup.c       **** 			}
 516:setup.c       **** 			else {
 517:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 517 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 518:setup.c       **** 			}
 519:setup.c       **** 			
 520:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 520 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 521:setup.c       **** 			asm ("nop");
 899               		.loc 1 521 0 discriminator 2
 900               	/* #APP */
 901               	 ;  521 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 522:setup.c       **** 			asm ("nop");
 904               		.loc 1 522 0 discriminator 2
 905               	 ;  522 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 523:setup.c       **** 			wrPin_high; 
 908               		.loc 1 523 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 524:setup.c       **** 			asm ("nop");
 911               		.loc 1 524 0 discriminator 2
 912               	/* #APP */
 913               	 ;  524 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 525:setup.c       **** 			asm ("nop");
 916               		.loc 1 525 0 discriminator 2
 917               	 ;  525 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE175:
 511:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 511 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE174:
 526:setup.c       **** 		}
 527:setup.c       **** 	}
 528:setup.c       **** 	
 529:setup.c       **** 	// Last bit low
 530:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 530 0
 935 0250 C098      		cbi 0x18,0
 531:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 531 0
 937 0252 9698      		cbi 0x12,6
 532:setup.c       **** 	asm ("nop");
 938               		.loc 1 532 0
 939               	/* #APP */
 940               	 ;  532 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 533:setup.c       **** 	asm ("nop");
 943               		.loc 1 533 0
 944               	 ;  533 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 534:setup.c       **** 	wrPin_high; 
 947               		.loc 1 534 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 535:setup.c       **** 	asm ("nop");
 950               		.loc 1 535 0
 951               	/* #APP */
 952               	 ;  535 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 536:setup.c       **** 	asm ("nop");
 955               		.loc 1 536 0
 956               	 ;  536 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 537:setup.c       **** 	
 538:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 538 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 539:setup.c       **** }
 540:setup.c       **** 
 541:setup.c       **** 
 542:setup.c       **** 
 543:setup.c       **** // ---------- FLASH ----------
 544:setup.c       **** 
 545:setup.c       **** // Set the address and data for the write byte cycle to the flash
 546:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 546 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 547:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 547 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 548:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 548 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 549:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 549 0
 989 026c C5BB      		out 0x15,r28
 550:setup.c       **** 	
 551:setup.c       **** 	cs2Pin_low;
 990               		.loc 1 551 0
 991 026e 3A98      		cbi 0x7,2
 552:setup.c       **** 	wrPin_low;
 992               		.loc 1 552 0
 993 0270 9698      		cbi 0x12,6
 553:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 553 0
 995               	/* #APP */
 996               	 ;  553 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 554:setup.c       **** 	cs2Pin_high;
 999               		.loc 1 554 0
 1000               	/* #NOAPP */
 1001 0274 3A9A      		sbi 0x7,2
 555:setup.c       **** 	wrPin_high;
 1002               		.loc 1 555 0
 1003 0276 969A      		sbi 0x12,6
 1004               	/* epilogue start */
 556:setup.c       **** }
 1005               		.loc 1 556 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 557:setup.c       **** 
 558:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 559:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 559 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 560:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 560 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 561:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 561 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 562:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 562 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB176:
 1049               	.LBB177:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE177:
 1060               	.LBE176:
 563:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 564:setup.c       **** 	
 565:setup.c       **** 	// Set data as inputs
 566:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 566 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 567:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 567 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 568:setup.c       **** 	
 569:setup.c       **** 	// Read and transmit the 2 bytes
 570:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 570 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 571:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 571 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 572:setup.c       **** 	
 573:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 573 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 574:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 574 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 575:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 575 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB178:
 1098               	.LBB179:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE179:
 1109               	.LBE178:
 576:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 577:setup.c       **** }
 1110               		.loc 1 577 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 578:setup.c       **** 
 579:setup.c       **** // Switch banks on the Flash
 580:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 580 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 581:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 581 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 582:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 582 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 583:setup.c       **** 	
 584:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 584 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 585:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 585 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 586:setup.c       **** }
 1157               		.loc 1 586 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 585:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 585 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 587:setup.c       **** 
 588:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 589:setup.c       **** // Takes 25ms after last command to erase sector
 590:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 590 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 591:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 591 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 592:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 592 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 593:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 593 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 594:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 594 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 595:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 595 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 596:setup.c       **** 	
 597:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 597 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB180:
 1222               	.LBB181:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE181:
 1233               	.LBE180:
 598:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 599:setup.c       **** }
 1234               		.loc 1 599 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 600:setup.c       **** 
 601:setup.c       **** // Write a single byte to the Flash address
 602:setup.c       **** // Takes 20us to program Flash
 603:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 603 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 604:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 604 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 605:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 605 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 606:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 606 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 607:setup.c       **** 	
 608:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 608 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB182:
 1292               	.LBB183:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE183:
 1301               	.LBE182:
 609:setup.c       **** 	_delay_us(20); // Wait byte program time
 610:setup.c       **** }
 1302               		.loc 1 610 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 611:setup.c       **** 
 612:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 613:setup.c       **** // Takes 20ms for write cycle
 614:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 614 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 615:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 615 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 616:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 616 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 617:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 617 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB184:
 618:setup.c       **** 	
 619:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 620:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 621:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 621 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 621 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 620:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 620 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE184:
 1400               	.LBB185:
 1401               	.LBB186:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE186:
 1412               	.LBE185:
 622:setup.c       **** 	}
 623:setup.c       **** 	_delay_ms(20); // Wait sector program time
 624:setup.c       **** }
 1413               		.loc 1 624 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 625:setup.c       **** 
 626:setup.c       **** 
 627:setup.c       **** 
 628:setup.c       **** // ---------- GB FLASH CARTS ----------
 629:setup.c       **** 
 630:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 631:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 631 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 632:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 632 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 633:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 633 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 634:setup.c       **** 	
 635:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 635 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 636:setup.c       **** 	
 637:setup.c       **** 	rdPin_low;
 1443               		.loc 1 637 0
 1444 03fe 9598      		cbi 0x12,5
 638:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 638 0
 1446               	/* #APP */
 1447               	 ;  638 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 639:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 639 0
 1451               	 ;  639 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 640:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 640 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 641:setup.c       **** 	rdPin_high;
 1458               		.loc 1 641 0
 1459 0406 959A      		sbi 0x12,5
 642:setup.c       **** 	
 643:setup.c       **** 	return data;
 644:setup.c       **** }
 1460               		.loc 1 644 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_read_byte_fast
 1467               	gb_flash_read_byte_fast:
 1468               	.LFB37:
 645:setup.c       **** 
 646:setup.c       **** // No setting address or outputs, assuming already set
 647:setup.c       **** uint8_t gb_flash_read_byte_fast(void) {
 1469               		.loc 1 647 0
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 648:setup.c       **** 	rdPin_low;
 1475               		.loc 1 648 0
 1476 040a 9598      		cbi 0x12,5
 649:setup.c       **** 	asm volatile("nop"); // Delay a little
 1477               		.loc 1 649 0
 1478               	/* #APP */
 1479               	 ;  649 "setup.c" 1
 1480 040c 0000      		nop
 1481               	 ;  0 "" 2
 650:setup.c       **** 	asm volatile("nop");
 1482               		.loc 1 650 0
 1483               	 ;  650 "setup.c" 1
 1484 040e 0000      		nop
 1485               	 ;  0 "" 2
 651:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1486               		.loc 1 651 0
 1487               	/* #NOAPP */
 1488 0410 83B3      		in r24,0x13
 1489               	.LVL116:
 652:setup.c       **** 	rdPin_high;
 1490               		.loc 1 652 0
 1491 0412 959A      		sbi 0x12,5
 653:setup.c       **** 	
 654:setup.c       **** 	return data;
 655:setup.c       **** }
 1492               		.loc 1 655 0
 1493 0414 0895      		ret
 1494               		.cfi_endproc
 1495               	.LFE37:
 1497               	.global	gb_flash_write_bus_cycle
 1499               	gb_flash_write_bus_cycle:
 1500               	.LFB38:
 656:setup.c       **** 
 657:setup.c       **** // Set the address and data for the write byte cycle to the flash
 658:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1501               		.loc 1 658 0
 1502               		.cfi_startproc
 1503               	.LVL117:
 1504 0416 CF93      		push r28
 1505               	.LCFI25:
 1506               		.cfi_def_cfa_offset 3
 1507               		.cfi_offset 28, -2
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 1 */
 1511               	.L__stack_usage = 1
 1512 0418 C62F      		mov r28,r22
 659:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1513               		.loc 1 659 0
 1514 041a 2FEF      		ldi r18,lo8(-1)
 1515 041c 24BB      		out 0x14,r18
 660:setup.c       **** 	set_16bit_address(address);
 1516               		.loc 1 660 0
 1517 041e 00D0      		rcall set_16bit_address
 1518               	.LVL118:
 661:setup.c       **** 	PORT_DATA7_0 = data;
 1519               		.loc 1 661 0
 1520 0420 C5BB      		out 0x15,r28
 662:setup.c       **** 	
 663:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1521               		.loc 1 663 0
 1522 0422 8091 0000 		lds r24,flashWriteWePin
 1523 0426 8134      		cpi r24,lo8(65)
 1524 0428 01F4      		brne .L71
 664:setup.c       **** 		audioPin_low; // WE low
 1525               		.loc 1 664 0
 1526 042a 3998      		cbi 0x7,1
 665:setup.c       **** 		asm volatile("nop");
 1527               		.loc 1 665 0
 1528               	/* #APP */
 1529               	 ;  665 "setup.c" 1
 1530 042c 0000      		nop
 1531               	 ;  0 "" 2
 666:setup.c       **** 		asm volatile("nop");
 1532               		.loc 1 666 0
 1533               	 ;  666 "setup.c" 1
 1534 042e 0000      		nop
 1535               	 ;  0 "" 2
 667:setup.c       **** 		asm volatile("nop");
 1536               		.loc 1 667 0
 1537               	 ;  667 "setup.c" 1
 1538 0430 0000      		nop
 1539               	 ;  0 "" 2
 668:setup.c       **** 		audioPin_high; // WE high
 1540               		.loc 1 668 0
 1541               	/* #NOAPP */
 1542 0432 399A      		sbi 0x7,1
 1543 0434 00C0      		rjmp .L72
 1544               	.L71:
 669:setup.c       **** 	}
 670:setup.c       **** 	else { // WR pin
 671:setup.c       **** 		wrPin_low; // WE low
 1545               		.loc 1 671 0
 1546 0436 9698      		cbi 0x12,6
 672:setup.c       **** 		asm volatile("nop");
 1547               		.loc 1 672 0
 1548               	/* #APP */
 1549               	 ;  672 "setup.c" 1
 1550 0438 0000      		nop
 1551               	 ;  0 "" 2
 673:setup.c       **** 		asm volatile("nop");
 1552               		.loc 1 673 0
 1553               	 ;  673 "setup.c" 1
 1554 043a 0000      		nop
 1555               	 ;  0 "" 2
 674:setup.c       **** 		asm volatile("nop");
 1556               		.loc 1 674 0
 1557               	 ;  674 "setup.c" 1
 1558 043c 0000      		nop
 1559               	 ;  0 "" 2
 675:setup.c       **** 		wrPin_high; // WE high
 1560               		.loc 1 675 0
 1561               	/* #NOAPP */
 1562 043e 969A      		sbi 0x12,6
 1563               	.L72:
 676:setup.c       **** 	}
 677:setup.c       **** 	
 678:setup.c       **** 	// Clear data outputs and set data pins as inputs
 679:setup.c       **** 	PORT_DATA7_0 = 0;
 1564               		.loc 1 679 0
 1565 0440 15BA      		out 0x15,__zero_reg__
 680:setup.c       **** 	DDR_DATA7_0 = 0;
 1566               		.loc 1 680 0
 1567 0442 14BA      		out 0x14,__zero_reg__
 1568               	/* epilogue start */
 681:setup.c       **** }
 1569               		.loc 1 681 0
 1570 0444 CF91      		pop r28
 1571               	.LVL119:
 1572 0446 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE38:
 1576               	.global	gb_flash_write_bus_cycle_fast
 1578               	gb_flash_write_bus_cycle_fast:
 1579               	.LFB39:
 682:setup.c       **** 
 683:setup.c       **** void gb_flash_write_bus_cycle_fast(uint16_t address, uint8_t data) {
 1580               		.loc 1 683 0
 1581               		.cfi_startproc
 1582               	.LVL120:
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1585               	/* stack size = 0 */
 1586               	.L__stack_usage = 0
 684:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 1587               		.loc 1 684 0
 1588 0448 9BBB      		out 0x1b,r25
 685:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1589               		.loc 1 685 0
 1590 044a 88BB      		out 0x18,r24
 686:setup.c       **** 	PORT_DATA7_0 = data;
 1591               		.loc 1 686 0
 1592 044c 65BB      		out 0x15,r22
 687:setup.c       **** 	
 688:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1593               		.loc 1 688 0
 1594 044e 8091 0000 		lds r24,flashWriteWePin
 1595               	.LVL121:
 1596 0452 8134      		cpi r24,lo8(65)
 1597 0454 01F4      		brne .L74
 1598               	.LVL122:
 1599               	.LBB189:
 1600               	.LBB190:
 689:setup.c       **** 		audioPin_low; // WE low
 1601               		.loc 1 689 0
 1602 0456 3998      		cbi 0x7,1
 690:setup.c       **** 		asm volatile("nop");
 1603               		.loc 1 690 0
 1604               	/* #APP */
 1605               	 ;  690 "setup.c" 1
 1606 0458 0000      		nop
 1607               	 ;  0 "" 2
 691:setup.c       **** 		asm volatile("nop");
 1608               		.loc 1 691 0
 1609               	 ;  691 "setup.c" 1
 1610 045a 0000      		nop
 1611               	 ;  0 "" 2
 692:setup.c       **** 		asm volatile("nop");
 1612               		.loc 1 692 0
 1613               	 ;  692 "setup.c" 1
 1614 045c 0000      		nop
 1615               	 ;  0 "" 2
 693:setup.c       **** 		audioPin_high; // WE high
 1616               		.loc 1 693 0
 1617               	/* #NOAPP */
 1618 045e 399A      		sbi 0x7,1
 1619 0460 0895      		ret
 1620               	.LVL123:
 1621               	.L74:
 1622               	.LBE190:
 1623               	.LBE189:
 694:setup.c       **** 	}
 695:setup.c       **** 	else { // WR pin
 696:setup.c       **** 		wrPin_low; // WE low
 1624               		.loc 1 696 0
 1625 0462 9698      		cbi 0x12,6
 697:setup.c       **** 		asm volatile("nop");
 1626               		.loc 1 697 0
 1627               	/* #APP */
 1628               	 ;  697 "setup.c" 1
 1629 0464 0000      		nop
 1630               	 ;  0 "" 2
 698:setup.c       **** 		asm volatile("nop");
 1631               		.loc 1 698 0
 1632               	 ;  698 "setup.c" 1
 1633 0466 0000      		nop
 1634               	 ;  0 "" 2
 699:setup.c       **** 		asm volatile("nop");
 1635               		.loc 1 699 0
 1636               	 ;  699 "setup.c" 1
 1637 0468 0000      		nop
 1638               	 ;  0 "" 2
 700:setup.c       **** 		wrPin_high; // WE high
 1639               		.loc 1 700 0
 1640               	/* #NOAPP */
 1641 046a 969A      		sbi 0x12,6
 1642 046c 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE39:
 1646               	.global	gb_flash_write_byte
 1648               	gb_flash_write_byte:
 1649               	.LFB40:
 701:setup.c       **** 	}
 702:setup.c       **** }
 703:setup.c       **** 
 704:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 705:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1650               		.loc 1 705 0
 1651               		.cfi_startproc
 1652               	.LVL124:
 1653 046e 0F93      		push r16
 1654               	.LCFI26:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 0470 1F93      		push r17
 1658               	.LCFI27:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661 0472 CF93      		push r28
 1662               	.LCFI28:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 28, -4
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 3 */
 1668               	.L__stack_usage = 3
 1669 0474 8C01      		movw r16,r24
 1670 0476 C62F      		mov r28,r22
 706:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1671               		.loc 1 706 0
 1672 0478 8FEF      		ldi r24,lo8(-1)
 1673               	.LVL125:
 1674 047a 84BB      		out 0x14,r24
 707:setup.c       **** 	
 708:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1675               		.loc 1 708 0
 1676 047c 6091 0000 		lds r22,flashWriteCycle+2
 1677               	.LVL126:
 1678 0480 8091 0000 		lds r24,flashWriteCycle
 1679 0484 9091 0000 		lds r25,flashWriteCycle+1
 1680 0488 00D0      		rcall gb_flash_write_bus_cycle_fast
 1681               	.LVL127:
 709:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1682               		.loc 1 709 0
 1683 048a 6091 0000 		lds r22,flashWriteCycle+6
 1684 048e 8091 0000 		lds r24,flashWriteCycle+4
 1685 0492 9091 0000 		lds r25,flashWriteCycle+4+1
 1686 0496 00D0      		rcall gb_flash_write_bus_cycle_fast
 1687               	.LVL128:
 710:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1688               		.loc 1 710 0
 1689 0498 6091 0000 		lds r22,flashWriteCycle+10
 1690 049c 8091 0000 		lds r24,flashWriteCycle+8
 1691 04a0 9091 0000 		lds r25,flashWriteCycle+8+1
 1692 04a4 00D0      		rcall gb_flash_write_bus_cycle_fast
 1693               	.LVL129:
 711:setup.c       **** 	gb_flash_write_bus_cycle_fast(address, data);
 1694               		.loc 1 711 0
 1695 04a6 6C2F      		mov r22,r28
 1696 04a8 C801      		movw r24,r16
 1697 04aa 00D0      		rcall gb_flash_write_bus_cycle_fast
 1698               	.LVL130:
 1699               	.LBB191:
 1700               	.LBB192:
 1701               		.loc 2 276 0
 1702 04ac 8DE0      		ldi r24,lo8(13)
 1703 04ae 8A95      	1:	dec r24
 1704 04b0 01F4      		brne 1b
 1705 04b2 0000      		nop
 1706               	.LVL131:
 1707               	.LBE192:
 1708               	.LBE191:
 712:setup.c       **** 	_delay_us(5); // Wait byte program time
 713:setup.c       **** 	
 714:setup.c       **** 	// Set data pins inputs
 715:setup.c       **** 	PORT_DATA7_0 = 0;
 1709               		.loc 1 715 0
 1710 04b4 15BA      		out 0x15,__zero_reg__
 716:setup.c       **** 	DDR_DATA7_0 = 0;
 1711               		.loc 1 716 0
 1712 04b6 14BA      		out 0x14,__zero_reg__
 717:setup.c       **** 	
 718:setup.c       **** 	// Verify data
 719:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte_fast();
 1713               		.loc 1 719 0
 1714 04b8 00D0      		rcall gb_flash_read_byte_fast
 1715               	.LVL132:
 1716               	.L77:
 720:setup.c       **** 	while (data != dataVerify) {
 1717               		.loc 1 720 0
 1718 04ba 8C17      		cp r24,r28
 1719 04bc 01F0      		breq .L76
 721:setup.c       **** 		dataVerify = gb_flash_read_byte_fast();
 1720               		.loc 1 721 0
 1721 04be 00D0      		rcall gb_flash_read_byte_fast
 1722               	.LVL133:
 1723               	.LBB193:
 1724               	.LBB194:
 1725               		.loc 2 276 0
 1726 04c0 92E0      		ldi r25,lo8(2)
 1727 04c2 9A95      	1:	dec r25
 1728 04c4 01F4      		brne 1b
 1729 04c6 00C0      		rjmp .
 1730               	.LVL134:
 1731               	.LBE194:
 1732               	.LBE193:
 722:setup.c       **** 		_delay_us(1);
 723:setup.c       **** 		if (writingTimedout == 1) {
 1733               		.loc 1 723 0
 1734 04c8 9091 0000 		lds r25,writingTimedout
 1735 04cc 9130      		cpi r25,lo8(1)
 1736 04ce 01F4      		brne .L77
 1737               	.L76:
 1738               	/* epilogue start */
 724:setup.c       **** 			break;
 725:setup.c       **** 		}
 726:setup.c       **** 	}
 727:setup.c       **** }
 1739               		.loc 1 727 0
 1740 04d0 CF91      		pop r28
 1741               	.LVL135:
 1742 04d2 1F91      		pop r17
 1743 04d4 0F91      		pop r16
 1744               	.LVL136:
 1745 04d6 0895      		ret
 1746               		.cfi_endproc
 1747               	.LFE40:
 1749               	.global	gb_flash_write_byte_special
 1751               	gb_flash_write_byte_special:
 1752               	.LFB41:
 728:setup.c       **** 
 729:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 730:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1753               		.loc 1 730 0
 1754               		.cfi_startproc
 1755               	.LVL137:
 1756 04d8 1F93      		push r17
 1757               	.LCFI29:
 1758               		.cfi_def_cfa_offset 3
 1759               		.cfi_offset 17, -2
 1760 04da CF93      		push r28
 1761               	.LCFI30:
 1762               		.cfi_def_cfa_offset 4
 1763               		.cfi_offset 28, -3
 1764 04dc DF93      		push r29
 1765               	.LCFI31:
 1766               		.cfi_def_cfa_offset 5
 1767               		.cfi_offset 29, -4
 1768               	/* prologue: function */
 1769               	/* frame size = 0 */
 1770               	/* stack size = 3 */
 1771               	.L__stack_usage = 3
 1772 04de EC01      		movw r28,r24
 1773 04e0 162F      		mov r17,r22
 731:setup.c       **** 	// Set bank back
 732:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1774               		.loc 1 732 0
 1775 04e2 8091 0000 		lds r24,flashBank1CommandWrites
 1776               	.LVL138:
 1777 04e6 8130      		cpi r24,lo8(1)
 1778 04e8 01F4      		brne .L82
 733:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1779               		.loc 1 733 0
 1780 04ea 40E0      		ldi r20,0
 1781 04ec 6091 0000 		lds r22,lastBankAccessed
 1782               	.LVL139:
 1783 04f0 80E0      		ldi r24,0
 1784 04f2 91E2      		ldi r25,lo8(33)
 1785 04f4 00D0      		rcall write_8bit_data
 1786               	.LVL140:
 1787               	.LBB195:
 1788               	.LBB196:
 1789               		.loc 2 276 0
 1790 04f6 85E8      		ldi r24,lo8(-123)
 1791 04f8 8A95      	1:	dec r24
 1792 04fa 01F4      		brne 1b
 1793 04fc 0000      		nop
 1794               	.LVL141:
 1795               	.L82:
 1796               	.LBE196:
 1797               	.LBE195:
 734:setup.c       **** 		_delay_us(50);
 735:setup.c       **** 	}
 736:setup.c       **** 	
 737:setup.c       **** 	// Write
 738:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1798               		.loc 1 738 0
 1799 04fe 6091 0000 		lds r22,flashWriteCycle+2
 1800 0502 8091 0000 		lds r24,flashWriteCycle
 1801 0506 9091 0000 		lds r25,flashWriteCycle+1
 1802 050a 00D0      		rcall gb_flash_write_bus_cycle
 1803               	.LVL142:
 739:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1804               		.loc 1 739 0
 1805 050c 6091 0000 		lds r22,flashWriteCycle+6
 1806 0510 8091 0000 		lds r24,flashWriteCycle+4
 1807 0514 9091 0000 		lds r25,flashWriteCycle+4+1
 1808 0518 00D0      		rcall gb_flash_write_bus_cycle
 1809               	.LVL143:
 740:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1810               		.loc 1 740 0
 1811 051a 6091 0000 		lds r22,flashWriteCycle+10
 1812 051e 8091 0000 		lds r24,flashWriteCycle+8
 1813 0522 9091 0000 		lds r25,flashWriteCycle+8+1
 1814 0526 00D0      		rcall gb_flash_write_bus_cycle
 1815               	.LVL144:
 741:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1816               		.loc 1 741 0
 1817 0528 612F      		mov r22,r17
 1818 052a CE01      		movw r24,r28
 1819 052c 00D0      		rcall gb_flash_write_bus_cycle
 1820               	.LVL145:
 1821               	.LBB197:
 1822               	.LBB198:
 1823               		.loc 2 276 0
 1824 052e 83EF      		ldi r24,lo8(499)
 1825 0530 91E0      		ldi r25,hi8(499)
 1826 0532 0197      	1:	sbiw r24,1
 1827 0534 01F4      		brne 1b
 1828 0536 00C0      		rjmp .
 1829 0538 0000      		nop
 1830               	.LVL146:
 1831               	.LBE198:
 1832               	.LBE197:
 742:setup.c       **** 	_delay_us(250); // Wait byte program time
 743:setup.c       **** 	
 744:setup.c       **** 	// Set data pins inputs
 745:setup.c       **** 	PORT_DATA7_0 = 0;
 1833               		.loc 1 745 0
 1834 053a 15BA      		out 0x15,__zero_reg__
 746:setup.c       **** 	DDR_DATA7_0 = 0;
 1835               		.loc 1 746 0
 1836 053c 14BA      		out 0x14,__zero_reg__
 747:setup.c       **** 	
 748:setup.c       **** 	// Pulse reset
 749:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1837               		.loc 1 749 0
 1838 053e 3A98      		cbi 0x7,2
 1839               	.LVL147:
 1840               	.LBB199:
 1841               	.LBB200:
 1842               		.loc 2 276 0
 1843 0540 95E8      		ldi r25,lo8(-123)
 1844 0542 9A95      	1:	dec r25
 1845 0544 01F4      		brne 1b
 1846 0546 0000      		nop
 1847               	.LVL148:
 1848               	.LBE200:
 1849               	.LBE199:
 750:setup.c       **** 	_delay_us(50);
 751:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1850               		.loc 1 751 0
 1851 0548 3A9A      		sbi 0x7,2
 1852               	.LVL149:
 1853               	.LBB201:
 1854               	.LBB202:
 1855               		.loc 2 276 0
 1856 054a 85E8      		ldi r24,lo8(-123)
 1857 054c 8A95      	1:	dec r24
 1858 054e 01F4      		brne 1b
 1859 0550 0000      		nop
 1860               	.LVL150:
 1861               	/* epilogue start */
 1862               	.LBE202:
 1863               	.LBE201:
 752:setup.c       **** 	_delay_us(50);
 753:setup.c       **** }
 1864               		.loc 1 753 0
 1865 0552 DF91      		pop r29
 1866 0554 CF91      		pop r28
 1867               	.LVL151:
 1868 0556 1F91      		pop r17
 1869               	.LVL152:
 1870 0558 0895      		ret
 1871               		.cfi_endproc
 1872               	.LFE41:
 1874               	.global	gb_flash_write_byte_bank1_commands
 1876               	gb_flash_write_byte_bank1_commands:
 1877               	.LFB42:
 754:setup.c       **** 
 755:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 756:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 757:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1878               		.loc 1 757 0
 1879               		.cfi_startproc
 1880               	.LVL153:
 1881 055a FF92      		push r15
 1882               	.LCFI32:
 1883               		.cfi_def_cfa_offset 3
 1884               		.cfi_offset 15, -2
 1885 055c 0F93      		push r16
 1886               	.LCFI33:
 1887               		.cfi_def_cfa_offset 4
 1888               		.cfi_offset 16, -3
 1889 055e 1F93      		push r17
 1890               	.LCFI34:
 1891               		.cfi_def_cfa_offset 5
 1892               		.cfi_offset 17, -4
 1893 0560 CF93      		push r28
 1894               	.LCFI35:
 1895               		.cfi_def_cfa_offset 6
 1896               		.cfi_offset 28, -5
 1897 0562 DF93      		push r29
 1898               	.LCFI36:
 1899               		.cfi_def_cfa_offset 7
 1900               		.cfi_offset 29, -6
 1901               	/* prologue: function */
 1902               	/* frame size = 0 */
 1903               	/* stack size = 5 */
 1904               	.L__stack_usage = 5
 1905 0564 EC01      		movw r28,r24
 1906 0566 162F      		mov r17,r22
 758:setup.c       **** 	// Set bank 1
 759:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1907               		.loc 1 759 0
 1908 0568 FF24      		clr r15
 1909 056a FA94      		dec r15
 1910 056c F4BA      		out 0x14,r15
 1911               	.LVL154:
 1912               	.LBB203:
 1913               	.LBB204:
 253:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1914               		.loc 1 253 0
 1915 056e 01E2      		ldi r16,lo8(33)
 1916 0570 0BBB      		out 0x1b,r16
 254:setup.c       **** }
 1917               		.loc 1 254 0
 1918 0572 18BA      		out 0x18,__zero_reg__
 1919               	.LVL155:
 1920               	.LBE204:
 1921               	.LBE203:
 760:setup.c       **** 	set_16bit_address(0x2100);
 761:setup.c       **** 	PORT_DATA7_0 = 1;
 1922               		.loc 1 761 0
 1923 0574 81E0      		ldi r24,lo8(1)
 1924               	.LVL156:
 1925 0576 85BB      		out 0x15,r24
 762:setup.c       **** 	wrPin_low; // Pulse WR
 1926               		.loc 1 762 0
 1927 0578 9698      		cbi 0x12,6
 763:setup.c       **** 	asm volatile("nop");
 1928               		.loc 1 763 0
 1929               	/* #APP */
 1930               	 ;  763 "setup.c" 1
 1931 057a 0000      		nop
 1932               	 ;  0 "" 2
 764:setup.c       **** 	wrPin_high;
 1933               		.loc 1 764 0
 1934               	/* #NOAPP */
 1935 057c 969A      		sbi 0x12,6
 765:setup.c       **** 	
 766:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1936               		.loc 1 766 0
 1937 057e 6091 0000 		lds r22,flashWriteCycle+2
 1938               	.LVL157:
 1939 0582 8091 0000 		lds r24,flashWriteCycle
 1940 0586 9091 0000 		lds r25,flashWriteCycle+1
 1941 058a 00D0      		rcall gb_flash_write_bus_cycle
 1942               	.LVL158:
 767:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1943               		.loc 1 767 0
 1944 058c 6091 0000 		lds r22,flashWriteCycle+6
 1945 0590 8091 0000 		lds r24,flashWriteCycle+4
 1946 0594 9091 0000 		lds r25,flashWriteCycle+4+1
 1947 0598 00D0      		rcall gb_flash_write_bus_cycle
 1948               	.LVL159:
 768:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1949               		.loc 1 768 0
 1950 059a 6091 0000 		lds r22,flashWriteCycle+10
 1951 059e 8091 0000 		lds r24,flashWriteCycle+8
 1952 05a2 9091 0000 		lds r25,flashWriteCycle+8+1
 1953 05a6 00D0      		rcall gb_flash_write_bus_cycle
 1954               	.LVL160:
 769:setup.c       **** 	
 770:setup.c       **** 	
 771:setup.c       **** 	// Set bank back
 772:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1955               		.loc 1 772 0
 1956 05a8 F4BA      		out 0x14,r15
 1957               	.LVL161:
 1958               	.LBB205:
 1959               	.LBB206:
 253:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1960               		.loc 1 253 0
 1961 05aa 0BBB      		out 0x1b,r16
 254:setup.c       **** }
 1962               		.loc 1 254 0
 1963 05ac 18BA      		out 0x18,__zero_reg__
 1964               	.LVL162:
 1965               	.LBE206:
 1966               	.LBE205:
 773:setup.c       **** 	set_16bit_address(0x2100);
 774:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1967               		.loc 1 774 0
 1968 05ae 8091 0000 		lds r24,lastBankAccessed
 1969 05b2 85BB      		out 0x15,r24
 775:setup.c       **** 	wrPin_low; // Pulse WR
 1970               		.loc 1 775 0
 1971 05b4 9698      		cbi 0x12,6
 776:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 776 0
 1973               	/* #APP */
 1974               	 ;  776 "setup.c" 1
 1975 05b6 0000      		nop
 1976               	 ;  0 "" 2
 777:setup.c       **** 	wrPin_high;
 1977               		.loc 1 777 0
 1978               	/* #NOAPP */
 1979 05b8 969A      		sbi 0x12,6
 778:setup.c       **** 	
 779:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1980               		.loc 1 779 0
 1981 05ba 612F      		mov r22,r17
 1982 05bc CE01      		movw r24,r28
 1983 05be 00D0      		rcall gb_flash_write_bus_cycle
 1984               	.LVL163:
 1985               	.LBB207:
 1986               	.LBB208:
 1987               		.loc 2 276 0
 1988 05c0 8AE1      		ldi r24,lo8(26)
 1989 05c2 8A95      	1:	dec r24
 1990 05c4 01F4      		brne 1b
 1991 05c6 00C0      		rjmp .
 1992               	.LVL164:
 1993               	.LBE208:
 1994               	.LBE207:
 780:setup.c       **** 	_delay_us(10); // Wait byte program time
 781:setup.c       **** 	
 782:setup.c       **** 	// Set data pins inputs
 783:setup.c       **** 	PORT_DATA7_0 = 0;
 1995               		.loc 1 783 0
 1996 05c8 15BA      		out 0x15,__zero_reg__
 784:setup.c       **** 	DDR_DATA7_0 = 0;
 1997               		.loc 1 784 0
 1998 05ca 14BA      		out 0x14,__zero_reg__
 785:setup.c       **** 	
 786:setup.c       **** 	// Verify data
 787:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1999               		.loc 1 787 0
 2000 05cc CE01      		movw r24,r28
 2001 05ce 00D0      		rcall gb_flash_read_byte
 2002               	.LVL165:
 2003               	.L84:
 788:setup.c       **** 	while (data != dataVerify) {
 2004               		.loc 1 788 0
 2005 05d0 8117      		cp r24,r17
 2006 05d2 01F0      		breq .L83
 789:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2007               		.loc 1 789 0
 2008 05d4 CE01      		movw r24,r28
 2009               	.LVL166:
 2010 05d6 00D0      		rcall gb_flash_read_byte
 2011               	.LVL167:
 2012               	.LBB209:
 2013               	.LBB210:
 2014               		.loc 2 276 0
 2015 05d8 9DE0      		ldi r25,lo8(13)
 2016 05da 9A95      	1:	dec r25
 2017 05dc 01F4      		brne 1b
 2018 05de 0000      		nop
 2019               	.LVL168:
 2020               	.LBE210:
 2021               	.LBE209:
 790:setup.c       **** 		_delay_us(5);
 791:setup.c       **** 		if (writingTimedout == 1) {
 2022               		.loc 1 791 0
 2023 05e0 9091 0000 		lds r25,writingTimedout
 2024 05e4 9130      		cpi r25,lo8(1)
 2025 05e6 01F4      		brne .L84
 2026               	.L83:
 2027               	/* epilogue start */
 792:setup.c       **** 			break;
 793:setup.c       **** 		}
 794:setup.c       **** 	}
 795:setup.c       **** }
 2028               		.loc 1 795 0
 2029 05e8 DF91      		pop r29
 2030 05ea CF91      		pop r28
 2031               	.LVL169:
 2032 05ec 1F91      		pop r17
 2033               	.LVL170:
 2034 05ee 0F91      		pop r16
 2035 05f0 FF90      		pop r15
 2036 05f2 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE42:
 2040               	.global	gba_flash_write_bus_cycle
 2042               	gba_flash_write_bus_cycle:
 2043               	.LFB43:
 796:setup.c       **** 
 797:setup.c       **** 
 798:setup.c       **** 
 799:setup.c       **** // ---------- GBA FLASH CARTS ----------
 800:setup.c       **** 
 801:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 802:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2044               		.loc 1 802 0
 2045               		.cfi_startproc
 2046               	.LVL171:
 2047 05f4 0F93      		push r16
 2048               	.LCFI37:
 2049               		.cfi_def_cfa_offset 3
 2050               		.cfi_offset 16, -2
 2051 05f6 1F93      		push r17
 2052               	.LCFI38:
 2053               		.cfi_def_cfa_offset 4
 2054               		.cfi_offset 17, -3
 2055               	/* prologue: function */
 2056               	/* frame size = 0 */
 2057               	/* stack size = 2 */
 2058               	.L__stack_usage = 2
 803:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 2059               		.loc 1 803 0
 2060 05f8 8C01      		movw r16,r24
 2061 05fa 2227      		clr r18
 2062 05fc 3327      		clr r19
 2063 05fe 05BB      		out 0x15,r16
 804:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 2064               		.loc 1 804 0
 2065 0600 072F      		mov r16,r23
 2066 0602 182F      		mov r17,r24
 2067 0604 292F      		mov r18,r25
 2068 0606 3327      		clr r19
 2069 0608 0BBB      		out 0x1b,r16
 805:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 2070               		.loc 1 805 0
 2071 060a 68BB      		out 0x18,r22
 806:setup.c       **** 	
 807:setup.c       **** 	cs_mreqPin_low;
 2072               		.loc 1 807 0
 2073 060c 9498      		cbi 0x12,4
 808:setup.c       **** 	
 809:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2074               		.loc 1 809 0
 2075 060e 5BBB      		out 0x1b,r21
 810:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2076               		.loc 1 810 0
 2077 0610 48BB      		out 0x18,r20
 811:setup.c       **** 	
 812:setup.c       **** 	wrPin_low;
 2078               		.loc 1 812 0
 2079 0612 9698      		cbi 0x12,6
 813:setup.c       **** 	asm volatile("nop");
 2080               		.loc 1 813 0
 2081               	/* #APP */
 2082               	 ;  813 "setup.c" 1
 2083 0614 0000      		nop
 2084               	 ;  0 "" 2
 814:setup.c       **** 	asm volatile("nop");
 2085               		.loc 1 814 0
 2086               	 ;  814 "setup.c" 1
 2087 0616 0000      		nop
 2088               	 ;  0 "" 2
 815:setup.c       **** 	asm volatile("nop");
 2089               		.loc 1 815 0
 2090               	 ;  815 "setup.c" 1
 2091 0618 0000      		nop
 2092               	 ;  0 "" 2
 816:setup.c       **** 	wrPin_high;
 2093               		.loc 1 816 0
 2094               	/* #NOAPP */
 2095 061a 969A      		sbi 0x12,6
 817:setup.c       **** 	cs_mreqPin_high;
 2096               		.loc 1 817 0
 2097 061c 949A      		sbi 0x12,4
 2098               	/* epilogue start */
 818:setup.c       **** }
 2099               		.loc 1 818 0
 2100 061e 1F91      		pop r17
 2101 0620 0F91      		pop r16
 2102 0622 0895      		ret
 2103               		.cfi_endproc
 2104               	.LFE43:
 2106               	.global	gba_flash_write_cycle_start_swapped
 2108               	gba_flash_write_cycle_start_swapped:
 2109               	.LFB44:
 819:setup.c       **** 
 820:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 821:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2110               		.loc 1 821 0
 2111               		.cfi_startproc
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 0 */
 2115               	.L__stack_usage = 0
 822:setup.c       **** 	// Set outputs
 823:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2116               		.loc 1 823 0
 2117 0624 8FEF      		ldi r24,lo8(-1)
 2118 0626 84BB      		out 0x14,r24
 824:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2119               		.loc 1 824 0
 2120 0628 8ABB      		out 0x1a,r24
 825:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2121               		.loc 1 825 0
 2122 062a 87BB      		out 0x17,r24
 826:setup.c       **** 	
 827:setup.c       **** 	// 0x555, 0xA9
 828:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2123               		.loc 1 828 0
 2124 062c 15BA      		out 0x15,__zero_reg__
 829:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2125               		.loc 1 829 0
 2126 062e 95E0      		ldi r25,lo8(5)
 2127 0630 9BBB      		out 0x1b,r25
 830:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2128               		.loc 1 830 0
 2129 0632 85E5      		ldi r24,lo8(85)
 2130 0634 88BB      		out 0x18,r24
 831:setup.c       **** 	cs_mreqPin_low;
 2131               		.loc 1 831 0
 2132 0636 9498      		cbi 0x12,4
 832:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2133               		.loc 1 832 0
 2134 0638 1BBA      		out 0x1b,__zero_reg__
 833:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2135               		.loc 1 833 0
 2136 063a 29EA      		ldi r18,lo8(-87)
 2137 063c 28BB      		out 0x18,r18
 834:setup.c       **** 	wrPin_low;
 2138               		.loc 1 834 0
 2139 063e 9698      		cbi 0x12,6
 835:setup.c       **** 	asm volatile("nop");
 2140               		.loc 1 835 0
 2141               	/* #APP */
 2142               	 ;  835 "setup.c" 1
 2143 0640 0000      		nop
 2144               	 ;  0 "" 2
 836:setup.c       **** 	asm volatile("nop");
 2145               		.loc 1 836 0
 2146               	 ;  836 "setup.c" 1
 2147 0642 0000      		nop
 2148               	 ;  0 "" 2
 837:setup.c       **** 	asm volatile("nop");
 2149               		.loc 1 837 0
 2150               	 ;  837 "setup.c" 1
 2151 0644 0000      		nop
 2152               	 ;  0 "" 2
 838:setup.c       **** 	wrPin_high;
 2153               		.loc 1 838 0
 2154               	/* #NOAPP */
 2155 0646 969A      		sbi 0x12,6
 839:setup.c       **** 	cs_mreqPin_high;
 2156               		.loc 1 839 0
 2157 0648 949A      		sbi 0x12,4
 840:setup.c       **** 	
 841:setup.c       **** 	// 0x2AA, 0x56
 842:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2158               		.loc 1 842 0
 2159 064a 15BA      		out 0x15,__zero_reg__
 843:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2160               		.loc 1 843 0
 2161 064c 22E0      		ldi r18,lo8(2)
 2162 064e 2BBB      		out 0x1b,r18
 844:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2163               		.loc 1 844 0
 2164 0650 2AEA      		ldi r18,lo8(-86)
 2165 0652 28BB      		out 0x18,r18
 845:setup.c       **** 	cs_mreqPin_low;
 2166               		.loc 1 845 0
 2167 0654 9498      		cbi 0x12,4
 846:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2168               		.loc 1 846 0
 2169 0656 1BBA      		out 0x1b,__zero_reg__
 847:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2170               		.loc 1 847 0
 2171 0658 26E5      		ldi r18,lo8(86)
 2172 065a 28BB      		out 0x18,r18
 848:setup.c       **** 	wrPin_low;
 2173               		.loc 1 848 0
 2174 065c 9698      		cbi 0x12,6
 849:setup.c       **** 	asm volatile("nop");
 2175               		.loc 1 849 0
 2176               	/* #APP */
 2177               	 ;  849 "setup.c" 1
 2178 065e 0000      		nop
 2179               	 ;  0 "" 2
 850:setup.c       **** 	asm volatile("nop");
 2180               		.loc 1 850 0
 2181               	 ;  850 "setup.c" 1
 2182 0660 0000      		nop
 2183               	 ;  0 "" 2
 851:setup.c       **** 	asm volatile("nop");
 2184               		.loc 1 851 0
 2185               	 ;  851 "setup.c" 1
 2186 0662 0000      		nop
 2187               	 ;  0 "" 2
 852:setup.c       **** 	wrPin_high;
 2188               		.loc 1 852 0
 2189               	/* #NOAPP */
 2190 0664 969A      		sbi 0x12,6
 853:setup.c       **** 	cs_mreqPin_high;
 2191               		.loc 1 853 0
 2192 0666 949A      		sbi 0x12,4
 854:setup.c       **** 	
 855:setup.c       **** 	// 0x555, 0xA0;
 856:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2193               		.loc 1 856 0
 2194 0668 15BA      		out 0x15,__zero_reg__
 857:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2195               		.loc 1 857 0
 2196 066a 9BBB      		out 0x1b,r25
 858:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2197               		.loc 1 858 0
 2198 066c 88BB      		out 0x18,r24
 859:setup.c       **** 	cs_mreqPin_low;
 2199               		.loc 1 859 0
 2200 066e 9498      		cbi 0x12,4
 860:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2201               		.loc 1 860 0
 2202 0670 1BBA      		out 0x1b,__zero_reg__
 861:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2203               		.loc 1 861 0
 2204 0672 80EA      		ldi r24,lo8(-96)
 2205 0674 88BB      		out 0x18,r24
 862:setup.c       **** 	wrPin_low;
 2206               		.loc 1 862 0
 2207 0676 9698      		cbi 0x12,6
 863:setup.c       **** 	asm volatile("nop");
 2208               		.loc 1 863 0
 2209               	/* #APP */
 2210               	 ;  863 "setup.c" 1
 2211 0678 0000      		nop
 2212               	 ;  0 "" 2
 864:setup.c       **** 	asm volatile("nop");
 2213               		.loc 1 864 0
 2214               	 ;  864 "setup.c" 1
 2215 067a 0000      		nop
 2216               	 ;  0 "" 2
 865:setup.c       **** 	asm volatile("nop");
 2217               		.loc 1 865 0
 2218               	 ;  865 "setup.c" 1
 2219 067c 0000      		nop
 2220               	 ;  0 "" 2
 866:setup.c       **** 	wrPin_high;
 2221               		.loc 1 866 0
 2222               	/* #NOAPP */
 2223 067e 969A      		sbi 0x12,6
 867:setup.c       **** 	cs_mreqPin_high;
 2224               		.loc 1 867 0
 2225 0680 949A      		sbi 0x12,4
 2226 0682 0895      		ret
 2227               		.cfi_endproc
 2228               	.LFE44:
 2230               	.global	gba_flash_write_cycle_start
 2232               	gba_flash_write_cycle_start:
 2233               	.LFB45:
 868:setup.c       **** }
 869:setup.c       **** 
 870:setup.c       **** 
 871:setup.c       **** // Send the first 3 write cycles to the flash
 872:setup.c       **** void gba_flash_write_cycle_start(void) {
 2234               		.loc 1 872 0
 2235               		.cfi_startproc
 2236               	/* prologue: function */
 2237               	/* frame size = 0 */
 2238               	/* stack size = 0 */
 2239               	.L__stack_usage = 0
 873:setup.c       **** 	// Set outputs
 874:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2240               		.loc 1 874 0
 2241 0684 8FEF      		ldi r24,lo8(-1)
 2242 0686 84BB      		out 0x14,r24
 875:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2243               		.loc 1 875 0
 2244 0688 8ABB      		out 0x1a,r24
 876:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2245               		.loc 1 876 0
 2246 068a 87BB      		out 0x17,r24
 877:setup.c       **** 	
 878:setup.c       **** 	// 0x555, 0xAA
 879:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2247               		.loc 1 879 0
 2248 068c 15BA      		out 0x15,__zero_reg__
 880:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2249               		.loc 1 880 0
 2250 068e 95E0      		ldi r25,lo8(5)
 2251 0690 9BBB      		out 0x1b,r25
 881:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2252               		.loc 1 881 0
 2253 0692 85E5      		ldi r24,lo8(85)
 2254 0694 88BB      		out 0x18,r24
 882:setup.c       **** 	cs_mreqPin_low;
 2255               		.loc 1 882 0
 2256 0696 9498      		cbi 0x12,4
 883:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2257               		.loc 1 883 0
 2258 0698 1BBA      		out 0x1b,__zero_reg__
 884:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2259               		.loc 1 884 0
 2260 069a 2AEA      		ldi r18,lo8(-86)
 2261 069c 28BB      		out 0x18,r18
 885:setup.c       **** 	wrPin_low;
 2262               		.loc 1 885 0
 2263 069e 9698      		cbi 0x12,6
 886:setup.c       **** 	asm volatile("nop");
 2264               		.loc 1 886 0
 2265               	/* #APP */
 2266               	 ;  886 "setup.c" 1
 2267 06a0 0000      		nop
 2268               	 ;  0 "" 2
 887:setup.c       **** 	asm volatile("nop");
 2269               		.loc 1 887 0
 2270               	 ;  887 "setup.c" 1
 2271 06a2 0000      		nop
 2272               	 ;  0 "" 2
 888:setup.c       **** 	asm volatile("nop");
 2273               		.loc 1 888 0
 2274               	 ;  888 "setup.c" 1
 2275 06a4 0000      		nop
 2276               	 ;  0 "" 2
 889:setup.c       **** 	wrPin_high;
 2277               		.loc 1 889 0
 2278               	/* #NOAPP */
 2279 06a6 969A      		sbi 0x12,6
 890:setup.c       **** 	cs_mreqPin_high;
 2280               		.loc 1 890 0
 2281 06a8 949A      		sbi 0x12,4
 891:setup.c       **** 	
 892:setup.c       **** 	// 0x2AA, 0x55
 893:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2282               		.loc 1 893 0
 2283 06aa 15BA      		out 0x15,__zero_reg__
 894:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2284               		.loc 1 894 0
 2285 06ac 32E0      		ldi r19,lo8(2)
 2286 06ae 3BBB      		out 0x1b,r19
 895:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2287               		.loc 1 895 0
 2288 06b0 28BB      		out 0x18,r18
 896:setup.c       **** 	cs_mreqPin_low;
 2289               		.loc 1 896 0
 2290 06b2 9498      		cbi 0x12,4
 897:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2291               		.loc 1 897 0
 2292 06b4 1BBA      		out 0x1b,__zero_reg__
 898:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2293               		.loc 1 898 0
 2294 06b6 88BB      		out 0x18,r24
 899:setup.c       **** 	wrPin_low;
 2295               		.loc 1 899 0
 2296 06b8 9698      		cbi 0x12,6
 900:setup.c       **** 	asm volatile("nop");
 2297               		.loc 1 900 0
 2298               	/* #APP */
 2299               	 ;  900 "setup.c" 1
 2300 06ba 0000      		nop
 2301               	 ;  0 "" 2
 901:setup.c       **** 	asm volatile("nop");
 2302               		.loc 1 901 0
 2303               	 ;  901 "setup.c" 1
 2304 06bc 0000      		nop
 2305               	 ;  0 "" 2
 902:setup.c       **** 	asm volatile("nop");
 2306               		.loc 1 902 0
 2307               	 ;  902 "setup.c" 1
 2308 06be 0000      		nop
 2309               	 ;  0 "" 2
 903:setup.c       **** 	wrPin_high;
 2310               		.loc 1 903 0
 2311               	/* #NOAPP */
 2312 06c0 969A      		sbi 0x12,6
 904:setup.c       **** 	cs_mreqPin_high;
 2313               		.loc 1 904 0
 2314 06c2 949A      		sbi 0x12,4
 905:setup.c       **** 	
 906:setup.c       **** 	// 0x555, 0xA0;
 907:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2315               		.loc 1 907 0
 2316 06c4 15BA      		out 0x15,__zero_reg__
 908:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2317               		.loc 1 908 0
 2318 06c6 9BBB      		out 0x1b,r25
 909:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2319               		.loc 1 909 0
 2320 06c8 88BB      		out 0x18,r24
 910:setup.c       **** 	cs_mreqPin_low;
 2321               		.loc 1 910 0
 2322 06ca 9498      		cbi 0x12,4
 911:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2323               		.loc 1 911 0
 2324 06cc 1BBA      		out 0x1b,__zero_reg__
 912:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2325               		.loc 1 912 0
 2326 06ce 80EA      		ldi r24,lo8(-96)
 2327 06d0 88BB      		out 0x18,r24
 913:setup.c       **** 	wrPin_low;
 2328               		.loc 1 913 0
 2329 06d2 9698      		cbi 0x12,6
 914:setup.c       **** 	asm volatile("nop");
 2330               		.loc 1 914 0
 2331               	/* #APP */
 2332               	 ;  914 "setup.c" 1
 2333 06d4 0000      		nop
 2334               	 ;  0 "" 2
 915:setup.c       **** 	asm volatile("nop");
 2335               		.loc 1 915 0
 2336               	 ;  915 "setup.c" 1
 2337 06d6 0000      		nop
 2338               	 ;  0 "" 2
 916:setup.c       **** 	asm volatile("nop");
 2339               		.loc 1 916 0
 2340               	 ;  916 "setup.c" 1
 2341 06d8 0000      		nop
 2342               	 ;  0 "" 2
 917:setup.c       **** 	wrPin_high;
 2343               		.loc 1 917 0
 2344               	/* #NOAPP */
 2345 06da 969A      		sbi 0x12,6
 918:setup.c       **** 	cs_mreqPin_high;
 2346               		.loc 1 918 0
 2347 06dc 949A      		sbi 0x12,4
 2348 06de 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE45:
 2352               	.global	gba_flash_write_byte
 2354               	gba_flash_write_byte:
 2355               	.LFB46:
 919:setup.c       **** }	
 920:setup.c       **** 
 921:setup.c       **** 
 922:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 923:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 924:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2356               		.loc 1 924 0
 2357               		.cfi_startproc
 2358               	.LVL172:
 2359 06e0 CF92      		push r12
 2360               	.LCFI39:
 2361               		.cfi_def_cfa_offset 3
 2362               		.cfi_offset 12, -2
 2363 06e2 DF92      		push r13
 2364               	.LCFI40:
 2365               		.cfi_def_cfa_offset 4
 2366               		.cfi_offset 13, -3
 2367 06e4 EF92      		push r14
 2368               	.LCFI41:
 2369               		.cfi_def_cfa_offset 5
 2370               		.cfi_offset 14, -4
 2371 06e6 FF92      		push r15
 2372               	.LCFI42:
 2373               		.cfi_def_cfa_offset 6
 2374               		.cfi_offset 15, -5
 2375 06e8 CF93      		push r28
 2376               	.LCFI43:
 2377               		.cfi_def_cfa_offset 7
 2378               		.cfi_offset 28, -6
 2379 06ea DF93      		push r29
 2380               	.LCFI44:
 2381               		.cfi_def_cfa_offset 8
 2382               		.cfi_offset 29, -7
 2383               	/* prologue: function */
 2384               	/* frame size = 0 */
 2385               	/* stack size = 6 */
 2386               	.L__stack_usage = 6
 2387 06ec 6B01      		movw r12,r22
 2388 06ee 7C01      		movw r14,r24
 2389 06f0 EA01      		movw r28,r20
 925:setup.c       **** 	if (isD0D1Swapped == 0) {
 2390               		.loc 1 925 0
 2391 06f2 2111      		cpse r18,__zero_reg__
 2392 06f4 00C0      		rjmp .L92
 926:setup.c       **** 		gba_flash_write_cycle_start();
 2393               		.loc 1 926 0
 2394 06f6 00D0      		rcall gba_flash_write_cycle_start
 2395               	.LVL173:
 2396 06f8 00C0      		rjmp .L93
 2397               	.LVL174:
 2398               	.L92:
 927:setup.c       **** 	}
 928:setup.c       **** 	else {
 929:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2399               		.loc 1 929 0
 2400 06fa 00D0      		rcall gba_flash_write_cycle_start_swapped
 2401               	.LVL175:
 2402               	.L93:
 930:setup.c       **** 	}
 931:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2403               		.loc 1 931 0
 2404 06fc AE01      		movw r20,r28
 2405 06fe C701      		movw r24,r14
 2406 0700 B601      		movw r22,r12
 2407 0702 00D0      		rcall gba_flash_write_bus_cycle
 2408               	.LVL176:
 2409               	.LBB211:
 2410               	.LBB212:
 2411               		.loc 2 276 0
 2412 0704 25E0      		ldi r18,lo8(5)
 2413 0706 2A95      	1:	dec r18
 2414 0708 01F4      		brne 1b
 2415 070a 0000      		nop
 2416               	.LVL177:
 2417               	.LBE212:
 2418               	.LBE211:
 932:setup.c       **** 	_delay_us(2); // Wait byte program time
 933:setup.c       **** 	
 934:setup.c       **** 	// Verify data
 935:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2419               		.loc 1 935 0
 2420 070c C701      		movw r24,r14
 2421 070e B601      		movw r22,r12
 2422 0710 00D0      		rcall gba_read_16bit_data
 2423               	.LVL178:
 2424               	.L94:
 936:setup.c       **** 	while (data != dataVerify) {
 2425               		.loc 1 936 0
 2426 0712 8C17      		cp r24,r28
 2427 0714 9D07      		cpc r25,r29
 2428 0716 01F0      		breq .L91
 937:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2429               		.loc 1 937 0
 2430 0718 C701      		movw r24,r14
 2431 071a B601      		movw r22,r12
 2432 071c 00D0      		rcall gba_read_16bit_data
 2433               	.LVL179:
 2434               	.LBB213:
 2435               	.LBB214:
 2436               		.loc 2 276 0
 2437 071e 25E0      		ldi r18,lo8(5)
 2438 0720 2A95      	1:	dec r18
 2439 0722 01F4      		brne 1b
 2440 0724 0000      		nop
 2441               	.LVL180:
 2442               	.LBE214:
 2443               	.LBE213:
 938:setup.c       **** 		_delay_us(2);
 939:setup.c       **** 		if (writingTimedout == 1) {
 2444               		.loc 1 939 0
 2445 0726 2091 0000 		lds r18,writingTimedout
 2446 072a 2130      		cpi r18,lo8(1)
 2447 072c 01F4      		brne .L94
 2448               	.L91:
 2449               	/* epilogue start */
 940:setup.c       **** 			break;
 941:setup.c       **** 		}
 942:setup.c       **** 	}
 943:setup.c       **** }
 2450               		.loc 1 943 0
 2451 072e DF91      		pop r29
 2452 0730 CF91      		pop r28
 2453               	.LVL181:
 2454 0732 FF90      		pop r15
 2455 0734 EF90      		pop r14
 2456 0736 DF90      		pop r13
 2457 0738 CF90      		pop r12
 2458               	.LVL182:
 2459 073a 0895      		ret
 2460               		.cfi_endproc
 2461               	.LFE46:
 2463               	.global	start_timeout_timer
 2465               	start_timeout_timer:
 2466               	.LFB47:
 944:setup.c       **** 
 945:setup.c       **** // Timeout for ~500ms when flashing carts
 946:setup.c       **** void start_timeout_timer(void) {
 2467               		.loc 1 946 0
 2468               		.cfi_startproc
 2469               	/* prologue: function */
 2470               	/* frame size = 0 */
 2471               	/* stack size = 0 */
 2472               	.L__stack_usage = 0
 947:setup.c       **** 	writingTimedout = 0;
 2473               		.loc 1 947 0
 2474 073c 1092 0000 		sts writingTimedout,__zero_reg__
 948:setup.c       **** 	TCNT1 = 0;
 2475               		.loc 1 948 0
 2476 0740 1DBC      		out 0x2c+1,__zero_reg__
 2477 0742 1CBC      		out 0x2c,__zero_reg__
 949:setup.c       **** 	TCCR1B |= (1<<CS11) | (1<<CS10);
 2478               		.loc 1 949 0
 2479 0744 8EB5      		in r24,0x2e
 2480 0746 8360      		ori r24,lo8(3)
 2481 0748 8EBD      		out 0x2e,r24
 2482 074a 0895      		ret
 2483               		.cfi_endproc
 2484               	.LFE47:
 2486               	.global	stop_timeout_timer
 2488               	stop_timeout_timer:
 2489               	.LFB48:
 950:setup.c       **** }
 951:setup.c       **** 
 952:setup.c       **** // Stop the flash timeout timer
 953:setup.c       **** void stop_timeout_timer(void) {
 2490               		.loc 1 953 0
 2491               		.cfi_startproc
 2492               	/* prologue: function */
 2493               	/* frame size = 0 */
 2494               	/* stack size = 0 */
 2495               	.L__stack_usage = 0
 954:setup.c       **** 	writingTimedout = 0;
 2496               		.loc 1 954 0
 2497 074c 1092 0000 		sts writingTimedout,__zero_reg__
 955:setup.c       **** 	TCNT1 = 0;
 2498               		.loc 1 955 0
 2499 0750 1DBC      		out 0x2c+1,__zero_reg__
 2500 0752 1CBC      		out 0x2c,__zero_reg__
 956:setup.c       **** 	TCCR1B = 0;
 2501               		.loc 1 956 0
 2502 0754 1EBC      		out 0x2e,__zero_reg__
 957:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2503               		.loc 1 957 0
 2504 0756 9398      		cbi 0x12,3
 2505 0758 0895      		ret
 2506               		.cfi_endproc
 2507               	.LFE48:
 2509               	.global	check_if_timed_out
 2511               	check_if_timed_out:
 2512               	.LFB49:
 958:setup.c       **** }
 959:setup.c       **** 
 960:setup.c       **** void check_if_timed_out(void) {
 2513               		.loc 1 960 0
 2514               		.cfi_startproc
 2515               	/* prologue: function */
 2516               	/* frame size = 0 */
 2517               	/* stack size = 0 */
 2518               	.L__stack_usage = 0
 961:setup.c       **** 	if (writingTimedout == 0) {
 2519               		.loc 1 961 0
 2520 075a 8091 0000 		lds r24,writingTimedout
 2521 075e 8111      		cpse r24,__zero_reg__
 2522 0760 00C0      		rjmp .L100
 2523               	.LBB217:
 2524               	.LBB218:
 962:setup.c       **** 		stop_timeout_timer();		
 2525               		.loc 1 962 0
 2526 0762 00D0      		rcall stop_timeout_timer
 2527               	.LVL183:
 963:setup.c       **** 		USART_Transmit(SEND_ACK); // Send back acknowledgement
 2528               		.loc 1 963 0
 2529 0764 81E3      		ldi r24,lo8(49)
 2530 0766 00D0      		rcall USART_Transmit
 2531               	.LVL184:
 964:setup.c       **** 		PORTD &= ~(1<<ACTIVITY_LED);
 2532               		.loc 1 964 0
 2533 0768 9398      		cbi 0x12,3
 2534               	.L100:
 2535 076a 0895      		ret
 2536               	.LBE218:
 2537               	.LBE217:
 2538               		.cfi_endproc
 2539               	.LFE49:
 2541               	.global	setup
 2543               	setup:
 2544               	.LFB50:
 965:setup.c       **** 	}
 966:setup.c       **** }
 967:setup.c       **** 
 968:setup.c       **** 
 969:setup.c       **** // Setup
 970:setup.c       **** void setup(void) {
 2545               		.loc 1 970 0
 2546               		.cfi_startproc
 2547               	/* prologue: function */
 2548               	/* frame size = 0 */
 2549               	/* stack size = 0 */
 2550               	.L__stack_usage = 0
 971:setup.c       **** 	// Turn off watchdog
 972:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2551               		.loc 1 972 0
 2552 076c 84B7      		in r24,0x34
 2553 076e 877F      		andi r24,lo8(-9)
 2554 0770 84BF      		out 0x34,r24
 973:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2555               		.loc 1 973 0
 2556 0772 88E1      		ldi r24,lo8(24)
 2557 0774 81BD      		out 0x21,r24
 974:setup.c       **** 	WDTCR = 0;
 2558               		.loc 1 974 0
 2559 0776 11BC      		out 0x21,__zero_reg__
 975:setup.c       **** 	
 976:setup.c       **** 	// Reset common lines
 977:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2560               		.loc 1 977 0
 2561 0778 00D0      		rcall rd_wr_csmreq_cs2_reset
 2562               	.LVL185:
 978:setup.c       **** 	
 979:setup.c       **** 	// Set outputs
 980:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V);
 2563               		.loc 1 980 0
 2564 077a 81B3      		in r24,0x11
 2565 077c 886F      		ori r24,lo8(-8)
 2566 077e 81BB      		out 0x11,r24
 981:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2567               		.loc 1 981 0
 2568 0780 86B1      		in r24,0x6
 2569 0782 8560      		ori r24,lo8(5)
 2570 0784 86B9      		out 0x6,r24
 982:setup.c       **** 	
 983:setup.c       **** 	// Set all pins as inputs
 984:setup.c       **** 	PORT_DATA7_0 = 0;
 2571               		.loc 1 984 0
 2572 0786 15BA      		out 0x15,__zero_reg__
 985:setup.c       **** 	DDR_DATA7_0 = 0;
 2573               		.loc 1 985 0
 2574 0788 14BA      		out 0x14,__zero_reg__
 986:setup.c       **** 	PORT_ADDR7_0 = 0;
 2575               		.loc 1 986 0
 2576 078a 18BA      		out 0x18,__zero_reg__
 987:setup.c       **** 	DDR_ADDR7_0 = 0;
 2577               		.loc 1 987 0
 2578 078c 17BA      		out 0x17,__zero_reg__
 988:setup.c       **** 	PORT_ADDR15_8 = 0;
 2579               		.loc 1 988 0
 2580 078e 1BBA      		out 0x1b,__zero_reg__
 989:setup.c       **** 	DDR_ADDR15_8 = 0;
 2581               		.loc 1 989 0
 2582 0790 1ABA      		out 0x1a,__zero_reg__
 990:setup.c       **** 	
 991:setup.c       **** 	// Light up 3.3V or 5V
 992:setup.c       **** 	if (PIND & (1<<SWITCH_DETECT)) {
 2583               		.loc 1 992 0
 2584 0792 829B      		sbis 0x10,2
 2585 0794 00C0      		rjmp .L103
 993:setup.c       **** 		PORTD |= (1<<LED_5V);
 2586               		.loc 1 993 0
 2587 0796 979A      		sbi 0x12,7
 994:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2588               		.loc 1 994 0
 2589 0798 3898      		cbi 0x7,0
 995:setup.c       **** 		
 996:setup.c       **** 		// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 997:setup.c       **** 		cs2Pin_low;
 2590               		.loc 1 997 0
 2591 079a 3A98      		cbi 0x7,2
 2592               	.LVL186:
 2593               	.LBB219:
 2594               	.LBB220:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2595               		.loc 2 187 0
 2596 079c 2FE7      		ldi r18,lo8(79999)
 2597 079e 88E3      		ldi r24,hi8(79999)
 2598 07a0 91E0      		ldi r25,hlo8(79999)
 2599 07a2 2150      	1:	subi r18,1
 2600 07a4 8040      		sbci r24,0
 2601 07a6 9040      		sbci r25,0
 2602 07a8 01F4      		brne 1b
 2603 07aa 00C0      		rjmp .
 2604 07ac 0000      		nop
 2605               	.LVL187:
 2606               	.LBE220:
 2607               	.LBE219:
 998:setup.c       **** 		_delay_ms(50);
 999:setup.c       **** 		cs2Pin_high;
 2608               		.loc 1 999 0
 2609 07ae 3A9A      		sbi 0x7,2
 2610 07b0 00C0      		rjmp .L104
 2611               	.L103:
1000:setup.c       **** 	}
1001:setup.c       **** 	else {
1002:setup.c       **** 		PORTE |= (1<<LED_3V);
 2612               		.loc 1 1002 0
 2613 07b2 389A      		sbi 0x7,0
1003:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2614               		.loc 1 1003 0
 2615 07b4 9798      		cbi 0x12,7
 2616               	.L104:
1004:setup.c       **** 	}
1005:setup.c       **** 	
1006:setup.c       **** 	// Light LED
1007:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2617               		.loc 1 1007 0
 2618 07b6 939A      		sbi 0x12,3
 2619               	.LVL188:
 2620               	.LBB221:
 2621               	.LBB222:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2622               		.loc 2 187 0
 2623 07b8 2FEF      		ldi r18,lo8(799999)
 2624 07ba 84E3      		ldi r24,hi8(799999)
 2625 07bc 9CE0      		ldi r25,hlo8(799999)
 2626 07be 2150      	1:	subi r18,1
 2627 07c0 8040      		sbci r24,0
 2628 07c2 9040      		sbci r25,0
 2629 07c4 01F4      		brne 1b
 2630 07c6 00C0      		rjmp .
 2631 07c8 0000      		nop
 2632               	.LVL189:
 2633               	.LBE222:
 2634               	.LBE221:
1008:setup.c       **** 	_delay_ms(500);
1009:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2635               		.loc 1 1009 0
 2636 07ca 9398      		cbi 0x12,3
1010:setup.c       **** 	
1011:setup.c       **** 	// Setup USART
1012:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2637               		.loc 1 1012 0
 2638 07cc 19B8      		out 0x9,__zero_reg__
1013:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2639               		.loc 1 1013 0
 2640 07ce 599A      		sbi 0xb,1
1014:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2641               		.loc 1 1014 0
 2642 07d0 539A      		sbi 0xa,3
1015:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2643               		.loc 1 1015 0
 2644 07d2 549A      		sbi 0xa,4
1016:setup.c       **** 	
1017:setup.c       **** 	// Timer1 setup
1018:setup.c       **** 	TIMSK |= (1<<TOIE1);
 2645               		.loc 1 1018 0
 2646 07d4 89B7      		in r24,0x39
 2647 07d6 8068      		ori r24,lo8(-128)
 2648 07d8 89BF      		out 0x39,r24
1019:setup.c       **** 	TCNT1 = 0;
 2649               		.loc 1 1019 0
 2650 07da 1DBC      		out 0x2c+1,__zero_reg__
 2651 07dc 1CBC      		out 0x2c,__zero_reg__
1020:setup.c       **** 	
1021:setup.c       **** 	// Turn on interrupts
1022:setup.c       **** 	sei();
 2652               		.loc 1 1022 0
 2653               	/* #APP */
 2654               	 ;  1022 "setup.c" 1
 2655 07de 7894      		sei
 2656               	 ;  0 "" 2
 2657               	/* #NOAPP */
 2658 07e0 0895      		ret
 2659               		.cfi_endproc
 2660               	.LFE50:
 2662               		.section	.text.startup,"ax",@progbits
 2663               	.global	main
 2665               	main:
 2666               	.LFB51:
 2667               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.1 or 1.2
   4:main.c        ****  Firmware version: R22
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 24/10/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.x_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.x_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  */
  28:main.c        **** 
  29:main.c        **** // ATmega8515L Pin Map
  30:main.c        **** //
  31:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  32:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  33:main.c        **** // 
  34:main.c        **** // Gameboy / Gameboy Colour
  35:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  36:main.c        **** // 
  37:main.c        **** // Gameboy Advance
  38:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  39:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  40:main.c        **** 
  41:main.c        **** #define F_CPU 8000000 // 8 MHz
  42:main.c        **** #define PCB_VERSION 2
  43:main.c        **** #define FIRMWARE_VERSION 22
  44:main.c        **** 
  45:main.c        **** #include <avr/io.h>
  46:main.c        **** #include <avr/wdt.h>
  47:main.c        **** #include <avr/eeprom.h>
  48:main.c        **** #include <avr/interrupt.h>
  49:main.c        **** #include <avr/sleep.h>
  50:main.c        **** #include <util/delay.h>
  51:main.c        **** #include <stdlib.h>
  52:main.c        **** #include <string.h>
  53:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  54:main.c        **** 
  55:main.c        **** 
  56:main.c        **** int main(void) {
 2668               		.loc 3 56 0
 2669               		.cfi_startproc
 2670 0000 CF93      		push r28
 2671               	.LCFI45:
 2672               		.cfi_def_cfa_offset 3
 2673               		.cfi_offset 28, -2
 2674 0002 DF93      		push r29
 2675               	.LCFI46:
 2676               		.cfi_def_cfa_offset 4
 2677               		.cfi_offset 29, -3
 2678 0004 CDB7      		in r28,__SP_L__
 2679 0006 DEB7      		in r29,__SP_H__
 2680               	.LCFI47:
 2681               		.cfi_def_cfa_register 28
 2682 0008 AA97      		sbiw r28,42
 2683               	.LCFI48:
 2684               		.cfi_def_cfa_offset 46
 2685 000a 0FB6      		in __tmp_reg__,__SREG__
 2686 000c F894      		cli
 2687 000e DEBF      		out __SP_H__,r29
 2688 0010 0FBE      		out __SREG__,__tmp_reg__
 2689 0012 CDBF      		out __SP_L__,r28
 2690               	/* prologue: function */
 2691               	/* frame size = 42 */
 2692               	/* stack size = 44 */
 2693               	.L__stack_usage = 44
  57:main.c        **** 	setup();
 2694               		.loc 3 57 0
 2695 0014 00D0      		rcall setup
 2696               	.LVL190:
  58:main.c        **** 	
  59:main.c        **** 	uint32_t address = 0;
  60:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  61:main.c        **** 	uint8_t cartMode = GB_MODE;
  62:main.c        **** 	uint8_t resetCommonLines = 1;
 2697               		.loc 3 62 0
 2698 0016 21E0      		ldi r18,lo8(1)
 2699 0018 2EA3      		std Y+38,r18
  60:main.c        **** 	uint8_t cartMode = GB_MODE;
 2700               		.loc 3 60 0
 2701 001a 81E0      		ldi r24,lo8(1)
 2702 001c 8DA3      		std Y+37,r24
  59:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2703               		.loc 3 59 0
 2704 001e 412C      		mov r4,__zero_reg__
 2705 0020 512C      		mov r5,__zero_reg__
 2706 0022 3201      		movw r6,r4
 2707               	.LBB223:
 2708               	.LBB224:
 2709               	.LBB225:
  63:main.c        **** 	
  64:main.c        **** 	while(1) {
  65:main.c        **** 		if (resetCommonLines == 1) {
  66:main.c        **** 			rd_wr_csmreq_cs2_reset();
  67:main.c        **** 		}
  68:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  69:main.c        **** 		
  70:main.c        **** 		// Read the pin to find out which mode we are in, if it reads high, we are powered by 5V
  71:main.c        **** 		if (PIND & (1<<SWITCH_DETECT)) {
  72:main.c        **** 			cartMode = GB_MODE;
  73:main.c        **** 			PORTD |= (1<<LED_5V);
  74:main.c        **** 			PORTE &= ~(1<<LED_3V);
  75:main.c        **** 		}
  76:main.c        **** 		else {
  77:main.c        **** 			cartMode = GBA_MODE;
  78:main.c        **** 			PORTE |= (1<<LED_3V);
  79:main.c        **** 			PORTD &= ~(1<<LED_5V);
  80:main.c        **** 		}
  81:main.c        **** 		
  82:main.c        **** 		// Return the cart mode in use
  83:main.c        **** 		if (receivedChar == CART_MODE) {
  84:main.c        **** 			USART_Transmit(cartMode);
  85:main.c        **** 			stop_timeout_timer();
  86:main.c        **** 		}
  87:main.c        **** 		
  88:main.c        **** 		// Change to GB mode or GBA mode if requested
  89:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  90:main.c        **** 			gb_mode();
  91:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
  92:main.c        **** 			stop_timeout_timer();
  93:main.c        **** 		}
  94:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
  95:main.c        **** 			gba_mode();
  96:main.c        **** 			stop_timeout_timer();
  97:main.c        **** 		}
  98:main.c        **** 		
  99:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 100:main.c        **** 		
 101:main.c        **** 		// Set address
 102:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 103:main.c        **** 			usart_read_chars(); // Read start address
 104:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 105:main.c        **** 		}
 106:main.c        **** 		
 107:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 108:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 109:main.c        **** 			gb_mode();
 110:main.c        **** 			receivedChar = '1';
 111:main.c        **** 			while (receivedChar == '1') {
 112:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 113:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 114:main.c        **** 					USART_Transmit(read_8bit_data(address));
 115:main.c        **** 					address++;
 116:main.c        **** 				}
 117:main.c        **** 				
 118:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 119:main.c        **** 				receivedChar = USART_Receive();
 120:main.c        **** 			}
 121:main.c        **** 		}
 122:main.c        **** 		
 123:main.c        **** 		// Read and send 0x4000 bytes of data
 124:main.c        **** 		else if (receivedChar == READ_ROM_4000H) {
 125:main.c        **** 			gb_mode();
 126:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 127:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 128:main.c        **** 				USART_Transmit(read_8bit_data(address));
 129:main.c        **** 				address++;
 130:main.c        **** 			}
 131:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 132:main.c        **** 		}
 133:main.c        **** 		
 134:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 135:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 136:main.c        **** 			gb_mode();
 137:main.c        **** 			
 138:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 139:main.c        **** 			usart_read_bytes(64);
 140:main.c        **** 			
 141:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 142:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 143:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 144:main.c        **** 				address++;
 145:main.c        **** 			}
 146:main.c        **** 			
 147:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 148:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 149:main.c        **** 		}
 150:main.c        **** 		
 151:main.c        **** 		// Set bank address and write a byte
 152:main.c        **** 		else if (receivedChar == SET_BANK) {
 153:main.c        **** 			gb_mode();
 154:main.c        **** 			
 155:main.c        **** 			usart_read_chars(); // Read start address
 156:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 157:main.c        **** 			
 158:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 159:main.c        **** 			if (receivedChar == 'B') {
 160:main.c        **** 				usart_read_chars(); // Read data
 161:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 162:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 163:main.c        **** 				
 164:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 165:main.c        **** 			}
 166:main.c        **** 		}
 167:main.c        **** 		
 168:main.c        **** 		
 169:main.c        **** 		// ****** Gameboy Advance ******
 170:main.c        **** 		
 171:main.c        **** 		// ---------- ROM ----------
 172:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 173:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 174:main.c        **** 			gba_mode();
 175:main.c        **** 			
 176:main.c        **** 			uint8_t readEnd = 32;
 177:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 178:main.c        **** 				readEnd = 128;
 179:main.c        **** 			}
 180:main.c        **** 			
 181:main.c        **** 			receivedChar = '1';
 182:main.c        **** 			while (receivedChar == '1') {
 183:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 184:main.c        **** 				
 185:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 186:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 187:main.c        **** 					
 188:main.c        **** 					// Low byte & High byte
 189:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 190:main.c        **** 					USART_Transmit(dataRead >> 8);
 191:main.c        **** 					
 192:main.c        **** 					address++;
 193:main.c        **** 				}
 194:main.c        **** 				
 195:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 196:main.c        **** 				receivedChar = USART_Receive();
 197:main.c        **** 			}
 198:main.c        **** 		}
 199:main.c        **** 		
 200:main.c        **** 		// Read and send 0x10000 bytes of data
 201:main.c        **** 		else if (receivedChar == GBA_READ_ROM_8000H) {
 202:main.c        **** 			gba_mode();
 203:main.c        **** 			
 204:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 205:main.c        **** 			gba_set_24bit_address(address);
 206:main.c        **** 			cs_mreqPin_low;
 207:main.c        **** 			
 208:main.c        **** 			GBA_PORT_ROM_ADDR15_8 = 0;
 209:main.c        **** 			GBA_PORT_ROM_ADDR7_0 = 0;
 210:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0;
 211:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0;
 212:main.c        **** 			
 213:main.c        **** 			for (uint16_t x = 0; x < 0x8000; x++) {
 214:main.c        **** 				rdPin_low;
 215:main.c        **** 				asm volatile("nop");
 216:main.c        **** 				
 217:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA7_0);
 218:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA15_8);
 219:main.c        **** 				rdPin_high;
 220:main.c        **** 			}
 221:main.c        **** 			address += 0x8000;
 222:main.c        **** 			
 223:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 224:main.c        **** 		}
 225:main.c        **** 		
 226:main.c        **** 		// ---------- SRAM ----------
 227:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 228:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 229:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 230:main.c        **** 			
 231:main.c        **** 			receivedChar = '1';
 232:main.c        **** 			while (receivedChar == '1') {
 233:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 234:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 235:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 236:main.c        **** 					address++;
 237:main.c        **** 				}
 238:main.c        **** 				
 239:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 240:main.c        **** 				receivedChar = USART_Receive();
 241:main.c        **** 			}
 242:main.c        **** 			
 243:main.c        **** 			gba_mode(); // Set back
 244:main.c        **** 		}
 245:main.c        **** 		
 246:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 247:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 248:main.c        **** 			gb_mode();
 249:main.c        **** 			
 250:main.c        **** 			usart_read_bytes(64);
 251:main.c        **** 			
 252:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 253:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 254:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 255:main.c        **** 				address++;
 256:main.c        **** 			}
 257:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 258:main.c        **** 			
 259:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 260:main.c        **** 			gba_mode(); // Set back
 261:main.c        **** 		}
 262:main.c        **** 		
 263:main.c        **** 		// Write 1 byte to SRAM address
 264:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 265:main.c        **** 			gb_mode();
 266:main.c        **** 			
 267:main.c        **** 			uint8_t data = USART_Receive();
 268:main.c        **** 			gba_write_ram_8bit_data(address, data);
 269:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 270:main.c        **** 			
 271:main.c        **** 			gba_mode(); // Set back
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		
 275:main.c        **** 		// ---------- FLASH ----------
 276:main.c        **** 		// Read the Flash Manufacturer and Device ID
 277:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 278:main.c        **** 			gb_mode();
 279:main.c        **** 			
 280:main.c        **** 			flash_read_chip_id();
 281:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 282:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 283:main.c        **** 			
 284:main.c        **** 			gba_mode(); // Set back
 285:main.c        **** 		}
 286:main.c        **** 		
 287:main.c        **** 		// Change bank
 288:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 289:main.c        **** 			usart_read_chars(); // Read data
 290:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 291:main.c        **** 			
 292:main.c        **** 			gb_mode();
 293:main.c        **** 			flash_switch_bank(bank);
 294:main.c        **** 			
 295:main.c        **** 			gba_mode(); // Set back
 296:main.c        **** 		}
 297:main.c        **** 		
 298:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 299:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 300:main.c        **** 			gb_mode();
 301:main.c        **** 			
 302:main.c        **** 			usart_read_chars(); // Read sector
 303:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 304:main.c        **** 			
 305:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 306:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 307:main.c        **** 			
 308:main.c        **** 			gba_mode(); // Set back
 309:main.c        **** 		}
 310:main.c        **** 		
 311:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 312:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 313:main.c        **** 			gb_mode();
 314:main.c        **** 			
 315:main.c        **** 			usart_read_bytes(64);
 316:main.c        **** 			
 317:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 318:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 319:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 320:main.c        **** 				address++;
 321:main.c        **** 			}
 322:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 323:main.c        **** 			
 324:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 325:main.c        **** 			gba_mode(); // Set back
 326:main.c        **** 		}
 327:main.c        **** 		
 328:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 329:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 330:main.c        **** 			gb_mode();
 331:main.c        **** 			
 332:main.c        **** 			usart_read_bytes(128);
 333:main.c        **** 			
 334:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 335:main.c        **** 			flash_write_sector(address); // Address used as sector number
 336:main.c        **** 			address++;
 337:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 338:main.c        **** 			
 339:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 340:main.c        **** 			gba_mode(); // Set back
 341:main.c        **** 		}
 342:main.c        **** 		
 343:main.c        **** 		
 344:main.c        **** 		// ---------- EEPROM ----------
 345:main.c        **** 		// Set EEPROM size
 346:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 347:main.c        **** 			usart_read_chars(); // Read size
 348:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 349:main.c        **** 		}
 350:main.c        **** 		
 351:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 352:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 353:main.c        **** 			gba_eeprom_mode();
 354:main.c        **** 			
 355:main.c        **** 			receivedChar = '1';
 356:main.c        **** 			while (receivedChar == '1') {
 357:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 358:main.c        **** 				gba_eeprom_read(address, eepromSize);
 359:main.c        **** 				
 360:main.c        **** 				// Send back the 8 bytes of data
 361:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 362:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 363:main.c        **** 				}
 364:main.c        **** 				address++; // Increment to next 8 bytes
 365:main.c        **** 				
 366:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 367:main.c        **** 				receivedChar = USART_Receive();
 368:main.c        **** 			}
 369:main.c        **** 			
 370:main.c        **** 			gba_mode(); // Set back
 371:main.c        **** 		}
 372:main.c        **** 		
 373:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 374:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 375:main.c        **** 			gba_eeprom_mode();
 376:main.c        **** 			
 377:main.c        **** 			// Read 8 bytes from USART and place in buffer
 378:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 379:main.c        **** 				eepromBuffer[x] = USART_Receive();
 380:main.c        **** 			}
 381:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 382:main.c        **** 			
 383:main.c        **** 			gba_eeprom_write(address, eepromSize);
 384:main.c        **** 			address++;
 385:main.c        **** 			
 386:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 387:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 388:main.c        **** 			
 389:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 390:main.c        **** 			gba_mode(); // Set back
 391:main.c        **** 		}
 392:main.c        **** 		
 393:main.c        **** 		
 394:main.c        **** 		// ---------- GB FLASH CARTS ----------
 395:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 396:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 397:main.c        **** 			flashWriteWePin = USART_Receive();
 398:main.c        **** 			
 399:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 400:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 401:main.c        **** 				audioPin_high;
 402:main.c        **** 			}
 403:main.c        **** 		}
 404:main.c        **** 		
 405:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 406:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 407:main.c        **** 			flashBank1CommandWrites = 1;
 408:main.c        **** 		}
 409:main.c        **** 		
 410:main.c        **** 		// Load the program method to use
 411:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 412:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 413:main.c        **** 				usart_read_chars(); // Address
 414:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 415:main.c        **** 				USART_Transmit(SEND_ACK);
 416:main.c        **** 				
 417:main.c        **** 				usart_read_chars(); // Data
 418:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 419:main.c        **** 				USART_Transmit(SEND_ACK);
 420:main.c        **** 			}
 421:main.c        **** 		}
 422:main.c        **** 		
 423:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 424:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 425:main.c        **** 			usart_read_chars(); // Read address
 426:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 427:main.c        **** 			
 428:main.c        **** 			usart_read_chars(); // Read data byte
 429:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 430:main.c        **** 			
 431:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 432:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 433:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 434:main.c        **** 			
 435:main.c        **** 			USART_Transmit(SEND_ACK);
 436:main.c        **** 		}
 437:main.c        **** 		
 438:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 439:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 440:main.c        **** 			usart_read_bytes(64);
 441:main.c        **** 			start_timeout_timer();
 442:main.c        **** 			
 443:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 444:main.c        **** 			if (flashBank1CommandWrites == 0) {
 445:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 446:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 447:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 448:main.c        **** 					}
 449:main.c        **** 					address++;
 450:main.c        **** 				}
 451:main.c        **** 			}
 452:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 453:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 454:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 455:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 456:main.c        **** 					}
 457:main.c        **** 					address++;
 458:main.c        **** 				}
 459:main.c        **** 			}
 460:main.c        **** 			
 461:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 462:main.c        **** 		}
 463:main.c        **** 		
 464:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 465:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 466:main.c        **** 			usart_read_bytes(32);
 467:main.c        **** 			start_timeout_timer();
 468:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 469:main.c        **** 			
 470:main.c        **** 			// Setup buffered write
 471:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 472:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 473:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 474:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 475:main.c        **** 			_delay_us(1);
 476:main.c        **** 			
 477:main.c        **** 			// Write data
 478:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 479:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 480:main.c        **** 				address++;
 481:main.c        **** 			}
 482:main.c        **** 			
 483:main.c        **** 			// Write buffer to flash
 484:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 485:main.c        **** 			_delay_us(200);
 486:main.c        **** 			
 487:main.c        **** 			// Verify last byte written
 488:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 489:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 490:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 491:main.c        **** 				_delay_us(5);
 492:main.c        **** 				if (writingTimedout == 1) {
 493:main.c        **** 					break;
 494:main.c        **** 				}
 495:main.c        **** 			}
 496:main.c        **** 			
 497:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 498:main.c        **** 		}
 499:main.c        **** 		
 500:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 501:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_256BYTE) {
 502:main.c        **** 			usart_read_bytes(256);
 503:main.c        **** 			start_timeout_timer();
 504:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 505:main.c        **** 			
 506:main.c        **** 			int16_t byteCounter = 0;
 507:main.c        **** 			for (uint8_t b = 0; b < 8; b++) {
 508:main.c        **** 				// Store to local buffer
 509:main.c        **** 				uint8_t localBuffer[32];
 510:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 511:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 512:main.c        **** 					byteCounter++;
 513:main.c        **** 				}
 514:main.c        **** 				
 515:main.c        **** 				// Setup buffered write
 516:main.c        **** 				gb_flash_write_bus_cycle(0xAAA, 0xAA);
 517:main.c        **** 				gb_flash_write_bus_cycle(0x555, 0x55);
 518:main.c        **** 				gb_flash_write_bus_cycle(address, 0x25);
 519:main.c        **** 				gb_flash_write_bus_cycle(address, 0x1F); // Length
 520:main.c        **** 				_delay_us(1);
 521:main.c        **** 				
 522:main.c        **** 				// Write data
 523:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 524:main.c        **** 					gb_flash_write_bus_cycle(address, localBuffer[x]);
 525:main.c        **** 					address++;
 526:main.c        **** 				}
 527:main.c        **** 				
 528:main.c        **** 				// Write buffer to flash
 529:main.c        **** 				gb_flash_write_bus_cycle(address-32, 0x29);
 530:main.c        **** 				_delay_us(200);
 531:main.c        **** 				
 532:main.c        **** 				// Verify last byte written
 533:main.c        **** 				uint8_t dataVerify = gb_flash_read_byte(address-1);
 534:main.c        **** 				while (dataVerify != localBuffer[31]) {
 535:main.c        **** 					dataVerify = gb_flash_read_byte(address-1);
 536:main.c        **** 					_delay_us(5);
 537:main.c        **** 					if (writingTimedout == 1) {
 538:main.c        **** 						break;
 539:main.c        **** 					}
 540:main.c        **** 				}
 541:main.c        **** 				if (writingTimedout == 1) {
 542:main.c        **** 					break;
 543:main.c        **** 				}
 544:main.c        **** 			}
 545:main.c        **** 			
 546:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 547:main.c        **** 		}
 548:main.c        **** 		
 549:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 550:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 551:main.c        **** 			usart_read_bytes(64);
 552:main.c        **** 			start_timeout_timer();
 553:main.c        **** 			
 554:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 555:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 556:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 557:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 558:main.c        **** 				}
 559:main.c        **** 				address++;
 560:main.c        **** 			}
 561:main.c        **** 			
 562:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 563:main.c        **** 		}
 564:main.c        **** 		
 565:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 566:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 567:main.c        **** 			usart_read_bytes(256);
 568:main.c        **** 			start_timeout_timer();
 569:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 570:main.c        **** 			
 571:main.c        **** 			// Setup buffered write
 572:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 573:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 574:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 575:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 576:main.c        **** 			_delay_us(50);
 577:main.c        **** 			
 578:main.c        **** 			// Write data
 579:main.c        **** 			for (int x = 0; x < 256; x++) {
 580:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 581:main.c        **** 				address++;
 582:main.c        **** 			}
 583:main.c        **** 			
 584:main.c        **** 			// Write buffer to flash
 585:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 586:main.c        **** 			
 587:main.c        **** 			// Verify last byte written
 588:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 589:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 590:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 591:main.c        **** 				_delay_us(5);
 592:main.c        **** 				if (writingTimedout == 1) {
 593:main.c        **** 					break;
 594:main.c        **** 				}
 595:main.c        **** 			}
 596:main.c        **** 			
 597:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 598:main.c        **** 		}
 599:main.c        **** 		
 600:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 601:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 602:main.c        **** 			usart_read_bytes(128);
 603:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 604:main.c        **** 			
 605:main.c        **** 			// Enable flash chip access
 606:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 607:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 608:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 609:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 610:main.c        **** 			_delay_us(5);
 611:main.c        **** 			
 612:main.c        **** 			// Re-Enable writes to MBC registers
 613:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 614:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 615:main.c        **** 			_delay_us(5);
 616:main.c        **** 			
 617:main.c        **** 			// Bank 1 for commands
 618:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 619:main.c        **** 			_delay_us(5);
 620:main.c        **** 			
 621:main.c        **** 			
 622:main.c        **** 			// Write setup
 623:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 624:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 625:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 626:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 627:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 628:main.c        **** 			_delay_us(5);
 629:main.c        **** 			
 630:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 631:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 632:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 633:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 634:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 635:main.c        **** 			_delay_us(5);
 636:main.c        **** 			
 637:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 638:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 639:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 640:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 641:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 642:main.c        **** 			_delay_us(5);
 643:main.c        **** 			
 644:main.c        **** 			// Set bank back
 645:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 646:main.c        **** 			_delay_us(5);
 647:main.c        **** 			
 648:main.c        **** 			// Disable writes to MBC registers
 649:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 650:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 651:main.c        **** 			_delay_us(5);
 652:main.c        **** 			
 653:main.c        **** 			// Undo Wakeup
 654:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 655:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 656:main.c        **** 			_delay_us(5);
 657:main.c        **** 			
 658:main.c        **** 			
 659:main.c        **** 			// Write data
 660:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 661:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 662:main.c        **** 				_delay_us(5);
 663:main.c        **** 				address++;
 664:main.c        **** 			}
 665:main.c        **** 			
 666:main.c        **** 			// Write buffer to flash
 667:main.c        **** 			address--;
 668:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 669:main.c        **** 			address++;
 670:main.c        **** 			_delay_ms(10);
 671:main.c        **** 			
 672:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 673:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 674:main.c        **** 		}
 675:main.c        **** 		
 676:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 677:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 678:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 679:main.c        **** 			usart_read_bytes(32);
 680:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 681:main.c        **** 			
 682:main.c        **** 			// Setup buffered write
 683:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 684:main.c        **** 			
 685:main.c        **** 			// Wait until ready
 686:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 687:main.c        **** 			start_timeout_timer();
 688:main.c        **** 			while (gb_flash_read_byte(address) != 0x80) {
 689:main.c        **** 				if (writingTimedout == 1) {
 690:main.c        **** 					break;
 691:main.c        **** 				}
 692:main.c        **** 			}
 693:main.c        **** 			
 694:main.c        **** 			if (writingTimedout == 0) {
 695:main.c        **** 				start_timeout_timer();
 696:main.c        **** 				
 697:main.c        **** 				// Set buffer size
 698:main.c        **** 				gb_flash_write_bus_cycle(address, 0x1F);
 699:main.c        **** 				
 700:main.c        **** 				// Write data to buffer
 701:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 702:main.c        **** 					gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 703:main.c        **** 					address++;
 704:main.c        **** 				}
 705:main.c        **** 				
 706:main.c        **** 				// Write buffer to flash
 707:main.c        **** 				gb_flash_write_bus_cycle(address-32, 0xD0);
 708:main.c        **** 				_delay_us(196);
 709:main.c        **** 				
 710:main.c        **** 				// Wait until ready
 711:main.c        **** 				//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 712:main.c        **** 				while (gb_flash_read_byte(address-32) != 0x80) {
 713:main.c        **** 					if (writingTimedout == 1) {
 714:main.c        **** 						break;
 715:main.c        **** 					}
 716:main.c        **** 				}
 717:main.c        **** 				
 718:main.c        **** 				check_if_timed_out(); // Send ACK if successful write
 719:main.c        **** 			}
 720:main.c        **** 		}
 721:main.c        **** 		
 722:main.c        **** 		
 723:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 724:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 725:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 726:main.c        **** 			usart_read_chars(); // Read address
 727:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 728:main.c        **** 			
 729:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 730:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 731:main.c        **** 				usart_read_chars(); // Read data
 732:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 733:main.c        **** 				
 734:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 735:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 736:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 737:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 738:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 739:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 740:main.c        **** 				
 741:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 742:main.c        **** 			}
 743:main.c        **** 		}
 744:main.c        **** 		
 745:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 746:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 747:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 748:main.c        **** 			
 749:main.c        **** 			int readLength = 64;
 750:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 751:main.c        **** 				readLength = 256;
 752:main.c        **** 			}
 753:main.c        **** 			usart_read_bytes(readLength);
 754:main.c        **** 			start_timeout_timer();
 755:main.c        **** 			
 756:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 757:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 758:main.c        **** 				if (combinedBytes != 0xFFFF) {
 759:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 760:main.c        **** 				}
 761:main.c        **** 				address++;
 762:main.c        **** 			}
 763:main.c        **** 			
 764:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 765:main.c        **** 		}
 766:main.c        **** 		
 767:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 768:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 769:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 770:main.c        **** 			
 771:main.c        **** 			int readLength = 256;
 772:main.c        **** 			usart_read_bytes(readLength);
 773:main.c        **** 			start_timeout_timer();
 774:main.c        **** 			
 775:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 776:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 777:main.c        **** 				if (combinedBytes != 0xFFFF) {
 778:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 779:main.c        **** 				}
 780:main.c        **** 				address++;
 781:main.c        **** 			}
 782:main.c        **** 			
 783:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 784:main.c        **** 		}
 785:main.c        **** 		
 786:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 787:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BUFFERED_256BYTE) {
 788:main.c        **** 			usart_read_bytes(256);
 789:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 790:main.c        **** 			
 791:main.c        **** 			// Setup buffered write
 792:main.c        **** 			int16_t byteCounter = 0;
 793:main.c        **** 			for (uint8_t b = 0; b < 8; b++) {
 794:main.c        **** 				start_timeout_timer();
 795:main.c        **** 				
 796:main.c        **** 				// Set address lines as outputs
 797:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 798:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 799:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 800:main.c        **** 				
 801:main.c        **** 				// Store to local buffer
 802:main.c        **** 				uint8_t localBuffer[32];
 803:main.c        **** 				for (uint8_t x = 0; x < 32; x++) {
 804:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 805:main.c        **** 					byteCounter++;
 806:main.c        **** 				}
 807:main.c        **** 				
 808:main.c        **** 				gba_flash_write_bus_cycle(0x555, 0xAA);
 809:main.c        **** 				gba_flash_write_bus_cycle(0x2AA, 0x55);
 810:main.c        **** 				gba_flash_write_bus_cycle(address, 0x25);
 811:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // Length
 812:main.c        **** 				_delay_us(1);
 813:main.c        **** 				
 814:main.c        **** 				// Set address
 815:main.c        **** 				GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 816:main.c        **** 				GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 817:main.c        **** 				GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 818:main.c        **** 				cs_mreqPin_low;
 819:main.c        **** 				
 820:main.c        **** 				// Write data
 821:main.c        **** 				for (uint8_t x = 0; x < 32; x += 2) {
 822:main.c        **** 					GBA_PORT_ROM_DATA15_8 = localBuffer[x+1];
 823:main.c        **** 					GBA_PORT_ROM_DATA7_0 = localBuffer[x];
 824:main.c        **** 					
 825:main.c        **** 					wrPin_low;
 826:main.c        **** 					asm volatile("nop");
 827:main.c        **** 					asm volatile("nop");
 828:main.c        **** 					asm volatile("nop");
 829:main.c        **** 					wrPin_high;
 830:main.c        **** 					
 831:main.c        **** 					// Increment address
 832:main.c        **** 					rdPin_low;
 833:main.c        **** 					asm volatile("nop");
 834:main.c        **** 					rdPin_high;
 835:main.c        **** 					address++;
 836:main.c        **** 				}
 837:main.c        **** 				cs_mreqPin_high;
 838:main.c        **** 				
 839:main.c        **** 				// Write buffer to flash
 840:main.c        **** 				gba_flash_write_bus_cycle(address-15, 0x29);
 841:main.c        **** 				_delay_us(200);
 842:main.c        **** 				
 843:main.c        **** 				// Verify last byte written
 844:main.c        **** 				uint16_t combinedBytes = (uint16_t) localBuffer[31] << 8 | (uint16_t) localBuffer[30];
 845:main.c        **** 				uint16_t dataVerify = gba_read_16bit_data(address-1);
 846:main.c        **** 				while (dataVerify != combinedBytes) {
 847:main.c        **** 					dataVerify = gba_read_16bit_data(address-1);
 848:main.c        **** 					_delay_us(1);
 849:main.c        **** 					if (writingTimedout == 1) {
 850:main.c        **** 						break;
 851:main.c        **** 					}
 852:main.c        **** 				}
 853:main.c        **** 				if (writingTimedout == 1) {
 854:main.c        **** 					break;
 855:main.c        **** 				}
 856:main.c        **** 			}
 857:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 858:main.c        **** 		}
 859:main.c        **** 		
 860:main.c        **** 		// Intel flash command based chips
 861:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 862:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 863:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 864:main.c        **** 			usart_read_bytes(64);
 865:main.c        **** 			start_timeout_timer();
 866:main.c        **** 			
 867:main.c        **** 			// Set address lines as outputs
 868:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 869:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 870:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 871:main.c        **** 			
 872:main.c        **** 			// Unlock
 873:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 874:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 875:main.c        **** 			
 876:main.c        **** 			// Buffered write command
 877:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 878:main.c        **** 			_delay_us(50);
 879:main.c        **** 			
 880:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 881:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 882:main.c        **** 			while (dataVerify != 0x0080) {
 883:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 884:main.c        **** 				_delay_us(50);
 885:main.c        **** 				if (writingTimedout == 1) {
 886:main.c        **** 					break;
 887:main.c        **** 				}
 888:main.c        **** 			}
 889:main.c        **** 			
 890:main.c        **** 			
 891:main.c        **** 			// Set address lines as outputs
 892:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 893:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 894:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 895:main.c        **** 			
 896:main.c        **** 			// Set length
 897:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 898:main.c        **** 			
 899:main.c        **** 			// Write data
 900:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 901:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 902:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 903:main.c        **** 				address++;
 904:main.c        **** 			}
 905:main.c        **** 			
 906:main.c        **** 			// Write buffer to flash
 907:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 908:main.c        **** 			_delay_us(440);
 909:main.c        **** 			
 910:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 911:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 912:main.c        **** 			while (dataVerify != 0x0080) {
 913:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 914:main.c        **** 				_delay_us(50);
 915:main.c        **** 				if (writingTimedout == 1) {
 916:main.c        **** 					break;
 917:main.c        **** 				}
 918:main.c        **** 			}
 919:main.c        **** 			
 920:main.c        **** 			
 921:main.c        **** 			// Set address lines as outputs
 922:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 923:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 924:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 925:main.c        **** 			
 926:main.c        **** 			// Back to reading mode
 927:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 928:main.c        **** 			
 929:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 930:main.c        **** 		}
 931:main.c        **** 		
 932:main.c        **** 		// Intel word programming
 933:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 934:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 935:main.c        **** 			usart_read_bytes(64);
 936:main.c        **** 			start_timeout_timer();
 937:main.c        **** 			
 938:main.c        **** 			// Write data
 939:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 940:main.c        **** 				// Set address lines as outputs
 941:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 942:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 943:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 944:main.c        **** 				
 945:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 946:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 947:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 948:main.c        **** 				
 949:main.c        **** 				// Verify status ok
 950:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 951:main.c        **** 				while ((status & 0x80) == 0) {
 952:main.c        **** 					status = gba_read_16bit_data(address);
 953:main.c        **** 					_delay_us(2);
 954:main.c        **** 					if (writingTimedout == 1) {
 955:main.c        **** 						break;
 956:main.c        **** 					}
 957:main.c        **** 				}
 958:main.c        **** 				address++;
 959:main.c        **** 			}
 960:main.c        **** 			
 961:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 962:main.c        **** 		}
 963:main.c        **** 		
 964:main.c        **** 		// Intel flash command based chips, two chips interleaved (Flash2Advance 256M cart)
 965:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 966:main.c        **** 		// Thanks to lesserkuma for adding support
 967:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE) {
 968:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 969:main.c        **** 			usart_read_bytes(256);
 970:main.c        **** 			start_timeout_timer();
 971:main.c        **** 			
 972:main.c        **** 			// Loop four times, transferring 256 bytes over USB at once is faster than doing four transfers
 973:main.c        **** 			for (int c = 0; c < 4; c++) {
 974:main.c        **** 				// Set address lines as outputs
 975:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 976:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 977:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 978:main.c        **** 				
 979:main.c        **** 				// Setup buffered write
 980:main.c        **** 				gba_flash_write_bus_cycle(address, 0xE8);
 981:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 982:main.c        **** 				
 983:main.c        **** 				// Wait until both chips are ready
 984:main.c        **** 				while (gba_read_16bit_data(address) != 0x80) {
 985:main.c        **** 					if (writingTimedout == 1) {
 986:main.c        **** 						break;
 987:main.c        **** 					}
 988:main.c        **** 				}
 989:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80) {
 990:main.c        **** 					if (writingTimedout == 1) {
 991:main.c        **** 						break;
 992:main.c        **** 					}
 993:main.c        **** 				}
 994:main.c        **** 				
 995:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 996:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 997:main.c        **** 				
 998:main.c        **** 				if (writingTimedout == 0) {
 999:main.c        **** 					start_timeout_timer();
1000:main.c        **** 					
1001:main.c        **** 					// Set address lines as outputs
1002:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
1003:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
1004:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
1005:main.c        **** 					
1006:main.c        **** 					// Set length (number of words+1 to write)
1007:main.c        **** 					gba_flash_write_bus_cycle(address, 0x0F); // 16 words
1008:main.c        **** 					gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
1009:main.c        **** 					
1010:main.c        **** 					// Write data (32 words total)
1011:main.c        **** 					uint16_t combinedBytes;
1012:main.c        **** 					for (int x = 0; x < 64; x += 2) {
1013:main.c        **** 						combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
1014:main.c        **** 						gba_flash_write_bus_cycle(address, combinedBytes);
1015:main.c        **** 						address++;
1016:main.c        **** 					}
1017:main.c        **** 					
1018:main.c        **** 					// Write buffer to flash
1019:main.c        **** 					gba_flash_write_bus_cycle(address-32, 0xD0);
1020:main.c        **** 					gba_flash_write_bus_cycle(address-32+1, 0xD0);
1021:main.c        **** 					
1022:main.c        **** 					// Wait until ready
1023:main.c        **** 					while (gba_read_16bit_data(address) != 0x80) {
1024:main.c        **** 						if (writingTimedout == 1) {
1025:main.c        **** 							break;
1026:main.c        **** 						}
1027:main.c        **** 					}
1028:main.c        **** 					while (gba_read_16bit_data(address+1) != 0x80) {
1029:main.c        **** 						if (writingTimedout == 1) {
1030:main.c        **** 							break;
1031:main.c        **** 						}
1032:main.c        **** 					}
1033:main.c        **** 				}
1034:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
1035:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
1036:main.c        **** 			}
1037:main.c        **** 			
1038:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
1039:main.c        **** 		}
1040:main.c        **** 
1041:main.c        **** 		// Sharp LH28F320BJE programming (Thanks to lesserkuma for adding support)
1042:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_SHARP_64BYTE) {
1043:main.c        **** 			uint16_t status = 0;
1044:main.c        **** 			
1045:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1046:main.c        **** 			usart_read_bytes(64);
1047:main.c        **** 			start_timeout_timer();
1048:main.c        **** 			
1049:main.c        **** 			// Write data
1050:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
1051:main.c        **** 				// Wait until ready
1052:main.c        **** 				while ((status & 0x80) != 0x80) {
1053:main.c        **** 					// Set address lines as outputs
1054:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2710               		.loc 3 1054 0
 2711 0024 9924      		clr r9
 2712 0026 9A94      		dec r9
 2713 0028 1E01      		movw r2,r28
 2714 002a 91E2      		ldi r25,33
 2715 002c 290E      		add r2,r25
 2716 002e 311C      		adc r3,__zero_reg__
 2717               	.LVL191:
 2718               	.L106:
 2719               	.LBE225:
 2720               	.LBE224:
 2721               	.LBE223:
  65:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2722               		.loc 3 65 0
 2723 0030 BEA1      		ldd r27,Y+38
 2724 0032 B130      		cpi r27,lo8(1)
 2725 0034 01F4      		brne .L107
 2726               	.LVL192:
 2727               	.L338:
  66:main.c        **** 		}
 2728               		.loc 3 66 0
 2729 0036 00D0      		rcall rd_wr_csmreq_cs2_reset
 2730               	.LVL193:
 2731               	.L107:
  68:main.c        **** 		
 2732               		.loc 3 68 0
 2733 0038 00D0      		rcall USART_Receive
 2734               	.LVL194:
 2735 003a 8093 0000 		sts receivedChar,r24
  71:main.c        **** 			cartMode = GB_MODE;
 2736               		.loc 3 71 0
 2737 003e 829B      		sbis 0x10,2
 2738 0040 00C0      		rjmp .L108
 2739               	.LVL195:
  73:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2740               		.loc 3 73 0
 2741 0042 979A      		sbi 0x12,7
  74:main.c        **** 		}
 2742               		.loc 3 74 0
 2743 0044 3898      		cbi 0x7,0
  72:main.c        **** 			PORTD |= (1<<LED_5V);
 2744               		.loc 3 72 0
 2745 0046 81E0      		ldi r24,lo8(1)
 2746 0048 00C0      		rjmp .L109
 2747               	.LVL196:
 2748               	.L108:
  78:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2749               		.loc 3 78 0
 2750 004a 389A      		sbi 0x7,0
  79:main.c        **** 		}
 2751               		.loc 3 79 0
 2752 004c 9798      		cbi 0x12,7
  77:main.c        **** 			PORTE |= (1<<LED_3V);
 2753               		.loc 3 77 0
 2754 004e 82E0      		ldi r24,lo8(2)
 2755               	.LVL197:
 2756               	.L109:
  83:main.c        **** 			USART_Transmit(cartMode);
 2757               		.loc 3 83 0
 2758 0050 9091 0000 		lds r25,receivedChar
 2759 0054 9334      		cpi r25,lo8(67)
 2760 0056 01F4      		brne .L110
  84:main.c        **** 			stop_timeout_timer();
 2761               		.loc 3 84 0
 2762 0058 00D0      		rcall USART_Transmit
 2763               	.LVL198:
 2764 005a 00C0      		rjmp .L345
 2765               	.LVL199:
 2766               	.L110:
  89:main.c        **** 			gb_mode();
 2767               		.loc 3 89 0
 2768 005c 9734      		cpi r25,lo8(71)
 2769 005e 01F4      		brne .L112
  90:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
 2770               		.loc 3 90 0
 2771 0060 00D0      		rcall gb_mode
 2772               	.LVL200:
  91:main.c        **** 			stop_timeout_timer();
 2773               		.loc 3 91 0
 2774 0062 1092 0000 		sts flashBank1CommandWrites,__zero_reg__
 2775               	.L345:
  92:main.c        **** 		}
 2776               		.loc 3 92 0
 2777 0066 00D0      		rcall stop_timeout_timer
 2778               	.LVL201:
 2779 0068 00C0      		rjmp .L106
 2780               	.LVL202:
 2781               	.L112:
  94:main.c        **** 			gba_mode();
 2782               		.loc 3 94 0
 2783 006a 9736      		cpi r25,lo8(103)
 2784 006c 01F4      		brne .L113
  95:main.c        **** 			stop_timeout_timer();
 2785               		.loc 3 95 0
 2786 006e 00D0      		rcall gba_mode
 2787               	.LVL203:
 2788 0070 00C0      		rjmp .L345
 2789               	.LVL204:
 2790               	.L113:
 102:main.c        **** 			usart_read_chars(); // Read start address
 2791               		.loc 3 102 0
 2792 0072 9134      		cpi r25,lo8(65)
 2793 0074 01F4      		brne .L114
 103:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2794               		.loc 3 103 0
 2795 0076 00D0      		rcall usart_read_chars
 2796               	.LVL205:
 104:main.c        **** 		}
 2797               		.loc 3 104 0
 2798 0078 40E1      		ldi r20,lo8(16)
 2799 007a 50E0      		ldi r21,0
 2800 007c 60E0      		ldi r22,0
 2801 007e 70E0      		ldi r23,0
 2802 0080 80E0      		ldi r24,lo8(receivedBuffer)
 2803 0082 90E0      		ldi r25,hi8(receivedBuffer)
 2804 0084 00D0      		rcall strtol
 2805               	.LVL206:
 2806 0086 2B01      		movw r4,r22
 2807 0088 3C01      		movw r6,r24
 2808               	.LVL207:
 2809 008a 00C0      		rjmp .L106
 2810               	.LVL208:
 2811               	.L114:
 108:main.c        **** 			gb_mode();
 2812               		.loc 3 108 0
 2813 008c 9235      		cpi r25,lo8(82)
 2814 008e 01F4      		brne .L115
 109:main.c        **** 			receivedChar = '1';
 2815               		.loc 3 109 0
 2816 0090 00D0      		rcall gb_mode
 2817               	.LVL209:
 110:main.c        **** 			while (receivedChar == '1') {
 2818               		.loc 3 110 0
 2819 0092 81E3      		ldi r24,lo8(49)
 2820               	.LVL210:
 2821               	.L351:
 119:main.c        **** 			}
 2822               		.loc 3 119 0
 2823 0094 8093 0000 		sts receivedChar,r24
 2824               	.LVL211:
 111:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2825               		.loc 3 111 0
 2826 0098 8091 0000 		lds r24,receivedChar
 2827 009c 8133      		cpi r24,lo8(49)
 2828 009e 01F4      		brne .L106
 112:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2829               		.loc 3 112 0
 2830 00a0 939A      		sbi 0x12,3
 2831               	.LVL212:
 2832 00a2 00E0      		ldi r16,0
 2833 00a4 10E0      		ldi r17,0
 2834               	.LVL213:
 2835               	.L117:
 2836               	.LBB230:
 114:main.c        **** 					address++;
 2837               		.loc 3 114 0 discriminator 3
 2838 00a6 C801      		movw r24,r16
 2839 00a8 840D      		add r24,r4
 2840 00aa 951D      		adc r25,r5
 2841 00ac 00D0      		rcall read_8bit_data
 2842               	.LVL214:
 2843 00ae 00D0      		rcall USART_Transmit
 2844               	.LVL215:
 2845 00b0 0F5F      		subi r16,-1
 2846 00b2 1F4F      		sbci r17,-1
 2847               	.LVL216:
 113:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2848               		.loc 3 113 0 discriminator 3
 2849 00b4 0034      		cpi r16,64
 2850 00b6 1105      		cpc r17,__zero_reg__
 2851 00b8 01F4      		brne .L117
 2852 00ba E0E4      		ldi r30,64
 2853 00bc 4E0E      		add r4,r30
 2854 00be 511C      		adc r5,__zero_reg__
 2855 00c0 611C      		adc r6,__zero_reg__
 2856 00c2 711C      		adc r7,__zero_reg__
 2857               	.LBE230:
 118:main.c        **** 				receivedChar = USART_Receive();
 2858               		.loc 3 118 0
 2859 00c4 9398      		cbi 0x12,3
 119:main.c        **** 			}
 2860               		.loc 3 119 0
 2861 00c6 00D0      		rcall USART_Receive
 2862               	.LVL217:
 2863 00c8 00C0      		rjmp .L351
 2864               	.LVL218:
 2865               	.L115:
 124:main.c        **** 			gb_mode();
 2866               		.loc 3 124 0
 2867 00ca 9135      		cpi r25,lo8(81)
 2868 00cc 01F4      		brne .L119
 125:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2869               		.loc 3 125 0
 2870 00ce 00D0      		rcall gb_mode
 2871               	.LVL219:
 126:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2872               		.loc 3 126 0
 2873 00d0 939A      		sbi 0x12,3
 2874               	.LVL220:
 2875               	.LBB231:
 127:main.c        **** 				USART_Transmit(read_8bit_data(address));
 2876               		.loc 3 127 0
 2877 00d2 00E0      		ldi r16,0
 2878 00d4 10E0      		ldi r17,0
 2879               	.LVL221:
 2880               	.L120:
 128:main.c        **** 				address++;
 2881               		.loc 3 128 0 discriminator 3
 2882 00d6 C801      		movw r24,r16
 2883 00d8 840D      		add r24,r4
 2884 00da 951D      		adc r25,r5
 2885 00dc 00D0      		rcall read_8bit_data
 2886               	.LVL222:
 2887 00de 00D0      		rcall USART_Transmit
 2888               	.LVL223:
 127:main.c        **** 				USART_Transmit(read_8bit_data(address));
 2889               		.loc 3 127 0 discriminator 3
 2890 00e0 0F5F      		subi r16,-1
 2891 00e2 1F4F      		sbci r17,-1
 2892               	.LVL224:
 2893 00e4 0115      		cp r16,__zero_reg__
 2894 00e6 F0E4      		ldi r31,64
 2895 00e8 1F07      		cpc r17,r31
 2896 00ea 01F4      		brne .L120
 2897 00ec 20E4      		ldi r18,64
 2898 00ee 520E      		add r5,r18
 2899 00f0 611C      		adc r6,__zero_reg__
 2900 00f2 711C      		adc r7,__zero_reg__
 2901 00f4 00C0      		rjmp .L346
 2902               	.LVL225:
 2903               	.L119:
 2904               	.LBE231:
 135:main.c        **** 			gb_mode();
 2905               		.loc 3 135 0
 2906 00f6 9735      		cpi r25,lo8(87)
 2907 00f8 01F4      		brne .L121
 136:main.c        **** 			
 2908               		.loc 3 136 0
 2909 00fa 00D0      		rcall gb_mode
 2910               	.LVL226:
 139:main.c        **** 			
 2911               		.loc 3 139 0
 2912 00fc 80E4      		ldi r24,lo8(64)
 2913 00fe 90E0      		ldi r25,0
 2914 0100 00D0      		rcall usart_read_bytes
 2915               	.LVL227:
 141:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2916               		.loc 3 141 0
 2917 0102 939A      		sbi 0x12,3
 2918               	.LVL228:
 2919 0104 E0E0      		ldi r30,lo8(receivedBuffer)
 2920 0106 EE2E      		mov r14,r30
 2921 0108 E0E0      		ldi r30,hi8(receivedBuffer)
 2922 010a FE2E      		mov r15,r30
 2923 010c 00E0      		ldi r16,0
 2924 010e 10E0      		ldi r17,0
 2925               	.LVL229:
 2926               	.L122:
 2927               	.LBB232:
 143:main.c        **** 				address++;
 2928               		.loc 3 143 0 discriminator 3
 2929 0110 D701      		movw r26,r14
 2930 0112 6D91      		ld r22,X+
 2931 0114 7D01      		movw r14,r26
 2932 0116 C801      		movw r24,r16
 2933 0118 840D      		add r24,r4
 2934 011a 951D      		adc r25,r5
 2935 011c 41E0      		ldi r20,lo8(1)
 2936 011e 00D0      		rcall write_8bit_data
 2937               	.LVL230:
 2938 0120 0F5F      		subi r16,-1
 2939 0122 1F4F      		sbci r17,-1
 2940               	.LVL231:
 142:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2941               		.loc 3 142 0 discriminator 3
 2942 0124 0034      		cpi r16,64
 2943 0126 1105      		cpc r17,__zero_reg__
 2944 0128 01F4      		brne .L122
 2945 012a B0E4      		ldi r27,64
 2946 012c 4B0E      		add r4,r27
 2947 012e 511C      		adc r5,__zero_reg__
 2948 0130 611C      		adc r6,__zero_reg__
 2949 0132 711C      		adc r7,__zero_reg__
 2950 0134 00C0      		rjmp .L356
 2951               	.LVL232:
 2952               	.L121:
 2953               	.LBE232:
 152:main.c        **** 			gb_mode();
 2954               		.loc 3 152 0
 2955 0136 9234      		cpi r25,lo8(66)
 2956 0138 01F4      		brne .L123
 2957               	.LBB233:
 153:main.c        **** 			
 2958               		.loc 3 153 0
 2959 013a 00D0      		rcall gb_mode
 2960               	.LVL233:
 155:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2961               		.loc 3 155 0
 2962 013c 00D0      		rcall usart_read_chars
 2963               	.LVL234:
 156:main.c        **** 			
 2964               		.loc 3 156 0
 2965 013e 40E1      		ldi r20,lo8(16)
 2966 0140 50E0      		ldi r21,0
 2967 0142 60E0      		ldi r22,0
 2968 0144 70E0      		ldi r23,0
 2969 0146 80E0      		ldi r24,lo8(receivedBuffer)
 2970 0148 90E0      		ldi r25,hi8(receivedBuffer)
 2971 014a 00D0      		rcall strtol
 2972               	.LVL235:
 2973 014c 6B01      		movw r12,r22
 2974 014e 7C01      		movw r14,r24
 2975               	.LVL236:
 158:main.c        **** 			if (receivedChar == 'B') {
 2976               		.loc 3 158 0
 2977 0150 00D0      		rcall USART_Receive
 2978               	.LVL237:
 2979 0152 8093 0000 		sts receivedChar,r24
 159:main.c        **** 				usart_read_chars(); // Read data
 2980               		.loc 3 159 0
 2981 0156 8234      		cpi r24,lo8(66)
 2982 0158 01F0      		breq .+2
 2983 015a 00C0      		rjmp .L106
 2984               	.LBB234:
 160:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2985               		.loc 3 160 0
 2986 015c 00D0      		rcall usart_read_chars
 2987               	.LVL238:
 161:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2988               		.loc 3 161 0
 2989 015e 80E0      		ldi r24,lo8(receivedBuffer)
 2990 0160 90E0      		ldi r25,hi8(receivedBuffer)
 2991 0162 00D0      		rcall atoi
 2992               	.LVL239:
 162:main.c        **** 				
 2993               		.loc 3 162 0
 2994 0164 8093 0000 		sts lastBankAccessed,r24
 164:main.c        **** 			}
 2995               		.loc 3 164 0
 2996 0168 40E0      		ldi r20,0
 2997 016a 682F      		mov r22,r24
 2998 016c C601      		movw r24,r12
 2999               	.LVL240:
 3000 016e 00D0      		rcall write_8bit_data
 3001               	.LVL241:
 3002 0170 00C0      		rjmp .L106
 3003               	.LVL242:
 3004               	.L123:
 3005               	.LBE234:
 3006               	.LBE233:
 173:main.c        **** 			gba_mode();
 3007               		.loc 3 173 0
 3008 0172 9237      		cpi r25,lo8(114)
 3009 0174 01F0      		breq .L124
 173:main.c        **** 			gba_mode();
 3010               		.loc 3 173 0 is_stmt 0 discriminator 1
 3011 0176 9A36      		cpi r25,lo8(106)
 3012 0178 01F0      		breq .+2
 3013 017a 00C0      		rjmp .L125
 3014               	.L124:
 3015               	.LBB235:
 174:main.c        **** 			
 3016               		.loc 3 174 0 is_stmt 1
 3017 017c 00D0      		rcall gba_mode
 3018               	.LVL243:
 177:main.c        **** 				readEnd = 128;
 3019               		.loc 3 177 0
 3020 017e 8091 0000 		lds r24,receivedChar
 3021 0182 8A36      		cpi r24,lo8(106)
 3022 0184 01F0      		breq .L254
 176:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 3023               		.loc 3 176 0
 3024 0186 10E2      		ldi r17,lo8(32)
 3025 0188 00C0      		rjmp .L126
 3026               	.L254:
 178:main.c        **** 			}
 3027               		.loc 3 178 0
 3028 018a 10E8      		ldi r17,lo8(-128)
 3029               	.L126:
 3030               	.LVL244:
 181:main.c        **** 			while (receivedChar == '1') {
 3031               		.loc 3 181 0
 3032 018c 81E3      		ldi r24,lo8(49)
 3033 018e 8093 0000 		sts receivedChar,r24
 3034 0192 CC24      		clr r12
 3035 0194 CA94      		dec r12
 3036 0196 C10E      		add r12,r17
 3037 0198 D12C      		mov r13,__zero_reg__
 3038 019a E12C      		mov r14,__zero_reg__
 3039 019c F12C      		mov r15,__zero_reg__
 3040 019e D701      		movw r26,r14
 3041 01a0 C601      		movw r24,r12
 3042 01a2 0196      		adiw r24,1
 3043 01a4 A11D      		adc r26,__zero_reg__
 3044 01a6 B11D      		adc r27,__zero_reg__
 3045 01a8 89A3      		std Y+33,r24
 3046 01aa 9AA3      		std Y+34,r25
 3047 01ac ABA3      		std Y+35,r26
 3048 01ae BCA3      		std Y+36,r27
 3049               	.LVL245:
 3050               	.L127:
 182:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3051               		.loc 3 182 0
 3052 01b0 8091 0000 		lds r24,receivedChar
 3053 01b4 8133      		cpi r24,lo8(49)
 3054 01b6 01F0      		breq .+2
 3055 01b8 00C0      		rjmp .L106
 183:main.c        **** 				
 3056               		.loc 3 183 0
 3057 01ba 939A      		sbi 0x12,3
 3058               	.LVL246:
 3059 01bc 7301      		movw r14,r6
 3060 01be 6201      		movw r12,r4
 3061               	.LVL247:
 3062               	.L128:
 3063               	.LBB236:
 3064               	.LBB237:
 186:main.c        **** 					
 3065               		.loc 3 186 0 discriminator 3
 3066 01c0 C701      		movw r24,r14
 3067 01c2 B601      		movw r22,r12
 3068 01c4 00D0      		rcall gba_read_16bit_data
 3069               	.LVL248:
 3070 01c6 092F      		mov r16,r25
 3071               	.LVL249:
 189:main.c        **** 					USART_Transmit(dataRead >> 8);
 3072               		.loc 3 189 0 discriminator 3
 3073 01c8 00D0      		rcall USART_Transmit
 3074               	.LVL250:
 190:main.c        **** 					
 3075               		.loc 3 190 0 discriminator 3
 3076 01ca 802F      		mov r24,r16
 3077 01cc 00D0      		rcall USART_Transmit
 3078               	.LVL251:
 192:main.c        **** 				}
 3079               		.loc 3 192 0 discriminator 3
 3080 01ce 9FEF      		ldi r25,-1
 3081 01d0 C91A      		sub r12,r25
 3082 01d2 D90A      		sbc r13,r25
 3083 01d4 E90A      		sbc r14,r25
 3084 01d6 F90A      		sbc r15,r25
 3085               	.LVL252:
 3086               	.LBE237:
 185:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 3087               		.loc 3 185 0 discriminator 3
 3088 01d8 8C2D      		mov r24,r12
 3089 01da 8419      		sub r24,r4
 3090 01dc 8117      		cp r24,r17
 3091 01de 00F0      		brlo .L128
 3092 01e0 89A1      		ldd r24,Y+33
 3093 01e2 9AA1      		ldd r25,Y+34
 3094 01e4 ABA1      		ldd r26,Y+35
 3095 01e6 BCA1      		ldd r27,Y+36
 3096 01e8 480E      		add r4,r24
 3097 01ea 591E      		adc r5,r25
 3098 01ec 6A1E      		adc r6,r26
 3099 01ee 7B1E      		adc r7,r27
 3100               	.LVL253:
 3101               	.LBE236:
 195:main.c        **** 				receivedChar = USART_Receive();
 3102               		.loc 3 195 0
 3103 01f0 9398      		cbi 0x12,3
 196:main.c        **** 			}
 3104               		.loc 3 196 0
 3105 01f2 00D0      		rcall USART_Receive
 3106               	.LVL254:
 3107 01f4 8093 0000 		sts receivedChar,r24
 3108 01f8 00C0      		rjmp .L127
 3109               	.LVL255:
 3110               	.L125:
 3111               	.LBE235:
 201:main.c        **** 			gba_mode();
 3112               		.loc 3 201 0
 3113 01fa 9A35      		cpi r25,lo8(90)
 3114 01fc 01F4      		brne .L130
 202:main.c        **** 			
 3115               		.loc 3 202 0
 3116 01fe 00D0      		rcall gba_mode
 3117               	.LVL256:
 204:main.c        **** 			gba_set_24bit_address(address);
 3118               		.loc 3 204 0
 3119 0200 939A      		sbi 0x12,3
 205:main.c        **** 			cs_mreqPin_low;
 3120               		.loc 3 205 0
 3121 0202 C301      		movw r24,r6
 3122 0204 B201      		movw r22,r4
 3123 0206 00D0      		rcall gba_set_24bit_address
 3124               	.LVL257:
 206:main.c        **** 			
 3125               		.loc 3 206 0
 3126 0208 9498      		cbi 0x12,4
 208:main.c        **** 			GBA_PORT_ROM_ADDR7_0 = 0;
 3127               		.loc 3 208 0
 3128 020a 1BBA      		out 0x1b,__zero_reg__
 209:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0;
 3129               		.loc 3 209 0
 3130 020c 18BA      		out 0x18,__zero_reg__
 210:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0;
 3131               		.loc 3 210 0
 3132 020e 1ABA      		out 0x1a,__zero_reg__
 211:main.c        **** 			
 3133               		.loc 3 211 0
 3134 0210 17BA      		out 0x17,__zero_reg__
 3135               	.LVL258:
 3136               	.LBB238:
 213:main.c        **** 				rdPin_low;
 3137               		.loc 3 213 0
 3138 0212 00E0      		ldi r16,0
 3139 0214 10E0      		ldi r17,0
 3140               	.LVL259:
 3141               	.L131:
 213:main.c        **** 				rdPin_low;
 3142               		.loc 3 213 0 is_stmt 0 discriminator 1
 3143 0216 17FD      		sbrc r17,7
 3144 0218 00C0      		rjmp .L357
 214:main.c        **** 				asm volatile("nop");
 3145               		.loc 3 214 0 is_stmt 1 discriminator 3
 3146 021a 9598      		cbi 0x12,5
 215:main.c        **** 				
 3147               		.loc 3 215 0 discriminator 3
 3148               	/* #APP */
 3149               	 ;  215 "main.c" 1
 3150 021c 0000      		nop
 3151               	 ;  0 "" 2
 217:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA15_8);
 3152               		.loc 3 217 0 discriminator 3
 3153               	/* #NOAPP */
 3154 021e 86B3      		in r24,0x16
 3155 0220 00D0      		rcall USART_Transmit
 3156               	.LVL260:
 218:main.c        **** 				rdPin_high;
 3157               		.loc 3 218 0 discriminator 3
 3158 0222 89B3      		in r24,0x19
 3159 0224 00D0      		rcall USART_Transmit
 3160               	.LVL261:
 219:main.c        **** 			}
 3161               		.loc 3 219 0 discriminator 3
 3162 0226 959A      		sbi 0x12,5
 213:main.c        **** 				rdPin_low;
 3163               		.loc 3 213 0 discriminator 3
 3164 0228 0F5F      		subi r16,-1
 3165 022a 1F4F      		sbci r17,-1
 3166               	.LVL262:
 3167 022c 00C0      		rjmp .L131
 3168               	.L357:
 3169               	.LBE238:
 221:main.c        **** 			
 3170               		.loc 3 221 0
 3171 022e 90E8      		ldi r25,-128
 3172 0230 590E      		add r5,r25
 3173 0232 611C      		adc r6,__zero_reg__
 3174 0234 711C      		adc r7,__zero_reg__
 3175               	.LVL263:
 3176               	.L346:
 223:main.c        **** 		}
 3177               		.loc 3 223 0
 3178 0236 9398      		cbi 0x12,3
 3179 0238 00C0      		rjmp .L106
 3180               	.LVL264:
 3181               	.L130:
 228:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 3182               		.loc 3 228 0
 3183 023a 9D36      		cpi r25,lo8(109)
 3184 023c 01F4      		brne .L133
 229:main.c        **** 			
 3185               		.loc 3 229 0
 3186 023e 00D0      		rcall gb_mode
 3187               	.LVL265:
 231:main.c        **** 			while (receivedChar == '1') {
 3188               		.loc 3 231 0
 3189 0240 81E3      		ldi r24,lo8(49)
 3190               	.LVL266:
 3191               	.L352:
 240:main.c        **** 			}
 3192               		.loc 3 240 0
 3193 0242 8093 0000 		sts receivedChar,r24
 3194               	.LVL267:
 232:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3195               		.loc 3 232 0
 3196 0246 8091 0000 		lds r24,receivedChar
 3197 024a 8133      		cpi r24,lo8(49)
 3198 024c 01F4      		brne .L349
 233:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3199               		.loc 3 233 0
 3200 024e 939A      		sbi 0x12,3
 3201               	.LVL268:
 3202 0250 00E0      		ldi r16,0
 3203 0252 10E0      		ldi r17,0
 3204               	.LVL269:
 3205               	.L135:
 3206               	.LBB239:
 235:main.c        **** 					address++;
 3207               		.loc 3 235 0 discriminator 3
 3208 0254 C801      		movw r24,r16
 3209 0256 840D      		add r24,r4
 3210 0258 951D      		adc r25,r5
 3211 025a 00D0      		rcall gba_read_ram_8bit_data
 3212               	.LVL270:
 3213 025c 00D0      		rcall USART_Transmit
 3214               	.LVL271:
 3215 025e 0F5F      		subi r16,-1
 3216 0260 1F4F      		sbci r17,-1
 3217               	.LVL272:
 234:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 3218               		.loc 3 234 0 discriminator 3
 3219 0262 0034      		cpi r16,64
 3220 0264 1105      		cpc r17,__zero_reg__
 3221 0266 01F4      		brne .L135
 3222 0268 A0E4      		ldi r26,64
 3223 026a 4A0E      		add r4,r26
 3224 026c 511C      		adc r5,__zero_reg__
 3225 026e 611C      		adc r6,__zero_reg__
 3226 0270 711C      		adc r7,__zero_reg__
 3227               	.LBE239:
 239:main.c        **** 				receivedChar = USART_Receive();
 3228               		.loc 3 239 0
 3229 0272 9398      		cbi 0x12,3
 240:main.c        **** 			}
 3230               		.loc 3 240 0
 3231 0274 00D0      		rcall USART_Receive
 3232               	.LVL273:
 3233 0276 00C0      		rjmp .L352
 3234               	.LVL274:
 3235               	.L133:
 247:main.c        **** 			gb_mode();
 3236               		.loc 3 247 0
 3237 0278 9737      		cpi r25,lo8(119)
 3238 027a 01F4      		brne .L137
 248:main.c        **** 			
 3239               		.loc 3 248 0
 3240 027c 00D0      		rcall gb_mode
 3241               	.LVL275:
 250:main.c        **** 			
 3242               		.loc 3 250 0
 3243 027e 80E4      		ldi r24,lo8(64)
 3244 0280 90E0      		ldi r25,0
 3245 0282 00D0      		rcall usart_read_bytes
 3246               	.LVL276:
 252:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3247               		.loc 3 252 0
 3248 0284 939A      		sbi 0x12,3
 3249               	.LVL277:
 3250 0286 70E0      		ldi r23,lo8(receivedBuffer)
 3251 0288 E72E      		mov r14,r23
 3252 028a 70E0      		ldi r23,hi8(receivedBuffer)
 3253 028c F72E      		mov r15,r23
 3254 028e 00E0      		ldi r16,0
 3255 0290 10E0      		ldi r17,0
 3256               	.LVL278:
 3257               	.L138:
 3258               	.LBB240:
 254:main.c        **** 				address++;
 3259               		.loc 3 254 0 discriminator 3
 3260 0292 F701      		movw r30,r14
 3261 0294 6191      		ld r22,Z+
 3262 0296 7F01      		movw r14,r30
 3263 0298 C801      		movw r24,r16
 3264 029a 840D      		add r24,r4
 3265 029c 951D      		adc r25,r5
 3266 029e 00D0      		rcall gba_write_ram_8bit_data
 3267               	.LVL279:
 3268 02a0 0F5F      		subi r16,-1
 3269 02a2 1F4F      		sbci r17,-1
 3270               	.LVL280:
 253:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 3271               		.loc 3 253 0 discriminator 3
 3272 02a4 0034      		cpi r16,64
 3273 02a6 1105      		cpc r17,__zero_reg__
 3274 02a8 01F4      		brne .L138
 3275 02aa F0E4      		ldi r31,64
 3276 02ac 4F0E      		add r4,r31
 3277 02ae 511C      		adc r5,__zero_reg__
 3278 02b0 611C      		adc r6,__zero_reg__
 3279 02b2 711C      		adc r7,__zero_reg__
 3280               	.LVL281:
 3281               	.L350:
 3282               	.LBE240:
 257:main.c        **** 			
 3283               		.loc 3 257 0
 3284 02b4 81E3      		ldi r24,lo8(49)
 3285 02b6 00D0      		rcall USART_Transmit
 3286               	.LVL282:
 259:main.c        **** 			gba_mode(); // Set back
 3287               		.loc 3 259 0
 3288 02b8 9398      		cbi 0x12,3
 3289               	.L349:
 260:main.c        **** 		}
 3290               		.loc 3 260 0
 3291 02ba 00D0      		rcall gba_mode
 3292               	.LVL283:
 3293 02bc 00C0      		rjmp .L106
 3294               	.LVL284:
 3295               	.L137:
 264:main.c        **** 			gb_mode();
 3296               		.loc 3 264 0
 3297 02be 9F36      		cpi r25,lo8(111)
 3298 02c0 01F4      		brne .L139
 3299               	.LBB241:
 265:main.c        **** 			
 3300               		.loc 3 265 0
 3301 02c2 00D0      		rcall gb_mode
 3302               	.LVL285:
 267:main.c        **** 			gba_write_ram_8bit_data(address, data);
 3303               		.loc 3 267 0
 3304 02c4 00D0      		rcall USART_Receive
 3305               	.LVL286:
 268:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3306               		.loc 3 268 0
 3307 02c6 682F      		mov r22,r24
 3308 02c8 C201      		movw r24,r4
 3309               	.LVL287:
 3310 02ca 00D0      		rcall gba_write_ram_8bit_data
 3311               	.LVL288:
 3312 02cc 00C0      		rjmp .L354
 3313               	.LVL289:
 3314               	.L139:
 3315               	.LBE241:
 277:main.c        **** 			gb_mode();
 3316               		.loc 3 277 0
 3317 02ce 9936      		cpi r25,lo8(105)
 3318 02d0 01F4      		brne .L140
 278:main.c        **** 			
 3319               		.loc 3 278 0
 3320 02d2 00D0      		rcall gb_mode
 3321               	.LVL290:
 280:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 3322               		.loc 3 280 0
 3323 02d4 00D0      		rcall flash_read_chip_id
 3324               	.LVL291:
 281:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 3325               		.loc 3 281 0
 3326 02d6 8091 0000 		lds r24,flashChipIdBuffer
 3327 02da 00D0      		rcall USART_Transmit
 3328               	.LVL292:
 282:main.c        **** 			
 3329               		.loc 3 282 0
 3330 02dc 8091 0000 		lds r24,flashChipIdBuffer+1
 3331               	.L353:
 3332 02e0 00D0      		rcall USART_Transmit
 3333               	.LVL293:
 3334 02e2 00C0      		rjmp .L349
 3335               	.LVL294:
 3336               	.L140:
 288:main.c        **** 			usart_read_chars(); // Read data
 3337               		.loc 3 288 0
 3338 02e4 9B36      		cpi r25,lo8(107)
 3339 02e6 01F4      		brne .L141
 3340               	.LBB242:
 289:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3341               		.loc 3 289 0
 3342 02e8 00D0      		rcall usart_read_chars
 3343               	.LVL295:
 290:main.c        **** 			
 3344               		.loc 3 290 0
 3345 02ea 80E0      		ldi r24,lo8(receivedBuffer)
 3346 02ec 90E0      		ldi r25,hi8(receivedBuffer)
 3347 02ee 00D0      		rcall atoi
 3348               	.LVL296:
 3349 02f0 182F      		mov r17,r24
 3350               	.LVL297:
 292:main.c        **** 			flash_switch_bank(bank);
 3351               		.loc 3 292 0
 3352 02f2 00D0      		rcall gb_mode
 3353               	.LVL298:
 293:main.c        **** 			
 3354               		.loc 3 293 0
 3355 02f4 812F      		mov r24,r17
 3356 02f6 00D0      		rcall flash_switch_bank
 3357               	.LVL299:
 3358 02f8 00C0      		rjmp .L349
 3359               	.LVL300:
 3360               	.L141:
 3361               	.LBE242:
 299:main.c        **** 			gb_mode();
 3362               		.loc 3 299 0
 3363 02fa 9337      		cpi r25,lo8(115)
 3364 02fc 01F4      		brne .L142
 3365               	.LBB243:
 300:main.c        **** 			
 3366               		.loc 3 300 0
 3367 02fe 00D0      		rcall gb_mode
 3368               	.LVL301:
 302:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3369               		.loc 3 302 0
 3370 0300 00D0      		rcall usart_read_chars
 3371               	.LVL302:
 303:main.c        **** 			
 3372               		.loc 3 303 0
 3373 0302 40E1      		ldi r20,lo8(16)
 3374 0304 50E0      		ldi r21,0
 3375 0306 60E0      		ldi r22,0
 3376 0308 70E0      		ldi r23,0
 3377 030a 80E0      		ldi r24,lo8(receivedBuffer)
 3378 030c 90E0      		ldi r25,hi8(receivedBuffer)
 3379 030e 00D0      		rcall strtol
 3380               	.LVL303:
 3381 0310 862F      		mov r24,r22
 3382               	.LVL304:
 305:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3383               		.loc 3 305 0
 3384 0312 00D0      		rcall flash_erase_4k_sector
 3385               	.LVL305:
 3386               	.L354:
 306:main.c        **** 			
 3387               		.loc 3 306 0
 3388 0314 81E3      		ldi r24,lo8(49)
 3389 0316 00C0      		rjmp .L353
 3390               	.LVL306:
 3391               	.L142:
 3392               	.LBE243:
 312:main.c        **** 			gb_mode();
 3393               		.loc 3 312 0
 3394 0318 9236      		cpi r25,lo8(98)
 3395 031a 01F4      		brne .L143
 313:main.c        **** 			
 3396               		.loc 3 313 0
 3397 031c 00D0      		rcall gb_mode
 3398               	.LVL307:
 315:main.c        **** 			
 3399               		.loc 3 315 0
 3400 031e 80E4      		ldi r24,lo8(64)
 3401 0320 90E0      		ldi r25,0
 3402 0322 00D0      		rcall usart_read_bytes
 3403               	.LVL308:
 317:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3404               		.loc 3 317 0
 3405 0324 939A      		sbi 0x12,3
 3406               	.LVL309:
 3407 0326 60E0      		ldi r22,lo8(receivedBuffer)
 3408 0328 E62E      		mov r14,r22
 3409 032a 60E0      		ldi r22,hi8(receivedBuffer)
 3410 032c F62E      		mov r15,r22
 3411 032e 00E0      		ldi r16,0
 3412 0330 10E0      		ldi r17,0
 3413               	.LVL310:
 3414               	.L144:
 3415               	.LBB244:
 319:main.c        **** 				address++;
 3416               		.loc 3 319 0 discriminator 3
 3417 0332 D701      		movw r26,r14
 3418 0334 6D91      		ld r22,X+
 3419 0336 7D01      		movw r14,r26
 3420 0338 C801      		movw r24,r16
 3421 033a 840D      		add r24,r4
 3422 033c 951D      		adc r25,r5
 3423 033e 00D0      		rcall flash_write_byte
 3424               	.LVL311:
 3425 0340 0F5F      		subi r16,-1
 3426 0342 1F4F      		sbci r17,-1
 3427               	.LVL312:
 318:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3428               		.loc 3 318 0 discriminator 3
 3429 0344 0034      		cpi r16,64
 3430 0346 1105      		cpc r17,__zero_reg__
 3431 0348 01F4      		brne .L144
 3432 034a B0E4      		ldi r27,64
 3433 034c 4B0E      		add r4,r27
 3434 034e 511C      		adc r5,__zero_reg__
 3435 0350 611C      		adc r6,__zero_reg__
 3436 0352 711C      		adc r7,__zero_reg__
 3437 0354 00C0      		rjmp .L350
 3438               	.LVL313:
 3439               	.L143:
 3440               	.LBE244:
 329:main.c        **** 			gb_mode();
 3441               		.loc 3 329 0
 3442 0356 9136      		cpi r25,lo8(97)
 3443 0358 01F4      		brne .L145
 330:main.c        **** 			
 3444               		.loc 3 330 0
 3445 035a 00D0      		rcall gb_mode
 3446               	.LVL314:
 332:main.c        **** 			
 3447               		.loc 3 332 0
 3448 035c 80E8      		ldi r24,lo8(-128)
 3449 035e 90E0      		ldi r25,0
 3450 0360 00D0      		rcall usart_read_bytes
 3451               	.LVL315:
 334:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3452               		.loc 3 334 0
 3453 0362 939A      		sbi 0x12,3
 335:main.c        **** 			address++;
 3454               		.loc 3 335 0
 3455 0364 C201      		movw r24,r4
 3456 0366 00D0      		rcall flash_write_sector
 3457               	.LVL316:
 336:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3458               		.loc 3 336 0
 3459 0368 EFEF      		ldi r30,-1
 3460 036a 4E1A      		sub r4,r30
 3461 036c 5E0A      		sbc r5,r30
 3462 036e 6E0A      		sbc r6,r30
 3463 0370 7E0A      		sbc r7,r30
 3464               	.LVL317:
 3465 0372 00C0      		rjmp .L350
 3466               	.LVL318:
 3467               	.L145:
 346:main.c        **** 			usart_read_chars(); // Read size
 3468               		.loc 3 346 0
 3469 0374 9335      		cpi r25,lo8(83)
 3470 0376 01F4      		brne .L146
 347:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3471               		.loc 3 347 0
 3472 0378 00D0      		rcall usart_read_chars
 3473               	.LVL319:
 348:main.c        **** 		}
 3474               		.loc 3 348 0
 3475 037a 40E1      		ldi r20,lo8(16)
 3476 037c 50E0      		ldi r21,0
 3477 037e 60E0      		ldi r22,0
 3478 0380 70E0      		ldi r23,0
 3479 0382 80E0      		ldi r24,lo8(receivedBuffer)
 3480 0384 90E0      		ldi r25,hi8(receivedBuffer)
 3481 0386 00D0      		rcall strtol
 3482               	.LVL320:
 3483 0388 6DA3      		std Y+37,r22
 3484               	.LVL321:
 3485 038a 00C0      		rjmp .L106
 3486               	.LVL322:
 3487               	.L146:
 352:main.c        **** 			gba_eeprom_mode();
 3488               		.loc 3 352 0
 3489 038c 9536      		cpi r25,lo8(101)
 3490 038e 01F4      		brne .L147
 353:main.c        **** 			
 3491               		.loc 3 353 0
 3492 0390 00D0      		rcall gba_eeprom_mode
 3493               	.LVL323:
 355:main.c        **** 			while (receivedChar == '1') {
 3494               		.loc 3 355 0
 3495 0392 81E3      		ldi r24,lo8(49)
 3496               	.L355:
 367:main.c        **** 			}
 3497               		.loc 3 367 0
 3498 0394 8093 0000 		sts receivedChar,r24
 356:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3499               		.loc 3 356 0
 3500 0398 8091 0000 		lds r24,receivedChar
 3501 039c 8133      		cpi r24,lo8(49)
 3502 039e 01F0      		breq .+2
 3503 03a0 00C0      		rjmp .L349
 357:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3504               		.loc 3 357 0
 3505 03a2 939A      		sbi 0x12,3
 358:main.c        **** 				
 3506               		.loc 3 358 0
 3507 03a4 6DA1      		ldd r22,Y+37
 3508 03a6 C201      		movw r24,r4
 3509 03a8 00D0      		rcall gba_eeprom_read
 3510               	.LVL324:
 3511 03aa 00E0      		ldi r16,lo8(eepromBuffer)
 3512 03ac 10E0      		ldi r17,hi8(eepromBuffer)
 3513               	.LVL325:
 3514               	.L149:
 3515               	.LBB245:
 362:main.c        **** 				}
 3516               		.loc 3 362 0 discriminator 3
 3517 03ae D801      		movw r26,r16
 3518 03b0 8D91      		ld r24,X+
 3519 03b2 8D01      		movw r16,r26
 3520               	.LVL326:
 3521 03b4 00D0      		rcall USART_Transmit
 3522               	.LVL327:
 361:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3523               		.loc 3 361 0 discriminator 3
 3524 03b6 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3525 03b8 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3526 03ba E017      		cp r30,r16
 3527 03bc F107      		cpc r31,r17
 3528 03be 01F4      		brne .L149
 3529               	.LBE245:
 364:main.c        **** 				
 3530               		.loc 3 364 0
 3531 03c0 FFEF      		ldi r31,-1
 3532 03c2 4F1A      		sub r4,r31
 3533 03c4 5F0A      		sbc r5,r31
 3534 03c6 6F0A      		sbc r6,r31
 3535 03c8 7F0A      		sbc r7,r31
 3536               	.LVL328:
 366:main.c        **** 				receivedChar = USART_Receive();
 3537               		.loc 3 366 0
 3538 03ca 9398      		cbi 0x12,3
 367:main.c        **** 			}
 3539               		.loc 3 367 0
 3540 03cc 00D0      		rcall USART_Receive
 3541               	.LVL329:
 3542 03ce 00C0      		rjmp .L355
 3543               	.LVL330:
 3544               	.L147:
 374:main.c        **** 			gba_eeprom_mode();
 3545               		.loc 3 374 0
 3546 03d0 9037      		cpi r25,lo8(112)
 3547 03d2 01F4      		brne .L151
 375:main.c        **** 			
 3548               		.loc 3 375 0
 3549 03d4 00D0      		rcall gba_eeprom_mode
 3550               	.LVL331:
 3551 03d6 00E0      		ldi r16,lo8(eepromBuffer)
 3552 03d8 10E0      		ldi r17,hi8(eepromBuffer)
 3553               	.LVL332:
 3554               	.L152:
 3555               	.LBB246:
 379:main.c        **** 			}
 3556               		.loc 3 379 0 discriminator 3
 3557 03da 00D0      		rcall USART_Receive
 3558               	.LVL333:
 3559 03dc D801      		movw r26,r16
 3560 03de 8D93      		st X+,r24
 3561 03e0 8D01      		movw r16,r26
 3562               	.LVL334:
 378:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3563               		.loc 3 378 0 discriminator 3
 3564 03e2 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3565 03e4 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3566 03e6 EA17      		cp r30,r26
 3567 03e8 FB07      		cpc r31,r27
 3568 03ea 01F4      		brne .L152
 3569               	.LBE246:
 381:main.c        **** 			
 3570               		.loc 3 381 0
 3571 03ec 939A      		sbi 0x12,3
 383:main.c        **** 			address++;
 3572               		.loc 3 383 0
 3573 03ee 6DA1      		ldd r22,Y+37
 3574 03f0 C201      		movw r24,r4
 3575 03f2 00D0      		rcall gba_eeprom_write
 3576               	.LVL335:
 384:main.c        **** 			
 3577               		.loc 3 384 0
 3578 03f4 FFEF      		ldi r31,-1
 3579 03f6 4F1A      		sub r4,r31
 3580 03f8 5F0A      		sbc r5,r31
 3581 03fa 6F0A      		sbc r6,r31
 3582 03fc 7F0A      		sbc r7,r31
 3583               	.LVL336:
 3584               	.LBB247:
 3585               	.LBB248:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3586               		.loc 2 187 0
 3587 03fe 8FE7      		ldi r24,lo8(15999)
 3588 0400 9EE3      		ldi r25,hi8(15999)
 3589 0402 0197      	1:	sbiw r24,1
 3590 0404 01F4      		brne 1b
 3591 0406 00C0      		rjmp .
 3592 0408 0000      		nop
 3593               	.LVL337:
 3594 040a 00C0      		rjmp .L350
 3595               	.LVL338:
 3596               	.L151:
 3597               	.LBE248:
 3598               	.LBE247:
 396:main.c        **** 			flashWriteWePin = USART_Receive();
 3599               		.loc 3 396 0
 3600 040c 9035      		cpi r25,lo8(80)
 3601 040e 01F4      		brne .L153
 397:main.c        **** 			
 3602               		.loc 3 397 0
 3603 0410 00D0      		rcall USART_Receive
 3604               	.LVL339:
 3605 0412 8093 0000 		sts flashWriteWePin,r24
 399:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3606               		.loc 3 399 0
 3607 0416 8134      		cpi r24,lo8(65)
 3608 0418 01F0      		breq .+2
 3609 041a 00C0      		rjmp .L106
 400:main.c        **** 				audioPin_high;
 3610               		.loc 3 400 0
 3611 041c 319A      		sbi 0x6,1
 401:main.c        **** 			}
 3612               		.loc 3 401 0
 3613 041e 399A      		sbi 0x7,1
 3614 0420 00C0      		rjmp .L106
 3615               	.LVL340:
 3616               	.L153:
 406:main.c        **** 			flashBank1CommandWrites = 1;
 3617               		.loc 3 406 0
 3618 0422 9E34      		cpi r25,lo8(78)
 3619 0424 01F4      		brne .L154
 407:main.c        **** 		}
 3620               		.loc 3 407 0
 3621 0426 81E0      		ldi r24,lo8(1)
 3622               	.LVL341:
 3623 0428 8093 0000 		sts flashBank1CommandWrites,r24
 3624 042c 00C0      		rjmp .L106
 3625               	.LVL342:
 3626               	.L154:
 411:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 3627               		.loc 3 411 0
 3628 042e 9534      		cpi r25,lo8(69)
 3629 0430 01F4      		brne .L155
 3630 0432 00E0      		ldi r16,lo8(flashWriteCycle)
 3631 0434 10E0      		ldi r17,hi8(flashWriteCycle)
 3632               	.LVL343:
 3633               	.L156:
 3634               	.LBB249:
 413:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3635               		.loc 3 413 0 discriminator 3
 3636 0436 00D0      		rcall usart_read_chars
 3637               	.LVL344:
 414:main.c        **** 				USART_Transmit(SEND_ACK);
 3638               		.loc 3 414 0 discriminator 3
 3639 0438 40E1      		ldi r20,lo8(16)
 3640 043a 50E0      		ldi r21,0
 3641 043c 60E0      		ldi r22,0
 3642 043e 70E0      		ldi r23,0
 3643 0440 80E0      		ldi r24,lo8(receivedBuffer)
 3644 0442 90E0      		ldi r25,hi8(receivedBuffer)
 3645 0444 00D0      		rcall strtol
 3646               	.LVL345:
 3647 0446 D801      		movw r26,r16
 3648 0448 6D93      		st X+,r22
 3649 044a 7C93      		st X,r23
 415:main.c        **** 				
 3650               		.loc 3 415 0 discriminator 3
 3651 044c 81E3      		ldi r24,lo8(49)
 3652 044e 00D0      		rcall USART_Transmit
 3653               	.LVL346:
 417:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3654               		.loc 3 417 0 discriminator 3
 3655 0450 00D0      		rcall usart_read_chars
 3656               	.LVL347:
 418:main.c        **** 				USART_Transmit(SEND_ACK);
 3657               		.loc 3 418 0 discriminator 3
 3658 0452 40E1      		ldi r20,lo8(16)
 3659 0454 50E0      		ldi r21,0
 3660 0456 60E0      		ldi r22,0
 3661 0458 70E0      		ldi r23,0
 3662 045a 80E0      		ldi r24,lo8(receivedBuffer)
 3663 045c 90E0      		ldi r25,hi8(receivedBuffer)
 3664 045e 00D0      		rcall strtol
 3665               	.LVL348:
 3666 0460 F801      		movw r30,r16
 3667 0462 7383      		std Z+3,r23
 3668 0464 6283      		std Z+2,r22
 419:main.c        **** 			}
 3669               		.loc 3 419 0 discriminator 3
 3670 0466 81E3      		ldi r24,lo8(49)
 3671 0468 00D0      		rcall USART_Transmit
 3672               	.LVL349:
 3673 046a 0C5F      		subi r16,-4
 3674 046c 1F4F      		sbci r17,-1
 412:main.c        **** 				usart_read_chars(); // Address
 3675               		.loc 3 412 0 discriminator 3
 3676 046e F0E0      		ldi r31,hi8(flashWriteCycle+12)
 3677 0470 0030      		cpi r16,lo8(flashWriteCycle+12)
 3678 0472 1F07      		cpc r17,r31
 3679 0474 01F4      		brne .L156
 3680 0476 00C0      		rjmp .L106
 3681               	.LVL350:
 3682               	.L155:
 3683               	.LBE249:
 424:main.c        **** 			usart_read_chars(); // Read address
 3684               		.loc 3 424 0
 3685 0478 9634      		cpi r25,lo8(70)
 3686 047a 01F4      		brne .L157
 3687               	.LBB250:
 425:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3688               		.loc 3 425 0
 3689 047c 00D0      		rcall usart_read_chars
 3690               	.LVL351:
 426:main.c        **** 			
 3691               		.loc 3 426 0
 3692 047e 40E1      		ldi r20,lo8(16)
 3693 0480 50E0      		ldi r21,0
 3694 0482 60E0      		ldi r22,0
 3695 0484 70E0      		ldi r23,0
 3696 0486 80E0      		ldi r24,lo8(receivedBuffer)
 3697 0488 90E0      		ldi r25,hi8(receivedBuffer)
 3698 048a 00D0      		rcall strtol
 3699               	.LVL352:
 3700 048c 6B01      		movw r12,r22
 3701 048e 7C01      		movw r14,r24
 3702               	.LVL353:
 428:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3703               		.loc 3 428 0
 3704 0490 00D0      		rcall usart_read_chars
 3705               	.LVL354:
 429:main.c        **** 			
 3706               		.loc 3 429 0
 3707 0492 40E1      		ldi r20,lo8(16)
 3708 0494 50E0      		ldi r21,0
 3709 0496 60E0      		ldi r22,0
 3710 0498 70E0      		ldi r23,0
 3711 049a 80E0      		ldi r24,lo8(receivedBuffer)
 3712 049c 90E0      		ldi r25,hi8(receivedBuffer)
 3713 049e 00D0      		rcall strtol
 3714               	.LVL355:
 431:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3715               		.loc 3 431 0
 3716 04a0 939A      		sbi 0x12,3
 432:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3717               		.loc 3 432 0
 3718 04a2 C601      		movw r24,r12
 3719 04a4 00D0      		rcall gb_flash_write_bus_cycle
 3720               	.LVL356:
 3721 04a6 00C0      		rjmp .L356
 3722               	.LVL357:
 3723               	.L157:
 3724               	.LBE250:
 439:main.c        **** 			usart_read_bytes(64);
 3725               		.loc 3 439 0
 3726 04a8 9435      		cpi r25,lo8(84)
 3727 04aa 01F4      		brne .L158
 440:main.c        **** 			start_timeout_timer();
 3728               		.loc 3 440 0
 3729 04ac 80E4      		ldi r24,lo8(64)
 3730 04ae 90E0      		ldi r25,0
 3731               	.LVL358:
 3732 04b0 00D0      		rcall usart_read_bytes
 3733               	.LVL359:
 441:main.c        **** 			
 3734               		.loc 3 441 0
 3735 04b2 00D0      		rcall start_timeout_timer
 3736               	.LVL360:
 443:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3737               		.loc 3 443 0
 3738 04b4 939A      		sbi 0x12,3
 444:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3739               		.loc 3 444 0
 3740 04b6 8091 0000 		lds r24,flashBank1CommandWrites
 3741 04ba 50E0      		ldi r21,lo8(receivedBuffer)
 3742 04bc E52E      		mov r14,r21
 3743 04be 50E0      		ldi r21,hi8(receivedBuffer)
 3744 04c0 F52E      		mov r15,r21
 3745 04c2 00E0      		ldi r16,0
 3746 04c4 10E0      		ldi r17,0
 3747 04c6 8111      		cpse r24,__zero_reg__
 3748 04c8 00C0      		rjmp .L164
 3749               	.LVL361:
 3750               	.L161:
 3751               	.LBB251:
 446:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3752               		.loc 3 446 0
 3753 04ca D701      		movw r26,r14
 3754 04cc 6D91      		ld r22,X+
 3755 04ce 7D01      		movw r14,r26
 3756 04d0 6F3F      		cpi r22,lo8(-1)
 3757 04d2 01F0      		breq .L160
 447:main.c        **** 					}
 3758               		.loc 3 447 0
 3759 04d4 C801      		movw r24,r16
 3760 04d6 840D      		add r24,r4
 3761 04d8 951D      		adc r25,r5
 3762 04da 00D0      		rcall gb_flash_write_byte
 3763               	.LVL362:
 3764               	.L160:
 3765 04dc 0F5F      		subi r16,-1
 3766 04de 1F4F      		sbci r17,-1
 3767               	.LVL363:
 445:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3768               		.loc 3 445 0 discriminator 2
 3769 04e0 0034      		cpi r16,64
 3770 04e2 1105      		cpc r17,__zero_reg__
 3771 04e4 01F4      		brne .L161
 3772 04e6 20E4      		ldi r18,64
 3773 04e8 420E      		add r4,r18
 3774 04ea 511C      		adc r5,__zero_reg__
 3775 04ec 611C      		adc r6,__zero_reg__
 3776 04ee 711C      		adc r7,__zero_reg__
 3777               	.LVL364:
 3778 04f0 00C0      		rjmp .L348
 3779               	.LVL365:
 3780               	.L164:
 3781               	.LBE251:
 3782               	.LBB252:
 454:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3783               		.loc 3 454 0
 3784 04f2 F701      		movw r30,r14
 3785 04f4 6191      		ld r22,Z+
 3786 04f6 7F01      		movw r14,r30
 3787 04f8 6F3F      		cpi r22,lo8(-1)
 3788 04fa 01F0      		breq .L163
 455:main.c        **** 					}
 3789               		.loc 3 455 0
 3790 04fc C801      		movw r24,r16
 3791 04fe 840D      		add r24,r4
 3792 0500 951D      		adc r25,r5
 3793 0502 00D0      		rcall gb_flash_write_byte_bank1_commands
 3794               	.LVL366:
 3795               	.L163:
 3796 0504 0F5F      		subi r16,-1
 3797 0506 1F4F      		sbci r17,-1
 3798               	.LVL367:
 453:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3799               		.loc 3 453 0 discriminator 2
 3800 0508 0034      		cpi r16,64
 3801 050a 1105      		cpc r17,__zero_reg__
 3802 050c 01F4      		brne .L164
 3803 050e F0E4      		ldi r31,64
 3804 0510 4F0E      		add r4,r31
 3805 0512 511C      		adc r5,__zero_reg__
 3806 0514 611C      		adc r6,__zero_reg__
 3807 0516 711C      		adc r7,__zero_reg__
 3808 0518 00C0      		rjmp .L348
 3809               	.LVL368:
 3810               	.L158:
 3811               	.LBE252:
 465:main.c        **** 			usart_read_bytes(32);
 3812               		.loc 3 465 0
 3813 051a 9935      		cpi r25,lo8(89)
 3814 051c 01F0      		breq .+2
 3815 051e 00C0      		rjmp .L166
 3816               	.LBB253:
 466:main.c        **** 			start_timeout_timer();
 3817               		.loc 3 466 0
 3818 0520 80E2      		ldi r24,lo8(32)
 3819 0522 90E0      		ldi r25,0
 3820               	.LVL369:
 3821 0524 00D0      		rcall usart_read_bytes
 3822               	.LVL370:
 467:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3823               		.loc 3 467 0
 3824 0526 00D0      		rcall start_timeout_timer
 3825               	.LVL371:
 468:main.c        **** 			
 3826               		.loc 3 468 0
 3827 0528 939A      		sbi 0x12,3
 471:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3828               		.loc 3 471 0
 3829 052a 6AEA      		ldi r22,lo8(-86)
 3830 052c 8AEA      		ldi r24,lo8(-86)
 3831 052e 9AE0      		ldi r25,lo8(10)
 3832 0530 00D0      		rcall gb_flash_write_bus_cycle
 3833               	.LVL372:
 472:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3834               		.loc 3 472 0
 3835 0532 65E5      		ldi r22,lo8(85)
 3836 0534 85E5      		ldi r24,lo8(85)
 3837 0536 95E0      		ldi r25,lo8(5)
 3838 0538 00D0      		rcall gb_flash_write_bus_cycle
 3839               	.LVL373:
 473:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3840               		.loc 3 473 0
 3841 053a 7201      		movw r14,r4
 3842 053c 65E2      		ldi r22,lo8(37)
 3843 053e C201      		movw r24,r4
 3844 0540 00D0      		rcall gb_flash_write_bus_cycle
 3845               	.LVL374:
 474:main.c        **** 			_delay_us(1);
 3846               		.loc 3 474 0
 3847 0542 6FE1      		ldi r22,lo8(31)
 3848 0544 C201      		movw r24,r4
 3849 0546 00D0      		rcall gb_flash_write_bus_cycle
 3850               	.LVL375:
 3851               	.LBB254:
 3852               	.LBB255:
 3853               		.loc 2 276 0
 3854 0548 82E0      		ldi r24,lo8(2)
 3855 054a 8A95      	1:	dec r24
 3856 054c 01F4      		brne 1b
 3857 054e 00C0      		rjmp .
 3858               	.LVL376:
 3859 0550 00E0      		ldi r16,lo8(receivedBuffer)
 3860 0552 10E0      		ldi r17,hi8(receivedBuffer)
 3861 0554 C12C      		mov r12,__zero_reg__
 3862 0556 D12C      		mov r13,__zero_reg__
 3863               	.LVL377:
 3864               	.L167:
 3865               	.LBE255:
 3866               	.LBE254:
 3867               	.LBB257:
 479:main.c        **** 				address++;
 3868               		.loc 3 479 0 discriminator 3
 3869 0558 D801      		movw r26,r16
 3870 055a 6D91      		ld r22,X+
 3871 055c 8D01      		movw r16,r26
 3872 055e C701      		movw r24,r14
 3873 0560 8C0D      		add r24,r12
 3874 0562 9D1D      		adc r25,r13
 3875 0564 00D0      		rcall gb_flash_write_bus_cycle
 3876               	.LVL378:
 3877 0566 BFEF      		ldi r27,-1
 3878 0568 CB1A      		sub r12,r27
 3879 056a DB0A      		sbc r13,r27
 3880               	.LVL379:
 478:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3881               		.loc 3 478 0 discriminator 3
 3882 056c E0E2      		ldi r30,32
 3883 056e CE16      		cp r12,r30
 3884 0570 D104      		cpc r13,__zero_reg__
 3885 0572 01F4      		brne .L167
 3886 0574 F0E2      		ldi r31,32
 3887 0576 4F0E      		add r4,r31
 3888 0578 511C      		adc r5,__zero_reg__
 3889 057a 611C      		adc r6,__zero_reg__
 3890 057c 711C      		adc r7,__zero_reg__
 3891               	.LBE257:
 484:main.c        **** 			_delay_us(200);
 3892               		.loc 3 484 0
 3893 057e C201      		movw r24,r4
 3894 0580 8097      		sbiw r24,32
 3895 0582 69E2      		ldi r22,lo8(41)
 3896 0584 00D0      		rcall gb_flash_write_bus_cycle
 3897               	.LVL380:
 3898               	.LBB258:
 3899               	.LBB259:
 3900               		.loc 2 276 0
 3901 0586 8FE8      		ldi r24,lo8(399)
 3902 0588 91E0      		ldi r25,hi8(399)
 3903 058a 0197      	1:	sbiw r24,1
 3904 058c 01F4      		brne 1b
 3905 058e 00C0      		rjmp .
 3906 0590 0000      		nop
 3907               	.LVL381:
 3908               	.LBE259:
 3909               	.LBE258:
 488:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3910               		.loc 3 488 0
 3911 0592 8201      		movw r16,r4
 3912 0594 0150      		subi r16,1
 3913 0596 1109      		sbc r17,__zero_reg__
 3914 0598 C801      		movw r24,r16
 3915 059a 00D0      		rcall gb_flash_read_byte
 3916               	.LVL382:
 3917               	.L168:
 489:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3918               		.loc 3 489 0
 3919 059c 9091 0000 		lds r25,receivedBuffer+31
 3920 05a0 8917      		cp r24,r25
 3921 05a2 01F4      		brne .+2
 3922 05a4 00C0      		rjmp .L348
 490:main.c        **** 				_delay_us(5);
 3923               		.loc 3 490 0
 3924 05a6 C801      		movw r24,r16
 3925               	.LVL383:
 3926 05a8 00D0      		rcall gb_flash_read_byte
 3927               	.LVL384:
 3928               	.LBB260:
 3929               	.LBB261:
 3930               		.loc 2 276 0
 3931 05aa 9DE0      		ldi r25,lo8(13)
 3932 05ac 9A95      	1:	dec r25
 3933 05ae 01F4      		brne 1b
 3934 05b0 0000      		nop
 3935               	.LVL385:
 3936               	.LBE261:
 3937               	.LBE260:
 492:main.c        **** 					break;
 3938               		.loc 3 492 0
 3939 05b2 9091 0000 		lds r25,writingTimedout
 3940 05b6 9130      		cpi r25,lo8(1)
 3941 05b8 01F4      		brne .L168
 3942 05ba 00C0      		rjmp .L348
 3943               	.LVL386:
 3944               	.L166:
 3945               	.LBE253:
 501:main.c        **** 			usart_read_bytes(256);
 3946               		.loc 3 501 0
 3947 05bc 9535      		cpi r25,lo8(85)
 3948 05be 01F0      		breq .+2
 3949 05c0 00C0      		rjmp .L171
 3950               	.LBB263:
 502:main.c        **** 			start_timeout_timer();
 3951               		.loc 3 502 0
 3952 05c2 80E0      		ldi r24,0
 3953 05c4 91E0      		ldi r25,lo8(1)
 3954               	.LVL387:
 3955 05c6 00D0      		rcall usart_read_bytes
 3956               	.LVL388:
 503:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3957               		.loc 3 503 0
 3958 05c8 00D0      		rcall start_timeout_timer
 3959               	.LVL389:
 504:main.c        **** 			
 3960               		.loc 3 504 0
 3961 05ca 939A      		sbi 0x12,3
 3962               	.LVL390:
 3963 05cc 30E0      		ldi r19,lo8(receivedBuffer)
 3964 05ce E32E      		mov r14,r19
 3965 05d0 30E0      		ldi r19,hi8(receivedBuffer)
 3966 05d2 F32E      		mov r15,r19
 3967 05d4 48E0      		ldi r20,lo8(8)
 3968 05d6 842E      		mov r8,r20
 3969               	.LVL391:
 3970               	.L172:
 3971 05d8 FE01      		movw r30,r28
 3972 05da 3196      		adiw r30,1
 3973 05dc 6F01      		movw r12,r30
 3974               	.LBE263:
 3975               	.LBB274:
 3976               	.LBB262:
 3977               	.LBB256:
 3978               		.loc 2 276 0
 3979 05de D701      		movw r26,r14
 3980               	.LVL392:
 3981               	.L173:
 3982               	.LBE256:
 3983               	.LBE262:
 3984               	.LBE274:
 3985               	.LBB275:
 3986               	.LBB264:
 3987               	.LBB265:
 3988               	.LBB266:
 511:main.c        **** 					byteCounter++;
 3989               		.loc 3 511 0 discriminator 3
 3990 05e0 8D91      		ld r24,X+
 3991               	.LVL393:
 3992 05e2 8193      		st Z+,r24
 3993               	.LVL394:
 510:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 3994               		.loc 3 510 0 discriminator 3
 3995 05e4 E215      		cp r30,r2
 3996 05e6 F305      		cpc r31,r3
 3997 05e8 01F4      		brne .L173
 3998               	.LBE266:
 516:main.c        **** 				gb_flash_write_bus_cycle(0x555, 0x55);
 3999               		.loc 3 516 0
 4000 05ea 6AEA      		ldi r22,lo8(-86)
 4001 05ec 8AEA      		ldi r24,lo8(-86)
 4002 05ee 9AE0      		ldi r25,lo8(10)
 4003 05f0 00D0      		rcall gb_flash_write_bus_cycle
 4004               	.LVL395:
 517:main.c        **** 				gb_flash_write_bus_cycle(address, 0x25);
 4005               		.loc 3 517 0
 4006 05f2 65E5      		ldi r22,lo8(85)
 4007 05f4 85E5      		ldi r24,lo8(85)
 4008 05f6 95E0      		ldi r25,lo8(5)
 4009 05f8 00D0      		rcall gb_flash_write_bus_cycle
 4010               	.LVL396:
 518:main.c        **** 				gb_flash_write_bus_cycle(address, 0x1F); // Length
 4011               		.loc 3 518 0
 4012 05fa 5201      		movw r10,r4
 4013 05fc 65E2      		ldi r22,lo8(37)
 4014 05fe C201      		movw r24,r4
 4015 0600 00D0      		rcall gb_flash_write_bus_cycle
 4016               	.LVL397:
 519:main.c        **** 				_delay_us(1);
 4017               		.loc 3 519 0
 4018 0602 6FE1      		ldi r22,lo8(31)
 4019 0604 C201      		movw r24,r4
 4020 0606 00D0      		rcall gb_flash_write_bus_cycle
 4021               	.LVL398:
 4022               	.LBB267:
 4023               	.LBB268:
 4024               		.loc 2 276 0
 4025 0608 A2E0      		ldi r26,lo8(2)
 4026 060a AA95      	1:	dec r26
 4027 060c 01F4      		brne 1b
 4028 060e 00C0      		rjmp .
 4029               	.LVL399:
 4030 0610 00E0      		ldi r16,0
 4031 0612 10E0      		ldi r17,0
 4032               	.LVL400:
 4033               	.L174:
 4034               	.LBE268:
 4035               	.LBE267:
 4036               	.LBB269:
 524:main.c        **** 					address++;
 4037               		.loc 3 524 0 discriminator 3
 4038 0614 F601      		movw r30,r12
 4039 0616 6191      		ld r22,Z+
 4040 0618 6F01      		movw r12,r30
 4041 061a C501      		movw r24,r10
 4042 061c 800F      		add r24,r16
 4043 061e 911F      		adc r25,r17
 4044 0620 00D0      		rcall gb_flash_write_bus_cycle
 4045               	.LVL401:
 4046 0622 0F5F      		subi r16,-1
 4047 0624 1F4F      		sbci r17,-1
 4048               	.LVL402:
 523:main.c        **** 					gb_flash_write_bus_cycle(address, localBuffer[x]);
 4049               		.loc 3 523 0 discriminator 3
 4050 0626 0032      		cpi r16,32
 4051 0628 1105      		cpc r17,__zero_reg__
 4052 062a 01F4      		brne .L174
 4053 062c F0E2      		ldi r31,32
 4054 062e 4F0E      		add r4,r31
 4055 0630 511C      		adc r5,__zero_reg__
 4056 0632 611C      		adc r6,__zero_reg__
 4057 0634 711C      		adc r7,__zero_reg__
 4058               	.LBE269:
 529:main.c        **** 				_delay_us(200);
 4059               		.loc 3 529 0
 4060 0636 C201      		movw r24,r4
 4061 0638 8097      		sbiw r24,32
 4062 063a 69E2      		ldi r22,lo8(41)
 4063 063c 00D0      		rcall gb_flash_write_bus_cycle
 4064               	.LVL403:
 4065               	.LBB270:
 4066               	.LBB271:
 4067               		.loc 2 276 0
 4068 063e 8FE8      		ldi r24,lo8(399)
 4069 0640 91E0      		ldi r25,hi8(399)
 4070 0642 0197      	1:	sbiw r24,1
 4071 0644 01F4      		brne 1b
 4072 0646 00C0      		rjmp .
 4073 0648 0000      		nop
 4074               	.LVL404:
 4075 064a 8201      		movw r16,r4
 4076               	.LVL405:
 4077 064c 0150      		subi r16,1
 4078 064e 1109      		sbc r17,__zero_reg__
 4079               	.LBE271:
 4080               	.LBE270:
 533:main.c        **** 				while (dataVerify != localBuffer[31]) {
 4081               		.loc 3 533 0
 4082 0650 C801      		movw r24,r16
 4083 0652 00D0      		rcall gb_flash_read_byte
 4084               	.LVL406:
 4085               	.L175:
 534:main.c        **** 					dataVerify = gb_flash_read_byte(address-1);
 4086               		.loc 3 534 0
 4087 0654 98A1      		ldd r25,Y+32
 4088 0656 8917      		cp r24,r25
 4089 0658 01F0      		breq .L179
 535:main.c        **** 					_delay_us(5);
 4090               		.loc 3 535 0
 4091 065a C801      		movw r24,r16
 4092               	.LVL407:
 4093 065c 00D0      		rcall gb_flash_read_byte
 4094               	.LVL408:
 4095               	.LBB272:
 4096               	.LBB273:
 4097               		.loc 2 276 0
 4098 065e 9DE0      		ldi r25,lo8(13)
 4099 0660 9A95      	1:	dec r25
 4100 0662 01F4      		brne 1b
 4101 0664 0000      		nop
 4102               	.LVL409:
 4103               	.LBE273:
 4104               	.LBE272:
 537:main.c        **** 						break;
 4105               		.loc 3 537 0
 4106 0666 9091 0000 		lds r25,writingTimedout
 4107 066a 9130      		cpi r25,lo8(1)
 4108 066c 01F4      		brne .L175
 4109               	.L179:
 541:main.c        **** 					break;
 4110               		.loc 3 541 0
 4111 066e 8091 0000 		lds r24,writingTimedout
 4112               	.LVL410:
 4113 0672 8130      		cpi r24,lo8(1)
 4114 0674 01F4      		brne .+2
 4115 0676 00C0      		rjmp .L348
 4116               	.LVL411:
 4117 0678 8A94      		dec r8
 4118               	.LVL412:
 4119 067a A0E2      		ldi r26,32
 4120 067c EA0E      		add r14,r26
 4121 067e F11C      		adc r15,__zero_reg__
 4122               	.LVL413:
 4123               	.LBE265:
 507:main.c        **** 				// Store to local buffer
 4124               		.loc 3 507 0
 4125 0680 8110      		cpse r8,__zero_reg__
 4126 0682 00C0      		rjmp .L172
 4127 0684 00C0      		rjmp .L348
 4128               	.LVL414:
 4129               	.L171:
 4130               	.LBE264:
 4131               	.LBE275:
 550:main.c        **** 			usart_read_bytes(64);
 4132               		.loc 3 550 0
 4133 0686 9A34      		cpi r25,lo8(74)
 4134 0688 01F4      		brne .L181
 551:main.c        **** 			start_timeout_timer();
 4135               		.loc 3 551 0
 4136 068a 80E4      		ldi r24,lo8(64)
 4137 068c 90E0      		ldi r25,0
 4138               	.LVL415:
 4139 068e 00D0      		rcall usart_read_bytes
 4140               	.LVL416:
 552:main.c        **** 			
 4141               		.loc 3 552 0
 4142 0690 00D0      		rcall start_timeout_timer
 4143               	.LVL417:
 554:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 4144               		.loc 3 554 0
 4145 0692 939A      		sbi 0x12,3
 4146               	.LVL418:
 4147 0694 20E0      		ldi r18,lo8(receivedBuffer)
 4148 0696 E22E      		mov r14,r18
 4149 0698 20E0      		ldi r18,hi8(receivedBuffer)
 4150 069a F22E      		mov r15,r18
 4151 069c 00E0      		ldi r16,0
 4152 069e 10E0      		ldi r17,0
 4153               	.LVL419:
 4154               	.L183:
 4155               	.LBB276:
 556:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 4156               		.loc 3 556 0
 4157 06a0 D701      		movw r26,r14
 4158 06a2 6D91      		ld r22,X+
 4159 06a4 7D01      		movw r14,r26
 4160 06a6 6F3F      		cpi r22,lo8(-1)
 4161 06a8 01F0      		breq .L182
 557:main.c        **** 				}
 4162               		.loc 3 557 0
 4163 06aa C801      		movw r24,r16
 4164 06ac 840D      		add r24,r4
 4165 06ae 951D      		adc r25,r5
 4166 06b0 00D0      		rcall gb_flash_write_byte_special
 4167               	.LVL420:
 4168               	.L182:
 4169 06b2 0F5F      		subi r16,-1
 4170 06b4 1F4F      		sbci r17,-1
 4171               	.LVL421:
 555:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 4172               		.loc 3 555 0 discriminator 2
 4173 06b6 0034      		cpi r16,64
 4174 06b8 1105      		cpc r17,__zero_reg__
 4175 06ba 01F4      		brne .L183
 4176 06bc B0E4      		ldi r27,64
 4177 06be 4B0E      		add r4,r27
 4178 06c0 511C      		adc r5,__zero_reg__
 4179 06c2 611C      		adc r6,__zero_reg__
 4180 06c4 711C      		adc r7,__zero_reg__
 4181 06c6 00C0      		rjmp .L348
 4182               	.LVL422:
 4183               	.L181:
 4184               	.LBE276:
 566:main.c        **** 			usart_read_bytes(256);
 4185               		.loc 3 566 0
 4186 06c8 9835      		cpi r25,lo8(88)
 4187 06ca 01F0      		breq .+2
 4188 06cc 00C0      		rjmp .L184
 4189               	.LBB277:
 567:main.c        **** 			start_timeout_timer();
 4190               		.loc 3 567 0
 4191 06ce 80E0      		ldi r24,0
 4192 06d0 91E0      		ldi r25,lo8(1)
 4193               	.LVL423:
 4194 06d2 00D0      		rcall usart_read_bytes
 4195               	.LVL424:
 568:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4196               		.loc 3 568 0
 4197 06d4 00D0      		rcall start_timeout_timer
 4198               	.LVL425:
 569:main.c        **** 			
 4199               		.loc 3 569 0
 4200 06d6 939A      		sbi 0x12,3
 572:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 4201               		.loc 3 572 0
 4202 06d8 69EA      		ldi r22,lo8(-87)
 4203 06da 8AEA      		ldi r24,lo8(-86)
 4204 06dc 9AE0      		ldi r25,lo8(10)
 4205 06de 00D0      		rcall gb_flash_write_bus_cycle
 4206               	.LVL426:
 573:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 4207               		.loc 3 573 0
 4208 06e0 66E5      		ldi r22,lo8(86)
 4209 06e2 85E5      		ldi r24,lo8(85)
 4210 06e4 95E0      		ldi r25,lo8(5)
 4211 06e6 00D0      		rcall gb_flash_write_bus_cycle
 4212               	.LVL427:
 574:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 4213               		.loc 3 574 0
 4214 06e8 7201      		movw r14,r4
 4215 06ea 66E2      		ldi r22,lo8(38)
 4216 06ec C201      		movw r24,r4
 4217 06ee 00D0      		rcall gb_flash_write_bus_cycle
 4218               	.LVL428:
 575:main.c        **** 			_delay_us(50);
 4219               		.loc 3 575 0
 4220 06f0 6FEF      		ldi r22,lo8(-1)
 4221 06f2 C201      		movw r24,r4
 4222 06f4 00D0      		rcall gb_flash_write_bus_cycle
 4223               	.LVL429:
 4224               	.LBB278:
 4225               	.LBB279:
 4226               		.loc 2 276 0
 4227 06f6 E5E8      		ldi r30,lo8(-123)
 4228 06f8 EA95      	1:	dec r30
 4229 06fa 01F4      		brne 1b
 4230 06fc 0000      		nop
 4231               	.LVL430:
 4232 06fe 00E0      		ldi r16,lo8(receivedBuffer)
 4233 0700 10E0      		ldi r17,hi8(receivedBuffer)
 4234               	.LBE279:
 4235               	.LBE278:
 4236               	.LBB280:
 579:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4237               		.loc 3 579 0
 4238 0702 C12C      		mov r12,__zero_reg__
 4239 0704 D12C      		mov r13,__zero_reg__
 4240               	.LVL431:
 4241               	.L185:
 580:main.c        **** 				address++;
 4242               		.loc 3 580 0 discriminator 3
 4243 0706 D801      		movw r26,r16
 4244 0708 6D91      		ld r22,X+
 4245 070a 8D01      		movw r16,r26
 4246 070c C601      		movw r24,r12
 4247 070e 8E0D      		add r24,r14
 4248 0710 9F1D      		adc r25,r15
 4249 0712 00D0      		rcall gb_flash_write_bus_cycle
 4250               	.LVL432:
 579:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4251               		.loc 3 579 0 discriminator 3
 4252 0714 BFEF      		ldi r27,-1
 4253 0716 CB1A      		sub r12,r27
 4254 0718 DB0A      		sbc r13,r27
 4255               	.LVL433:
 4256 071a C114      		cp r12,__zero_reg__
 4257 071c E1E0      		ldi r30,1
 4258 071e DE06      		cpc r13,r30
 4259 0720 01F4      		brne .L185
 4260 0722 FFEF      		ldi r31,-1
 4261 0724 5F1A      		sub r5,r31
 4262 0726 6F0A      		sbc r6,r31
 4263 0728 7F0A      		sbc r7,r31
 4264               	.LBE280:
 585:main.c        **** 			
 4265               		.loc 3 585 0
 4266 072a C201      		movw r24,r4
 4267 072c 9A95      		dec r25
 4268 072e 6AE2      		ldi r22,lo8(42)
 4269 0730 00D0      		rcall gb_flash_write_bus_cycle
 4270               	.LVL434:
 588:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 4271               		.loc 3 588 0
 4272 0732 8201      		movw r16,r4
 4273 0734 0150      		subi r16,1
 4274 0736 1109      		sbc r17,__zero_reg__
 4275 0738 C801      		movw r24,r16
 4276 073a 00D0      		rcall gb_flash_read_byte
 4277               	.LVL435:
 4278               	.L186:
 589:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 4279               		.loc 3 589 0
 4280 073c 9091 0000 		lds r25,receivedBuffer+255
 4281 0740 8917      		cp r24,r25
 4282 0742 01F4      		brne .+2
 4283 0744 00C0      		rjmp .L348
 590:main.c        **** 				_delay_us(5);
 4284               		.loc 3 590 0
 4285 0746 C801      		movw r24,r16
 4286               	.LVL436:
 4287 0748 00D0      		rcall gb_flash_read_byte
 4288               	.LVL437:
 4289               	.LBB281:
 4290               	.LBB282:
 4291               		.loc 2 276 0
 4292 074a 2DE0      		ldi r18,lo8(13)
 4293 074c 2A95      	1:	dec r18
 4294 074e 01F4      		brne 1b
 4295 0750 0000      		nop
 4296               	.LVL438:
 4297               	.LBE282:
 4298               	.LBE281:
 592:main.c        **** 					break;
 4299               		.loc 3 592 0
 4300 0752 9091 0000 		lds r25,writingTimedout
 4301 0756 9130      		cpi r25,lo8(1)
 4302 0758 01F4      		brne .L186
 4303 075a 00C0      		rjmp .L348
 4304               	.LVL439:
 4305               	.L184:
 4306               	.LBE277:
 601:main.c        **** 			usart_read_bytes(128);
 4307               		.loc 3 601 0
 4308 075c 9A37      		cpi r25,lo8(122)
 4309 075e 01F0      		breq .+2
 4310 0760 00C0      		rjmp .L189
 602:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4311               		.loc 3 602 0
 4312 0762 80E8      		ldi r24,lo8(-128)
 4313 0764 90E0      		ldi r25,0
 4314               	.LVL440:
 4315 0766 00D0      		rcall usart_read_bytes
 4316               	.LVL441:
 603:main.c        **** 			
 4317               		.loc 3 603 0
 4318 0768 939A      		sbi 0x12,3
 606:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 4319               		.loc 3 606 0
 4320 076a 69E0      		ldi r22,lo8(9)
 4321 076c 80E2      		ldi r24,lo8(32)
 4322 076e 91E0      		ldi r25,lo8(1)
 4323 0770 00D0      		rcall gb_flash_write_bus_cycle
 4324               	.LVL442:
 607:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 4325               		.loc 3 607 0
 4326 0772 6AEA      		ldi r22,lo8(-86)
 4327 0774 81E2      		ldi r24,lo8(33)
 4328 0776 91E0      		ldi r25,lo8(1)
 4329 0778 00D0      		rcall gb_flash_write_bus_cycle
 4330               	.LVL443:
 608:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4331               		.loc 3 608 0
 4332 077a 65E5      		ldi r22,lo8(85)
 4333 077c 82E2      		ldi r24,lo8(34)
 4334 077e 91E0      		ldi r25,lo8(1)
 4335 0780 00D0      		rcall gb_flash_write_bus_cycle
 4336               	.LVL444:
 609:main.c        **** 			_delay_us(5);
 4337               		.loc 3 609 0
 4338 0782 65EA      		ldi r22,lo8(-91)
 4339 0784 8FE3      		ldi r24,lo8(63)
 4340 0786 91E0      		ldi r25,lo8(1)
 4341 0788 00D0      		rcall gb_flash_write_bus_cycle
 4342               	.LVL445:
 4343               	.LBB283:
 4344               	.LBB284:
 4345               		.loc 2 276 0
 4346 078a 8DE0      		ldi r24,lo8(13)
 4347 078c 8A95      	1:	dec r24
 4348 078e 01F4      		brne 1b
 4349 0790 0000      		nop
 4350               	.LVL446:
 4351               	.LBE284:
 4352               	.LBE283:
 613:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4353               		.loc 3 613 0
 4354 0792 61E1      		ldi r22,lo8(17)
 4355 0794 80E2      		ldi r24,lo8(32)
 4356 0796 91E0      		ldi r25,lo8(1)
 4357 0798 00D0      		rcall gb_flash_write_bus_cycle
 4358               	.LVL447:
 614:main.c        **** 			_delay_us(5);
 4359               		.loc 3 614 0
 4360 079a 65EA      		ldi r22,lo8(-91)
 4361 079c 8FE3      		ldi r24,lo8(63)
 4362 079e 91E0      		ldi r25,lo8(1)
 4363 07a0 00D0      		rcall gb_flash_write_bus_cycle
 4364               	.LVL448:
 4365               	.LBB285:
 4366               	.LBB286:
 4367               		.loc 2 276 0
 4368 07a2 9DE0      		ldi r25,lo8(13)
 4369 07a4 9A95      	1:	dec r25
 4370 07a6 01F4      		brne 1b
 4371 07a8 0000      		nop
 4372               	.LVL449:
 4373               	.LBE286:
 4374               	.LBE285:
 618:main.c        **** 			_delay_us(5);
 4375               		.loc 3 618 0
 4376 07aa 61E0      		ldi r22,lo8(1)
 4377 07ac 80E0      		ldi r24,0
 4378 07ae 91E2      		ldi r25,lo8(33)
 4379 07b0 00D0      		rcall gb_flash_write_bus_cycle
 4380               	.LVL450:
 4381               	.LBB287:
 4382               	.LBB288:
 4383               		.loc 2 276 0
 4384 07b2 ADE0      		ldi r26,lo8(13)
 4385 07b4 AA95      	1:	dec r26
 4386 07b6 01F4      		brne 1b
 4387 07b8 0000      		nop
 4388               	.LVL451:
 4389               	.LBE288:
 4390               	.LBE287:
 623:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 4391               		.loc 3 623 0
 4392 07ba 6FE0      		ldi r22,lo8(15)
 4393 07bc 80E2      		ldi r24,lo8(32)
 4394 07be 91E0      		ldi r25,lo8(1)
 4395 07c0 00D0      		rcall gb_flash_write_bus_cycle
 4396               	.LVL452:
 624:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 4397               		.loc 3 624 0
 4398 07c2 65E5      		ldi r22,lo8(85)
 4399 07c4 85E2      		ldi r24,lo8(37)
 4400 07c6 91E0      		ldi r25,lo8(1)
 4401 07c8 00D0      		rcall gb_flash_write_bus_cycle
 4402               	.LVL453:
 625:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 4403               		.loc 3 625 0
 4404 07ca 65E5      		ldi r22,lo8(85)
 4405 07cc 86E2      		ldi r24,lo8(38)
 4406 07ce 91E0      		ldi r25,lo8(1)
 4407 07d0 00D0      		rcall gb_flash_write_bus_cycle
 4408               	.LVL454:
 626:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4409               		.loc 3 626 0
 4410 07d2 6AEA      		ldi r22,lo8(-86)
 4411 07d4 87E2      		ldi r24,lo8(39)
 4412 07d6 91E0      		ldi r25,lo8(1)
 4413 07d8 00D0      		rcall gb_flash_write_bus_cycle
 4414               	.LVL455:
 627:main.c        **** 			_delay_us(5);
 4415               		.loc 3 627 0
 4416 07da 65EA      		ldi r22,lo8(-91)
 4417 07dc 8FE3      		ldi r24,lo8(63)
 4418 07de 91E0      		ldi r25,lo8(1)
 4419 07e0 00D0      		rcall gb_flash_write_bus_cycle
 4420               	.LVL456:
 4421               	.LBB289:
 4422               	.LBB290:
 4423               		.loc 2 276 0
 4424 07e2 BDE0      		ldi r27,lo8(13)
 4425 07e4 BA95      	1:	dec r27
 4426 07e6 01F4      		brne 1b
 4427 07e8 0000      		nop
 4428               	.LVL457:
 4429               	.LBE290:
 4430               	.LBE289:
 630:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 4431               		.loc 3 630 0
 4432 07ea 6FE0      		ldi r22,lo8(15)
 4433 07ec 80E2      		ldi r24,lo8(32)
 4434 07ee 91E0      		ldi r25,lo8(1)
 4435 07f0 00D0      		rcall gb_flash_write_bus_cycle
 4436               	.LVL458:
 631:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 4437               		.loc 3 631 0
 4438 07f2 6AE2      		ldi r22,lo8(42)
 4439 07f4 85E2      		ldi r24,lo8(37)
 4440 07f6 91E0      		ldi r25,lo8(1)
 4441 07f8 00D0      		rcall gb_flash_write_bus_cycle
 4442               	.LVL459:
 632:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 4443               		.loc 3 632 0
 4444 07fa 6AEA      		ldi r22,lo8(-86)
 4445 07fc 86E2      		ldi r24,lo8(38)
 4446 07fe 91E0      		ldi r25,lo8(1)
 4447 0800 00D0      		rcall gb_flash_write_bus_cycle
 4448               	.LVL460:
 633:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4449               		.loc 3 633 0
 4450 0802 65E5      		ldi r22,lo8(85)
 4451 0804 87E2      		ldi r24,lo8(39)
 4452 0806 91E0      		ldi r25,lo8(1)
 4453 0808 00D0      		rcall gb_flash_write_bus_cycle
 4454               	.LVL461:
 634:main.c        **** 			_delay_us(5);
 4455               		.loc 3 634 0
 4456 080a 65EA      		ldi r22,lo8(-91)
 4457 080c 8FE3      		ldi r24,lo8(63)
 4458 080e 91E0      		ldi r25,lo8(1)
 4459 0810 00D0      		rcall gb_flash_write_bus_cycle
 4460               	.LVL462:
 4461               	.LBB291:
 4462               	.LBB292:
 4463               		.loc 2 276 0
 4464 0812 EDE0      		ldi r30,lo8(13)
 4465 0814 EA95      	1:	dec r30
 4466 0816 01F4      		brne 1b
 4467 0818 0000      		nop
 4468               	.LVL463:
 4469               	.LBE292:
 4470               	.LBE291:
 637:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 4471               		.loc 3 637 0
 4472 081a 6FE0      		ldi r22,lo8(15)
 4473 081c 80E2      		ldi r24,lo8(32)
 4474 081e 91E0      		ldi r25,lo8(1)
 4475 0820 00D0      		rcall gb_flash_write_bus_cycle
 4476               	.LVL464:
 638:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 4477               		.loc 3 638 0
 4478 0822 65E5      		ldi r22,lo8(85)
 4479 0824 85E2      		ldi r24,lo8(37)
 4480 0826 91E0      		ldi r25,lo8(1)
 4481 0828 00D0      		rcall gb_flash_write_bus_cycle
 4482               	.LVL465:
 639:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 4483               		.loc 3 639 0
 4484 082a 65E5      		ldi r22,lo8(85)
 4485 082c 86E2      		ldi r24,lo8(38)
 4486 082e 91E0      		ldi r25,lo8(1)
 4487 0830 00D0      		rcall gb_flash_write_bus_cycle
 4488               	.LVL466:
 640:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 4489               		.loc 3 640 0
 4490 0832 60EA      		ldi r22,lo8(-96)
 4491 0834 87E2      		ldi r24,lo8(39)
 4492 0836 91E0      		ldi r25,lo8(1)
 4493 0838 00D0      		rcall gb_flash_write_bus_cycle
 4494               	.LVL467:
 641:main.c        **** 			_delay_us(5);
 4495               		.loc 3 641 0
 4496 083a 65EA      		ldi r22,lo8(-91)
 4497 083c 8FE3      		ldi r24,lo8(63)
 4498 083e 91E0      		ldi r25,lo8(1)
 4499 0840 00D0      		rcall gb_flash_write_bus_cycle
 4500               	.LVL468:
 4501               	.LBB293:
 4502               	.LBB294:
 4503               		.loc 2 276 0
 4504 0842 FDE0      		ldi r31,lo8(13)
 4505 0844 FA95      	1:	dec r31
 4506 0846 01F4      		brne 1b
 4507 0848 0000      		nop
 4508               	.LVL469:
 4509               	.LBE294:
 4510               	.LBE293:
 645:main.c        **** 			_delay_us(5);
 4511               		.loc 3 645 0
 4512 084a 40E0      		ldi r20,0
 4513 084c 6091 0000 		lds r22,lastBankAccessed
 4514 0850 80E0      		ldi r24,0
 4515 0852 91E2      		ldi r25,lo8(33)
 4516 0854 00D0      		rcall write_8bit_data
 4517               	.LVL470:
 4518               	.LBB295:
 4519               	.LBB296:
 4520               		.loc 2 276 0
 4521 0856 2DE0      		ldi r18,lo8(13)
 4522 0858 2A95      	1:	dec r18
 4523 085a 01F4      		brne 1b
 4524 085c 0000      		nop
 4525               	.LVL471:
 4526               	.LBE296:
 4527               	.LBE295:
 649:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4528               		.loc 3 649 0
 4529 085e 60E1      		ldi r22,lo8(16)
 4530 0860 80E2      		ldi r24,lo8(32)
 4531 0862 91E0      		ldi r25,lo8(1)
 4532 0864 00D0      		rcall gb_flash_write_bus_cycle
 4533               	.LVL472:
 650:main.c        **** 			_delay_us(5);
 4534               		.loc 3 650 0
 4535 0866 65EA      		ldi r22,lo8(-91)
 4536 0868 8FE3      		ldi r24,lo8(63)
 4537 086a 91E0      		ldi r25,lo8(1)
 4538 086c 00D0      		rcall gb_flash_write_bus_cycle
 4539               	.LVL473:
 4540               	.LBB297:
 4541               	.LBB298:
 4542               		.loc 2 276 0
 4543 086e 8DE0      		ldi r24,lo8(13)
 4544 0870 8A95      	1:	dec r24
 4545 0872 01F4      		brne 1b
 4546 0874 0000      		nop
 4547               	.LVL474:
 4548               	.LBE298:
 4549               	.LBE297:
 654:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 4550               		.loc 3 654 0
 4551 0876 68E0      		ldi r22,lo8(8)
 4552 0878 80E2      		ldi r24,lo8(32)
 4553 087a 91E0      		ldi r25,lo8(1)
 4554 087c 00D0      		rcall gb_flash_write_bus_cycle
 4555               	.LVL475:
 655:main.c        **** 			_delay_us(5);
 4556               		.loc 3 655 0
 4557 087e 65EA      		ldi r22,lo8(-91)
 4558 0880 8FE3      		ldi r24,lo8(63)
 4559 0882 91E0      		ldi r25,lo8(1)
 4560 0884 00D0      		rcall gb_flash_write_bus_cycle
 4561               	.LVL476:
 4562               	.LBB299:
 4563               	.LBB300:
 4564               		.loc 2 276 0
 4565 0886 9DE0      		ldi r25,lo8(13)
 4566 0888 9A95      	1:	dec r25
 4567 088a 01F4      		brne 1b
 4568 088c 0000      		nop
 4569               	.LVL477:
 4570 088e 00E0      		ldi r16,lo8(receivedBuffer)
 4571 0890 10E0      		ldi r17,hi8(receivedBuffer)
 4572               	.L190:
 4573               	.LBE300:
 4574               	.LBE299:
 4575               	.LBB301:
 660:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4576               		.loc 3 660 0 discriminator 1
 4577 0892 80E0      		ldi r24,lo8(receivedBuffer+128)
 4578 0894 90E0      		ldi r25,hi8(receivedBuffer+128)
 4579 0896 8017      		cp r24,r16
 4580 0898 9107      		cpc r25,r17
 4581 089a 01F0      		breq .L358
 661:main.c        **** 				_delay_us(5);
 4582               		.loc 3 661 0 discriminator 3
 4583 089c D801      		movw r26,r16
 4584 089e 6D91      		ld r22,X+
 4585 08a0 8D01      		movw r16,r26
 4586 08a2 C201      		movw r24,r4
 4587 08a4 00D0      		rcall gb_flash_write_bus_cycle
 4588               	.LVL478:
 4589               	.LBB302:
 4590               	.LBB303:
 4591               		.loc 2 276 0 discriminator 3
 4592 08a6 BDE0      		ldi r27,lo8(13)
 4593 08a8 BA95      	1:	dec r27
 4594 08aa 01F4      		brne 1b
 4595 08ac 0000      		nop
 4596               	.LVL479:
 4597               	.LBE303:
 4598               	.LBE302:
 663:main.c        **** 			}
 4599               		.loc 3 663 0 discriminator 3
 4600 08ae EFEF      		ldi r30,-1
 4601 08b0 4E1A      		sub r4,r30
 4602 08b2 5E0A      		sbc r5,r30
 4603 08b4 6E0A      		sbc r6,r30
 4604 08b6 7E0A      		sbc r7,r30
 4605               	.LVL480:
 4606 08b8 00C0      		rjmp .L190
 4607               	.L358:
 4608               	.LVL481:
 4609               	.LBE301:
 668:main.c        **** 			address++;
 4610               		.loc 3 668 0
 4611 08ba 6FEF      		ldi r22,lo8(-1)
 4612 08bc D301      		movw r26,r6
 4613 08be C201      		movw r24,r4
 4614 08c0 0197      		sbiw r24,1
 4615 08c2 A109      		sbc r26,__zero_reg__
 4616 08c4 B109      		sbc r27,__zero_reg__
 4617               	.LVL482:
 4618 08c6 00D0      		rcall gb_flash_write_bus_cycle
 4619               	.LVL483:
 4620               	.LBB304:
 4621               	.LBB305:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 4622               		.loc 2 187 0
 4623 08c8 AFE1      		ldi r26,lo8(19999)
 4624 08ca BEE4      		ldi r27,hi8(19999)
 4625 08cc 1197      	1:	sbiw r26,1
 4626 08ce 01F4      		brne 1b
 4627 08d0 00C0      		rjmp .
 4628 08d2 0000      		nop
 4629               	.LVL484:
 4630               	.LBE305:
 4631               	.LBE304:
 672:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 4632               		.loc 3 672 0
 4633 08d4 81E3      		ldi r24,lo8(49)
 4634 08d6 00D0      		rcall USART_Transmit
 4635               	.LVL485:
 4636 08d8 00C0      		rjmp .L346
 4637               	.LVL486:
 4638               	.L189:
 678:main.c        **** 			usart_read_bytes(32);
 4639               		.loc 3 678 0
 4640 08da 9937      		cpi r25,lo8(121)
 4641 08dc 01F0      		breq .+2
 4642 08de 00C0      		rjmp .L192
 679:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4643               		.loc 3 679 0
 4644 08e0 80E2      		ldi r24,lo8(32)
 4645 08e2 90E0      		ldi r25,0
 4646               	.LVL487:
 4647 08e4 00D0      		rcall usart_read_bytes
 4648               	.LVL488:
 680:main.c        **** 			
 4649               		.loc 3 680 0
 4650 08e6 939A      		sbi 0x12,3
 683:main.c        **** 			
 4651               		.loc 3 683 0
 4652 08e8 8201      		movw r16,r4
 4653 08ea 68EE      		ldi r22,lo8(-24)
 4654 08ec C201      		movw r24,r4
 4655 08ee 00D0      		rcall gb_flash_write_bus_cycle
 4656               	.LVL489:
 687:main.c        **** 			while (gb_flash_read_byte(address) != 0x80) {
 4657               		.loc 3 687 0
 4658 08f0 00D0      		rcall start_timeout_timer
 4659               	.LVL490:
 4660               	.L193:
 688:main.c        **** 				if (writingTimedout == 1) {
 4661               		.loc 3 688 0
 4662 08f2 C801      		movw r24,r16
 4663 08f4 00D0      		rcall gb_flash_read_byte
 4664               	.LVL491:
 4665 08f6 8038      		cpi r24,lo8(-128)
 4666 08f8 01F0      		breq .L194
 689:main.c        **** 					break;
 4667               		.loc 3 689 0
 4668 08fa 8091 0000 		lds r24,writingTimedout
 4669 08fe 8130      		cpi r24,lo8(1)
 4670 0900 01F4      		brne .L193
 4671               	.L194:
 694:main.c        **** 				start_timeout_timer();
 4672               		.loc 3 694 0
 4673 0902 8091 0000 		lds r24,writingTimedout
 4674 0906 8111      		cpse r24,__zero_reg__
 4675 0908 00C0      		rjmp .L106
 695:main.c        **** 				
 4676               		.loc 3 695 0
 4677 090a 00D0      		rcall start_timeout_timer
 4678               	.LVL492:
 698:main.c        **** 				
 4679               		.loc 3 698 0
 4680 090c 6FE1      		ldi r22,lo8(31)
 4681 090e C801      		movw r24,r16
 4682 0910 00D0      		rcall gb_flash_write_bus_cycle
 4683               	.LVL493:
 4684 0912 90E0      		ldi r25,lo8(receivedBuffer)
 4685 0914 E92E      		mov r14,r25
 4686 0916 90E0      		ldi r25,hi8(receivedBuffer)
 4687 0918 F92E      		mov r15,r25
 4688 091a C12C      		mov r12,__zero_reg__
 4689 091c D12C      		mov r13,__zero_reg__
 4690               	.LVL494:
 4691               	.L196:
 4692               	.LBB306:
 702:main.c        **** 					address++;
 4693               		.loc 3 702 0 discriminator 3
 4694 091e F701      		movw r30,r14
 4695 0920 6191      		ld r22,Z+
 4696 0922 7F01      		movw r14,r30
 4697 0924 C601      		movw r24,r12
 4698 0926 800F      		add r24,r16
 4699 0928 911F      		adc r25,r17
 4700 092a 00D0      		rcall gb_flash_write_bus_cycle
 4701               	.LVL495:
 4702 092c FFEF      		ldi r31,-1
 4703 092e CF1A      		sub r12,r31
 4704 0930 DF0A      		sbc r13,r31
 4705               	.LVL496:
 701:main.c        **** 					gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4706               		.loc 3 701 0 discriminator 3
 4707 0932 20E2      		ldi r18,32
 4708 0934 C216      		cp r12,r18
 4709 0936 D104      		cpc r13,__zero_reg__
 4710 0938 01F4      		brne .L196
 4711 093a 80E2      		ldi r24,32
 4712 093c 480E      		add r4,r24
 4713 093e 511C      		adc r5,__zero_reg__
 4714 0940 611C      		adc r6,__zero_reg__
 4715 0942 711C      		adc r7,__zero_reg__
 4716               	.LBE306:
 707:main.c        **** 				_delay_us(196);
 4717               		.loc 3 707 0
 4718 0944 8201      		movw r16,r4
 4719 0946 0052      		subi r16,32
 4720 0948 1109      		sbc r17,__zero_reg__
 4721 094a 60ED      		ldi r22,lo8(-48)
 4722 094c C801      		movw r24,r16
 4723 094e 00D0      		rcall gb_flash_write_bus_cycle
 4724               	.LVL497:
 4725               	.LBB307:
 4726               	.LBB308:
 4727               		.loc 2 276 0
 4728 0950 A7E8      		ldi r26,lo8(391)
 4729 0952 B1E0      		ldi r27,hi8(391)
 4730 0954 1197      	1:	sbiw r26,1
 4731 0956 01F4      		brne 1b
 4732 0958 00C0      		rjmp .
 4733 095a 0000      		nop
 4734               	.L197:
 4735               	.LBE308:
 4736               	.LBE307:
 712:main.c        **** 					if (writingTimedout == 1) {
 4737               		.loc 3 712 0
 4738 095c C801      		movw r24,r16
 4739 095e 00D0      		rcall gb_flash_read_byte
 4740               	.LVL498:
 4741 0960 8038      		cpi r24,lo8(-128)
 4742 0962 01F4      		brne .+2
 4743 0964 00C0      		rjmp .L348
 713:main.c        **** 						break;
 4744               		.loc 3 713 0
 4745 0966 8091 0000 		lds r24,writingTimedout
 4746 096a 8130      		cpi r24,lo8(1)
 4747 096c 01F4      		brne .L197
 4748 096e 00C0      		rjmp .L348
 4749               	.LVL499:
 4750               	.L192:
 725:main.c        **** 			usart_read_chars(); // Read address
 4751               		.loc 3 725 0
 4752 0970 9E36      		cpi r25,lo8(110)
 4753 0972 01F4      		brne .L200
 4754               	.LBB309:
 726:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4755               		.loc 3 726 0
 4756 0974 00D0      		rcall usart_read_chars
 4757               	.LVL500:
 727:main.c        **** 			
 4758               		.loc 3 727 0
 4759 0976 40E1      		ldi r20,lo8(16)
 4760 0978 50E0      		ldi r21,0
 4761 097a 60E0      		ldi r22,0
 4762 097c 70E0      		ldi r23,0
 4763 097e 80E0      		ldi r24,lo8(receivedBuffer)
 4764 0980 90E0      		ldi r25,hi8(receivedBuffer)
 4765 0982 00D0      		rcall strtol
 4766               	.LVL501:
 4767 0984 6B01      		movw r12,r22
 4768 0986 7C01      		movw r14,r24
 4769               	.LVL502:
 729:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4770               		.loc 3 729 0
 4771 0988 00D0      		rcall USART_Receive
 4772               	.LVL503:
 4773 098a 8093 0000 		sts receivedChar,r24
 730:main.c        **** 				usart_read_chars(); // Read data
 4774               		.loc 3 730 0
 4775 098e 8E36      		cpi r24,lo8(110)
 4776 0990 01F0      		breq .+2
 4777 0992 00C0      		rjmp .L106
 4778               	.LBB310:
 731:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4779               		.loc 3 731 0
 4780 0994 00D0      		rcall usart_read_chars
 4781               	.LVL504:
 732:main.c        **** 				
 4782               		.loc 3 732 0
 4783 0996 40E1      		ldi r20,lo8(16)
 4784 0998 50E0      		ldi r21,0
 4785 099a 60E0      		ldi r22,0
 4786 099c 70E0      		ldi r23,0
 4787 099e 80E0      		ldi r24,lo8(receivedBuffer)
 4788 09a0 90E0      		ldi r25,hi8(receivedBuffer)
 4789 09a2 00D0      		rcall strtol
 4790               	.LVL505:
 734:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4791               		.loc 3 734 0
 4792 09a4 939A      		sbi 0x12,3
 735:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4793               		.loc 3 735 0
 4794 09a6 94BA      		out 0x14,r9
 736:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4795               		.loc 3 736 0
 4796 09a8 9ABA      		out 0x1a,r9
 737:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4797               		.loc 3 737 0
 4798 09aa 97BA      		out 0x17,r9
 738:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4799               		.loc 3 738 0
 4800 09ac AB01      		movw r20,r22
 4801 09ae C701      		movw r24,r14
 4802 09b0 B601      		movw r22,r12
 4803               	.LVL506:
 4804 09b2 00D0      		rcall gba_flash_write_bus_cycle
 4805               	.LVL507:
 4806               	.L356:
 739:main.c        **** 				
 4807               		.loc 3 739 0
 4808 09b4 9398      		cbi 0x12,3
 741:main.c        **** 			}
 4809               		.loc 3 741 0
 4810 09b6 81E3      		ldi r24,lo8(49)
 4811 09b8 00C0      		rjmp .L344
 4812               	.LVL508:
 4813               	.L200:
 4814               	.LBE310:
 4815               	.LBE309:
 746:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4816               		.loc 3 746 0
 4817 09ba 9137      		cpi r25,lo8(113)
 4818 09bc 01F0      		breq .L201
 746:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4819               		.loc 3 746 0 is_stmt 0 discriminator 1
 4820 09be 9437      		cpi r25,lo8(116)
 4821 09c0 01F4      		brne .L202
 4822               	.L201:
 4823               	.LBB311:
 747:main.c        **** 			
 4824               		.loc 3 747 0 is_stmt 1
 4825 09c2 939A      		sbi 0x12,3
 4826               	.LVL509:
 750:main.c        **** 				readLength = 256;
 4827               		.loc 3 750 0
 4828 09c4 8091 0000 		lds r24,receivedChar
 4829               	.LVL510:
 4830 09c8 8437      		cpi r24,lo8(116)
 4831 09ca 01F0      		breq .L255
 749:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4832               		.loc 3 749 0
 4833 09cc 00E4      		ldi r16,lo8(64)
 4834 09ce 10E0      		ldi r17,0
 4835 09d0 00C0      		rjmp .L203
 4836               	.L255:
 751:main.c        **** 			}
 4837               		.loc 3 751 0
 4838 09d2 00E0      		ldi r16,0
 4839 09d4 11E0      		ldi r17,lo8(1)
 4840               	.L203:
 4841               	.LVL511:
 753:main.c        **** 			start_timeout_timer();
 4842               		.loc 3 753 0
 4843 09d6 C801      		movw r24,r16
 4844 09d8 00D0      		rcall usart_read_bytes
 4845               	.LVL512:
 754:main.c        **** 			
 4846               		.loc 3 754 0
 4847 09da 00D0      		rcall start_timeout_timer
 4848               	.LVL513:
 4849 09dc 80E0      		ldi r24,lo8(receivedBuffer)
 4850 09de E82E      		mov r14,r24
 4851 09e0 80E0      		ldi r24,hi8(receivedBuffer)
 4852 09e2 F82E      		mov r15,r24
 4853 09e4 6301      		movw r12,r6
 4854 09e6 5201      		movw r10,r4
 4855               	.LVL514:
 4856               	.L205:
 4857               	.LBB312:
 4858               	.LBB313:
 757:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4859               		.loc 3 757 0
 4860 09e8 F701      		movw r30,r14
 4861 09ea 4181      		ldd r20,Z+1
 4862 09ec 50E0      		ldi r21,0
 4863 09ee 542F      		mov r21,r20
 4864 09f0 4427      		clr r20
 4865 09f2 8081      		ld r24,Z
 4866 09f4 482B      		or r20,r24
 4867               	.LVL515:
 758:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4868               		.loc 3 758 0
 4869 09f6 4F3F      		cpi r20,-1
 4870 09f8 FFEF      		ldi r31,-1
 4871 09fa 5F07      		cpc r21,r31
 4872 09fc 01F0      		breq .L204
 759:main.c        **** 				}
 4873               		.loc 3 759 0
 4874 09fe 21E0      		ldi r18,lo8(1)
 4875 0a00 C601      		movw r24,r12
 4876 0a02 B501      		movw r22,r10
 4877 0a04 00D0      		rcall gba_flash_write_byte
 4878               	.LVL516:
 4879               	.L204:
 761:main.c        **** 			}
 4880               		.loc 3 761 0 discriminator 2
 4881 0a06 2FEF      		ldi r18,-1
 4882 0a08 A21A      		sub r10,r18
 4883 0a0a B20A      		sbc r11,r18
 4884 0a0c C20A      		sbc r12,r18
 4885 0a0e D20A      		sbc r13,r18
 4886               	.LVL517:
 4887 0a10 82E0      		ldi r24,2
 4888 0a12 E80E      		add r14,r24
 4889 0a14 F11C      		adc r15,__zero_reg__
 4890               	.LVL518:
 4891               	.LBE313:
 756:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4892               		.loc 3 756 0 discriminator 2
 4893 0a16 C701      		movw r24,r14
 4894 0a18 8050      		subi r24,lo8(receivedBuffer)
 4895 0a1a 9040      		sbci r25,hi8(receivedBuffer)
 4896 0a1c 8017      		cp r24,r16
 4897 0a1e 9107      		cpc r25,r17
 4898 0a20 04F0      		brlt .L205
 4899 0a22 9FEF      		ldi r25,-1
 4900 0a24 491A      		sub r4,r25
 4901 0a26 590A      		sbc r5,r25
 4902 0a28 690A      		sbc r6,r25
 4903 0a2a 790A      		sbc r7,r25
 4904 0a2c 0150      		subi r16,1
 4905 0a2e 1109      		sbc r17,__zero_reg__
 4906               	.LVL519:
 4907 0a30 1695      		lsr r17
 4908 0a32 0795      		ror r16
 4909               	.LVL520:
 4910 0a34 400E      		add r4,r16
 4911 0a36 511E      		adc r5,r17
 4912 0a38 611C      		adc r6,__zero_reg__
 4913 0a3a 711C      		adc r7,__zero_reg__
 4914 0a3c 00C0      		rjmp .L348
 4915               	.LVL521:
 4916               	.L202:
 4917               	.LBE312:
 4918               	.LBE311:
 768:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4919               		.loc 3 768 0
 4920 0a3e 9636      		cpi r25,lo8(102)
 4921 0a40 01F4      		brne .L206
 4922               	.LBB314:
 769:main.c        **** 			
 4923               		.loc 3 769 0
 4924 0a42 939A      		sbi 0x12,3
 4925               	.LVL522:
 772:main.c        **** 			start_timeout_timer();
 4926               		.loc 3 772 0
 4927 0a44 80E0      		ldi r24,0
 4928 0a46 91E0      		ldi r25,lo8(1)
 4929               	.LVL523:
 4930 0a48 00D0      		rcall usart_read_bytes
 4931               	.LVL524:
 773:main.c        **** 			
 4932               		.loc 3 773 0
 4933 0a4a 00D0      		rcall start_timeout_timer
 4934               	.LVL525:
 4935 0a4c 00E0      		ldi r16,lo8(receivedBuffer)
 4936 0a4e 10E0      		ldi r17,hi8(receivedBuffer)
 4937 0a50 7301      		movw r14,r6
 4938 0a52 6201      		movw r12,r4
 4939               	.LVL526:
 4940               	.L208:
 4941               	.LBB315:
 4942               	.LBB316:
 776:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4943               		.loc 3 776 0
 4944 0a54 D801      		movw r26,r16
 4945 0a56 1196      		adiw r26,1
 4946 0a58 4C91      		ld r20,X
 4947 0a5a 1197      		sbiw r26,1
 4948 0a5c 50E0      		ldi r21,0
 4949 0a5e 542F      		mov r21,r20
 4950 0a60 4427      		clr r20
 4951 0a62 8C91      		ld r24,X
 4952 0a64 482B      		or r20,r24
 4953               	.LVL527:
 777:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4954               		.loc 3 777 0
 4955 0a66 4F3F      		cpi r20,-1
 4956 0a68 BFEF      		ldi r27,-1
 4957 0a6a 5B07      		cpc r21,r27
 4958 0a6c 01F0      		breq .L207
 778:main.c        **** 				}
 4959               		.loc 3 778 0
 4960 0a6e 20E0      		ldi r18,0
 4961 0a70 C701      		movw r24,r14
 4962 0a72 B601      		movw r22,r12
 4963 0a74 00D0      		rcall gba_flash_write_byte
 4964               	.LVL528:
 4965               	.L207:
 780:main.c        **** 			}
 4966               		.loc 3 780 0 discriminator 2
 4967 0a76 EFEF      		ldi r30,-1
 4968 0a78 CE1A      		sub r12,r30
 4969 0a7a DE0A      		sbc r13,r30
 4970 0a7c EE0A      		sbc r14,r30
 4971 0a7e FE0A      		sbc r15,r30
 4972               	.LVL529:
 4973 0a80 0E5F      		subi r16,-2
 4974 0a82 1F4F      		sbci r17,-1
 4975               	.LVL530:
 4976               	.LBE316:
 775:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4977               		.loc 3 775 0 discriminator 2
 4978 0a84 F0E0      		ldi r31,hi8(receivedBuffer+256)
 4979 0a86 0030      		cpi r16,lo8(receivedBuffer+256)
 4980 0a88 1F07      		cpc r17,r31
 4981 0a8a 01F4      		brne .L208
 4982 0a8c 20E8      		ldi r18,-128
 4983 0a8e 420E      		add r4,r18
 4984 0a90 511C      		adc r5,__zero_reg__
 4985 0a92 611C      		adc r6,__zero_reg__
 4986 0a94 711C      		adc r7,__zero_reg__
 4987 0a96 00C0      		rjmp .L348
 4988               	.LVL531:
 4989               	.L206:
 4990               	.LBE315:
 4991               	.LBE314:
 787:main.c        **** 			usart_read_bytes(256);
 4992               		.loc 3 787 0
 4993 0a98 9336      		cpi r25,lo8(99)
 4994 0a9a 01F0      		breq .+2
 4995 0a9c 00C0      		rjmp .L209
 4996               	.LBB317:
 788:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4997               		.loc 3 788 0
 4998 0a9e 80E0      		ldi r24,0
 4999 0aa0 91E0      		ldi r25,lo8(1)
 5000               	.LVL532:
 5001 0aa2 00D0      		rcall usart_read_bytes
 5002               	.LVL533:
 789:main.c        **** 			
 5003               		.loc 3 789 0
 5004 0aa4 939A      		sbi 0x12,3
 5005               	.LVL534:
 5006 0aa6 00E0      		ldi r16,lo8(receivedBuffer)
 5007 0aa8 10E0      		ldi r17,hi8(receivedBuffer)
 5008               	.LVL535:
 5009               	.L217:
 5010               	.LBB318:
 5011               	.LBB319:
 794:main.c        **** 				
 5012               		.loc 3 794 0
 5013 0aaa 00D0      		rcall start_timeout_timer
 5014               	.LVL536:
 797:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5015               		.loc 3 797 0
 5016 0aac 94BA      		out 0x14,r9
 798:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5017               		.loc 3 798 0
 5018 0aae 9ABA      		out 0x1a,r9
 799:main.c        **** 				
 5019               		.loc 3 799 0
 5020 0ab0 97BA      		out 0x17,r9
 5021               	.LVL537:
 5022 0ab2 CE01      		movw r24,r28
 5023 0ab4 0196      		adiw r24,1
 5024 0ab6 7C01      		movw r14,r24
 5025 0ab8 FC01      		movw r30,r24
 5026 0aba D801      		movw r26,r16
 5027               	.LVL538:
 5028               	.L210:
 5029               	.LBB320:
 804:main.c        **** 					byteCounter++;
 5030               		.loc 3 804 0 discriminator 3
 5031 0abc 8D91      		ld r24,X+
 5032               	.LVL539:
 5033 0abe 8193      		st Z+,r24
 5034               	.LVL540:
 803:main.c        **** 					localBuffer[x] = receivedBuffer[byteCounter];
 5035               		.loc 3 803 0 discriminator 3
 5036 0ac0 2E16      		cp r2,r30
 5037 0ac2 3F06      		cpc r3,r31
 5038 0ac4 01F4      		brne .L210
 5039               	.LBE320:
 808:main.c        **** 				gba_flash_write_bus_cycle(0x2AA, 0x55);
 5040               		.loc 3 808 0
 5041 0ac6 4AEA      		ldi r20,lo8(-86)
 5042 0ac8 50E0      		ldi r21,0
 5043 0aca 65E5      		ldi r22,lo8(85)
 5044 0acc 75E0      		ldi r23,lo8(5)
 5045 0ace 80E0      		ldi r24,0
 5046 0ad0 90E0      		ldi r25,0
 5047 0ad2 00D0      		rcall gba_flash_write_bus_cycle
 5048               	.LVL541:
 809:main.c        **** 				gba_flash_write_bus_cycle(address, 0x25);
 5049               		.loc 3 809 0
 5050 0ad4 45E5      		ldi r20,lo8(85)
 5051 0ad6 50E0      		ldi r21,0
 5052 0ad8 6AEA      		ldi r22,lo8(-86)
 5053 0ada 72E0      		ldi r23,lo8(2)
 5054 0adc 80E0      		ldi r24,0
 5055 0ade 90E0      		ldi r25,0
 5056 0ae0 00D0      		rcall gba_flash_write_bus_cycle
 5057               	.LVL542:
 810:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // Length
 5058               		.loc 3 810 0
 5059 0ae2 45E2      		ldi r20,lo8(37)
 5060 0ae4 50E0      		ldi r21,0
 5061 0ae6 C301      		movw r24,r6
 5062 0ae8 B201      		movw r22,r4
 5063 0aea 00D0      		rcall gba_flash_write_bus_cycle
 5064               	.LVL543:
 811:main.c        **** 				_delay_us(1);
 5065               		.loc 3 811 0
 5066 0aec 4FE0      		ldi r20,lo8(15)
 5067 0aee 50E0      		ldi r21,0
 5068 0af0 C301      		movw r24,r6
 5069 0af2 B201      		movw r22,r4
 5070 0af4 00D0      		rcall gba_flash_write_bus_cycle
 5071               	.LVL544:
 5072               	.LBB321:
 5073               	.LBB322:
 5074               		.loc 2 276 0
 5075 0af6 92E0      		ldi r25,lo8(2)
 5076 0af8 9A95      	1:	dec r25
 5077 0afa 01F4      		brne 1b
 5078 0afc 00C0      		rjmp .
 5079               	.LVL545:
 5080               	.LBE322:
 5081               	.LBE321:
 815:main.c        **** 				GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 5082               		.loc 3 815 0
 5083 0afe C301      		movw r24,r6
 5084 0b00 AA27      		clr r26
 5085 0b02 BB27      		clr r27
 5086 0b04 85BB      		out 0x15,r24
 816:main.c        **** 				GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 5087               		.loc 3 816 0
 5088 0b06 BB27      		clr r27
 5089 0b08 A72D      		mov r26,r7
 5090 0b0a 962D      		mov r25,r6
 5091 0b0c 852D      		mov r24,r5
 5092 0b0e 8BBB      		out 0x1b,r24
 817:main.c        **** 				cs_mreqPin_low;
 5093               		.loc 3 817 0
 5094 0b10 48BA      		out 0x18,r4
 818:main.c        **** 				
 5095               		.loc 3 818 0
 5096 0b12 9498      		cbi 0x12,4
 5097               	.LVL546:
 5098               	.L211:
 5099               	.LBB323:
 822:main.c        **** 					GBA_PORT_ROM_DATA7_0 = localBuffer[x];
 5100               		.loc 3 822 0 discriminator 3
 5101 0b14 D701      		movw r26,r14
 5102 0b16 1196      		adiw r26,1
 5103 0b18 8C91      		ld r24,X
 5104 0b1a 1197      		sbiw r26,1
 5105 0b1c 8BBB      		out 0x1b,r24
 823:main.c        **** 					
 5106               		.loc 3 823 0 discriminator 3
 5107 0b1e 8C91      		ld r24,X
 5108 0b20 88BB      		out 0x18,r24
 825:main.c        **** 					asm volatile("nop");
 5109               		.loc 3 825 0 discriminator 3
 5110 0b22 9698      		cbi 0x12,6
 826:main.c        **** 					asm volatile("nop");
 5111               		.loc 3 826 0 discriminator 3
 5112               	/* #APP */
 5113               	 ;  826 "main.c" 1
 5114 0b24 0000      		nop
 5115               	 ;  0 "" 2
 827:main.c        **** 					asm volatile("nop");
 5116               		.loc 3 827 0 discriminator 3
 5117               	 ;  827 "main.c" 1
 5118 0b26 0000      		nop
 5119               	 ;  0 "" 2
 828:main.c        **** 					wrPin_high;
 5120               		.loc 3 828 0 discriminator 3
 5121               	 ;  828 "main.c" 1
 5122 0b28 0000      		nop
 5123               	 ;  0 "" 2
 829:main.c        **** 					
 5124               		.loc 3 829 0 discriminator 3
 5125               	/* #NOAPP */
 5126 0b2a 969A      		sbi 0x12,6
 832:main.c        **** 					asm volatile("nop");
 5127               		.loc 3 832 0 discriminator 3
 5128 0b2c 9598      		cbi 0x12,5
 833:main.c        **** 					rdPin_high;
 5129               		.loc 3 833 0 discriminator 3
 5130               	/* #APP */
 5131               	 ;  833 "main.c" 1
 5132 0b2e 0000      		nop
 5133               	 ;  0 "" 2
 834:main.c        **** 					address++;
 5134               		.loc 3 834 0 discriminator 3
 5135               	/* #NOAPP */
 5136 0b30 959A      		sbi 0x12,5
 5137 0b32 B2E0      		ldi r27,2
 5138 0b34 EB0E      		add r14,r27
 5139 0b36 F11C      		adc r15,__zero_reg__
 821:main.c        **** 					GBA_PORT_ROM_DATA15_8 = localBuffer[x+1];
 5140               		.loc 3 821 0 discriminator 3
 5141 0b38 2E14      		cp r2,r14
 5142 0b3a 3F04      		cpc r3,r15
 5143 0b3c 01F4      		brne .L211
 5144 0b3e 7301      		movw r14,r6
 5145 0b40 6201      		movw r12,r4
 5146 0b42 E0E1      		ldi r30,16
 5147 0b44 CE0E      		add r12,r30
 5148 0b46 D11C      		adc r13,__zero_reg__
 5149 0b48 E11C      		adc r14,__zero_reg__
 5150 0b4a F11C      		adc r15,__zero_reg__
 5151 0b4c D301      		movw r26,r6
 5152 0b4e C201      		movw r24,r4
 5153 0b50 0F96      		adiw r24,15
 5154 0b52 A11D      		adc r26,__zero_reg__
 5155 0b54 B11D      		adc r27,__zero_reg__
 5156 0b56 89A3      		std Y+33,r24
 5157 0b58 9AA3      		std Y+34,r25
 5158 0b5a ABA3      		std Y+35,r26
 5159 0b5c BCA3      		std Y+36,r27
 5160               	.LBE323:
 837:main.c        **** 				
 5161               		.loc 3 837 0
 5162 0b5e 949A      		sbi 0x12,4
 840:main.c        **** 				_delay_us(200);
 5163               		.loc 3 840 0
 5164 0b60 C301      		movw r24,r6
 5165 0b62 B201      		movw r22,r4
 5166 0b64 6F5F      		subi r22,-1
 5167 0b66 7F4F      		sbci r23,-1
 5168 0b68 8F4F      		sbci r24,-1
 5169 0b6a 9F4F      		sbci r25,-1
 5170 0b6c 49E2      		ldi r20,lo8(41)
 5171 0b6e 50E0      		ldi r21,0
 5172 0b70 00D0      		rcall gba_flash_write_bus_cycle
 5173               	.LVL547:
 5174               	.LBB324:
 5175               	.LBB325:
 5176               		.loc 2 276 0
 5177 0b72 AFE8      		ldi r26,lo8(399)
 5178 0b74 B1E0      		ldi r27,hi8(399)
 5179 0b76 1197      	1:	sbiw r26,1
 5180 0b78 01F4      		brne 1b
 5181 0b7a 00C0      		rjmp .
 5182 0b7c 0000      		nop
 5183               	.LVL548:
 5184               	.LBE325:
 5185               	.LBE324:
 844:main.c        **** 				uint16_t dataVerify = gba_read_16bit_data(address-1);
 5186               		.loc 3 844 0
 5187 0b7e AF8C      		ldd r10,Y+31
 5188 0b80 B8A0      		ldd r11,Y+32
 5189               	.LVL549:
 845:main.c        **** 				while (dataVerify != combinedBytes) {
 5190               		.loc 3 845 0
 5191 0b82 69A1      		ldd r22,Y+33
 5192 0b84 7AA1      		ldd r23,Y+34
 5193 0b86 8BA1      		ldd r24,Y+35
 5194 0b88 9CA1      		ldd r25,Y+36
 5195 0b8a 00D0      		rcall gba_read_16bit_data
 5196               	.LVL550:
 5197               	.L212:
 846:main.c        **** 					dataVerify = gba_read_16bit_data(address-1);
 5198               		.loc 3 846 0
 5199 0b8c 8A15      		cp r24,r10
 5200 0b8e 9B05      		cpc r25,r11
 5201 0b90 01F0      		breq .L216
 847:main.c        **** 					_delay_us(1);
 5202               		.loc 3 847 0
 5203 0b92 69A1      		ldd r22,Y+33
 5204 0b94 7AA1      		ldd r23,Y+34
 5205 0b96 8BA1      		ldd r24,Y+35
 5206 0b98 9CA1      		ldd r25,Y+36
 5207 0b9a 00D0      		rcall gba_read_16bit_data
 5208               	.LVL551:
 5209               	.LBB326:
 5210               	.LBB327:
 5211               		.loc 2 276 0
 5212 0b9c B2E0      		ldi r27,lo8(2)
 5213 0b9e BA95      	1:	dec r27
 5214 0ba0 01F4      		brne 1b
 5215 0ba2 00C0      		rjmp .
 5216               	.LVL552:
 5217               	.LBE327:
 5218               	.LBE326:
 849:main.c        **** 						break;
 5219               		.loc 3 849 0
 5220 0ba4 2091 0000 		lds r18,writingTimedout
 5221 0ba8 2130      		cpi r18,lo8(1)
 5222 0baa 01F4      		brne .L212
 5223               	.L216:
 853:main.c        **** 					break;
 5224               		.loc 3 853 0
 5225 0bac 8091 0000 		lds r24,writingTimedout
 5226               	.LVL553:
 5227 0bb0 8130      		cpi r24,lo8(1)
 5228 0bb2 01F0      		breq .L218
 5229               	.LVL554:
 5230 0bb4 005E      		subi r16,-32
 5231 0bb6 1F4F      		sbci r17,-1
 5232               	.LVL555:
 5233               	.LBE319:
 793:main.c        **** 				start_timeout_timer();
 5234               		.loc 3 793 0
 5235 0bb8 E0E0      		ldi r30,lo8(receivedBuffer+256)
 5236 0bba F0E0      		ldi r31,hi8(receivedBuffer+256)
 5237 0bbc E017      		cp r30,r16
 5238 0bbe F107      		cpc r31,r17
 5239 0bc0 01F0      		breq .L218
 5240 0bc2 2601      		movw r4,r12
 5241 0bc4 3701      		movw r6,r14
 5242 0bc6 00C0      		rjmp .L217
 5243               	.LVL556:
 5244               	.L218:
 5245               	.LBE318:
 857:main.c        **** 		}
 5246               		.loc 3 857 0
 5247 0bc8 00D0      		rcall check_if_timed_out
 5248               	.LVL557:
 5249               	.LBE317:
 5250 0bca 2601      		movw r4,r12
 5251 0bcc 3701      		movw r6,r14
 5252 0bce 00C0      		rjmp .L106
 5253               	.LVL558:
 5254               	.L209:
 862:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5255               		.loc 3 862 0
 5256 0bd0 9C36      		cpi r25,lo8(108)
 5257 0bd2 01F0      		breq .+2
 5258 0bd4 00C0      		rjmp .L219
 5259               	.LBB328:
 863:main.c        **** 			usart_read_bytes(64);
 5260               		.loc 3 863 0
 5261 0bd6 939A      		sbi 0x12,3
 864:main.c        **** 			start_timeout_timer();
 5262               		.loc 3 864 0
 5263 0bd8 80E4      		ldi r24,lo8(64)
 5264 0bda 90E0      		ldi r25,0
 5265               	.LVL559:
 5266 0bdc 00D0      		rcall usart_read_bytes
 5267               	.LVL560:
 865:main.c        **** 			
 5268               		.loc 3 865 0
 5269 0bde 00D0      		rcall start_timeout_timer
 5270               	.LVL561:
 868:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5271               		.loc 3 868 0
 5272 0be0 94BA      		out 0x14,r9
 869:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5273               		.loc 3 869 0
 5274 0be2 9ABA      		out 0x1a,r9
 870:main.c        **** 			
 5275               		.loc 3 870 0
 5276 0be4 97BA      		out 0x17,r9
 873:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 5277               		.loc 3 873 0
 5278 0be6 40E6      		ldi r20,lo8(96)
 5279 0be8 50E0      		ldi r21,0
 5280 0bea C301      		movw r24,r6
 5281 0bec B201      		movw r22,r4
 5282 0bee 00D0      		rcall gba_flash_write_bus_cycle
 5283               	.LVL562:
 874:main.c        **** 			
 5284               		.loc 3 874 0
 5285 0bf0 40ED      		ldi r20,lo8(-48)
 5286 0bf2 50E0      		ldi r21,0
 5287 0bf4 C301      		movw r24,r6
 5288 0bf6 B201      		movw r22,r4
 5289 0bf8 00D0      		rcall gba_flash_write_bus_cycle
 5290               	.LVL563:
 877:main.c        **** 			_delay_us(50);
 5291               		.loc 3 877 0
 5292 0bfa 48EE      		ldi r20,lo8(-24)
 5293 0bfc 50E0      		ldi r21,0
 5294 0bfe C301      		movw r24,r6
 5295 0c00 B201      		movw r22,r4
 5296 0c02 00D0      		rcall gba_flash_write_bus_cycle
 5297               	.LVL564:
 5298               	.LBB329:
 5299               	.LBB330:
 5300               		.loc 2 276 0
 5301 0c04 F5E8      		ldi r31,lo8(-123)
 5302 0c06 FA95      	1:	dec r31
 5303 0c08 01F4      		brne 1b
 5304 0c0a 0000      		nop
 5305               	.LVL565:
 5306               	.LBE330:
 5307               	.LBE329:
 881:main.c        **** 			while (dataVerify != 0x0080) {
 5308               		.loc 3 881 0
 5309 0c0c C301      		movw r24,r6
 5310 0c0e B201      		movw r22,r4
 5311 0c10 00D0      		rcall gba_read_16bit_data
 5312               	.LVL566:
 5313               	.L220:
 882:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 5314               		.loc 3 882 0
 5315 0c12 8038      		cpi r24,-128
 5316 0c14 9105      		cpc r25,__zero_reg__
 5317 0c16 01F0      		breq .L223
 883:main.c        **** 				_delay_us(50);
 5318               		.loc 3 883 0
 5319 0c18 C301      		movw r24,r6
 5320 0c1a B201      		movw r22,r4
 5321 0c1c 00D0      		rcall gba_read_16bit_data
 5322               	.LVL567:
 5323               	.LBB331:
 5324               	.LBB332:
 5325               		.loc 2 276 0
 5326 0c1e 25E8      		ldi r18,lo8(-123)
 5327 0c20 2A95      	1:	dec r18
 5328 0c22 01F4      		brne 1b
 5329 0c24 0000      		nop
 5330               	.LVL568:
 5331               	.LBE332:
 5332               	.LBE331:
 885:main.c        **** 					break;
 5333               		.loc 3 885 0
 5334 0c26 2091 0000 		lds r18,writingTimedout
 5335 0c2a 2130      		cpi r18,lo8(1)
 5336 0c2c 01F4      		brne .L220
 5337               	.L223:
 892:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5338               		.loc 3 892 0
 5339 0c2e 94BA      		out 0x14,r9
 893:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5340               		.loc 3 893 0
 5341 0c30 9ABA      		out 0x1a,r9
 894:main.c        **** 			
 5342               		.loc 3 894 0
 5343 0c32 97BA      		out 0x17,r9
 897:main.c        **** 			
 5344               		.loc 3 897 0
 5345 0c34 4FE1      		ldi r20,lo8(31)
 5346 0c36 50E0      		ldi r21,0
 5347 0c38 C301      		movw r24,r6
 5348 0c3a B201      		movw r22,r4
 5349 0c3c 00D0      		rcall gba_flash_write_bus_cycle
 5350               	.LVL569:
 5351 0c3e 00E0      		ldi r16,lo8(receivedBuffer)
 5352 0c40 10E0      		ldi r17,hi8(receivedBuffer)
 5353 0c42 7301      		movw r14,r6
 5354 0c44 6201      		movw r12,r4
 5355               	.LVL570:
 5356               	.L221:
 5357               	.LBB333:
 5358               	.LBB334:
 902:main.c        **** 				address++;
 5359               		.loc 3 902 0 discriminator 3
 5360 0c46 D801      		movw r26,r16
 5361 0c48 1196      		adiw r26,1
 5362 0c4a 4C91      		ld r20,X
 5363 0c4c 1197      		sbiw r26,1
 5364 0c4e 50E0      		ldi r21,0
 5365 0c50 542F      		mov r21,r20
 5366 0c52 4427      		clr r20
 5367 0c54 8C91      		ld r24,X
 5368 0c56 482B      		or r20,r24
 5369 0c58 C701      		movw r24,r14
 5370 0c5a B601      		movw r22,r12
 5371 0c5c 00D0      		rcall gba_flash_write_bus_cycle
 5372               	.LVL571:
 903:main.c        **** 			}
 5373               		.loc 3 903 0 discriminator 3
 5374 0c5e BFEF      		ldi r27,-1
 5375 0c60 CB1A      		sub r12,r27
 5376 0c62 DB0A      		sbc r13,r27
 5377 0c64 EB0A      		sbc r14,r27
 5378 0c66 FB0A      		sbc r15,r27
 5379               	.LVL572:
 5380 0c68 0E5F      		subi r16,-2
 5381 0c6a 1F4F      		sbci r17,-1
 5382               	.LVL573:
 5383               	.LBE334:
 900:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5384               		.loc 3 900 0 discriminator 3
 5385 0c6c E0E0      		ldi r30,lo8(receivedBuffer+64)
 5386 0c6e F0E0      		ldi r31,hi8(receivedBuffer+64)
 5387 0c70 E017      		cp r30,r16
 5388 0c72 F107      		cpc r31,r17
 5389 0c74 01F4      		brne .L221
 5390 0c76 F0E2      		ldi r31,32
 5391 0c78 4F0E      		add r4,r31
 5392 0c7a 511C      		adc r5,__zero_reg__
 5393 0c7c 611C      		adc r6,__zero_reg__
 5394 0c7e 711C      		adc r7,__zero_reg__
 5395               	.LBE333:
 907:main.c        **** 			_delay_us(440);
 5396               		.loc 3 907 0
 5397 0c80 40ED      		ldi r20,lo8(-48)
 5398 0c82 50E0      		ldi r21,0
 5399 0c84 C301      		movw r24,r6
 5400 0c86 B201      		movw r22,r4
 5401 0c88 00D0      		rcall gba_flash_write_bus_cycle
 5402               	.LVL574:
 5403               	.LBB335:
 5404               	.LBB336:
 5405               		.loc 2 276 0
 5406 0c8a 8FE6      		ldi r24,lo8(879)
 5407 0c8c 93E0      		ldi r25,hi8(879)
 5408 0c8e 0197      	1:	sbiw r24,1
 5409 0c90 01F4      		brne 1b
 5410 0c92 00C0      		rjmp .
 5411 0c94 0000      		nop
 5412               	.LVL575:
 5413               	.LBE336:
 5414               	.LBE335:
 911:main.c        **** 			while (dataVerify != 0x0080) {
 5415               		.loc 3 911 0
 5416 0c96 C301      		movw r24,r6
 5417 0c98 B201      		movw r22,r4
 5418 0c9a 00D0      		rcall gba_read_16bit_data
 5419               	.LVL576:
 5420               	.L224:
 912:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 5421               		.loc 3 912 0
 5422 0c9c 8038      		cpi r24,-128
 5423 0c9e 9105      		cpc r25,__zero_reg__
 5424 0ca0 01F0      		breq .L226
 913:main.c        **** 				_delay_us(50);
 5425               		.loc 3 913 0
 5426 0ca2 C301      		movw r24,r6
 5427 0ca4 B201      		movw r22,r4
 5428 0ca6 00D0      		rcall gba_read_16bit_data
 5429               	.LVL577:
 5430               	.LBB337:
 5431               	.LBB338:
 5432               		.loc 2 276 0
 5433 0ca8 A5E8      		ldi r26,lo8(-123)
 5434 0caa AA95      	1:	dec r26
 5435 0cac 01F4      		brne 1b
 5436 0cae 0000      		nop
 5437               	.LVL578:
 5438               	.LBE338:
 5439               	.LBE337:
 915:main.c        **** 					break;
 5440               		.loc 3 915 0
 5441 0cb0 2091 0000 		lds r18,writingTimedout
 5442 0cb4 2130      		cpi r18,lo8(1)
 5443 0cb6 01F4      		brne .L224
 5444               	.L226:
 922:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5445               		.loc 3 922 0
 5446 0cb8 94BA      		out 0x14,r9
 923:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5447               		.loc 3 923 0
 5448 0cba 9ABA      		out 0x1a,r9
 924:main.c        **** 			
 5449               		.loc 3 924 0
 5450 0cbc 97BA      		out 0x17,r9
 927:main.c        **** 			
 5451               		.loc 3 927 0
 5452 0cbe 4FEF      		ldi r20,lo8(-1)
 5453 0cc0 50E0      		ldi r21,0
 5454 0cc2 C301      		movw r24,r6
 5455 0cc4 B201      		movw r22,r4
 5456 0cc6 00D0      		rcall gba_flash_write_bus_cycle
 5457               	.LVL579:
 5458 0cc8 00C0      		rjmp .L348
 5459               	.LVL580:
 5460               	.L219:
 5461               	.LBE328:
 933:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5462               		.loc 3 933 0
 5463 0cca 9537      		cpi r25,lo8(117)
 5464 0ccc 01F4      		brne .L227
 934:main.c        **** 			usart_read_bytes(64);
 5465               		.loc 3 934 0
 5466 0cce 939A      		sbi 0x12,3
 935:main.c        **** 			start_timeout_timer();
 5467               		.loc 3 935 0
 5468 0cd0 80E4      		ldi r24,lo8(64)
 5469 0cd2 90E0      		ldi r25,0
 5470               	.LVL581:
 5471 0cd4 00D0      		rcall usart_read_bytes
 5472               	.LVL582:
 936:main.c        **** 			
 5473               		.loc 3 936 0
 5474 0cd6 00D0      		rcall start_timeout_timer
 5475               	.LVL583:
 5476 0cd8 40E0      		ldi r20,lo8(receivedBuffer)
 5477 0cda E42E      		mov r14,r20
 5478 0cdc 40E0      		ldi r20,hi8(receivedBuffer)
 5479 0cde F42E      		mov r15,r20
 5480 0ce0 6301      		movw r12,r6
 5481 0ce2 5201      		movw r10,r4
 5482               	.LVL584:
 5483               	.L229:
 5484               	.LBB339:
 5485               	.LBB340:
 941:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5486               		.loc 3 941 0
 5487 0ce4 94BA      		out 0x14,r9
 942:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5488               		.loc 3 942 0
 5489 0ce6 9ABA      		out 0x1a,r9
 943:main.c        **** 				
 5490               		.loc 3 943 0
 5491 0ce8 97BA      		out 0x17,r9
 945:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 5492               		.loc 3 945 0
 5493 0cea F701      		movw r30,r14
 5494 0cec 0181      		ldd r16,Z+1
 5495 0cee 10E0      		ldi r17,0
 5496 0cf0 102F      		mov r17,r16
 5497 0cf2 0027      		clr r16
 5498 0cf4 8081      		ld r24,Z
 5499 0cf6 082B      		or r16,r24
 5500               	.LVL585:
 946:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5501               		.loc 3 946 0
 5502 0cf8 40E4      		ldi r20,lo8(64)
 5503 0cfa 50E0      		ldi r21,0
 5504 0cfc C601      		movw r24,r12
 5505 0cfe B501      		movw r22,r10
 5506 0d00 00D0      		rcall gba_flash_write_bus_cycle
 5507               	.LVL586:
 947:main.c        **** 				
 5508               		.loc 3 947 0
 5509 0d02 A801      		movw r20,r16
 5510 0d04 C601      		movw r24,r12
 5511 0d06 B501      		movw r22,r10
 5512 0d08 00D0      		rcall gba_flash_write_bus_cycle
 5513               	.LVL587:
 950:main.c        **** 				while ((status & 0x80) == 0) {
 5514               		.loc 3 950 0
 5515 0d0a C601      		movw r24,r12
 5516 0d0c B501      		movw r22,r10
 5517 0d0e 00D0      		rcall gba_read_16bit_data
 5518               	.LVL588:
 5519               	.L228:
 951:main.c        **** 					status = gba_read_16bit_data(address);
 5520               		.loc 3 951 0
 5521 0d10 87FD      		sbrc r24,7
 5522 0d12 00C0      		rjmp .L232
 952:main.c        **** 					_delay_us(2);
 5523               		.loc 3 952 0
 5524 0d14 C601      		movw r24,r12
 5525 0d16 B501      		movw r22,r10
 5526 0d18 00D0      		rcall gba_read_16bit_data
 5527               	.LVL589:
 5528               	.LBB341:
 5529               	.LBB342:
 5530               		.loc 2 276 0
 5531 0d1a F5E0      		ldi r31,lo8(5)
 5532 0d1c FA95      	1:	dec r31
 5533 0d1e 01F4      		brne 1b
 5534 0d20 0000      		nop
 5535               	.LVL590:
 5536               	.LBE342:
 5537               	.LBE341:
 954:main.c        **** 						break;
 5538               		.loc 3 954 0
 5539 0d22 9091 0000 		lds r25,writingTimedout
 5540 0d26 9130      		cpi r25,lo8(1)
 5541 0d28 01F4      		brne .L228
 5542               	.L232:
 958:main.c        **** 			}
 5543               		.loc 3 958 0
 5544 0d2a 2FEF      		ldi r18,-1
 5545 0d2c A21A      		sub r10,r18
 5546 0d2e B20A      		sbc r11,r18
 5547 0d30 C20A      		sbc r12,r18
 5548 0d32 D20A      		sbc r13,r18
 5549               	.LVL591:
 5550 0d34 82E0      		ldi r24,2
 5551 0d36 E80E      		add r14,r24
 5552 0d38 F11C      		adc r15,__zero_reg__
 5553               	.LVL592:
 5554               	.LBE340:
 939:main.c        **** 				// Set address lines as outputs
 5555               		.loc 3 939 0
 5556 0d3a A0E0      		ldi r26,lo8(receivedBuffer+64)
 5557 0d3c B0E0      		ldi r27,hi8(receivedBuffer+64)
 5558 0d3e AE15      		cp r26,r14
 5559 0d40 BF05      		cpc r27,r15
 5560 0d42 01F4      		brne .L229
 5561 0d44 00C0      		rjmp .L347
 5562               	.LVL593:
 5563               	.L227:
 5564               	.LBE339:
 967:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5565               		.loc 3 967 0
 5566 0d46 9637      		cpi r25,lo8(118)
 5567 0d48 01F0      		breq .+2
 5568 0d4a 00C0      		rjmp .L233
 968:main.c        **** 			usart_read_bytes(256);
 5569               		.loc 3 968 0
 5570 0d4c 939A      		sbi 0x12,3
 969:main.c        **** 			start_timeout_timer();
 5571               		.loc 3 969 0
 5572 0d4e 80E0      		ldi r24,0
 5573 0d50 91E0      		ldi r25,lo8(1)
 5574               	.LVL594:
 5575 0d52 00D0      		rcall usart_read_bytes
 5576               	.LVL595:
 970:main.c        **** 			
 5577               		.loc 3 970 0
 5578 0d54 00D0      		rcall start_timeout_timer
 5579               	.LVL596:
 5580 0d56 00E0      		ldi r16,lo8(receivedBuffer)
 5581 0d58 10E0      		ldi r17,hi8(receivedBuffer)
 5582               	.LVL597:
 5583               	.L245:
 5584               	.LBB343:
 975:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5585               		.loc 3 975 0
 5586 0d5a 94BA      		out 0x14,r9
 976:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5587               		.loc 3 976 0
 5588 0d5c 9ABA      		out 0x1a,r9
 977:main.c        **** 				
 5589               		.loc 3 977 0
 5590 0d5e 97BA      		out 0x17,r9
 980:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 5591               		.loc 3 980 0
 5592 0d60 48EE      		ldi r20,lo8(-24)
 5593 0d62 50E0      		ldi r21,0
 5594 0d64 C301      		movw r24,r6
 5595 0d66 B201      		movw r22,r4
 5596 0d68 00D0      		rcall gba_flash_write_bus_cycle
 5597               	.LVL598:
 981:main.c        **** 				
 5598               		.loc 3 981 0
 5599 0d6a 7301      		movw r14,r6
 5600 0d6c 6201      		movw r12,r4
 5601 0d6e EFEF      		ldi r30,-1
 5602 0d70 CE1A      		sub r12,r30
 5603 0d72 DE0A      		sbc r13,r30
 5604 0d74 EE0A      		sbc r14,r30
 5605 0d76 FE0A      		sbc r15,r30
 5606 0d78 48EE      		ldi r20,lo8(-24)
 5607 0d7a 50E0      		ldi r21,0
 5608 0d7c C701      		movw r24,r14
 5609 0d7e B601      		movw r22,r12
 5610 0d80 00D0      		rcall gba_flash_write_bus_cycle
 5611               	.LVL599:
 5612               	.L234:
 984:main.c        **** 					if (writingTimedout == 1) {
 5613               		.loc 3 984 0
 5614 0d82 C301      		movw r24,r6
 5615 0d84 B201      		movw r22,r4
 5616 0d86 00D0      		rcall gba_read_16bit_data
 5617               	.LVL600:
 5618 0d88 8038      		cpi r24,-128
 5619 0d8a 9105      		cpc r25,__zero_reg__
 5620 0d8c 01F0      		breq .L322
 985:main.c        **** 						break;
 5621               		.loc 3 985 0
 5622 0d8e 8091 0000 		lds r24,writingTimedout
 5623 0d92 8130      		cpi r24,lo8(1)
 5624 0d94 01F4      		brne .L234
 5625 0d96 00C0      		rjmp .L322
 5626               	.L238:
 990:main.c        **** 						break;
 5627               		.loc 3 990 0
 5628 0d98 8091 0000 		lds r24,writingTimedout
 5629 0d9c 8130      		cpi r24,lo8(1)
 5630 0d9e 01F0      		breq .L237
 5631               	.L322:
 989:main.c        **** 					if (writingTimedout == 1) {
 5632               		.loc 3 989 0
 5633 0da0 C701      		movw r24,r14
 5634 0da2 B601      		movw r22,r12
 5635 0da4 00D0      		rcall gba_read_16bit_data
 5636               	.LVL601:
 5637 0da6 8038      		cpi r24,-128
 5638 0da8 9105      		cpc r25,__zero_reg__
 5639 0daa 01F4      		brne .L238
 5640               	.L237:
 998:main.c        **** 					start_timeout_timer();
 5641               		.loc 3 998 0
 5642 0dac 8091 0000 		lds r24,writingTimedout
 5643 0db0 8111      		cpse r24,__zero_reg__
 5644 0db2 00C0      		rjmp .L257
 5645               	.LBB344:
 999:main.c        **** 					
 5646               		.loc 3 999 0
 5647 0db4 00D0      		rcall start_timeout_timer
 5648               	.LVL602:
1002:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5649               		.loc 3 1002 0
 5650 0db6 94BA      		out 0x14,r9
1003:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5651               		.loc 3 1003 0
 5652 0db8 9ABA      		out 0x1a,r9
1004:main.c        **** 					
 5653               		.loc 3 1004 0
 5654 0dba 97BA      		out 0x17,r9
1007:main.c        **** 					gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
 5655               		.loc 3 1007 0
 5656 0dbc 4FE0      		ldi r20,lo8(15)
 5657 0dbe 50E0      		ldi r21,0
 5658 0dc0 C301      		movw r24,r6
 5659 0dc2 B201      		movw r22,r4
 5660 0dc4 00D0      		rcall gba_flash_write_bus_cycle
 5661               	.LVL603:
1008:main.c        **** 					
 5662               		.loc 3 1008 0
 5663 0dc6 4FE0      		ldi r20,lo8(15)
 5664 0dc8 50E0      		ldi r21,0
 5665 0dca C701      		movw r24,r14
 5666 0dcc B601      		movw r22,r12
 5667 0dce 00D0      		rcall gba_flash_write_bus_cycle
 5668               	.LVL604:
 5669 0dd0 1AA3      		std Y+34,r17
 5670 0dd2 09A3      		std Y+33,r16
 5671 0dd4 4FA2      		std Y+39,r4
 5672 0dd6 58A6      		std Y+40,r5
 5673 0dd8 69A6      		std Y+41,r6
 5674 0dda 7AA6      		std Y+42,r7
 5675               	.LBB345:
1012:main.c        **** 						combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 5676               		.loc 3 1012 0
 5677 0ddc A12C      		mov r10,__zero_reg__
 5678 0dde B12C      		mov r11,__zero_reg__
 5679               	.LVL605:
 5680               	.L240:
1014:main.c        **** 						address++;
 5681               		.loc 3 1014 0 discriminator 3
 5682 0de0 A9A1      		ldd r26,Y+33
 5683 0de2 BAA1      		ldd r27,Y+34
 5684 0de4 1196      		adiw r26,1
 5685 0de6 4C91      		ld r20,X
 5686 0de8 1197      		sbiw r26,1
 5687 0dea 50E0      		ldi r21,0
 5688 0dec 542F      		mov r21,r20
 5689 0dee 4427      		clr r20
 5690 0df0 8C91      		ld r24,X
 5691 0df2 482B      		or r20,r24
 5692 0df4 6FA1      		ldd r22,Y+39
 5693 0df6 78A5      		ldd r23,Y+40
 5694 0df8 89A5      		ldd r24,Y+41
 5695 0dfa 9AA5      		ldd r25,Y+42
 5696 0dfc 00D0      		rcall gba_flash_write_bus_cycle
 5697               	.LVL606:
1015:main.c        **** 					}
 5698               		.loc 3 1015 0 discriminator 3
 5699 0dfe 8FA1      		ldd r24,Y+39
 5700 0e00 98A5      		ldd r25,Y+40
 5701 0e02 A9A5      		ldd r26,Y+41
 5702 0e04 BAA5      		ldd r27,Y+42
 5703 0e06 0196      		adiw r24,1
 5704 0e08 A11D      		adc r26,__zero_reg__
 5705 0e0a B11D      		adc r27,__zero_reg__
 5706 0e0c 8FA3      		std Y+39,r24
 5707 0e0e 98A7      		std Y+40,r25
 5708 0e10 A9A7      		std Y+41,r26
 5709 0e12 BAA7      		std Y+42,r27
 5710               	.LVL607:
1012:main.c        **** 						combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 5711               		.loc 3 1012 0 discriminator 3
 5712 0e14 92E0      		ldi r25,2
 5713 0e16 A90E      		add r10,r25
 5714 0e18 B11C      		adc r11,__zero_reg__
 5715               	.LVL608:
 5716 0e1a A9A1      		ldd r26,Y+33
 5717 0e1c BAA1      		ldd r27,Y+34
 5718 0e1e 1296      		adiw r26,2
 5719 0e20 BAA3      		std Y+34,r27
 5720 0e22 A9A3      		std Y+33,r26
 5721 0e24 B0E4      		ldi r27,64
 5722 0e26 AB16      		cp r10,r27
 5723 0e28 B104      		cpc r11,__zero_reg__
 5724 0e2a 01F4      		brne .L240
 5725 0e2c D301      		movw r26,r6
 5726 0e2e C201      		movw r24,r4
 5727               	.LVL609:
 5728 0e30 8096      		adiw r24,32
 5729 0e32 A11D      		adc r26,__zero_reg__
 5730 0e34 B11D      		adc r27,__zero_reg__
 5731 0e36 89A3      		std Y+33,r24
 5732 0e38 9AA3      		std Y+34,r25
 5733 0e3a ABA3      		std Y+35,r26
 5734 0e3c BCA3      		std Y+36,r27
 5735               	.LBE345:
1019:main.c        **** 					gba_flash_write_bus_cycle(address-32+1, 0xD0);
 5736               		.loc 3 1019 0
 5737 0e3e 40ED      		ldi r20,lo8(-48)
 5738 0e40 50E0      		ldi r21,0
 5739 0e42 C301      		movw r24,r6
 5740 0e44 B201      		movw r22,r4
 5741 0e46 00D0      		rcall gba_flash_write_bus_cycle
 5742               	.LVL610:
1020:main.c        **** 					
 5743               		.loc 3 1020 0
 5744 0e48 40ED      		ldi r20,lo8(-48)
 5745 0e4a 50E0      		ldi r21,0
 5746 0e4c C701      		movw r24,r14
 5747 0e4e B601      		movw r22,r12
 5748 0e50 00D0      		rcall gba_flash_write_bus_cycle
 5749               	.LVL611:
 5750               	.L241:
1023:main.c        **** 						if (writingTimedout == 1) {
 5751               		.loc 3 1023 0
 5752 0e52 69A1      		ldd r22,Y+33
 5753 0e54 7AA1      		ldd r23,Y+34
 5754 0e56 8BA1      		ldd r24,Y+35
 5755 0e58 9CA1      		ldd r25,Y+36
 5756 0e5a 00D0      		rcall gba_read_16bit_data
 5757               	.LVL612:
 5758 0e5c 8038      		cpi r24,-128
 5759 0e5e 9105      		cpc r25,__zero_reg__
 5760 0e60 01F0      		breq .L242
1024:main.c        **** 							break;
 5761               		.loc 3 1024 0
 5762 0e62 8091 0000 		lds r24,writingTimedout
 5763 0e66 8130      		cpi r24,lo8(1)
 5764 0e68 01F4      		brne .L241
 5765               	.L242:
1028:main.c        **** 						if (writingTimedout == 1) {
 5766               		.loc 3 1028 0
 5767 0e6a 91E2      		ldi r25,33
 5768 0e6c 490E      		add r4,r25
 5769 0e6e 511C      		adc r5,__zero_reg__
 5770 0e70 611C      		adc r6,__zero_reg__
 5771 0e72 711C      		adc r7,__zero_reg__
 5772               	.L343:
 5773 0e74 C301      		movw r24,r6
 5774 0e76 B201      		movw r22,r4
 5775 0e78 00D0      		rcall gba_read_16bit_data
 5776               	.LVL613:
 5777 0e7a 8038      		cpi r24,-128
 5778 0e7c 9105      		cpc r25,__zero_reg__
 5779 0e7e 01F0      		breq .L239
1029:main.c        **** 							break;
 5780               		.loc 3 1029 0
 5781 0e80 8091 0000 		lds r24,writingTimedout
 5782 0e84 8130      		cpi r24,lo8(1)
 5783 0e86 01F4      		brne .L343
 5784 0e88 00C0      		rjmp .L239
 5785               	.LVL614:
 5786               	.L257:
 5787 0e8a 49A2      		std Y+33,r4
 5788 0e8c 5AA2      		std Y+34,r5
 5789 0e8e 6BA2      		std Y+35,r6
 5790 0e90 7CA2      		std Y+36,r7
 5791               	.LVL615:
 5792               	.L239:
 5793 0e92 005C      		subi r16,-64
 5794 0e94 1F4F      		sbci r17,-1
 5795               	.LBE344:
 973:main.c        **** 				// Set address lines as outputs
 5796               		.loc 3 973 0 discriminator 2
 5797 0e96 A0E0      		ldi r26,hi8(receivedBuffer+256)
 5798 0e98 0030      		cpi r16,lo8(receivedBuffer+256)
 5799 0e9a 1A07      		cpc r17,r26
 5800 0e9c 01F0      		breq .L359
 5801 0e9e 49A0      		ldd r4,Y+33
 5802 0ea0 5AA0      		ldd r5,Y+34
 5803 0ea2 6BA0      		ldd r6,Y+35
 5804 0ea4 7CA0      		ldd r7,Y+36
 5805 0ea6 00C0      		rjmp .L245
 5806               	.L359:
 5807               	.LBE343:
1038:main.c        **** 		}
 5808               		.loc 3 1038 0
 5809 0ea8 00D0      		rcall check_if_timed_out
 5810               	.LVL616:
 5811 0eaa 49A0      		ldd r4,Y+33
 5812 0eac 5AA0      		ldd r5,Y+34
 5813 0eae 6BA0      		ldd r6,Y+35
 5814 0eb0 7CA0      		ldd r7,Y+36
 5815 0eb2 00C0      		rjmp .L106
 5816               	.LVL617:
 5817               	.L233:
1042:main.c        **** 			uint16_t status = 0;
 5818               		.loc 3 1042 0
 5819 0eb4 9837      		cpi r25,lo8(120)
 5820 0eb6 01F0      		breq .+2
 5821 0eb8 00C0      		rjmp .L246
 5822               	.LVL618:
 5823               	.LBB346:
1045:main.c        **** 			usart_read_bytes(64);
 5824               		.loc 3 1045 0
 5825 0eba 939A      		sbi 0x12,3
1046:main.c        **** 			start_timeout_timer();
 5826               		.loc 3 1046 0
 5827 0ebc 80E4      		ldi r24,lo8(64)
 5828 0ebe 90E0      		ldi r25,0
 5829               	.LVL619:
 5830 0ec0 00D0      		rcall usart_read_bytes
 5831               	.LVL620:
1047:main.c        **** 			
 5832               		.loc 3 1047 0
 5833 0ec2 00D0      		rcall start_timeout_timer
 5834               	.LVL621:
 5835 0ec4 90E0      		ldi r25,lo8(receivedBuffer)
 5836 0ec6 E92E      		mov r14,r25
 5837 0ec8 90E0      		ldi r25,hi8(receivedBuffer)
 5838 0eca F92E      		mov r15,r25
 5839 0ecc 6301      		movw r12,r6
 5840 0ece 5201      		movw r10,r4
1043:main.c        **** 			
 5841               		.loc 3 1043 0
 5842 0ed0 812C      		mov r8,__zero_reg__
 5843               	.LVL622:
 5844               	.L250:
 5845               	.LBB229:
 5846               	.LBB228:
 5847               		.loc 3 1054 0
 5848 0ed2 94BA      		out 0x14,r9
1055:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 5849               		.loc 3 1055 0
 5850 0ed4 9ABA      		out 0x1a,r9
1056:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 5851               		.loc 3 1056 0
 5852 0ed6 97BA      		out 0x17,r9
1052:main.c        **** 					// Set address lines as outputs
 5853               		.loc 3 1052 0
 5854 0ed8 87FC      		sbrc r8,7
 5855 0eda 00C0      		rjmp .L360
1057:main.c        **** 					
1058:main.c        **** 					gba_flash_write_bus_cycle(address, 0x70); // Query status register
 5856               		.loc 3 1058 0
 5857 0edc 40E7      		ldi r20,lo8(112)
 5858 0ede 50E0      		ldi r21,0
 5859 0ee0 C601      		movw r24,r12
 5860 0ee2 B501      		movw r22,r10
 5861 0ee4 00D0      		rcall gba_flash_write_bus_cycle
 5862               	.LVL623:
1059:main.c        **** 					status = gba_read_16bit_data(address);
 5863               		.loc 3 1059 0
 5864 0ee6 C601      		movw r24,r12
 5865 0ee8 B501      		movw r22,r10
 5866 0eea 00D0      		rcall gba_read_16bit_data
 5867               	.LVL624:
 5868 0eec 882E      		mov r8,r24
 5869 0eee 00C0      		rjmp .L250
 5870               	.L360:
1060:main.c        **** 				}
1061:main.c        **** 				
1062:main.c        **** 				// Set address lines as outputs
1063:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
1064:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
1065:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
1066:main.c        **** 				
1067:main.c        **** 				// Write one word to flash
1068:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 5871               		.loc 3 1068 0 discriminator 2
 5872 0ef0 F701      		movw r30,r14
 5873 0ef2 0181      		ldd r16,Z+1
 5874 0ef4 10E0      		ldi r17,0
 5875 0ef6 102F      		mov r17,r16
 5876 0ef8 0027      		clr r16
 5877 0efa 8081      		ld r24,Z
 5878 0efc 082B      		or r16,r24
 5879               	.LVL625:
1069:main.c        **** 				gba_flash_write_bus_cycle(address, 0x10);
 5880               		.loc 3 1069 0 discriminator 2
 5881 0efe 40E1      		ldi r20,lo8(16)
 5882 0f00 50E0      		ldi r21,0
 5883 0f02 C601      		movw r24,r12
 5884 0f04 B501      		movw r22,r10
 5885 0f06 00D0      		rcall gba_flash_write_bus_cycle
 5886               	.LVL626:
1070:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5887               		.loc 3 1070 0 discriminator 2
 5888 0f08 A801      		movw r20,r16
 5889 0f0a C601      		movw r24,r12
 5890 0f0c B501      		movw r22,r10
 5891 0f0e 00D0      		rcall gba_flash_write_bus_cycle
 5892               	.LVL627:
 5893               	.LBB226:
 5894               	.LBB227:
 5895               		.loc 2 276 0 discriminator 2
 5896 0f10 FAE6      		ldi r31,lo8(106)
 5897 0f12 FA95      	1:	dec r31
 5898 0f14 01F4      		brne 1b
 5899 0f16 00C0      		rjmp .
 5900               	.LVL628:
 5901               	.LBE227:
 5902               	.LBE226:
1071:main.c        **** 				_delay_us(40);
1072:main.c        **** 				
1073:main.c        **** 				address++;
 5903               		.loc 3 1073 0 discriminator 2
 5904 0f18 2FEF      		ldi r18,-1
 5905 0f1a A21A      		sub r10,r18
 5906 0f1c B20A      		sbc r11,r18
 5907 0f1e C20A      		sbc r12,r18
 5908 0f20 D20A      		sbc r13,r18
 5909               	.LVL629:
 5910 0f22 82E0      		ldi r24,2
 5911 0f24 E80E      		add r14,r24
 5912 0f26 F11C      		adc r15,__zero_reg__
 5913               	.LVL630:
 5914               	.LBE228:
1050:main.c        **** 				// Wait until ready
 5915               		.loc 3 1050 0 discriminator 2
 5916 0f28 A0E0      		ldi r26,lo8(receivedBuffer+64)
 5917 0f2a B0E0      		ldi r27,hi8(receivedBuffer+64)
 5918 0f2c AE15      		cp r26,r14
 5919 0f2e BF05      		cpc r27,r15
 5920 0f30 01F4      		brne .L250
 5921               	.LVL631:
 5922               	.L347:
 5923 0f32 B0E2      		ldi r27,32
 5924 0f34 4B0E      		add r4,r27
 5925 0f36 511C      		adc r5,__zero_reg__
 5926 0f38 611C      		adc r6,__zero_reg__
 5927 0f3a 711C      		adc r7,__zero_reg__
 5928               	.LVL632:
 5929               	.L348:
 5930               	.LBE229:
1074:main.c        **** 			}
1075:main.c        **** 			
1076:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 5931               		.loc 3 1076 0
 5932 0f3c 00D0      		rcall check_if_timed_out
 5933               	.LVL633:
 5934               	.LBE346:
 5935 0f3e 00C0      		rjmp .L106
 5936               	.LVL634:
 5937               	.L246:
1077:main.c        **** 		}
1078:main.c        **** 		
1079:main.c        **** 		// ---------- General commands ----------
1080:main.c        **** 		// Set any pin as input/output
1081:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
1082:main.c        **** 		/*else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
1083:main.c        **** 			char portChar = USART_Receive();
1084:main.c        **** 			usart_read_chars();
1085:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
1086:main.c        **** 			
1087:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1088:main.c        **** 			if (receivedChar == SET_INPUT) {
1089:main.c        **** 				if (portChar == 'A') {
1090:main.c        **** 					DDRA &= ~(setValue);
1091:main.c        **** 				}
1092:main.c        **** 				else if (portChar == 'B') {
1093:main.c        **** 					DDRB &= ~(setValue);
1094:main.c        **** 				}
1095:main.c        **** 				else if (portChar == 'C') {
1096:main.c        **** 					DDRC &= ~(setValue);
1097:main.c        **** 				}
1098:main.c        **** 				else if (portChar == 'D') {
1099:main.c        **** 					DDRD &= ~(setValue);
1100:main.c        **** 				}
1101:main.c        **** 				else if (portChar == 'E') {
1102:main.c        **** 					DDRE &= ~(setValue);
1103:main.c        **** 				}
1104:main.c        **** 			}
1105:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
1106:main.c        **** 				if (portChar == 'A') {
1107:main.c        **** 					DDRA |= (setValue);
1108:main.c        **** 				}
1109:main.c        **** 				else if (portChar == 'B') {
1110:main.c        **** 					DDRB |= (setValue);
1111:main.c        **** 				}
1112:main.c        **** 				else if (portChar == 'C') {
1113:main.c        **** 					DDRC |= (setValue);
1114:main.c        **** 				}
1115:main.c        **** 				else if (portChar == 'D') {
1116:main.c        **** 					DDRD |= (setValue);
1117:main.c        **** 				}
1118:main.c        **** 				else if (portChar == 'E') {
1119:main.c        **** 					DDRE |= (setValue);
1120:main.c        **** 				}
1121:main.c        **** 			}
1122:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1123:main.c        **** 		}
1124:main.c        **** 		
1125:main.c        **** 		// Set pin output as low
1126:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
1127:main.c        **** 			char portChar = USART_Receive();			
1128:main.c        **** 			usart_read_chars();
1129:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
1130:main.c        **** 			
1131:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1132:main.c        **** 			if (portChar == 'A') {
1133:main.c        **** 				PORTA &= ~(setValue);
1134:main.c        **** 			}
1135:main.c        **** 			else if (portChar == 'B') {
1136:main.c        **** 				PORTB &= ~(setValue);
1137:main.c        **** 			}
1138:main.c        **** 			else if (portChar == 'C') {
1139:main.c        **** 				PORTC &= ~(setValue);
1140:main.c        **** 			}
1141:main.c        **** 			else if (portChar == 'D') {
1142:main.c        **** 				PORTD &= ~(setValue);
1143:main.c        **** 			}
1144:main.c        **** 			else if (portChar == 'E') {
1145:main.c        **** 				PORTE &= ~(setValue);
1146:main.c        **** 			}
1147:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1148:main.c        **** 		}
1149:main.c        **** 		
1150:main.c        **** 		// Set pin output as high
1151:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
1152:main.c        **** 			char portChar = USART_Receive();			
1153:main.c        **** 			usart_read_chars();
1154:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
1155:main.c        **** 			
1156:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1157:main.c        **** 			if (portChar == 'A') {
1158:main.c        **** 				PORTA |= (setValue);
1159:main.c        **** 			}
1160:main.c        **** 			else if (portChar == 'B') {
1161:main.c        **** 				PORTB |= (setValue);
1162:main.c        **** 			}
1163:main.c        **** 			else if (portChar == 'C') {
1164:main.c        **** 				PORTC |= (setValue);
1165:main.c        **** 			}
1166:main.c        **** 			else if (portChar == 'D') {
1167:main.c        **** 				PORTD |= (setValue);
1168:main.c        **** 			}
1169:main.c        **** 			else if (portChar == 'E') {
1170:main.c        **** 				PORTE |= (setValue);
1171:main.c        **** 			}
1172:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1173:main.c        **** 		}
1174:main.c        **** 		
1175:main.c        **** 		// Read all pins of a PORT and return the value
1176:main.c        **** 		else if (receivedChar == READ_INPUT) {
1177:main.c        **** 			char portChar = USART_Receive();			
1178:main.c        **** 			
1179:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
1180:main.c        **** 			if (portChar == 'A') {
1181:main.c        **** 				USART_Transmit(PINA);
1182:main.c        **** 			}
1183:main.c        **** 			else if (portChar == 'B') {
1184:main.c        **** 				USART_Transmit(PINB);
1185:main.c        **** 			}
1186:main.c        **** 			else if (portChar == 'C') {
1187:main.c        **** 				USART_Transmit(PINC);
1188:main.c        **** 			}
1189:main.c        **** 			else if (portChar == 'D') {
1190:main.c        **** 				USART_Transmit(PIND);
1191:main.c        **** 			}
1192:main.c        **** 			else if (portChar == 'E') {
1193:main.c        **** 				USART_Transmit(PINE);
1194:main.c        **** 			}
1195:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1196:main.c        **** 		}*/
1197:main.c        **** 		
1198:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
1199:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5938               		.loc 3 1199 0
 5939 0f40 9D34      		cpi r25,lo8(77)
 5940 0f42 01F4      		brne .L251
 5941               	.LBB347:
1200:main.c        **** 			char commonChar = USART_Receive();
 5942               		.loc 3 1200 0
 5943 0f44 00D0      		rcall USART_Receive
 5944               	.LVL635:
1201:main.c        **** 			if (commonChar == '1') {
 5945               		.loc 3 1201 0
 5946 0f46 8133      		cpi r24,lo8(49)
 5947 0f48 01F4      		brne .L361
1202:main.c        **** 				resetCommonLines = 1;
 5948               		.loc 3 1202 0
 5949 0f4a A1E0      		ldi r26,lo8(1)
 5950 0f4c AEA3      		std Y+38,r26
 5951 0f4e 00C0      		rjmp .L338
 5952               	.L361:
1203:main.c        **** 			}
1204:main.c        **** 			else if (commonChar == '0') {
 5953               		.loc 3 1204 0
 5954 0f50 8033      		cpi r24,lo8(48)
 5955 0f52 01F0      		breq .+2
 5956 0f54 00C0      		rjmp .L106
1205:main.c        **** 				resetCommonLines = 0;
 5957               		.loc 3 1205 0
 5958 0f56 1EA2      		std Y+38,__zero_reg__
 5959 0f58 00C0      		rjmp .L107
 5960               	.LVL636:
 5961               	.L251:
 5962               	.LBE347:
1206:main.c        **** 			}
1207:main.c        **** 		}
1208:main.c        **** 		
1209:main.c        **** 		// Send back the PCB version number
1210:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5963               		.loc 3 1210 0
 5964 0f5a 9836      		cpi r25,lo8(104)
 5965 0f5c 01F4      		brne .L252
1211:main.c        **** 			USART_Transmit(PCB_VERSION);
 5966               		.loc 3 1211 0
 5967 0f5e 82E0      		ldi r24,lo8(2)
 5968               	.LVL637:
 5969 0f60 00C0      		rjmp .L344
 5970               	.LVL638:
 5971               	.L252:
1212:main.c        **** 		}
1213:main.c        **** 		
1214:main.c        **** 		// Send back the firmware version number
1215:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5972               		.loc 3 1215 0
 5973 0f62 9635      		cpi r25,lo8(86)
 5974 0f64 01F4      		brne .L253
1216:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5975               		.loc 3 1216 0
 5976 0f66 86E1      		ldi r24,lo8(22)
 5977               	.LVL639:
 5978               	.L344:
 5979 0f68 00D0      		rcall USART_Transmit
 5980               	.LVL640:
 5981 0f6a 00C0      		rjmp .L106
 5982               	.LVL641:
 5983               	.L253:
1217:main.c        **** 		}
1218:main.c        **** 		
1219:main.c        **** 		// Reset the AVR if it matches the number
1220:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5984               		.loc 3 1220 0
 5985 0f6c 9A32      		cpi r25,lo8(42)
 5986 0f6e 01F0      		breq .+2
 5987 0f70 00C0      		rjmp .L106
 5988               	.LBB348:
1221:main.c        **** 			usart_read_chars();
 5989               		.loc 3 1221 0
 5990 0f72 00D0      		rcall usart_read_chars
 5991               	.LVL642:
1222:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5992               		.loc 3 1222 0
 5993 0f74 40E1      		ldi r20,lo8(16)
 5994 0f76 50E0      		ldi r21,0
 5995 0f78 60E0      		ldi r22,0
 5996 0f7a 70E0      		ldi r23,0
 5997 0f7c 80E0      		ldi r24,lo8(receivedBuffer)
 5998 0f7e 90E0      		ldi r25,hi8(receivedBuffer)
 5999 0f80 00D0      		rcall strtol
 6000               	.LVL643:
1223:main.c        **** 			if (resetValue == RESET_VALUE) {
 6001               		.loc 3 1223 0
 6002 0f82 613E      		cpi r22,-31
 6003 0f84 754E      		sbci r23,-27
 6004 0f86 8740      		sbci r24,7
 6005 0f88 9105      		cpc r25,__zero_reg__
 6006 0f8a 01F0      		breq .+2
 6007 0f8c 00C0      		rjmp .L106
1224:main.c        **** 				// Clear watchdog flag
1225:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 6008               		.loc 3 1225 0
 6009 0f8e 84B7      		in r24,0x34
 6010 0f90 877F      		andi r24,lo8(-9)
 6011 0f92 84BF      		out 0x34,r24
1226:main.c        **** 				
1227:main.c        **** 				// Start timed sequence
1228:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 6012               		.loc 3 1228 0
 6013 0f94 88E1      		ldi r24,lo8(24)
 6014 0f96 81BD      		out 0x21,r24
1229:main.c        **** 				
1230:main.c        **** 				// Reset in 250 ms
1231:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 6015               		.loc 3 1231 0
 6016 0f98 8CE0      		ldi r24,lo8(12)
 6017 0f9a 81BD      		out 0x21,r24
 6018               	.LVL644:
 6019               	.LBB349:
 6020               	.LBB350:
 6021               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 6022               		.loc 4 105 0
 6023 0f9c 8FEF      		ldi r24,lo8(-1)
 6024 0f9e 9FEF      		ldi r25,lo8(-1)
 6025               	/* #APP */
 6026               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 6027 0fa0 0197      		1: sbiw r24,1
 6028 0fa2 01F4      		brne 1b
 6029               	 ;  0 "" 2
 6030               	.LVL645:
 6031               	/* #NOAPP */
 6032 0fa4 00C0      		rjmp .L106
 6033               	.LBE350:
 6034               	.LBE349:
 6035               	.LBE348:
 6036               		.cfi_endproc
 6037               	.LFE51:
 6039               		.text
 6040               	.global	__vector_6
 6042               	__vector_6:
 6043               	.LFB52:
1232:main.c        **** 				
1233:main.c        **** 				// Wait for reset
1234:main.c        **** 				_delay_loop_2(65535);
1235:main.c        **** 			}
1236:main.c        **** 		}
1237:main.c        **** 	}
1238:main.c        **** }
1239:main.c        **** 
1240:main.c        **** // Timeout after ~500ms which also blinks the LED
1241:main.c        **** ISR(TIMER1_OVF_vect) {
 6044               		.loc 3 1241 0
 6045               		.cfi_startproc
 6046 07e2 1F92      		push r1
 6047               	.LCFI49:
 6048               		.cfi_def_cfa_offset 3
 6049               		.cfi_offset 1, -2
 6050 07e4 0F92      		push r0
 6051               	.LCFI50:
 6052               		.cfi_def_cfa_offset 4
 6053               		.cfi_offset 0, -3
 6054 07e6 0FB6      		in r0,__SREG__
 6055 07e8 0F92      		push r0
 6056 07ea 1124      		clr __zero_reg__
 6057 07ec 8F93      		push r24
 6058               	.LCFI51:
 6059               		.cfi_def_cfa_offset 5
 6060               		.cfi_offset 24, -4
 6061 07ee 9F93      		push r25
 6062               	.LCFI52:
 6063               		.cfi_def_cfa_offset 6
 6064               		.cfi_offset 25, -5
 6065               	/* prologue: Signal */
 6066               	/* frame size = 0 */
 6067               	/* stack size = 5 */
 6068               	.L__stack_usage = 5
1242:main.c        **** 	PORTD ^= (1<<ACTIVITY_LED);
 6069               		.loc 3 1242 0
 6070 07f0 92B3      		in r25,0x12
 6071 07f2 88E0      		ldi r24,lo8(8)
 6072 07f4 8927      		eor r24,r25
 6073 07f6 82BB      		out 0x12,r24
1243:main.c        **** 	writingTimedout = 1;
 6074               		.loc 3 1243 0
 6075 07f8 81E0      		ldi r24,lo8(1)
 6076 07fa 8093 0000 		sts writingTimedout,r24
 6077               	/* epilogue start */
1244:main.c        **** }...
 6078               		.loc 3 1244 0
 6079 07fe 9F91      		pop r25
 6080 0800 8F91      		pop r24
 6081 0802 0F90      		pop r0
 6082 0804 0FBE      		out __SREG__,r0
 6083 0806 0F90      		pop r0
 6084 0808 1F90      		pop r1
 6085 080a 1895      		reti
 6086               		.cfi_endproc
 6087               	.LFE52:
 6089               	.global	writingTimedout
 6090               		.section .bss
 6093               	writingTimedout:
 6094 0000 00        		.zero	1
 6095               	.global	lastBankAccessed
 6098               	lastBankAccessed:
 6099 0001 00        		.zero	1
 6100               	.global	flashBank1CommandWrites
 6103               	flashBank1CommandWrites:
 6104 0002 00        		.zero	1
 6105               		.comm	flashWriteCycle,12,1
 6106               		.comm	flashWriteWePin,1,1
 6107               		.comm	flashChipIdBuffer,2,1
 6108               		.comm	eepromBuffer,8,1
 6109               		.comm	receivedChar,1,1
 6110               		.comm	receivedBuffer,256,1
 6111               		.text
 6112               	.Letext0:
 6113               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 6114               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1467   .text:0000040a gb_flash_read_byte_fast
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1499   .text:00000416 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1578   .text:00000448 gb_flash_write_bus_cycle_fast
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1648   .text:0000046e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:6093   .bss:00000000 writingTimedout
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1751   .text:000004d8 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:6103   .bss:00000002 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:6098   .bss:00000001 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:1876   .text:0000055a gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2042   .text:000005f4 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2108   .text:00000624 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2232   .text:00000684 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2354   .text:000006e0 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2465   .text:0000073c start_timeout_timer
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2488   .text:0000074c stop_timeout_timer
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2511   .text:0000075a check_if_timed_out
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2543   .text:0000076c setup
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:2665   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\cchAsuuI.s:6042   .text:000007e2 __vector_6

UNDEFINED SYMBOLS
strtol
atoi
__do_clear_bss
