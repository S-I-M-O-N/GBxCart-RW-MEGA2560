   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW Mini
   3:setup.c       ****  PCB version: 1.0
   4:setup.c       ****  Firmware version: R16
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 21/01/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define ACTIVITY_LED PD3
  28:setup.c       **** 
  29:setup.c       **** #define WR_PIN PD6
  30:setup.c       **** #define RD_PIN PD5
  31:setup.c       **** #define CS_MREQ_PIN PD4
  32:setup.c       **** #define CS2_PIN PE2
  33:setup.c       **** #define AUDIO_PIN PE1
  34:setup.c       **** 
  35:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  36:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  37:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  38:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  39:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  40:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  41:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  42:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  43:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  44:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  45:setup.c       **** 
  46:setup.c       **** #define GB_MODE 1
  47:setup.c       **** 
  48:setup.c       **** // GB/GBC
  49:setup.c       **** #define PORT_ADDR7_0 PORTB
  50:setup.c       **** #define PORT_ADDR15_8 PORTA
  51:setup.c       **** #define PORT_DATA7_0 PORTC
  52:setup.c       **** 
  53:setup.c       **** #define DDR_ADDR7_0 DDRB
  54:setup.c       **** #define DDR_ADDR15_8 DDRA
  55:setup.c       **** #define DDR_DATA7_0 DDRC
  56:setup.c       **** 
  57:setup.c       **** #define PIN_ADDR7_0 PINB
  58:setup.c       **** #define PIN_ADDR15_8 PINA
  59:setup.c       **** #define PIN_DATA7_0 PINC
  60:setup.c       **** 
  61:setup.c       **** #define BANK_WRITE 0
  62:setup.c       **** #define MEMORY_WRITE 1
  63:setup.c       **** 
  64:setup.c       **** 
  65:setup.c       **** // GB/GBC commands
  66:setup.c       **** #define SET_START_ADDRESS 'A'
  67:setup.c       **** #define READ_ROM_RAM 'R'
  68:setup.c       **** #define WRITE_RAM 'W'
  69:setup.c       **** #define SET_BANK 'B'
  70:setup.c       **** #define GB_CART_MODE 'G'
  71:setup.c       **** 
  72:setup.c       **** // Flash Cart commands
  73:setup.c       **** #define GB_FLASH_WE_PIN 'P'
  74:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
  75:setup.c       **** 	#define WE_AS_WR_PIN 'W'
  76:setup.c       **** 
  77:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
  78:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
  79:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
  80:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
  81:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
  82:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
  83:setup.c       **** 
  84:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
  85:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
  86:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
  87:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
  88:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
  89:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
  90:setup.c       **** 
  91:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
  92:setup.c       **** 
  93:setup.c       **** #define D0D1_NOT_SWAPPED 0
  94:setup.c       **** #define D0D1_SWAPPED 1
  95:setup.c       **** 
  96:setup.c       **** // General commands
  97:setup.c       **** #define SEND_ACK '1'
  98:setup.c       **** #define CART_MODE 'C'
  99:setup.c       **** #define SET_INPUT 'I'
 100:setup.c       **** #define SET_OUTPUT 'O'
 101:setup.c       **** #define SET_OUTPUT_LOW 'L'
 102:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 103:setup.c       **** #define READ_INPUT 'D'
 104:setup.c       **** #define RESET_COMMON_LINES 'M'
 105:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 106:setup.c       **** #define READ_PCB_VERSION 'h'
 107:setup.c       **** 
 108:setup.c       **** #define RESET_AVR '*'
 109:setup.c       **** #define RESET_VALUE 0x7E5E1
 110:setup.c       **** 
 111:setup.c       **** 
 112:setup.c       **** char receivedBuffer[256];
 113:setup.c       **** char receivedChar;
 114:setup.c       **** 
 115:setup.c       **** char flashWriteWePin;
 116:setup.c       **** uint16_t flashWriteCycle[3][2];
 117:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 118:setup.c       **** uint8_t lastBankAccessed = 0;
 119:setup.c       **** 
 120:setup.c       **** uint8_t cartMode = GB_MODE;
 121:setup.c       **** 
 122:setup.c       **** // Receive USART data
 123:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 123 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 124:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 124 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 125:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 125 0
  26 0004 8CB1      		in r24,0xc
 126:setup.c       **** }
  27               		.loc 1 126 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 127:setup.c       **** 
 128:setup.c       **** // Transmit USART data
 129:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 129 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 130:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 130 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 131:setup.c       **** 	UDR = data;
  47               		.loc 1 131 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 132:setup.c       **** }
 133:setup.c       **** 
 134:setup.c       **** // Read 1-256 bytes from the USART 
 135:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 135 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB86:
 136:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 136 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 136 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 137:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 137 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE86:
 138:setup.c       **** 	}
 139:setup.c       **** }
 106               		.loc 1 139 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 140:setup.c       **** 
 141:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 142:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 142 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 143:setup.c       **** 	int x = 0;
 144:setup.c       **** 	while (1) {
 145:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 145 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 146:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 146 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 147:setup.c       **** 			break;
 148:setup.c       **** 		}
 149:setup.c       **** 		x++;
 150:setup.c       **** 	}
 151:setup.c       **** }
 148               		.loc 1 151 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 152:setup.c       **** 
 153:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 154:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 154 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 155:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 155 0
 167 0050 3A9A      		sbi 0x7,2
 156:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 156 0
 169 0052 949A      		sbi 0x12,4
 157:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 157 0
 171 0054 959A      		sbi 0x12,5
 158:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 158 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 159:setup.c       **** }
 160:setup.c       **** 
 161:setup.c       **** 
 162:setup.c       **** 
 163:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 164:setup.c       **** 
 165:setup.c       **** // Set Gameboy mode
 166:setup.c       **** void gb_mode(void) {
 182               		.loc 1 166 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 167:setup.c       **** 	// Set inputs
 168:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 168 0
 189 005a 15BA      		out 0x15,__zero_reg__
 169:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 169 0
 191 005c 14BA      		out 0x14,__zero_reg__
 170:setup.c       **** 	
 171:setup.c       **** 	// Set outputs
 172:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 172 0
 193 005e 18BA      		out 0x18,__zero_reg__
 173:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 173 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 174:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 174 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 175:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 175 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 176:setup.c       **** }
 177:setup.c       **** 
 178:setup.c       **** // Set the 16 bit address on A15-0
 179:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 179 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 180:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 180 0
 217 006a 9BBB      		out 0x1b,r25
 181:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 181 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 182:setup.c       **** }
 183:setup.c       **** 
 184:setup.c       **** // Set the address and read a byte from the 8 bit data line
 185:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 185 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 186:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 186 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 187:setup.c       **** 	
 188:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 188 0
 239 0072 9498      		cbi 0x12,4
 189:setup.c       **** 	rdPin_low;
 240               		.loc 1 189 0
 241 0074 9598      		cbi 0x12,5
 190:setup.c       **** 	
 191:setup.c       **** 	asm volatile("nop"); // Delay a little (At 8MHz - minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 191 0
 243               	/* #APP */
 244               	 ;  191 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 192:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 192 0
 248               	 ;  192 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 193:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 193 0
 252               	 ;  193 "setup.c" 1
 253 007a 0000      		nop
 254               	 ;  0 "" 2
 194:setup.c       **** 	asm volatile("nop");
 255               		.loc 1 194 0
 256               	 ;  194 "setup.c" 1
 257 007c 0000      		nop
 258               	 ;  0 "" 2
 195:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 259               		.loc 1 195 0
 260               	/* #NOAPP */
 261 007e 83B3      		in r24,0x13
 262               	.LVL17:
 196:setup.c       **** 	
 197:setup.c       **** 	rdPin_high;
 263               		.loc 1 197 0
 264 0080 959A      		sbi 0x12,5
 198:setup.c       **** 	cs_mreqPin_high;
 265               		.loc 1 198 0
 266 0082 949A      		sbi 0x12,4
 199:setup.c       **** 	
 200:setup.c       **** 	return data;
 201:setup.c       **** }
 267               		.loc 1 201 0
 268 0084 0895      		ret
 269               		.cfi_endproc
 270               	.LFE19:
 272               	.global	write_8bit_data
 274               	write_8bit_data:
 275               	.LFB20:
 202:setup.c       **** 
 203:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 204:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 276               		.loc 1 204 0
 277               		.cfi_startproc
 278               	.LVL18:
 279 0086 CF93      		push r28
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 28, -2
 283 0088 DF93      		push r29
 284               	.LCFI7:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 29, -3
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 2 */
 290               	.L__stack_usage = 2
 291 008a D62F      		mov r29,r22
 292 008c C42F      		mov r28,r20
 205:setup.c       **** 	set_16bit_address(address);
 293               		.loc 1 205 0
 294 008e 00D0      		rcall set_16bit_address
 295               	.LVL19:
 206:setup.c       **** 	
 207:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 296               		.loc 1 207 0
 297 0090 8FEF      		ldi r24,lo8(-1)
 298 0092 84BB      		out 0x14,r24
 208:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 299               		.loc 1 208 0
 300 0094 D5BB      		out 0x15,r29
 209:setup.c       **** 	
 210:setup.c       **** 	// Pulse WR and mREQ if the type matches
 211:setup.c       **** 	wrPin_low;
 301               		.loc 1 211 0
 302 0096 9698      		cbi 0x12,6
 212:setup.c       **** 	if (type == MEMORY_WRITE) {
 303               		.loc 1 212 0
 304 0098 C130      		cpi r28,lo8(1)
 305 009a 01F4      		brne .L21
 213:setup.c       **** 		cs_mreqPin_low;
 306               		.loc 1 213 0
 307 009c 9498      		cbi 0x12,4
 308               	.L21:
 214:setup.c       **** 	}
 215:setup.c       **** 	
 216:setup.c       **** 	asm volatile("nop");
 309               		.loc 1 216 0
 310               	/* #APP */
 311               	 ;  216 "setup.c" 1
 312 009e 0000      		nop
 313               	 ;  0 "" 2
 217:setup.c       **** 	asm volatile("nop");
 314               		.loc 1 217 0
 315               	 ;  217 "setup.c" 1
 316 00a0 0000      		nop
 317               	 ;  0 "" 2
 218:setup.c       **** 	
 219:setup.c       **** 	if (type == MEMORY_WRITE) {
 318               		.loc 1 219 0
 319               	/* #NOAPP */
 320 00a2 C130      		cpi r28,lo8(1)
 321 00a4 01F4      		brne .L22
 220:setup.c       **** 		cs_mreqPin_high;
 322               		.loc 1 220 0
 323 00a6 949A      		sbi 0x12,4
 324               	.L22:
 221:setup.c       **** 	}
 222:setup.c       **** 	wrPin_high;
 325               		.loc 1 222 0
 326 00a8 969A      		sbi 0x12,6
 223:setup.c       **** 	
 224:setup.c       **** 	// Clear data outputs and set data pins as inputs
 225:setup.c       **** 	PORT_DATA7_0 = 0;
 327               		.loc 1 225 0
 328 00aa 15BA      		out 0x15,__zero_reg__
 226:setup.c       **** 	DDR_DATA7_0 = 0;
 329               		.loc 1 226 0
 330 00ac 14BA      		out 0x14,__zero_reg__
 331               	/* epilogue start */
 227:setup.c       **** }
 332               		.loc 1 227 0
 333 00ae DF91      		pop r29
 334               	.LVL20:
 335 00b0 CF91      		pop r28
 336               	.LVL21:
 337 00b2 0895      		ret
 338               		.cfi_endproc
 339               	.LFE20:
 341               	.global	gb_flash_read_byte
 343               	gb_flash_read_byte:
 344               	.LFB21:
 228:setup.c       **** 
 229:setup.c       **** 
 230:setup.c       **** 
 231:setup.c       **** // ---------- GB FLASH CARTS ----------
 232:setup.c       **** 
 233:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 234:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 345               		.loc 1 234 0
 346               		.cfi_startproc
 347               	.LVL22:
 348               	/* prologue: function */
 349               	/* frame size = 0 */
 350               	/* stack size = 0 */
 351               	.L__stack_usage = 0
 235:setup.c       **** 	PORT_DATA7_0 = 0;
 352               		.loc 1 235 0
 353 00b4 15BA      		out 0x15,__zero_reg__
 236:setup.c       **** 	DDR_DATA7_0 = 0;
 354               		.loc 1 236 0
 355 00b6 14BA      		out 0x14,__zero_reg__
 237:setup.c       **** 	
 238:setup.c       **** 	set_16bit_address(address);
 356               		.loc 1 238 0
 357 00b8 00D0      		rcall set_16bit_address
 358               	.LVL23:
 239:setup.c       **** 	
 240:setup.c       **** 	rdPin_low;
 359               		.loc 1 240 0
 360 00ba 9598      		cbi 0x12,5
 241:setup.c       **** 	asm volatile("nop"); // Delay a little
 361               		.loc 1 241 0
 362               	/* #APP */
 363               	 ;  241 "setup.c" 1
 364 00bc 0000      		nop
 365               	 ;  0 "" 2
 242:setup.c       **** 	asm volatile("nop");
 366               		.loc 1 242 0
 367               	 ;  242 "setup.c" 1
 368 00be 0000      		nop
 369               	 ;  0 "" 2
 243:setup.c       **** 	asm volatile("nop");
 370               		.loc 1 243 0
 371               	 ;  243 "setup.c" 1
 372 00c0 0000      		nop
 373               	 ;  0 "" 2
 244:setup.c       **** 	asm volatile("nop");
 374               		.loc 1 244 0
 375               	 ;  244 "setup.c" 1
 376 00c2 0000      		nop
 377               	 ;  0 "" 2
 245:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 378               		.loc 1 245 0
 379               	/* #NOAPP */
 380 00c4 83B3      		in r24,0x13
 381               	.LVL24:
 246:setup.c       **** 	rdPin_high;
 382               		.loc 1 246 0
 383 00c6 959A      		sbi 0x12,5
 247:setup.c       **** 	
 248:setup.c       **** 	return data;
 249:setup.c       **** }
 384               		.loc 1 249 0
 385 00c8 0895      		ret
 386               		.cfi_endproc
 387               	.LFE21:
 389               	.global	gb_flash_write_bus_cycle
 391               	gb_flash_write_bus_cycle:
 392               	.LFB22:
 250:setup.c       **** 
 251:setup.c       **** // Set the address and data for the write byte cycle to the flash
 252:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 393               		.loc 1 252 0
 394               		.cfi_startproc
 395               	.LVL25:
 396 00ca CF93      		push r28
 397               	.LCFI8:
 398               		.cfi_def_cfa_offset 3
 399               		.cfi_offset 28, -2
 400               	/* prologue: function */
 401               	/* frame size = 0 */
 402               	/* stack size = 1 */
 403               	.L__stack_usage = 1
 404 00cc C62F      		mov r28,r22
 253:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 405               		.loc 1 253 0
 406 00ce 2FEF      		ldi r18,lo8(-1)
 407 00d0 24BB      		out 0x14,r18
 254:setup.c       **** 	set_16bit_address(address);
 408               		.loc 1 254 0
 409 00d2 00D0      		rcall set_16bit_address
 410               	.LVL26:
 255:setup.c       **** 	PORT_DATA7_0 = data;
 411               		.loc 1 255 0
 412 00d4 C5BB      		out 0x15,r28
 256:setup.c       **** 	
 257:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 413               		.loc 1 257 0
 414 00d6 8091 0000 		lds r24,flashWriteWePin
 415 00da 8134      		cpi r24,lo8(65)
 416 00dc 01F4      		brne .L25
 258:setup.c       **** 		audioPin_low; // WE low
 417               		.loc 1 258 0
 418 00de 3998      		cbi 0x7,1
 259:setup.c       **** 		asm volatile("nop");
 419               		.loc 1 259 0
 420               	/* #APP */
 421               	 ;  259 "setup.c" 1
 422 00e0 0000      		nop
 423               	 ;  0 "" 2
 260:setup.c       **** 		asm volatile("nop");
 424               		.loc 1 260 0
 425               	 ;  260 "setup.c" 1
 426 00e2 0000      		nop
 427               	 ;  0 "" 2
 261:setup.c       **** 		asm volatile("nop");
 428               		.loc 1 261 0
 429               	 ;  261 "setup.c" 1
 430 00e4 0000      		nop
 431               	 ;  0 "" 2
 262:setup.c       **** 		asm volatile("nop");
 432               		.loc 1 262 0
 433               	 ;  262 "setup.c" 1
 434 00e6 0000      		nop
 435               	 ;  0 "" 2
 263:setup.c       **** 		asm volatile("nop");
 436               		.loc 1 263 0
 437               	 ;  263 "setup.c" 1
 438 00e8 0000      		nop
 439               	 ;  0 "" 2
 264:setup.c       **** 		asm volatile("nop");
 440               		.loc 1 264 0
 441               	 ;  264 "setup.c" 1
 442 00ea 0000      		nop
 443               	 ;  0 "" 2
 265:setup.c       **** 		audioPin_high; // WE high
 444               		.loc 1 265 0
 445               	/* #NOAPP */
 446 00ec 399A      		sbi 0x7,1
 447 00ee 00C0      		rjmp .L26
 448               	.L25:
 266:setup.c       **** 	}
 267:setup.c       **** 	else { // WR pin
 268:setup.c       **** 		wrPin_low; // WE low
 449               		.loc 1 268 0
 450 00f0 9698      		cbi 0x12,6
 269:setup.c       **** 		asm volatile("nop");
 451               		.loc 1 269 0
 452               	/* #APP */
 453               	 ;  269 "setup.c" 1
 454 00f2 0000      		nop
 455               	 ;  0 "" 2
 270:setup.c       **** 		asm volatile("nop");
 456               		.loc 1 270 0
 457               	 ;  270 "setup.c" 1
 458 00f4 0000      		nop
 459               	 ;  0 "" 2
 271:setup.c       **** 		asm volatile("nop");
 460               		.loc 1 271 0
 461               	 ;  271 "setup.c" 1
 462 00f6 0000      		nop
 463               	 ;  0 "" 2
 272:setup.c       **** 		asm volatile("nop");
 464               		.loc 1 272 0
 465               	 ;  272 "setup.c" 1
 466 00f8 0000      		nop
 467               	 ;  0 "" 2
 273:setup.c       **** 		asm volatile("nop");
 468               		.loc 1 273 0
 469               	 ;  273 "setup.c" 1
 470 00fa 0000      		nop
 471               	 ;  0 "" 2
 274:setup.c       **** 		asm volatile("nop");
 472               		.loc 1 274 0
 473               	 ;  274 "setup.c" 1
 474 00fc 0000      		nop
 475               	 ;  0 "" 2
 275:setup.c       **** 		wrPin_high; // WE high
 476               		.loc 1 275 0
 477               	/* #NOAPP */
 478 00fe 969A      		sbi 0x12,6
 479               	.L26:
 276:setup.c       **** 	}
 277:setup.c       **** 	
 278:setup.c       **** 	// Clear data outputs and set data pins as inputs
 279:setup.c       **** 	PORT_DATA7_0 = 0;
 480               		.loc 1 279 0
 481 0100 15BA      		out 0x15,__zero_reg__
 280:setup.c       **** 	DDR_DATA7_0 = 0;
 482               		.loc 1 280 0
 483 0102 14BA      		out 0x14,__zero_reg__
 484               	/* epilogue start */
 281:setup.c       **** }
 485               		.loc 1 281 0
 486 0104 CF91      		pop r28
 487               	.LVL27:
 488 0106 0895      		ret
 489               		.cfi_endproc
 490               	.LFE22:
 492               	.global	gb_flash_write_byte
 494               	gb_flash_write_byte:
 495               	.LFB23:
 282:setup.c       **** 
 283:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 284:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 496               		.loc 1 284 0
 497               		.cfi_startproc
 498               	.LVL28:
 499 0108 1F93      		push r17
 500               	.LCFI9:
 501               		.cfi_def_cfa_offset 3
 502               		.cfi_offset 17, -2
 503 010a CF93      		push r28
 504               	.LCFI10:
 505               		.cfi_def_cfa_offset 4
 506               		.cfi_offset 28, -3
 507 010c DF93      		push r29
 508               	.LCFI11:
 509               		.cfi_def_cfa_offset 5
 510               		.cfi_offset 29, -4
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 3 */
 514               	.L__stack_usage = 3
 515 010e EC01      		movw r28,r24
 516 0110 162F      		mov r17,r22
 285:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 517               		.loc 1 285 0
 518 0112 6091 0000 		lds r22,flashWriteCycle+2
 519               	.LVL29:
 520 0116 8091 0000 		lds r24,flashWriteCycle
 521 011a 9091 0000 		lds r25,flashWriteCycle+1
 522               	.LVL30:
 523 011e 00D0      		rcall gb_flash_write_bus_cycle
 524               	.LVL31:
 286:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 525               		.loc 1 286 0
 526 0120 6091 0000 		lds r22,flashWriteCycle+6
 527 0124 8091 0000 		lds r24,flashWriteCycle+4
 528 0128 9091 0000 		lds r25,flashWriteCycle+4+1
 529 012c 00D0      		rcall gb_flash_write_bus_cycle
 530               	.LVL32:
 287:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 531               		.loc 1 287 0
 532 012e 6091 0000 		lds r22,flashWriteCycle+10
 533 0132 8091 0000 		lds r24,flashWriteCycle+8
 534 0136 9091 0000 		lds r25,flashWriteCycle+8+1
 535 013a 00D0      		rcall gb_flash_write_bus_cycle
 536               	.LVL33:
 288:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 537               		.loc 1 288 0
 538 013c 612F      		mov r22,r17
 539 013e CE01      		movw r24,r28
 540 0140 00D0      		rcall gb_flash_write_bus_cycle
 541               	.LVL34:
 542               	.LBB87:
 543               	.LBB88:
 544               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 545               		.loc 2 276 0
 546 0142 85E3      		ldi r24,lo8(53)
 547 0144 8A95      	1:	dec r24
 548 0146 01F4      		brne 1b
 549 0148 0000      		nop
 550               	.LVL35:
 551               	.LBE88:
 552               	.LBE87:
 289:setup.c       **** 	_delay_us(10); // Wait byte program time
 290:setup.c       **** 	
 291:setup.c       **** 	// Set data pins inputs
 292:setup.c       **** 	PORT_DATA7_0 = 0;
 553               		.loc 1 292 0
 554 014a 15BA      		out 0x15,__zero_reg__
 293:setup.c       **** 	DDR_DATA7_0 = 0;
 555               		.loc 1 293 0
 556 014c 14BA      		out 0x14,__zero_reg__
 294:setup.c       **** 	
 295:setup.c       **** 	// Verify data
 296:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 557               		.loc 1 296 0
 558 014e CE01      		movw r24,r28
 559 0150 00D0      		rcall gb_flash_read_byte
 560               	.LVL36:
 561               	.L28:
 297:setup.c       **** 	while (data != dataVerify) {
 562               		.loc 1 297 0
 563 0152 8117      		cp r24,r17
 564 0154 01F0      		breq .L30
 298:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 565               		.loc 1 298 0
 566 0156 CE01      		movw r24,r28
 567               	.LVL37:
 568 0158 00D0      		rcall gb_flash_read_byte
 569               	.LVL38:
 570               	.LBB89:
 571               	.LBB90:
 572               		.loc 2 276 0
 573 015a 9AE1      		ldi r25,lo8(26)
 574 015c 9A95      	1:	dec r25
 575 015e 01F4      		brne 1b
 576 0160 00C0      		rjmp .
 577 0162 00C0      		rjmp .L28
 578               	.LVL39:
 579               	.L30:
 580               	/* epilogue start */
 581               	.LBE90:
 582               	.LBE89:
 299:setup.c       **** 		_delay_us(5);
 300:setup.c       **** 	}
 301:setup.c       **** }
 583               		.loc 1 301 0
 584 0164 DF91      		pop r29
 585 0166 CF91      		pop r28
 586               	.LVL40:
 587 0168 1F91      		pop r17
 588               	.LVL41:
 589 016a 0895      		ret
 590               		.cfi_endproc
 591               	.LFE23:
 593               	.global	gb_flash_write_byte_special
 595               	gb_flash_write_byte_special:
 596               	.LFB24:
 302:setup.c       **** 
 303:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 304:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 597               		.loc 1 304 0
 598               		.cfi_startproc
 599               	.LVL42:
 600 016c 1F93      		push r17
 601               	.LCFI12:
 602               		.cfi_def_cfa_offset 3
 603               		.cfi_offset 17, -2
 604 016e CF93      		push r28
 605               	.LCFI13:
 606               		.cfi_def_cfa_offset 4
 607               		.cfi_offset 28, -3
 608 0170 DF93      		push r29
 609               	.LCFI14:
 610               		.cfi_def_cfa_offset 5
 611               		.cfi_offset 29, -4
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 3 */
 615               	.L__stack_usage = 3
 616 0172 EC01      		movw r28,r24
 617 0174 162F      		mov r17,r22
 305:setup.c       **** 	// Set bank back
 306:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 618               		.loc 1 306 0
 619 0176 8091 0000 		lds r24,flashBank1CommandWrites
 620               	.LVL43:
 621 017a 8130      		cpi r24,lo8(1)
 622 017c 01F4      		brne .L32
 307:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 623               		.loc 1 307 0
 624 017e 40E0      		ldi r20,0
 625 0180 6091 0000 		lds r22,lastBankAccessed
 626               	.LVL44:
 627 0184 80E0      		ldi r24,0
 628 0186 91E2      		ldi r25,lo8(33)
 629 0188 00D0      		rcall write_8bit_data
 630               	.LVL45:
 631               	.LBB91:
 632               	.LBB92:
 633               		.loc 2 276 0
 634 018a 87EC      		ldi r24,lo8(199)
 635 018c 90E0      		ldi r25,hi8(199)
 636 018e 0197      	1:	sbiw r24,1
 637 0190 01F4      		brne 1b
 638 0192 00C0      		rjmp .
 639 0194 0000      		nop
 640               	.LVL46:
 641               	.L32:
 642               	.LBE92:
 643               	.LBE91:
 308:setup.c       **** 		_delay_us(50);
 309:setup.c       **** 	}
 310:setup.c       **** 	
 311:setup.c       **** 	// Write
 312:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 644               		.loc 1 312 0
 645 0196 6091 0000 		lds r22,flashWriteCycle+2
 646 019a 8091 0000 		lds r24,flashWriteCycle
 647 019e 9091 0000 		lds r25,flashWriteCycle+1
 648 01a2 00D0      		rcall gb_flash_write_bus_cycle
 649               	.LVL47:
 313:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 650               		.loc 1 313 0
 651 01a4 6091 0000 		lds r22,flashWriteCycle+6
 652 01a8 8091 0000 		lds r24,flashWriteCycle+4
 653 01ac 9091 0000 		lds r25,flashWriteCycle+4+1
 654 01b0 00D0      		rcall gb_flash_write_bus_cycle
 655               	.LVL48:
 314:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 656               		.loc 1 314 0
 657 01b2 6091 0000 		lds r22,flashWriteCycle+10
 658 01b6 8091 0000 		lds r24,flashWriteCycle+8
 659 01ba 9091 0000 		lds r25,flashWriteCycle+8+1
 660 01be 00D0      		rcall gb_flash_write_bus_cycle
 661               	.LVL49:
 315:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 662               		.loc 1 315 0
 663 01c0 612F      		mov r22,r17
 664 01c2 CE01      		movw r24,r28
 665 01c4 00D0      		rcall gb_flash_write_bus_cycle
 666               	.LVL50:
 667               	.LBB93:
 668               	.LBB94:
 669               		.loc 2 276 0
 670 01c6 87EE      		ldi r24,lo8(999)
 671 01c8 93E0      		ldi r25,hi8(999)
 672 01ca 0197      	1:	sbiw r24,1
 673 01cc 01F4      		brne 1b
 674 01ce 00C0      		rjmp .
 675 01d0 0000      		nop
 676               	.LVL51:
 677               	.LBE94:
 678               	.LBE93:
 316:setup.c       **** 	_delay_us(250); // Wait byte program time
 317:setup.c       **** 	
 318:setup.c       **** 	// Set data pins inputs
 319:setup.c       **** 	PORT_DATA7_0 = 0;
 679               		.loc 1 319 0
 680 01d2 15BA      		out 0x15,__zero_reg__
 320:setup.c       **** 	DDR_DATA7_0 = 0;
 681               		.loc 1 320 0
 682 01d4 14BA      		out 0x14,__zero_reg__
 321:setup.c       **** 	
 322:setup.c       **** 	// Pulse reset
 323:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 683               		.loc 1 323 0
 684 01d6 3A98      		cbi 0x7,2
 685               	.LVL52:
 686               	.LBB95:
 687               	.LBB96:
 688               		.loc 2 276 0
 689 01d8 87EC      		ldi r24,lo8(199)
 690 01da 90E0      		ldi r25,hi8(199)
 691 01dc 0197      	1:	sbiw r24,1
 692 01de 01F4      		brne 1b
 693 01e0 00C0      		rjmp .
 694 01e2 0000      		nop
 695               	.LVL53:
 696               	.LBE96:
 697               	.LBE95:
 324:setup.c       **** 	_delay_us(50);
 325:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 698               		.loc 1 325 0
 699 01e4 3A9A      		sbi 0x7,2
 700               	.LVL54:
 701               	.LBB97:
 702               	.LBB98:
 703               		.loc 2 276 0
 704 01e6 87EC      		ldi r24,lo8(199)
 705 01e8 90E0      		ldi r25,hi8(199)
 706 01ea 0197      	1:	sbiw r24,1
 707 01ec 01F4      		brne 1b
 708 01ee 00C0      		rjmp .
 709 01f0 0000      		nop
 710               	.LVL55:
 711               	/* epilogue start */
 712               	.LBE98:
 713               	.LBE97:
 326:setup.c       **** 	_delay_us(50);
 327:setup.c       **** }
 714               		.loc 1 327 0
 715 01f2 DF91      		pop r29
 716 01f4 CF91      		pop r28
 717               	.LVL56:
 718 01f6 1F91      		pop r17
 719               	.LVL57:
 720 01f8 0895      		ret
 721               		.cfi_endproc
 722               	.LFE24:
 724               	.global	gb_flash_write_byte_bank1_commands
 726               	gb_flash_write_byte_bank1_commands:
 727               	.LFB25:
 328:setup.c       **** 
 329:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 330:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 331:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 728               		.loc 1 331 0
 729               		.cfi_startproc
 730               	.LVL58:
 731 01fa FF92      		push r15
 732               	.LCFI15:
 733               		.cfi_def_cfa_offset 3
 734               		.cfi_offset 15, -2
 735 01fc 0F93      		push r16
 736               	.LCFI16:
 737               		.cfi_def_cfa_offset 4
 738               		.cfi_offset 16, -3
 739 01fe 1F93      		push r17
 740               	.LCFI17:
 741               		.cfi_def_cfa_offset 5
 742               		.cfi_offset 17, -4
 743 0200 CF93      		push r28
 744               	.LCFI18:
 745               		.cfi_def_cfa_offset 6
 746               		.cfi_offset 28, -5
 747 0202 DF93      		push r29
 748               	.LCFI19:
 749               		.cfi_def_cfa_offset 7
 750               		.cfi_offset 29, -6
 751               	/* prologue: function */
 752               	/* frame size = 0 */
 753               	/* stack size = 5 */
 754               	.L__stack_usage = 5
 755 0204 EC01      		movw r28,r24
 756 0206 162F      		mov r17,r22
 332:setup.c       **** 	// Set bank 1
 333:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 757               		.loc 1 333 0
 758 0208 FF24      		clr r15
 759 020a FA94      		dec r15
 760 020c F4BA      		out 0x14,r15
 761               	.LVL59:
 762               	.LBB99:
 763               	.LBB100:
 180:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 764               		.loc 1 180 0
 765 020e 01E2      		ldi r16,lo8(33)
 766 0210 0BBB      		out 0x1b,r16
 181:setup.c       **** }
 767               		.loc 1 181 0
 768 0212 18BA      		out 0x18,__zero_reg__
 769               	.LVL60:
 770               	.LBE100:
 771               	.LBE99:
 334:setup.c       **** 	set_16bit_address(0x2100);
 335:setup.c       **** 	PORT_DATA7_0 = 1;
 772               		.loc 1 335 0
 773 0214 81E0      		ldi r24,lo8(1)
 774               	.LVL61:
 775 0216 85BB      		out 0x15,r24
 336:setup.c       **** 	wrPin_low; // Pulse WR
 776               		.loc 1 336 0
 777 0218 9698      		cbi 0x12,6
 337:setup.c       **** 	asm volatile("nop");
 778               		.loc 1 337 0
 779               	/* #APP */
 780               	 ;  337 "setup.c" 1
 781 021a 0000      		nop
 782               	 ;  0 "" 2
 338:setup.c       **** 	asm volatile("nop");
 783               		.loc 1 338 0
 784               	 ;  338 "setup.c" 1
 785 021c 0000      		nop
 786               	 ;  0 "" 2
 339:setup.c       **** 	wrPin_high;
 787               		.loc 1 339 0
 788               	/* #NOAPP */
 789 021e 969A      		sbi 0x12,6
 340:setup.c       **** 	
 341:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 790               		.loc 1 341 0
 791 0220 6091 0000 		lds r22,flashWriteCycle+2
 792               	.LVL62:
 793 0224 8091 0000 		lds r24,flashWriteCycle
 794 0228 9091 0000 		lds r25,flashWriteCycle+1
 795 022c 00D0      		rcall gb_flash_write_bus_cycle
 796               	.LVL63:
 342:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 797               		.loc 1 342 0
 798 022e 6091 0000 		lds r22,flashWriteCycle+6
 799 0232 8091 0000 		lds r24,flashWriteCycle+4
 800 0236 9091 0000 		lds r25,flashWriteCycle+4+1
 801 023a 00D0      		rcall gb_flash_write_bus_cycle
 802               	.LVL64:
 343:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 803               		.loc 1 343 0
 804 023c 6091 0000 		lds r22,flashWriteCycle+10
 805 0240 8091 0000 		lds r24,flashWriteCycle+8
 806 0244 9091 0000 		lds r25,flashWriteCycle+8+1
 807 0248 00D0      		rcall gb_flash_write_bus_cycle
 808               	.LVL65:
 344:setup.c       **** 	
 345:setup.c       **** 	
 346:setup.c       **** 	// Set bank back
 347:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 809               		.loc 1 347 0
 810 024a F4BA      		out 0x14,r15
 811               	.LVL66:
 812               	.LBB101:
 813               	.LBB102:
 180:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 814               		.loc 1 180 0
 815 024c 0BBB      		out 0x1b,r16
 181:setup.c       **** }
 816               		.loc 1 181 0
 817 024e 18BA      		out 0x18,__zero_reg__
 818               	.LVL67:
 819               	.LBE102:
 820               	.LBE101:
 348:setup.c       **** 	set_16bit_address(0x2100);
 349:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 821               		.loc 1 349 0
 822 0250 8091 0000 		lds r24,lastBankAccessed
 823 0254 85BB      		out 0x15,r24
 350:setup.c       **** 	wrPin_low; // Pulse WR
 824               		.loc 1 350 0
 825 0256 9698      		cbi 0x12,6
 351:setup.c       **** 	asm volatile("nop");
 826               		.loc 1 351 0
 827               	/* #APP */
 828               	 ;  351 "setup.c" 1
 829 0258 0000      		nop
 830               	 ;  0 "" 2
 352:setup.c       **** 	asm volatile("nop");
 831               		.loc 1 352 0
 832               	 ;  352 "setup.c" 1
 833 025a 0000      		nop
 834               	 ;  0 "" 2
 353:setup.c       **** 	wrPin_high;
 835               		.loc 1 353 0
 836               	/* #NOAPP */
 837 025c 969A      		sbi 0x12,6
 354:setup.c       **** 	
 355:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 838               		.loc 1 355 0
 839 025e 612F      		mov r22,r17
 840 0260 CE01      		movw r24,r28
 841 0262 00D0      		rcall gb_flash_write_bus_cycle
 842               	.LVL68:
 843               	.LBB103:
 844               	.LBB104:
 845               		.loc 2 276 0
 846 0264 85E3      		ldi r24,lo8(53)
 847 0266 8A95      	1:	dec r24
 848 0268 01F4      		brne 1b
 849 026a 0000      		nop
 850               	.LVL69:
 851               	.LBE104:
 852               	.LBE103:
 356:setup.c       **** 	_delay_us(10); // Wait byte program time
 357:setup.c       **** 	
 358:setup.c       **** 	// Set data pins inputs
 359:setup.c       **** 	PORT_DATA7_0 = 0;
 853               		.loc 1 359 0
 854 026c 15BA      		out 0x15,__zero_reg__
 360:setup.c       **** 	DDR_DATA7_0 = 0;
 855               		.loc 1 360 0
 856 026e 14BA      		out 0x14,__zero_reg__
 361:setup.c       **** 	
 362:setup.c       **** 	// Verify data
 363:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 857               		.loc 1 363 0
 858 0270 CE01      		movw r24,r28
 859 0272 00D0      		rcall gb_flash_read_byte
 860               	.LVL70:
 861               	.L34:
 364:setup.c       **** 	while (data != dataVerify) {
 862               		.loc 1 364 0
 863 0274 8117      		cp r24,r17
 864 0276 01F0      		breq .L36
 365:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 865               		.loc 1 365 0
 866 0278 CE01      		movw r24,r28
 867               	.LVL71:
 868 027a 00D0      		rcall gb_flash_read_byte
 869               	.LVL72:
 870               	.LBB105:
 871               	.LBB106:
 872               		.loc 2 276 0
 873 027c 9AE1      		ldi r25,lo8(26)
 874 027e 9A95      	1:	dec r25
 875 0280 01F4      		brne 1b
 876 0282 00C0      		rjmp .
 877 0284 00C0      		rjmp .L34
 878               	.LVL73:
 879               	.L36:
 880               	/* epilogue start */
 881               	.LBE106:
 882               	.LBE105:
 366:setup.c       **** 		_delay_us(5);
 367:setup.c       **** 	}
 368:setup.c       **** }
 883               		.loc 1 368 0
 884 0286 DF91      		pop r29
 885 0288 CF91      		pop r28
 886               	.LVL74:
 887 028a 1F91      		pop r17
 888               	.LVL75:
 889 028c 0F91      		pop r16
 890 028e FF90      		pop r15
 891 0290 0895      		ret
 892               		.cfi_endproc
 893               	.LFE25:
 895               	.global	setup
 897               	setup:
 898               	.LFB26:
 369:setup.c       **** 
 370:setup.c       **** 
 371:setup.c       **** // Setup
 372:setup.c       **** void setup(void) {
 899               		.loc 1 372 0
 900               		.cfi_startproc
 901               	/* prologue: function */
 902               	/* frame size = 0 */
 903               	/* stack size = 0 */
 904               	.L__stack_usage = 0
 373:setup.c       **** 	// Turn off watchdog
 374:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 905               		.loc 1 374 0
 906 0292 84B7      		in r24,0x34
 907 0294 877F      		andi r24,lo8(-9)
 908 0296 84BF      		out 0x34,r24
 375:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 909               		.loc 1 375 0
 910 0298 88E1      		ldi r24,lo8(24)
 911 029a 81BD      		out 0x21,r24
 376:setup.c       **** 	WDTCR = 0;
 912               		.loc 1 376 0
 913 029c 11BC      		out 0x21,__zero_reg__
 377:setup.c       **** 	
 378:setup.c       **** 	// Reset common lines
 379:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 914               		.loc 1 379 0
 915 029e 00D0      		rcall rd_wr_csmreq_cs2_reset
 916               	.LVL76:
 380:setup.c       **** 	
 381:setup.c       **** 	// Set outputs
 382:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN);
 917               		.loc 1 382 0
 918 02a0 81B3      		in r24,0x11
 919 02a2 8867      		ori r24,lo8(120)
 920 02a4 81BB      		out 0x11,r24
 383:setup.c       **** 	DDRE |= (1<<CS2_PIN);
 921               		.loc 1 383 0
 922 02a6 329A      		sbi 0x6,2
 384:setup.c       **** 	
 385:setup.c       **** 	// Pull ups
 386:setup.c       **** 	PORTE |= (1<<PE0);
 923               		.loc 1 386 0
 924 02a8 389A      		sbi 0x7,0
 387:setup.c       **** 	PORTD |= (1<<PD7) | (1<<PD2);
 925               		.loc 1 387 0
 926 02aa 82B3      		in r24,0x12
 927 02ac 8468      		ori r24,lo8(-124)
 928 02ae 82BB      		out 0x12,r24
 388:setup.c       **** 	
 389:setup.c       **** 	// Set all pins as inputs
 390:setup.c       **** 	PORT_DATA7_0 = 0;
 929               		.loc 1 390 0
 930 02b0 15BA      		out 0x15,__zero_reg__
 391:setup.c       **** 	DDR_DATA7_0 = 0;
 931               		.loc 1 391 0
 932 02b2 14BA      		out 0x14,__zero_reg__
 392:setup.c       **** 	PORT_ADDR7_0 = 0;
 933               		.loc 1 392 0
 934 02b4 18BA      		out 0x18,__zero_reg__
 393:setup.c       **** 	DDR_ADDR7_0 = 0;
 935               		.loc 1 393 0
 936 02b6 17BA      		out 0x17,__zero_reg__
 394:setup.c       **** 	PORT_ADDR15_8 = 0;
 937               		.loc 1 394 0
 938 02b8 1BBA      		out 0x1b,__zero_reg__
 395:setup.c       **** 	DDR_ADDR15_8 = 0;
 939               		.loc 1 395 0
 940 02ba 1ABA      		out 0x1a,__zero_reg__
 396:setup.c       **** 	
 397:setup.c       **** 	// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 398:setup.c       **** 	cs2Pin_low;
 941               		.loc 1 398 0
 942 02bc 3A98      		cbi 0x7,2
 943               	.LVL77:
 944               	.LBB107:
 945               	.LBB108:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 946               		.loc 2 187 0
 947 02be 2FEF      		ldi r18,lo8(159999)
 948 02c0 80E7      		ldi r24,hi8(159999)
 949 02c2 92E0      		ldi r25,hlo8(159999)
 950 02c4 2150      	1:	subi r18,1
 951 02c6 8040      		sbci r24,0
 952 02c8 9040      		sbci r25,0
 953 02ca 01F4      		brne 1b
 954 02cc 00C0      		rjmp .
 955 02ce 0000      		nop
 956               	.LVL78:
 957               	.LBE108:
 958               	.LBE107:
 399:setup.c       **** 	_delay_ms(50);
 400:setup.c       **** 	cs2Pin_high;
 959               		.loc 1 400 0
 960 02d0 3A9A      		sbi 0x7,2
 401:setup.c       **** 	
 402:setup.c       **** 	// Light LED
 403:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 961               		.loc 1 403 0
 962 02d2 939A      		sbi 0x12,3
 963               	.LVL79:
 964               	.LBB109:
 965               	.LBB110:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 966               		.loc 2 187 0
 967 02d4 2FEF      		ldi r18,lo8(1599999)
 968 02d6 89E6      		ldi r24,hi8(1599999)
 969 02d8 98E1      		ldi r25,hlo8(1599999)
 970 02da 2150      	1:	subi r18,1
 971 02dc 8040      		sbci r24,0
 972 02de 9040      		sbci r25,0
 973 02e0 01F4      		brne 1b
 974 02e2 00C0      		rjmp .
 975 02e4 0000      		nop
 976               	.LVL80:
 977               	.LBE110:
 978               	.LBE109:
 404:setup.c       **** 	_delay_ms(500);
 405:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 979               		.loc 1 405 0
 980 02e6 9398      		cbi 0x12,3
 406:setup.c       **** 	
 407:setup.c       **** 	// Setup USART
 408:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 981               		.loc 1 408 0
 982 02e8 19B8      		out 0x9,__zero_reg__
 409:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 983               		.loc 1 409 0
 984 02ea 539A      		sbi 0xa,3
 410:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 985               		.loc 1 410 0
 986 02ec 549A      		sbi 0xa,4
 411:setup.c       **** 	
 412:setup.c       **** 	// Turn on interrupts
 413:setup.c       **** 	sei();
 987               		.loc 1 413 0
 988               	/* #APP */
 989               	 ;  413 "setup.c" 1
 990 02ee 7894      		sei
 991               	 ;  0 "" 2
 992               	/* #NOAPP */
 993 02f0 0895      		ret
 994               		.cfi_endproc
 995               	.LFE26:
 997               		.section	.text.startup,"ax",@progbits
 998               	.global	main
 1000               	main:
 1001               	.LFB27:
 1002               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW Mini
   3:main.c        ****  PCB version: 1.0
   4:main.c        ****  Firmware version: R16
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 21/01/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW Mini allows you to dump your Gameboy/Gameboy Colour games ROM, save the RAM, write to t
  10:main.c        ****  write to certain Gameboy flash carts. GBA carts are not supported, please check out the non-Mini v
  11:main.c        ****  
  12:main.c        ****  The ATmega8515 talks to the cartridge and interfaces with the CH340G serial to USB converter with 
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 16MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BO
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.1_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart Mini RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  
  28:main.c        ****  Programming shortcuts (if added in Programmers Notepad):
  29:main.c        ****  Alt + W - Program fuse
  30:main.c        ****  Alt + B - Burn bootloader
  31:main.c        ****  
  32:main.c        ****  Plug in USB then
  33:main.c        ****  Alt + T - Program
  34:main.c        ****  Alt + N - Program delay settings
  35:main.c        ****  
  36:main.c        ****  
  37:main.c        ****  */
  38:main.c        **** 
  39:main.c        **** // ATmega8515L Pin Map
  40:main.c        **** //
  41:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  42:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  43:main.c        **** // 
  44:main.c        **** // Gameboy / Gameboy Colour
  45:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  46:main.c        **** 
  47:main.c        **** 
  48:main.c        **** #define F_CPU 16000000 // 16 MHz
  49:main.c        **** #define PCB_VERSION 100 // Mini v1.0
  50:main.c        **** #define FIRMWARE_VERSION 15
  51:main.c        **** 
  52:main.c        **** #include <avr/io.h>
  53:main.c        **** #include <avr/wdt.h>
  54:main.c        **** #include <avr/eeprom.h>
  55:main.c        **** #include <avr/interrupt.h>
  56:main.c        **** #include <avr/sleep.h>
  57:main.c        **** #include <util/delay.h>
  58:main.c        **** #include <stdlib.h>
  59:main.c        **** #include <string.h>
  60:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** int main(void) {
 1003               		.loc 3 63 0
 1004               		.cfi_startproc
 1005               	/* prologue: function */
 1006               	/* frame size = 0 */
 1007               	/* stack size = 0 */
 1008               	.L__stack_usage = 0
  64:main.c        **** 	setup();
 1009               		.loc 3 64 0
 1010 0000 00D0      		rcall setup
 1011               	.LVL81:
  65:main.c        **** 	
  66:main.c        **** 	uint32_t address = 0;
  67:main.c        **** 	uint8_t resetCommonLines = 1;
 1012               		.loc 3 67 0
 1013 0002 7724      		clr r7
 1014 0004 7394      		inc r7
  66:main.c        **** 	uint8_t resetCommonLines = 1;
 1015               		.loc 3 66 0
 1016 0006 C12C      		mov r12,__zero_reg__
 1017 0008 D12C      		mov r13,__zero_reg__
 1018 000a 7601      		movw r14,r12
 1019               	.LBB111:
  68:main.c        **** 	
  69:main.c        **** 	while(1) {
  70:main.c        **** 		if (resetCommonLines == 1) {
  71:main.c        **** 			rd_wr_csmreq_cs2_reset();
  72:main.c        **** 		}
  73:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  74:main.c        **** 		
  75:main.c        **** 		
  76:main.c        **** 		// Return the cart mode in use
  77:main.c        **** 		if (receivedChar == CART_MODE) {
  78:main.c        **** 			USART_Transmit(cartMode);
  79:main.c        **** 		}
  80:main.c        **** 		
  81:main.c        **** 		// Change to GB mode or GBA mode if requested
  82:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  83:main.c        **** 			gb_mode();
  84:main.c        **** 		}
  85:main.c        **** 		
  86:main.c        **** 		// Set address
  87:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
  88:main.c        **** 			usart_read_chars(); // Read start address
  89:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
  90:main.c        **** 		}
  91:main.c        **** 		
  92:main.c        **** 		
  93:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  94:main.c        **** 		
  95:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  96:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
  97:main.c        **** 			gb_mode();
  98:main.c        **** 			receivedChar = '1';
  99:main.c        **** 			while (receivedChar == '1') {
 100:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 101:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 102:main.c        **** 					USART_Transmit(read_8bit_data(address));
 103:main.c        **** 					address++;
 104:main.c        **** 				}
 105:main.c        **** 				
 106:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 107:main.c        **** 				receivedChar = USART_Receive();
 108:main.c        **** 			}
 109:main.c        **** 		}
 110:main.c        **** 		
 111:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 112:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 113:main.c        **** 			gb_mode();
 114:main.c        **** 			
 115:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 116:main.c        **** 			usart_read_bytes(64);
 117:main.c        **** 			
 118:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 119:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 120:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 121:main.c        **** 				address++;
 122:main.c        **** 			}
 123:main.c        **** 			
 124:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 125:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 126:main.c        **** 		}
 127:main.c        **** 		
 128:main.c        **** 		// Set bank address and write a byte
 129:main.c        **** 		else if (receivedChar == SET_BANK) {
 130:main.c        **** 			gb_mode();
 131:main.c        **** 			
 132:main.c        **** 			usart_read_chars(); // Read start address
 133:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 134:main.c        **** 			
 135:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 136:main.c        **** 			if (receivedChar == 'B') {
 137:main.c        **** 				usart_read_chars(); // Read data
 138:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 139:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 140:main.c        **** 				
 141:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 142:main.c        **** 			}
 143:main.c        **** 		}
 144:main.c        **** 		
 145:main.c        **** 		
 146:main.c        **** 		// ---------- GB FLASH CARTS ----------
 147:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 148:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 149:main.c        **** 			flashWriteWePin = USART_Receive();
 150:main.c        **** 			
 151:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 152:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 153:main.c        **** 				audioPin_high;
 154:main.c        **** 			}
 155:main.c        **** 		}
 156:main.c        **** 		
 157:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 158:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 159:main.c        **** 			flashBank1CommandWrites = 1;
 160:main.c        **** 		}
 161:main.c        **** 		
 162:main.c        **** 		// Load the program method to use
 163:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 164:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 165:main.c        **** 				usart_read_chars(); // Address
 166:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 167:main.c        **** 				USART_Transmit(SEND_ACK);
 168:main.c        **** 				
 169:main.c        **** 				usart_read_chars(); // Data
 170:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 171:main.c        **** 				USART_Transmit(SEND_ACK);
 172:main.c        **** 			}
 173:main.c        **** 		}
 174:main.c        **** 		
 175:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 176:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 177:main.c        **** 			usart_read_chars(); // Read address
 178:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 179:main.c        **** 			
 180:main.c        **** 			usart_read_chars(); // Read data byte
 181:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 182:main.c        **** 			
 183:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 184:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 185:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 186:main.c        **** 			
 187:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 188:main.c        **** 		}
 189:main.c        **** 		
 190:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 191:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 192:main.c        **** 			usart_read_bytes(64);
 193:main.c        **** 			
 194:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 195:main.c        **** 			if (flashBank1CommandWrites == 0) {
 196:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 197:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 198:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 199:main.c        **** 					}
 200:main.c        **** 					address++;
 201:main.c        **** 				}
 202:main.c        **** 			}
 203:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 204:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 205:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 206:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 207:main.c        **** 					}
 208:main.c        **** 					address++;
 209:main.c        **** 				}
 210:main.c        **** 			}
 211:main.c        **** 			
 212:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 213:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 214:main.c        **** 		}
 215:main.c        **** 		
 216:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 217:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 218:main.c        **** 			usart_read_bytes(32);
 219:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 220:main.c        **** 			
 221:main.c        **** 			// Setup buffered write
 222:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 223:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 224:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 225:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 226:main.c        **** 			_delay_us(1);
 227:main.c        **** 			
 228:main.c        **** 			// Write data
 229:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 230:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 231:main.c        **** 				address++;
 232:main.c        **** 			}
 233:main.c        **** 			
 234:main.c        **** 			// Write buffer to flash
 235:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 236:main.c        **** 			_delay_us(200);
 237:main.c        **** 			
 238:main.c        **** 			// Verify last byte written
 239:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 240:main.c        **** 			uint8_t verifyCount = 0;
 241:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 242:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 243:main.c        **** 				_delay_us(5);
 244:main.c        **** 				verifyCount++;
 245:main.c        **** 				if (verifyCount >= 200) {
 246:main.c        **** 					_delay_ms(500);
 247:main.c        **** 					break;
 248:main.c        **** 				}
 249:main.c        **** 			}
 250:main.c        **** 			
 251:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 252:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 253:main.c        **** 		}
 254:main.c        **** 		
 255:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 256:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 257:main.c        **** 			usart_read_bytes(64);
 258:main.c        **** 			
 259:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 260:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 261:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 262:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 263:main.c        **** 				}
 264:main.c        **** 				address++;
 265:main.c        **** 			}
 266:main.c        **** 			
 267:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 268:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 269:main.c        **** 		}
 270:main.c        **** 		
 271:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 272:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 273:main.c        **** 			usart_read_bytes(256);
 274:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 275:main.c        **** 			
 276:main.c        **** 			// Setup buffered write
 277:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 278:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 279:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 280:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 281:main.c        **** 			_delay_us(50);
 282:main.c        **** 			
 283:main.c        **** 			// Write data
 284:main.c        **** 			for (int x = 0; x < 256; x++) {
 285:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 286:main.c        **** 				address++;
 287:main.c        **** 			}
 288:main.c        **** 			
 289:main.c        **** 			// Write buffer to flash
 290:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 291:main.c        **** 			
 292:main.c        **** 			// Verify last byte written
 293:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 294:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 295:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 296:main.c        **** 				_delay_us(5);
 297:main.c        **** 			}
 298:main.c        **** 			
 299:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 300:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 301:main.c        **** 		}
 302:main.c        **** 		
 303:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 304:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 305:main.c        **** 			usart_read_bytes(128);
 306:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 307:main.c        **** 			
 308:main.c        **** 			// Enable flash chip access
 309:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 310:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 311:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 312:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 313:main.c        **** 			_delay_us(5);
 314:main.c        **** 			
 315:main.c        **** 			// Re-Enable writes to MBC registers
 316:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 317:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 318:main.c        **** 			_delay_us(5);
 319:main.c        **** 			
 320:main.c        **** 			// Bank 1 for commands
 321:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 322:main.c        **** 			_delay_us(5);
 323:main.c        **** 			
 324:main.c        **** 			
 325:main.c        **** 			// Write setup
 326:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 327:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 328:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 329:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 330:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 331:main.c        **** 			_delay_us(5);
 332:main.c        **** 			
 333:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 334:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 335:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 336:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 337:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 338:main.c        **** 			_delay_us(5);
 339:main.c        **** 			
 340:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 341:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 342:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 343:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 344:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 345:main.c        **** 			_delay_us(5);
 346:main.c        **** 			
 347:main.c        **** 			// Set bank back
 348:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 349:main.c        **** 			_delay_us(5);
 350:main.c        **** 			
 351:main.c        **** 			// Disable writes to MBC registers
 352:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 353:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 354:main.c        **** 			_delay_us(5);
 355:main.c        **** 			
 356:main.c        **** 			// Undo Wakeup
 357:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 358:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 359:main.c        **** 			_delay_us(5);
 360:main.c        **** 			
 361:main.c        **** 			
 362:main.c        **** 			// Write data
 363:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 364:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 365:main.c        **** 				_delay_us(5);
 366:main.c        **** 				address++;
 367:main.c        **** 			}
 368:main.c        **** 			
 369:main.c        **** 			// Write buffer to flash
 370:main.c        **** 			address--;
 371:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 372:main.c        **** 			address++;
 373:main.c        **** 			_delay_ms(10);
 374:main.c        **** 			
 375:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 376:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 377:main.c        **** 		}
 378:main.c        **** 		
 379:main.c        **** 		
 380:main.c        **** 		// ---------- General commands ----------
 381:main.c        **** 		// Set any pin as input/output
 382:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 383:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 384:main.c        **** 			char portChar = USART_Receive();
 385:main.c        **** 			usart_read_chars();
 386:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 387:main.c        **** 			
 388:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 389:main.c        **** 			if (receivedChar == SET_INPUT) {
 390:main.c        **** 				if (portChar == 'A') {
 391:main.c        **** 					DDRA &= ~(setValue);
 392:main.c        **** 				}
 393:main.c        **** 				else if (portChar == 'B') {
 394:main.c        **** 					DDRB &= ~(setValue);
 395:main.c        **** 				}
 396:main.c        **** 				else if (portChar == 'C') {
 397:main.c        **** 					DDRC &= ~(setValue);
 398:main.c        **** 				}
 399:main.c        **** 				else if (portChar == 'D') {
 400:main.c        **** 					DDRD &= ~(setValue);
 401:main.c        **** 				}
 402:main.c        **** 				else if (portChar == 'E') {
 403:main.c        **** 					DDRE &= ~(setValue);
 404:main.c        **** 				}
 405:main.c        **** 			}
 406:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 407:main.c        **** 				if (portChar == 'A') {
 408:main.c        **** 					DDRA |= (setValue);
 409:main.c        **** 				}
 410:main.c        **** 				else if (portChar == 'B') {
 411:main.c        **** 					DDRB |= (setValue);
 412:main.c        **** 				}
 413:main.c        **** 				else if (portChar == 'C') {
 414:main.c        **** 					DDRC |= (setValue);
 415:main.c        **** 				}
 416:main.c        **** 				else if (portChar == 'D') {
 417:main.c        **** 					DDRD |= (setValue);
 418:main.c        **** 				}
 419:main.c        **** 				else if (portChar == 'E') {
 420:main.c        **** 					DDRE |= (setValue);
 421:main.c        **** 				}
 422:main.c        **** 			}
 423:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 424:main.c        **** 		}
 425:main.c        **** 		
 426:main.c        **** 		// Set pin output as low
 427:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 428:main.c        **** 			char portChar = USART_Receive();			
 429:main.c        **** 			usart_read_chars();
 430:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 431:main.c        **** 			
 432:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 433:main.c        **** 			if (portChar == 'A') {
 434:main.c        **** 				PORTA &= ~(setValue);
 435:main.c        **** 			}
 436:main.c        **** 			else if (portChar == 'B') {
 437:main.c        **** 				PORTB &= ~(setValue);
 438:main.c        **** 			}
 439:main.c        **** 			else if (portChar == 'C') {
 440:main.c        **** 				PORTC &= ~(setValue);
 441:main.c        **** 			}
 442:main.c        **** 			else if (portChar == 'D') {
 443:main.c        **** 				PORTD &= ~(setValue);
 444:main.c        **** 			}
 445:main.c        **** 			else if (portChar == 'E') {
 446:main.c        **** 				PORTE &= ~(setValue);
 447:main.c        **** 			}
 448:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 449:main.c        **** 		}
 450:main.c        **** 		
 451:main.c        **** 		// Set pin output as high
 452:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 453:main.c        **** 			char portChar = USART_Receive();			
 454:main.c        **** 			usart_read_chars();
 455:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 456:main.c        **** 			
 457:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 458:main.c        **** 			if (portChar == 'A') {
 459:main.c        **** 				PORTA |= (setValue);
 460:main.c        **** 			}
 461:main.c        **** 			else if (portChar == 'B') {
 462:main.c        **** 				PORTB |= (setValue);
 463:main.c        **** 			}
 464:main.c        **** 			else if (portChar == 'C') {
 465:main.c        **** 				PORTC |= (setValue);
 466:main.c        **** 			}
 467:main.c        **** 			else if (portChar == 'D') {
 468:main.c        **** 				PORTD |= (setValue);
 469:main.c        **** 			}
 470:main.c        **** 			else if (portChar == 'E') {
 471:main.c        **** 				PORTE |= (setValue);
 472:main.c        **** 			}
 473:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 474:main.c        **** 		}
 475:main.c        **** 		
 476:main.c        **** 		// Read all pins of a PORT and return the value
 477:main.c        **** 		else if (receivedChar == READ_INPUT) {
 478:main.c        **** 			char portChar = USART_Receive();			
 479:main.c        **** 			
 480:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 481:main.c        **** 			if (portChar == 'A') {
 482:main.c        **** 				USART_Transmit(PINA);
 483:main.c        **** 			}
 484:main.c        **** 			else if (portChar == 'B') {
 485:main.c        **** 				USART_Transmit(PINB);
 486:main.c        **** 			}
 487:main.c        **** 			else if (portChar == 'C') {
 488:main.c        **** 				USART_Transmit(PINC);
 489:main.c        **** 			}
 490:main.c        **** 			else if (portChar == 'D') {
 491:main.c        **** 				USART_Transmit(PIND);
 492:main.c        **** 			}
 493:main.c        **** 			else if (portChar == 'E') {
 494:main.c        **** 				USART_Transmit(PINE);
 495:main.c        **** 			}
 496:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 497:main.c        **** 		}
 498:main.c        **** 		
 499:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 500:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 501:main.c        **** 			char commonChar = USART_Receive();
 502:main.c        **** 			if (commonChar == '1') {
 503:main.c        **** 				resetCommonLines = 1;
 504:main.c        **** 			}
 505:main.c        **** 			else if (commonChar == '0') {
 506:main.c        **** 				resetCommonLines = 0;
 507:main.c        **** 			}
 508:main.c        **** 		}
 509:main.c        **** 		
 510:main.c        **** 		// Send back the PCB version number
 511:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 512:main.c        **** 			USART_Transmit(PCB_VERSION);
 513:main.c        **** 		}
 514:main.c        **** 		
 515:main.c        **** 		// Send back the firmware version number
 516:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 517:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 518:main.c        **** 		}
 519:main.c        **** 		
 520:main.c        **** 		// Reset the AVR if it matches the number
 521:main.c        **** 		else if (receivedChar == RESET_AVR) {
 522:main.c        **** 			usart_read_chars();
 523:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 524:main.c        **** 			if (resetValue == RESET_VALUE) {
 525:main.c        **** 				// Clear watchdog flag
 526:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 527:main.c        **** 				
 528:main.c        **** 				// Start timed sequence
 529:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 1020               		.loc 3 529 0
 1021 000c 88E1      		ldi r24,lo8(24)
 1022 000e 382E      		mov r3,r24
 530:main.c        **** 				
 531:main.c        **** 				// Reset in 250 ms
 532:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 1023               		.loc 3 532 0
 1024 0010 9CE0      		ldi r25,lo8(12)
 1025 0012 292E      		mov r2,r25
 1026               	.LBB112:
 1027               	.LBB113:
 1028               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 1029               		.loc 4 105 0
 1030 0014 4424      		clr r4
 1031 0016 4A94      		dec r4
 1032 0018 542C      		mov r5,r4
 1033               	.LBE113:
 1034               	.LBE112:
 1035               	.LBE111:
 1036               	.LBB116:
 503:main.c        **** 			}
 1037               		.loc 3 503 0
 1038 001a 6624      		clr r6
 1039 001c 6394      		inc r6
 1040               	.LVL82:
 1041               	.L39:
 1042               	.LBE116:
  70:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1043               		.loc 3 70 0
 1044 001e 21E0      		ldi r18,lo8(1)
 1045 0020 7212      		cpse r7,r18
 1046 0022 00C0      		rjmp .L40
 1047               	.LVL83:
 1048               	.L134:
  71:main.c        **** 		}
 1049               		.loc 3 71 0
 1050 0024 00D0      		rcall rd_wr_csmreq_cs2_reset
 1051               	.LVL84:
 1052               	.L40:
  73:main.c        **** 		
 1053               		.loc 3 73 0
 1054 0026 00D0      		rcall USART_Receive
 1055               	.LVL85:
 1056 0028 8093 0000 		sts receivedChar,r24
  77:main.c        **** 			USART_Transmit(cartMode);
 1057               		.loc 3 77 0
 1058 002c 8334      		cpi r24,lo8(67)
 1059 002e 01F4      		brne .L41
  78:main.c        **** 		}
 1060               		.loc 3 78 0
 1061 0030 8091 0000 		lds r24,cartMode
 1062 0034 00C0      		rjmp .L135
 1063               	.L41:
  82:main.c        **** 			gb_mode();
 1064               		.loc 3 82 0
 1065 0036 8734      		cpi r24,lo8(71)
 1066 0038 01F4      		brne .L43
  83:main.c        **** 		}
 1067               		.loc 3 83 0
 1068 003a 00D0      		rcall gb_mode
 1069               	.LVL86:
 1070 003c 00C0      		rjmp .L39
 1071               	.L43:
  87:main.c        **** 			usart_read_chars(); // Read start address
 1072               		.loc 3 87 0
 1073 003e 8134      		cpi r24,lo8(65)
 1074 0040 01F4      		brne .L44
  88:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1075               		.loc 3 88 0
 1076 0042 00D0      		rcall usart_read_chars
 1077               	.LVL87:
  89:main.c        **** 		}
 1078               		.loc 3 89 0
 1079 0044 40E1      		ldi r20,lo8(16)
 1080 0046 50E0      		ldi r21,0
 1081 0048 60E0      		ldi r22,0
 1082 004a 70E0      		ldi r23,0
 1083 004c 80E0      		ldi r24,lo8(receivedBuffer)
 1084 004e 90E0      		ldi r25,hi8(receivedBuffer)
 1085 0050 00D0      		rcall strtol
 1086               	.LVL88:
 1087 0052 6B01      		movw r12,r22
 1088 0054 7C01      		movw r14,r24
 1089               	.LVL89:
 1090 0056 00C0      		rjmp .L39
 1091               	.L44:
  96:main.c        **** 			gb_mode();
 1092               		.loc 3 96 0
 1093 0058 8235      		cpi r24,lo8(82)
 1094 005a 01F4      		brne .L45
  97:main.c        **** 			receivedChar = '1';
 1095               		.loc 3 97 0
 1096 005c 00D0      		rcall gb_mode
 1097               	.LVL90:
  98:main.c        **** 			while (receivedChar == '1') {
 1098               		.loc 3 98 0
 1099 005e 81E3      		ldi r24,lo8(49)
 1100               	.LVL91:
 1101               	.L137:
 107:main.c        **** 			}
 1102               		.loc 3 107 0
 1103 0060 8093 0000 		sts receivedChar,r24
 1104               	.LVL92:
  99:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 1105               		.loc 3 99 0
 1106 0064 8091 0000 		lds r24,receivedChar
 1107 0068 8133      		cpi r24,lo8(49)
 1108 006a 01F4      		brne .L39
 100:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1109               		.loc 3 100 0
 1110 006c 939A      		sbi 0x12,3
 1111               	.LVL93:
 1112 006e C0E0      		ldi r28,0
 1113 0070 D0E0      		ldi r29,0
 1114               	.LVL94:
 1115               	.L47:
 1116               	.LBB117:
 102:main.c        **** 					address++;
 1117               		.loc 3 102 0 discriminator 3
 1118 0072 CE01      		movw r24,r28
 1119 0074 8C0D      		add r24,r12
 1120 0076 9D1D      		adc r25,r13
 1121 0078 00D0      		rcall read_8bit_data
 1122               	.LVL95:
 1123 007a 00D0      		rcall USART_Transmit
 1124               	.LVL96:
 1125 007c 2196      		adiw r28,1
 1126               	.LVL97:
 101:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1127               		.loc 3 101 0 discriminator 3
 1128 007e C034      		cpi r28,64
 1129 0080 D105      		cpc r29,__zero_reg__
 1130 0082 01F4      		brne .L47
 1131 0084 80E4      		ldi r24,64
 1132 0086 C80E      		add r12,r24
 1133 0088 D11C      		adc r13,__zero_reg__
 1134 008a E11C      		adc r14,__zero_reg__
 1135 008c F11C      		adc r15,__zero_reg__
 1136               	.LBE117:
 106:main.c        **** 				receivedChar = USART_Receive();
 1137               		.loc 3 106 0
 1138 008e 9398      		cbi 0x12,3
 107:main.c        **** 			}
 1139               		.loc 3 107 0
 1140 0090 00D0      		rcall USART_Receive
 1141               	.LVL98:
 1142 0092 00C0      		rjmp .L137
 1143               	.LVL99:
 1144               	.L45:
 112:main.c        **** 			gb_mode();
 1145               		.loc 3 112 0
 1146 0094 8735      		cpi r24,lo8(87)
 1147 0096 01F4      		brne .L49
 113:main.c        **** 			
 1148               		.loc 3 113 0
 1149 0098 00D0      		rcall gb_mode
 1150               	.LVL100:
 116:main.c        **** 			
 1151               		.loc 3 116 0
 1152 009a 80E4      		ldi r24,lo8(64)
 1153 009c 90E0      		ldi r25,0
 1154 009e 00D0      		rcall usart_read_bytes
 1155               	.LVL101:
 118:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1156               		.loc 3 118 0
 1157 00a0 939A      		sbi 0x12,3
 1158               	.LVL102:
 1159 00a2 C0E0      		ldi r28,lo8(receivedBuffer)
 1160 00a4 D0E0      		ldi r29,hi8(receivedBuffer)
 1161 00a6 00E0      		ldi r16,0
 1162 00a8 10E0      		ldi r17,0
 1163               	.LVL103:
 1164               	.L50:
 1165               	.LBB118:
 120:main.c        **** 				address++;
 1166               		.loc 3 120 0 discriminator 3
 1167 00aa 6991      		ld r22,Y+
 1168 00ac C801      		movw r24,r16
 1169 00ae 8C0D      		add r24,r12
 1170 00b0 9D1D      		adc r25,r13
 1171 00b2 41E0      		ldi r20,lo8(1)
 1172 00b4 00D0      		rcall write_8bit_data
 1173               	.LVL104:
 1174 00b6 0F5F      		subi r16,-1
 1175 00b8 1F4F      		sbci r17,-1
 1176               	.LVL105:
 119:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1177               		.loc 3 119 0 discriminator 3
 1178 00ba 0034      		cpi r16,64
 1179 00bc 1105      		cpc r17,__zero_reg__
 1180 00be 01F4      		brne .L50
 1181 00c0 90E4      		ldi r25,64
 1182 00c2 C90E      		add r12,r25
 1183 00c4 D11C      		adc r13,__zero_reg__
 1184 00c6 E11C      		adc r14,__zero_reg__
 1185 00c8 F11C      		adc r15,__zero_reg__
 1186 00ca 00C0      		rjmp .L149
 1187               	.LVL106:
 1188               	.L49:
 1189               	.LBE118:
 129:main.c        **** 			gb_mode();
 1190               		.loc 3 129 0
 1191 00cc 8234      		cpi r24,lo8(66)
 1192 00ce 01F4      		brne .L51
 1193               	.LBB119:
 130:main.c        **** 			
 1194               		.loc 3 130 0
 1195 00d0 00D0      		rcall gb_mode
 1196               	.LVL107:
 132:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1197               		.loc 3 132 0
 1198 00d2 00D0      		rcall usart_read_chars
 1199               	.LVL108:
 133:main.c        **** 			
 1200               		.loc 3 133 0
 1201 00d4 40E1      		ldi r20,lo8(16)
 1202 00d6 50E0      		ldi r21,0
 1203 00d8 60E0      		ldi r22,0
 1204 00da 70E0      		ldi r23,0
 1205 00dc 80E0      		ldi r24,lo8(receivedBuffer)
 1206 00de 90E0      		ldi r25,hi8(receivedBuffer)
 1207 00e0 00D0      		rcall strtol
 1208               	.LVL109:
 1209 00e2 4B01      		movw r8,r22
 1210 00e4 5C01      		movw r10,r24
 1211               	.LVL110:
 135:main.c        **** 			if (receivedChar == 'B') {
 1212               		.loc 3 135 0
 1213 00e6 00D0      		rcall USART_Receive
 1214               	.LVL111:
 1215 00e8 8093 0000 		sts receivedChar,r24
 136:main.c        **** 				usart_read_chars(); // Read data
 1216               		.loc 3 136 0
 1217 00ec 8234      		cpi r24,lo8(66)
 1218 00ee 01F0      		breq .+2
 1219 00f0 00C0      		rjmp .L39
 1220               	.LBB120:
 137:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1221               		.loc 3 137 0
 1222 00f2 00D0      		rcall usart_read_chars
 1223               	.LVL112:
 138:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 1224               		.loc 3 138 0
 1225 00f4 80E0      		ldi r24,lo8(receivedBuffer)
 1226 00f6 90E0      		ldi r25,hi8(receivedBuffer)
 1227 00f8 00D0      		rcall atoi
 1228               	.LVL113:
 139:main.c        **** 				
 1229               		.loc 3 139 0
 1230 00fa 8093 0000 		sts lastBankAccessed,r24
 141:main.c        **** 			}
 1231               		.loc 3 141 0
 1232 00fe 40E0      		ldi r20,0
 1233 0100 682F      		mov r22,r24
 1234 0102 C401      		movw r24,r8
 1235               	.LVL114:
 1236 0104 00D0      		rcall write_8bit_data
 1237               	.LVL115:
 1238 0106 00C0      		rjmp .L39
 1239               	.LVL116:
 1240               	.L51:
 1241               	.LBE120:
 1242               	.LBE119:
 148:main.c        **** 			flashWriteWePin = USART_Receive();
 1243               		.loc 3 148 0
 1244 0108 8035      		cpi r24,lo8(80)
 1245 010a 01F4      		brne .L52
 149:main.c        **** 			
 1246               		.loc 3 149 0
 1247 010c 00D0      		rcall USART_Receive
 1248               	.LVL117:
 1249 010e 8093 0000 		sts flashWriteWePin,r24
 151:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 1250               		.loc 3 151 0
 1251 0112 8134      		cpi r24,lo8(65)
 1252 0114 01F0      		breq .+2
 1253 0116 00C0      		rjmp .L39
 152:main.c        **** 				audioPin_high;
 1254               		.loc 3 152 0
 1255 0118 319A      		sbi 0x6,1
 153:main.c        **** 			}
 1256               		.loc 3 153 0
 1257 011a 399A      		sbi 0x7,1
 1258 011c 00C0      		rjmp .L39
 1259               	.L52:
 158:main.c        **** 			flashBank1CommandWrites = 1;
 1260               		.loc 3 158 0
 1261 011e 8E34      		cpi r24,lo8(78)
 1262 0120 01F4      		brne .L53
 159:main.c        **** 		}
 1263               		.loc 3 159 0
 1264 0122 6092 0000 		sts flashBank1CommandWrites,r6
 1265 0126 00C0      		rjmp .L39
 1266               	.L53:
 163:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 1267               		.loc 3 163 0
 1268 0128 8534      		cpi r24,lo8(69)
 1269 012a 01F4      		brne .L54
 1270 012c C0E0      		ldi r28,lo8(flashWriteCycle)
 1271 012e D0E0      		ldi r29,hi8(flashWriteCycle)
 1272               	.L55:
 1273               	.LBB121:
 165:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 1274               		.loc 3 165 0 discriminator 3
 1275 0130 00D0      		rcall usart_read_chars
 1276               	.LVL118:
 166:main.c        **** 				USART_Transmit(SEND_ACK);
 1277               		.loc 3 166 0 discriminator 3
 1278 0132 40E1      		ldi r20,lo8(16)
 1279 0134 50E0      		ldi r21,0
 1280 0136 60E0      		ldi r22,0
 1281 0138 70E0      		ldi r23,0
 1282 013a 80E0      		ldi r24,lo8(receivedBuffer)
 1283 013c 90E0      		ldi r25,hi8(receivedBuffer)
 1284 013e 00D0      		rcall strtol
 1285               	.LVL119:
 1286 0140 7983      		std Y+1,r23
 1287 0142 6883      		st Y,r22
 167:main.c        **** 				
 1288               		.loc 3 167 0 discriminator 3
 1289 0144 81E3      		ldi r24,lo8(49)
 1290 0146 00D0      		rcall USART_Transmit
 1291               	.LVL120:
 169:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 1292               		.loc 3 169 0 discriminator 3
 1293 0148 00D0      		rcall usart_read_chars
 1294               	.LVL121:
 170:main.c        **** 				USART_Transmit(SEND_ACK);
 1295               		.loc 3 170 0 discriminator 3
 1296 014a 40E1      		ldi r20,lo8(16)
 1297 014c 50E0      		ldi r21,0
 1298 014e 60E0      		ldi r22,0
 1299 0150 70E0      		ldi r23,0
 1300 0152 80E0      		ldi r24,lo8(receivedBuffer)
 1301 0154 90E0      		ldi r25,hi8(receivedBuffer)
 1302 0156 00D0      		rcall strtol
 1303               	.LVL122:
 1304 0158 7B83      		std Y+3,r23
 1305 015a 6A83      		std Y+2,r22
 171:main.c        **** 			}
 1306               		.loc 3 171 0 discriminator 3
 1307 015c 81E3      		ldi r24,lo8(49)
 1308 015e 00D0      		rcall USART_Transmit
 1309               	.LVL123:
 1310 0160 2496      		adiw r28,4
 164:main.c        **** 				usart_read_chars(); // Address
 1311               		.loc 3 164 0 discriminator 3
 1312 0162 E0E0      		ldi r30,lo8(flashWriteCycle+12)
 1313 0164 F0E0      		ldi r31,hi8(flashWriteCycle+12)
 1314 0166 EC17      		cp r30,r28
 1315 0168 FD07      		cpc r31,r29
 1316 016a 01F4      		brne .L55
 1317 016c 00C0      		rjmp .L39
 1318               	.L54:
 1319               	.LBE121:
 176:main.c        **** 			usart_read_chars(); // Read address
 1320               		.loc 3 176 0
 1321 016e 8634      		cpi r24,lo8(70)
 1322 0170 01F4      		brne .L56
 1323               	.LBB122:
 177:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 1324               		.loc 3 177 0
 1325 0172 00D0      		rcall usart_read_chars
 1326               	.LVL124:
 178:main.c        **** 			
 1327               		.loc 3 178 0
 1328 0174 40E1      		ldi r20,lo8(16)
 1329 0176 50E0      		ldi r21,0
 1330 0178 60E0      		ldi r22,0
 1331 017a 70E0      		ldi r23,0
 1332 017c 80E0      		ldi r24,lo8(receivedBuffer)
 1333 017e 90E0      		ldi r25,hi8(receivedBuffer)
 1334 0180 00D0      		rcall strtol
 1335               	.LVL125:
 1336 0182 4B01      		movw r8,r22
 1337 0184 5C01      		movw r10,r24
 1338               	.LVL126:
 180:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 1339               		.loc 3 180 0
 1340 0186 00D0      		rcall usart_read_chars
 1341               	.LVL127:
 181:main.c        **** 			
 1342               		.loc 3 181 0
 1343 0188 40E1      		ldi r20,lo8(16)
 1344 018a 50E0      		ldi r21,0
 1345 018c 60E0      		ldi r22,0
 1346 018e 70E0      		ldi r23,0
 1347 0190 80E0      		ldi r24,lo8(receivedBuffer)
 1348 0192 90E0      		ldi r25,hi8(receivedBuffer)
 1349 0194 00D0      		rcall strtol
 1350               	.LVL128:
 183:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 1351               		.loc 3 183 0
 1352 0196 939A      		sbi 0x12,3
 184:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1353               		.loc 3 184 0
 1354 0198 C401      		movw r24,r8
 1355 019a 00D0      		rcall gb_flash_write_bus_cycle
 1356               	.LVL129:
 1357               	.L149:
 185:main.c        **** 			
 1358               		.loc 3 185 0
 1359 019c 9398      		cbi 0x12,3
 187:main.c        **** 		}
 1360               		.loc 3 187 0
 1361 019e 81E3      		ldi r24,lo8(49)
 1362 01a0 00C0      		rjmp .L135
 1363               	.LVL130:
 1364               	.L56:
 1365               	.LBE122:
 191:main.c        **** 			usart_read_bytes(64);
 1366               		.loc 3 191 0
 1367 01a2 8435      		cpi r24,lo8(84)
 1368 01a4 01F4      		brne .L57
 192:main.c        **** 			
 1369               		.loc 3 192 0
 1370 01a6 80E4      		ldi r24,lo8(64)
 1371 01a8 90E0      		ldi r25,0
 1372 01aa 00D0      		rcall usart_read_bytes
 1373               	.LVL131:
 194:main.c        **** 			if (flashBank1CommandWrites == 0) {
 1374               		.loc 3 194 0
 1375 01ac 939A      		sbi 0x12,3
 195:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1376               		.loc 3 195 0
 1377 01ae 8091 0000 		lds r24,flashBank1CommandWrites
 1378 01b2 C0E0      		ldi r28,lo8(receivedBuffer)
 1379 01b4 D0E0      		ldi r29,hi8(receivedBuffer)
 1380 01b6 00E0      		ldi r16,0
 1381 01b8 10E0      		ldi r17,0
 1382 01ba 8111      		cpse r24,__zero_reg__
 1383 01bc 00C0      		rjmp .L63
 1384               	.LVL132:
 1385               	.L60:
 1386               	.LBB123:
 197:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 1387               		.loc 3 197 0
 1388 01be 6991      		ld r22,Y+
 1389 01c0 6F3F      		cpi r22,lo8(-1)
 1390 01c2 01F0      		breq .L59
 198:main.c        **** 					}
 1391               		.loc 3 198 0
 1392 01c4 C801      		movw r24,r16
 1393 01c6 8C0D      		add r24,r12
 1394 01c8 9D1D      		adc r25,r13
 1395 01ca 00D0      		rcall gb_flash_write_byte
 1396               	.LVL133:
 1397               	.L59:
 1398 01cc 0F5F      		subi r16,-1
 1399 01ce 1F4F      		sbci r17,-1
 1400               	.LVL134:
 196:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1401               		.loc 3 196 0 discriminator 2
 1402 01d0 0034      		cpi r16,64
 1403 01d2 1105      		cpc r17,__zero_reg__
 1404 01d4 01F4      		brne .L60
 1405 01d6 F0E4      		ldi r31,64
 1406 01d8 CF0E      		add r12,r31
 1407 01da D11C      		adc r13,__zero_reg__
 1408 01dc E11C      		adc r14,__zero_reg__
 1409 01de F11C      		adc r15,__zero_reg__
 1410 01e0 00C0      		rjmp .L138
 1411               	.LVL135:
 1412               	.L63:
 1413               	.LBE123:
 1414               	.LBB124:
 205:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 1415               		.loc 3 205 0
 1416 01e2 6991      		ld r22,Y+
 1417 01e4 6F3F      		cpi r22,lo8(-1)
 1418 01e6 01F0      		breq .L62
 206:main.c        **** 					}
 1419               		.loc 3 206 0
 1420 01e8 C801      		movw r24,r16
 1421 01ea 8C0D      		add r24,r12
 1422 01ec 9D1D      		adc r25,r13
 1423 01ee 00D0      		rcall gb_flash_write_byte_bank1_commands
 1424               	.LVL136:
 1425               	.L62:
 1426 01f0 0F5F      		subi r16,-1
 1427 01f2 1F4F      		sbci r17,-1
 1428               	.LVL137:
 204:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1429               		.loc 3 204 0 discriminator 2
 1430 01f4 0034      		cpi r16,64
 1431 01f6 1105      		cpc r17,__zero_reg__
 1432 01f8 01F4      		brne .L63
 1433 01fa 20E4      		ldi r18,64
 1434 01fc C20E      		add r12,r18
 1435 01fe D11C      		adc r13,__zero_reg__
 1436 0200 E11C      		adc r14,__zero_reg__
 1437 0202 F11C      		adc r15,__zero_reg__
 1438               	.LVL138:
 1439 0204 00C0      		rjmp .L138
 1440               	.LVL139:
 1441               	.L57:
 1442               	.LBE124:
 217:main.c        **** 			usart_read_bytes(32);
 1443               		.loc 3 217 0
 1444 0206 8935      		cpi r24,lo8(89)
 1445 0208 01F0      		breq .+2
 1446 020a 00C0      		rjmp .L64
 1447               	.LBB125:
 218:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1448               		.loc 3 218 0
 1449 020c 80E2      		ldi r24,lo8(32)
 1450 020e 90E0      		ldi r25,0
 1451 0210 00D0      		rcall usart_read_bytes
 1452               	.LVL140:
 219:main.c        **** 			
 1453               		.loc 3 219 0
 1454 0212 939A      		sbi 0x12,3
 222:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 1455               		.loc 3 222 0
 1456 0214 6AEA      		ldi r22,lo8(-86)
 1457 0216 8AEA      		ldi r24,lo8(-86)
 1458 0218 9AE0      		ldi r25,lo8(10)
 1459 021a 00D0      		rcall gb_flash_write_bus_cycle
 1460               	.LVL141:
 223:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 1461               		.loc 3 223 0
 1462 021c 65E5      		ldi r22,lo8(85)
 1463 021e 85E5      		ldi r24,lo8(85)
 1464 0220 95E0      		ldi r25,lo8(5)
 1465 0222 00D0      		rcall gb_flash_write_bus_cycle
 1466               	.LVL142:
 224:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 1467               		.loc 3 224 0
 1468 0224 5601      		movw r10,r12
 1469 0226 65E2      		ldi r22,lo8(37)
 1470 0228 C601      		movw r24,r12
 1471 022a 00D0      		rcall gb_flash_write_bus_cycle
 1472               	.LVL143:
 225:main.c        **** 			_delay_us(1);
 1473               		.loc 3 225 0
 1474 022c 6FE1      		ldi r22,lo8(31)
 1475 022e C601      		movw r24,r12
 1476 0230 00D0      		rcall gb_flash_write_bus_cycle
 1477               	.LVL144:
 1478               	.LBB126:
 1479               	.LBB127:
 1480               		.loc 2 276 0
 1481 0232 85E0      		ldi r24,lo8(5)
 1482 0234 8A95      	1:	dec r24
 1483 0236 01F4      		brne 1b
 1484 0238 0000      		nop
 1485               	.LVL145:
 1486 023a 00E0      		ldi r16,lo8(receivedBuffer)
 1487 023c 10E0      		ldi r17,hi8(receivedBuffer)
 1488 023e C0E0      		ldi r28,0
 1489 0240 D0E0      		ldi r29,0
 1490               	.LVL146:
 1491               	.L65:
 1492               	.LBE127:
 1493               	.LBE126:
 1494               	.LBB128:
 230:main.c        **** 				address++;
 1495               		.loc 3 230 0 discriminator 3
 1496 0242 F801      		movw r30,r16
 1497 0244 6191      		ld r22,Z+
 1498 0246 8F01      		movw r16,r30
 1499 0248 CE01      		movw r24,r28
 1500 024a 8A0D      		add r24,r10
 1501 024c 9B1D      		adc r25,r11
 1502 024e 00D0      		rcall gb_flash_write_bus_cycle
 1503               	.LVL147:
 1504 0250 2196      		adiw r28,1
 1505               	.LVL148:
 229:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1506               		.loc 3 229 0 discriminator 3
 1507 0252 C032      		cpi r28,32
 1508 0254 D105      		cpc r29,__zero_reg__
 1509 0256 01F4      		brne .L65
 1510 0258 F0E2      		ldi r31,32
 1511 025a CF0E      		add r12,r31
 1512 025c D11C      		adc r13,__zero_reg__
 1513 025e E11C      		adc r14,__zero_reg__
 1514 0260 F11C      		adc r15,__zero_reg__
 1515               	.LBE128:
 235:main.c        **** 			_delay_us(200);
 1516               		.loc 3 235 0
 1517 0262 C601      		movw r24,r12
 1518 0264 8097      		sbiw r24,32
 1519 0266 69E2      		ldi r22,lo8(41)
 1520 0268 00D0      		rcall gb_flash_write_bus_cycle
 1521               	.LVL149:
 1522               	.LBB129:
 1523               	.LBB130:
 1524               		.loc 2 276 0
 1525 026a 8FE1      		ldi r24,lo8(799)
 1526 026c 93E0      		ldi r25,hi8(799)
 1527 026e 0197      	1:	sbiw r24,1
 1528 0270 01F4      		brne 1b
 1529 0272 00C0      		rjmp .
 1530 0274 0000      		nop
 1531               	.LVL150:
 1532               	.LBE130:
 1533               	.LBE129:
 239:main.c        **** 			uint8_t verifyCount = 0;
 1534               		.loc 3 239 0
 1535 0276 E601      		movw r28,r12
 1536               	.LVL151:
 1537 0278 2197      		sbiw r28,1
 1538 027a CE01      		movw r24,r28
 1539 027c 00D0      		rcall gb_flash_read_byte
 1540               	.LVL152:
 241:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1541               		.loc 3 241 0
 1542 027e 18EC      		ldi r17,lo8(-56)
 1543               	.LVL153:
 1544               	.L66:
 1545 0280 9091 0000 		lds r25,receivedBuffer+31
 1546 0284 8917      		cp r24,r25
 1547 0286 01F4      		brne .+2
 1548 0288 00C0      		rjmp .L138
 242:main.c        **** 				_delay_us(5);
 1549               		.loc 3 242 0
 1550 028a CE01      		movw r24,r28
 1551               	.LVL154:
 1552 028c 00D0      		rcall gb_flash_read_byte
 1553               	.LVL155:
 1554               	.LBB131:
 1555               	.LBB132:
 1556               		.loc 2 276 0
 1557 028e 9AE1      		ldi r25,lo8(26)
 1558 0290 9A95      	1:	dec r25
 1559 0292 01F4      		brne 1b
 1560 0294 00C0      		rjmp .
 1561               	.LVL156:
 1562 0296 1150      		subi r17,lo8(-(-1))
 1563               	.LVL157:
 1564               	.LBE132:
 1565               	.LBE131:
 245:main.c        **** 					_delay_ms(500);
 1566               		.loc 3 245 0
 1567 0298 01F4      		brne .L66
 1568               	.LVL158:
 1569               	.LBB133:
 1570               	.LBB134:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1571               		.loc 2 187 0
 1572 029a EFEF      		ldi r30,lo8(1599999)
 1573 029c F9E6      		ldi r31,hi8(1599999)
 1574 029e 28E1      		ldi r18,hlo8(1599999)
 1575 02a0 E150      	1:	subi r30,1
 1576 02a2 F040      		sbci r31,0
 1577 02a4 2040      		sbci r18,0
 1578 02a6 01F4      		brne 1b
 1579 02a8 00C0      		rjmp .L150
 1580               	.LVL159:
 1581               	.L64:
 1582               	.LBE134:
 1583               	.LBE133:
 1584               	.LBE125:
 256:main.c        **** 			usart_read_bytes(64);
 1585               		.loc 3 256 0
 1586 02aa 8A34      		cpi r24,lo8(74)
 1587 02ac 01F4      		brne .L69
 257:main.c        **** 			
 1588               		.loc 3 257 0
 1589 02ae 80E4      		ldi r24,lo8(64)
 1590 02b0 90E0      		ldi r25,0
 1591 02b2 00D0      		rcall usart_read_bytes
 1592               	.LVL160:
 259:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1593               		.loc 3 259 0
 1594 02b4 939A      		sbi 0x12,3
 1595               	.LVL161:
 1596 02b6 C0E0      		ldi r28,lo8(receivedBuffer)
 1597 02b8 D0E0      		ldi r29,hi8(receivedBuffer)
 1598 02ba 00E0      		ldi r16,0
 1599 02bc 10E0      		ldi r17,0
 1600               	.LVL162:
 1601               	.L71:
 1602               	.LBB135:
 261:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 1603               		.loc 3 261 0
 1604 02be 6991      		ld r22,Y+
 1605 02c0 6F3F      		cpi r22,lo8(-1)
 1606 02c2 01F0      		breq .L70
 262:main.c        **** 				}
 1607               		.loc 3 262 0
 1608 02c4 C801      		movw r24,r16
 1609 02c6 8C0D      		add r24,r12
 1610 02c8 9D1D      		adc r25,r13
 1611 02ca 00D0      		rcall gb_flash_write_byte_special
 1612               	.LVL163:
 1613               	.L70:
 1614 02cc 0F5F      		subi r16,-1
 1615 02ce 1F4F      		sbci r17,-1
 1616               	.LVL164:
 260:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 1617               		.loc 3 260 0 discriminator 2
 1618 02d0 0034      		cpi r16,64
 1619 02d2 1105      		cpc r17,__zero_reg__
 1620 02d4 01F4      		brne .L71
 1621 02d6 80E4      		ldi r24,64
 1622 02d8 C80E      		add r12,r24
 1623 02da D11C      		adc r13,__zero_reg__
 1624 02dc E11C      		adc r14,__zero_reg__
 1625 02de F11C      		adc r15,__zero_reg__
 1626 02e0 00C0      		rjmp .L138
 1627               	.LVL165:
 1628               	.L69:
 1629               	.LBE135:
 272:main.c        **** 			usart_read_bytes(256);
 1630               		.loc 3 272 0
 1631 02e2 8835      		cpi r24,lo8(88)
 1632 02e4 01F0      		breq .+2
 1633 02e6 00C0      		rjmp .L72
 1634               	.LBB136:
 273:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1635               		.loc 3 273 0
 1636 02e8 80E0      		ldi r24,0
 1637 02ea 91E0      		ldi r25,lo8(1)
 1638 02ec 00D0      		rcall usart_read_bytes
 1639               	.LVL166:
 274:main.c        **** 			
 1640               		.loc 3 274 0
 1641 02ee 939A      		sbi 0x12,3
 277:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 1642               		.loc 3 277 0
 1643 02f0 69EA      		ldi r22,lo8(-87)
 1644 02f2 8AEA      		ldi r24,lo8(-86)
 1645 02f4 9AE0      		ldi r25,lo8(10)
 1646 02f6 00D0      		rcall gb_flash_write_bus_cycle
 1647               	.LVL167:
 278:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 1648               		.loc 3 278 0
 1649 02f8 66E5      		ldi r22,lo8(86)
 1650 02fa 85E5      		ldi r24,lo8(85)
 1651 02fc 95E0      		ldi r25,lo8(5)
 1652 02fe 00D0      		rcall gb_flash_write_bus_cycle
 1653               	.LVL168:
 279:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 1654               		.loc 3 279 0
 1655 0300 5601      		movw r10,r12
 1656 0302 66E2      		ldi r22,lo8(38)
 1657 0304 C601      		movw r24,r12
 1658 0306 00D0      		rcall gb_flash_write_bus_cycle
 1659               	.LVL169:
 280:main.c        **** 			_delay_us(50);
 1660               		.loc 3 280 0
 1661 0308 6FEF      		ldi r22,lo8(-1)
 1662 030a C601      		movw r24,r12
 1663 030c 00D0      		rcall gb_flash_write_bus_cycle
 1664               	.LVL170:
 1665               	.LBB137:
 1666               	.LBB138:
 1667               		.loc 2 276 0
 1668 030e E7EC      		ldi r30,lo8(199)
 1669 0310 F0E0      		ldi r31,hi8(199)
 1670 0312 3197      	1:	sbiw r30,1
 1671 0314 01F4      		brne 1b
 1672 0316 00C0      		rjmp .
 1673 0318 0000      		nop
 1674               	.LVL171:
 1675 031a 00E0      		ldi r16,lo8(receivedBuffer)
 1676 031c 10E0      		ldi r17,hi8(receivedBuffer)
 1677               	.LBE138:
 1678               	.LBE137:
 1679               	.LBB139:
 284:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1680               		.loc 3 284 0
 1681 031e C0E0      		ldi r28,0
 1682 0320 D0E0      		ldi r29,0
 1683               	.LVL172:
 1684               	.L73:
 285:main.c        **** 				address++;
 1685               		.loc 3 285 0 discriminator 3
 1686 0322 F801      		movw r30,r16
 1687 0324 6191      		ld r22,Z+
 1688 0326 8F01      		movw r16,r30
 1689 0328 CE01      		movw r24,r28
 1690 032a 8A0D      		add r24,r10
 1691 032c 9B1D      		adc r25,r11
 1692 032e 00D0      		rcall gb_flash_write_bus_cycle
 1693               	.LVL173:
 284:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1694               		.loc 3 284 0 discriminator 3
 1695 0330 2196      		adiw r28,1
 1696               	.LVL174:
 1697 0332 C115      		cp r28,__zero_reg__
 1698 0334 F1E0      		ldi r31,1
 1699 0336 DF07      		cpc r29,r31
 1700 0338 01F4      		brne .L73
 1701 033a 2FEF      		ldi r18,-1
 1702 033c D21A      		sub r13,r18
 1703 033e E20A      		sbc r14,r18
 1704 0340 F20A      		sbc r15,r18
 1705               	.LBE139:
 290:main.c        **** 			
 1706               		.loc 3 290 0
 1707 0342 C601      		movw r24,r12
 1708 0344 9A95      		dec r25
 1709 0346 6AE2      		ldi r22,lo8(42)
 1710 0348 00D0      		rcall gb_flash_write_bus_cycle
 1711               	.LVL175:
 293:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 1712               		.loc 3 293 0
 1713 034a E601      		movw r28,r12
 1714               	.LVL176:
 1715 034c 2197      		sbiw r28,1
 1716 034e CE01      		movw r24,r28
 1717 0350 00D0      		rcall gb_flash_read_byte
 1718               	.LVL177:
 1719               	.L74:
 294:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1720               		.loc 3 294 0
 1721 0352 9091 0000 		lds r25,receivedBuffer+255
 1722 0356 8917      		cp r24,r25
 1723 0358 01F4      		brne .+2
 1724 035a 00C0      		rjmp .L138
 295:main.c        **** 				_delay_us(5);
 1725               		.loc 3 295 0
 1726 035c CE01      		movw r24,r28
 1727               	.LVL178:
 1728 035e 00D0      		rcall gb_flash_read_byte
 1729               	.LVL179:
 1730               	.LBB140:
 1731               	.LBB141:
 1732               		.loc 2 276 0
 1733 0360 9AE1      		ldi r25,lo8(26)
 1734 0362 9A95      	1:	dec r25
 1735 0364 01F4      		brne 1b
 1736 0366 00C0      		rjmp .
 1737 0368 00C0      		rjmp .L74
 1738               	.LVL180:
 1739               	.L72:
 1740               	.LBE141:
 1741               	.LBE140:
 1742               	.LBE136:
 304:main.c        **** 			usart_read_bytes(128);
 1743               		.loc 3 304 0
 1744 036a 8A35      		cpi r24,lo8(90)
 1745 036c 01F0      		breq .+2
 1746 036e 00C0      		rjmp .L76
 305:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1747               		.loc 3 305 0
 1748 0370 80E8      		ldi r24,lo8(-128)
 1749 0372 90E0      		ldi r25,0
 1750 0374 00D0      		rcall usart_read_bytes
 1751               	.LVL181:
 306:main.c        **** 			
 1752               		.loc 3 306 0
 1753 0376 939A      		sbi 0x12,3
 309:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 1754               		.loc 3 309 0
 1755 0378 69E0      		ldi r22,lo8(9)
 1756 037a 80E2      		ldi r24,lo8(32)
 1757 037c 91E0      		ldi r25,lo8(1)
 1758 037e 00D0      		rcall gb_flash_write_bus_cycle
 1759               	.LVL182:
 310:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 1760               		.loc 3 310 0
 1761 0380 6AEA      		ldi r22,lo8(-86)
 1762 0382 81E2      		ldi r24,lo8(33)
 1763 0384 91E0      		ldi r25,lo8(1)
 1764 0386 00D0      		rcall gb_flash_write_bus_cycle
 1765               	.LVL183:
 311:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1766               		.loc 3 311 0
 1767 0388 65E5      		ldi r22,lo8(85)
 1768 038a 82E2      		ldi r24,lo8(34)
 1769 038c 91E0      		ldi r25,lo8(1)
 1770 038e 00D0      		rcall gb_flash_write_bus_cycle
 1771               	.LVL184:
 312:main.c        **** 			_delay_us(5);
 1772               		.loc 3 312 0
 1773 0390 65EA      		ldi r22,lo8(-91)
 1774 0392 8FE3      		ldi r24,lo8(63)
 1775 0394 91E0      		ldi r25,lo8(1)
 1776 0396 00D0      		rcall gb_flash_write_bus_cycle
 1777               	.LVL185:
 1778               	.LBB142:
 1779               	.LBB143:
 1780               		.loc 2 276 0
 1781 0398 EAE1      		ldi r30,lo8(26)
 1782 039a EA95      	1:	dec r30
 1783 039c 01F4      		brne 1b
 1784 039e 00C0      		rjmp .
 1785               	.LVL186:
 1786               	.LBE143:
 1787               	.LBE142:
 316:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1788               		.loc 3 316 0
 1789 03a0 61E1      		ldi r22,lo8(17)
 1790 03a2 80E2      		ldi r24,lo8(32)
 1791 03a4 91E0      		ldi r25,lo8(1)
 1792 03a6 00D0      		rcall gb_flash_write_bus_cycle
 1793               	.LVL187:
 317:main.c        **** 			_delay_us(5);
 1794               		.loc 3 317 0
 1795 03a8 65EA      		ldi r22,lo8(-91)
 1796 03aa 8FE3      		ldi r24,lo8(63)
 1797 03ac 91E0      		ldi r25,lo8(1)
 1798 03ae 00D0      		rcall gb_flash_write_bus_cycle
 1799               	.LVL188:
 1800               	.LBB144:
 1801               	.LBB145:
 1802               		.loc 2 276 0
 1803 03b0 FAE1      		ldi r31,lo8(26)
 1804 03b2 FA95      	1:	dec r31
 1805 03b4 01F4      		brne 1b
 1806 03b6 00C0      		rjmp .
 1807               	.LVL189:
 1808               	.LBE145:
 1809               	.LBE144:
 321:main.c        **** 			_delay_us(5);
 1810               		.loc 3 321 0
 1811 03b8 61E0      		ldi r22,lo8(1)
 1812 03ba 80E0      		ldi r24,0
 1813 03bc 91E2      		ldi r25,lo8(33)
 1814 03be 00D0      		rcall gb_flash_write_bus_cycle
 1815               	.LVL190:
 1816               	.LBB146:
 1817               	.LBB147:
 1818               		.loc 2 276 0
 1819 03c0 2AE1      		ldi r18,lo8(26)
 1820 03c2 2A95      	1:	dec r18
 1821 03c4 01F4      		brne 1b
 1822 03c6 00C0      		rjmp .
 1823               	.LVL191:
 1824               	.LBE147:
 1825               	.LBE146:
 326:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1826               		.loc 3 326 0
 1827 03c8 6FE0      		ldi r22,lo8(15)
 1828 03ca 80E2      		ldi r24,lo8(32)
 1829 03cc 91E0      		ldi r25,lo8(1)
 1830 03ce 00D0      		rcall gb_flash_write_bus_cycle
 1831               	.LVL192:
 327:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1832               		.loc 3 327 0
 1833 03d0 65E5      		ldi r22,lo8(85)
 1834 03d2 85E2      		ldi r24,lo8(37)
 1835 03d4 91E0      		ldi r25,lo8(1)
 1836 03d6 00D0      		rcall gb_flash_write_bus_cycle
 1837               	.LVL193:
 328:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 1838               		.loc 3 328 0
 1839 03d8 65E5      		ldi r22,lo8(85)
 1840 03da 86E2      		ldi r24,lo8(38)
 1841 03dc 91E0      		ldi r25,lo8(1)
 1842 03de 00D0      		rcall gb_flash_write_bus_cycle
 1843               	.LVL194:
 329:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1844               		.loc 3 329 0
 1845 03e0 6AEA      		ldi r22,lo8(-86)
 1846 03e2 87E2      		ldi r24,lo8(39)
 1847 03e4 91E0      		ldi r25,lo8(1)
 1848 03e6 00D0      		rcall gb_flash_write_bus_cycle
 1849               	.LVL195:
 330:main.c        **** 			_delay_us(5);
 1850               		.loc 3 330 0
 1851 03e8 65EA      		ldi r22,lo8(-91)
 1852 03ea 8FE3      		ldi r24,lo8(63)
 1853 03ec 91E0      		ldi r25,lo8(1)
 1854 03ee 00D0      		rcall gb_flash_write_bus_cycle
 1855               	.LVL196:
 1856               	.LBB148:
 1857               	.LBB149:
 1858               		.loc 2 276 0
 1859 03f0 8AE1      		ldi r24,lo8(26)
 1860 03f2 8A95      	1:	dec r24
 1861 03f4 01F4      		brne 1b
 1862 03f6 00C0      		rjmp .
 1863               	.LVL197:
 1864               	.LBE149:
 1865               	.LBE148:
 333:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 1866               		.loc 3 333 0
 1867 03f8 6FE0      		ldi r22,lo8(15)
 1868 03fa 80E2      		ldi r24,lo8(32)
 1869 03fc 91E0      		ldi r25,lo8(1)
 1870 03fe 00D0      		rcall gb_flash_write_bus_cycle
 1871               	.LVL198:
 334:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 1872               		.loc 3 334 0
 1873 0400 6AE2      		ldi r22,lo8(42)
 1874 0402 85E2      		ldi r24,lo8(37)
 1875 0404 91E0      		ldi r25,lo8(1)
 1876 0406 00D0      		rcall gb_flash_write_bus_cycle
 1877               	.LVL199:
 335:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 1878               		.loc 3 335 0
 1879 0408 6AEA      		ldi r22,lo8(-86)
 1880 040a 86E2      		ldi r24,lo8(38)
 1881 040c 91E0      		ldi r25,lo8(1)
 1882 040e 00D0      		rcall gb_flash_write_bus_cycle
 1883               	.LVL200:
 336:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1884               		.loc 3 336 0
 1885 0410 65E5      		ldi r22,lo8(85)
 1886 0412 87E2      		ldi r24,lo8(39)
 1887 0414 91E0      		ldi r25,lo8(1)
 1888 0416 00D0      		rcall gb_flash_write_bus_cycle
 1889               	.LVL201:
 337:main.c        **** 			_delay_us(5);
 1890               		.loc 3 337 0
 1891 0418 65EA      		ldi r22,lo8(-91)
 1892 041a 8FE3      		ldi r24,lo8(63)
 1893 041c 91E0      		ldi r25,lo8(1)
 1894 041e 00D0      		rcall gb_flash_write_bus_cycle
 1895               	.LVL202:
 1896               	.LBB150:
 1897               	.LBB151:
 1898               		.loc 2 276 0
 1899 0420 9AE1      		ldi r25,lo8(26)
 1900 0422 9A95      	1:	dec r25
 1901 0424 01F4      		brne 1b
 1902 0426 00C0      		rjmp .
 1903               	.LVL203:
 1904               	.LBE151:
 1905               	.LBE150:
 340:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1906               		.loc 3 340 0
 1907 0428 6FE0      		ldi r22,lo8(15)
 1908 042a 80E2      		ldi r24,lo8(32)
 1909 042c 91E0      		ldi r25,lo8(1)
 1910 042e 00D0      		rcall gb_flash_write_bus_cycle
 1911               	.LVL204:
 341:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1912               		.loc 3 341 0
 1913 0430 65E5      		ldi r22,lo8(85)
 1914 0432 85E2      		ldi r24,lo8(37)
 1915 0434 91E0      		ldi r25,lo8(1)
 1916 0436 00D0      		rcall gb_flash_write_bus_cycle
 1917               	.LVL205:
 342:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 1918               		.loc 3 342 0
 1919 0438 65E5      		ldi r22,lo8(85)
 1920 043a 86E2      		ldi r24,lo8(38)
 1921 043c 91E0      		ldi r25,lo8(1)
 1922 043e 00D0      		rcall gb_flash_write_bus_cycle
 1923               	.LVL206:
 343:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1924               		.loc 3 343 0
 1925 0440 60EA      		ldi r22,lo8(-96)
 1926 0442 87E2      		ldi r24,lo8(39)
 1927 0444 91E0      		ldi r25,lo8(1)
 1928 0446 00D0      		rcall gb_flash_write_bus_cycle
 1929               	.LVL207:
 344:main.c        **** 			_delay_us(5);
 1930               		.loc 3 344 0
 1931 0448 65EA      		ldi r22,lo8(-91)
 1932 044a 8FE3      		ldi r24,lo8(63)
 1933 044c 91E0      		ldi r25,lo8(1)
 1934 044e 00D0      		rcall gb_flash_write_bus_cycle
 1935               	.LVL208:
 1936               	.LBB152:
 1937               	.LBB153:
 1938               		.loc 2 276 0
 1939 0450 EAE1      		ldi r30,lo8(26)
 1940 0452 EA95      	1:	dec r30
 1941 0454 01F4      		brne 1b
 1942 0456 00C0      		rjmp .
 1943               	.LVL209:
 1944               	.LBE153:
 1945               	.LBE152:
 348:main.c        **** 			_delay_us(5);
 1946               		.loc 3 348 0
 1947 0458 40E0      		ldi r20,0
 1948 045a 6091 0000 		lds r22,lastBankAccessed
 1949 045e 80E0      		ldi r24,0
 1950 0460 91E2      		ldi r25,lo8(33)
 1951 0462 00D0      		rcall write_8bit_data
 1952               	.LVL210:
 1953               	.LBB154:
 1954               	.LBB155:
 1955               		.loc 2 276 0
 1956 0464 FAE1      		ldi r31,lo8(26)
 1957 0466 FA95      	1:	dec r31
 1958 0468 01F4      		brne 1b
 1959 046a 00C0      		rjmp .
 1960               	.LVL211:
 1961               	.LBE155:
 1962               	.LBE154:
 352:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1963               		.loc 3 352 0
 1964 046c 60E1      		ldi r22,lo8(16)
 1965 046e 80E2      		ldi r24,lo8(32)
 1966 0470 91E0      		ldi r25,lo8(1)
 1967 0472 00D0      		rcall gb_flash_write_bus_cycle
 1968               	.LVL212:
 353:main.c        **** 			_delay_us(5);
 1969               		.loc 3 353 0
 1970 0474 65EA      		ldi r22,lo8(-91)
 1971 0476 8FE3      		ldi r24,lo8(63)
 1972 0478 91E0      		ldi r25,lo8(1)
 1973 047a 00D0      		rcall gb_flash_write_bus_cycle
 1974               	.LVL213:
 1975               	.LBB156:
 1976               	.LBB157:
 1977               		.loc 2 276 0
 1978 047c 2AE1      		ldi r18,lo8(26)
 1979 047e 2A95      	1:	dec r18
 1980 0480 01F4      		brne 1b
 1981 0482 00C0      		rjmp .
 1982               	.LVL214:
 1983               	.LBE157:
 1984               	.LBE156:
 357:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1985               		.loc 3 357 0
 1986 0484 68E0      		ldi r22,lo8(8)
 1987 0486 80E2      		ldi r24,lo8(32)
 1988 0488 91E0      		ldi r25,lo8(1)
 1989 048a 00D0      		rcall gb_flash_write_bus_cycle
 1990               	.LVL215:
 358:main.c        **** 			_delay_us(5);
 1991               		.loc 3 358 0
 1992 048c 65EA      		ldi r22,lo8(-91)
 1993 048e 8FE3      		ldi r24,lo8(63)
 1994 0490 91E0      		ldi r25,lo8(1)
 1995 0492 00D0      		rcall gb_flash_write_bus_cycle
 1996               	.LVL216:
 1997               	.LBB158:
 1998               	.LBB159:
 1999               		.loc 2 276 0
 2000 0494 8AE1      		ldi r24,lo8(26)
 2001 0496 8A95      	1:	dec r24
 2002 0498 01F4      		brne 1b
 2003 049a 00C0      		rjmp .
 2004               	.LVL217:
 2005 049c C0E0      		ldi r28,lo8(receivedBuffer)
 2006 049e D0E0      		ldi r29,hi8(receivedBuffer)
 2007               	.L77:
 2008               	.LBE159:
 2009               	.LBE158:
 2010               	.LBB160:
 363:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2011               		.loc 3 363 0 discriminator 1
 2012 04a0 F0E0      		ldi r31,hi8(receivedBuffer+128)
 2013 04a2 C030      		cpi r28,lo8(receivedBuffer+128)
 2014 04a4 DF07      		cpc r29,r31
 2015 04a6 01F0      		breq .L151
 364:main.c        **** 				_delay_us(5);
 2016               		.loc 3 364 0 discriminator 3
 2017 04a8 6991      		ld r22,Y+
 2018 04aa C601      		movw r24,r12
 2019 04ac 00D0      		rcall gb_flash_write_bus_cycle
 2020               	.LVL218:
 2021               	.LBB161:
 2022               	.LBB162:
 2023               		.loc 2 276 0 discriminator 3
 2024 04ae 9AE1      		ldi r25,lo8(26)
 2025 04b0 9A95      	1:	dec r25
 2026 04b2 01F4      		brne 1b
 2027 04b4 00C0      		rjmp .
 2028               	.LVL219:
 2029               	.LBE162:
 2030               	.LBE161:
 366:main.c        **** 			}
 2031               		.loc 3 366 0 discriminator 3
 2032 04b6 EFEF      		ldi r30,-1
 2033 04b8 CE1A      		sub r12,r30
 2034 04ba DE0A      		sbc r13,r30
 2035 04bc EE0A      		sbc r14,r30
 2036 04be FE0A      		sbc r15,r30
 2037               	.LVL220:
 2038 04c0 00C0      		rjmp .L77
 2039               	.L151:
 2040               	.LVL221:
 2041               	.LBE160:
 371:main.c        **** 			address++;
 2042               		.loc 3 371 0
 2043 04c2 6FEF      		ldi r22,lo8(-1)
 2044 04c4 D701      		movw r26,r14
 2045 04c6 C601      		movw r24,r12
 2046 04c8 0197      		sbiw r24,1
 2047 04ca A109      		sbc r26,__zero_reg__
 2048 04cc B109      		sbc r27,__zero_reg__
 2049               	.LVL222:
 2050 04ce 00D0      		rcall gb_flash_write_bus_cycle
 2051               	.LVL223:
 2052               	.LBB163:
 2053               	.LBB164:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2054               		.loc 2 187 0
 2055 04d0 8FE3      		ldi r24,lo8(-25537)
 2056 04d2 9CE9      		ldi r25,hi8(-25537)
 2057 04d4 0197      	1:	sbiw r24,1
 2058 04d6 01F4      		brne 1b
 2059               	.LVL224:
 2060               	.L150:
 2061 04d8 00C0      		rjmp .
 2062 04da 0000      		nop
 2063               	.L138:
 2064               	.LBE164:
 2065               	.LBE163:
 375:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2066               		.loc 3 375 0
 2067 04dc 81E3      		ldi r24,lo8(49)
 2068 04de 00C0      		rjmp .L136
 2069               	.LVL225:
 2070               	.L76:
 383:main.c        **** 			char portChar = USART_Receive();
 2071               		.loc 3 383 0
 2072 04e0 8934      		cpi r24,lo8(73)
 2073 04e2 01F0      		breq .L79
 383:main.c        **** 			char portChar = USART_Receive();
 2074               		.loc 3 383 0 is_stmt 0 discriminator 1
 2075 04e4 8F34      		cpi r24,lo8(79)
 2076 04e6 01F0      		breq .+2
 2077 04e8 00C0      		rjmp .L80
 2078               	.L79:
 2079               	.LBB165:
 384:main.c        **** 			usart_read_chars();
 2080               		.loc 3 384 0 is_stmt 1
 2081 04ea 00D0      		rcall USART_Receive
 2082               	.LVL226:
 2083 04ec C82F      		mov r28,r24
 2084               	.LVL227:
 385:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2085               		.loc 3 385 0
 2086 04ee 00D0      		rcall usart_read_chars
 2087               	.LVL228:
 386:main.c        **** 			
 2088               		.loc 3 386 0
 2089 04f0 40E1      		ldi r20,lo8(16)
 2090 04f2 50E0      		ldi r21,0
 2091 04f4 60E0      		ldi r22,0
 2092 04f6 70E0      		ldi r23,0
 2093 04f8 80E0      		ldi r24,lo8(receivedBuffer)
 2094 04fa 90E0      		ldi r25,hi8(receivedBuffer)
 2095 04fc 00D0      		rcall strtol
 2096               	.LVL229:
 388:main.c        **** 			if (receivedChar == SET_INPUT) {
 2097               		.loc 3 388 0
 2098 04fe 939A      		sbi 0x12,3
 389:main.c        **** 				if (portChar == 'A') {
 2099               		.loc 3 389 0
 2100 0500 8091 0000 		lds r24,receivedChar
 2101 0504 8934      		cpi r24,lo8(73)
 2102 0506 01F4      		brne .L81
 390:main.c        **** 					DDRA &= ~(setValue);
 2103               		.loc 3 390 0
 2104 0508 C134      		cpi r28,lo8(65)
 2105 050a 01F4      		brne .L82
 391:main.c        **** 				}
 2106               		.loc 3 391 0
 2107 050c 8AB3      		in r24,0x1a
 2108 050e 6095      		com r22
 2109               	.LVL230:
 2110 0510 6823      		and r22,r24
 2111               	.LVL231:
 2112 0512 00C0      		rjmp .L140
 2113               	.LVL232:
 2114               	.L82:
 393:main.c        **** 					DDRB &= ~(setValue);
 2115               		.loc 3 393 0
 2116 0514 C234      		cpi r28,lo8(66)
 2117 0516 01F4      		brne .L84
 394:main.c        **** 				}
 2118               		.loc 3 394 0
 2119 0518 87B3      		in r24,0x17
 2120 051a 6095      		com r22
 2121               	.LVL233:
 2122 051c 6823      		and r22,r24
 2123               	.LVL234:
 2124 051e 00C0      		rjmp .L141
 2125               	.LVL235:
 2126               	.L84:
 396:main.c        **** 					DDRC &= ~(setValue);
 2127               		.loc 3 396 0
 2128 0520 C334      		cpi r28,lo8(67)
 2129 0522 01F4      		brne .L85
 397:main.c        **** 				}
 2130               		.loc 3 397 0
 2131 0524 84B3      		in r24,0x14
 2132 0526 6095      		com r22
 2133               	.LVL236:
 2134 0528 6823      		and r22,r24
 2135               	.LVL237:
 2136 052a 00C0      		rjmp .L146
 2137               	.LVL238:
 2138               	.L85:
 399:main.c        **** 					DDRD &= ~(setValue);
 2139               		.loc 3 399 0
 2140 052c C434      		cpi r28,lo8(68)
 2141 052e 01F4      		brne .L86
 400:main.c        **** 				}
 2142               		.loc 3 400 0
 2143 0530 81B3      		in r24,0x11
 2144 0532 6095      		com r22
 2145               	.LVL239:
 2146 0534 6823      		and r22,r24
 2147               	.LVL240:
 2148 0536 00C0      		rjmp .L147
 2149               	.LVL241:
 2150               	.L86:
 402:main.c        **** 					DDRE &= ~(setValue);
 2151               		.loc 3 402 0
 2152 0538 C534      		cpi r28,lo8(69)
 2153 053a 01F0      		breq .+2
 2154 053c 00C0      		rjmp .L105
 403:main.c        **** 				}
 2155               		.loc 3 403 0
 2156 053e 86B1      		in r24,0x6
 2157 0540 6095      		com r22
 2158               	.LVL242:
 2159 0542 6823      		and r22,r24
 2160               	.LVL243:
 2161 0544 00C0      		rjmp .L148
 2162               	.LVL244:
 2163               	.L81:
 406:main.c        **** 				if (portChar == 'A') {
 2164               		.loc 3 406 0
 2165 0546 8F34      		cpi r24,lo8(79)
 2166 0548 01F0      		breq .+2
 2167 054a 00C0      		rjmp .L105
 407:main.c        **** 					DDRA |= (setValue);
 2168               		.loc 3 407 0
 2169 054c C134      		cpi r28,lo8(65)
 2170 054e 01F4      		brne .L87
 408:main.c        **** 				}
 2171               		.loc 3 408 0
 2172 0550 8AB3      		in r24,0x1a
 2173 0552 682B      		or r22,r24
 2174               	.LVL245:
 2175               	.L140:
 2176 0554 6ABB      		out 0x1a,r22
 2177 0556 00C0      		rjmp .L105
 2178               	.LVL246:
 2179               	.L87:
 410:main.c        **** 					DDRB |= (setValue);
 2180               		.loc 3 410 0
 2181 0558 C234      		cpi r28,lo8(66)
 2182 055a 01F4      		brne .L88
 411:main.c        **** 				}
 2183               		.loc 3 411 0
 2184 055c 87B3      		in r24,0x17
 2185 055e 682B      		or r22,r24
 2186               	.LVL247:
 2187               	.L141:
 2188 0560 67BB      		out 0x17,r22
 2189 0562 00C0      		rjmp .L105
 2190               	.LVL248:
 2191               	.L88:
 413:main.c        **** 					DDRC |= (setValue);
 2192               		.loc 3 413 0
 2193 0564 C334      		cpi r28,lo8(67)
 2194 0566 01F4      		brne .L89
 414:main.c        **** 				}
 2195               		.loc 3 414 0
 2196 0568 84B3      		in r24,0x14
 2197 056a 682B      		or r22,r24
 2198               	.LVL249:
 2199               	.L146:
 2200 056c 64BB      		out 0x14,r22
 2201 056e 00C0      		rjmp .L105
 2202               	.LVL250:
 2203               	.L89:
 416:main.c        **** 					DDRD |= (setValue);
 2204               		.loc 3 416 0
 2205 0570 C434      		cpi r28,lo8(68)
 2206 0572 01F4      		brne .L90
 417:main.c        **** 				}
 2207               		.loc 3 417 0
 2208 0574 81B3      		in r24,0x11
 2209 0576 682B      		or r22,r24
 2210               	.LVL251:
 2211               	.L147:
 2212 0578 61BB      		out 0x11,r22
 2213 057a 00C0      		rjmp .L105
 2214               	.LVL252:
 2215               	.L90:
 419:main.c        **** 					DDRE |= (setValue);
 2216               		.loc 3 419 0
 2217 057c C534      		cpi r28,lo8(69)
 2218 057e 01F0      		breq .+2
 2219 0580 00C0      		rjmp .L105
 420:main.c        **** 				}
 2220               		.loc 3 420 0
 2221 0582 86B1      		in r24,0x6
 2222 0584 682B      		or r22,r24
 2223               	.LVL253:
 2224               	.L148:
 2225 0586 66B9      		out 0x6,r22
 2226 0588 00C0      		rjmp .L105
 2227               	.LVL254:
 2228               	.L80:
 2229               	.LBE165:
 427:main.c        **** 			char portChar = USART_Receive();			
 2230               		.loc 3 427 0
 2231 058a 8C34      		cpi r24,lo8(76)
 2232 058c 01F4      		brne .L91
 2233               	.LBB166:
 428:main.c        **** 			usart_read_chars();
 2234               		.loc 3 428 0
 2235 058e 00D0      		rcall USART_Receive
 2236               	.LVL255:
 2237 0590 C82F      		mov r28,r24
 2238               	.LVL256:
 429:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2239               		.loc 3 429 0
 2240 0592 00D0      		rcall usart_read_chars
 2241               	.LVL257:
 430:main.c        **** 			
 2242               		.loc 3 430 0
 2243 0594 40E1      		ldi r20,lo8(16)
 2244 0596 50E0      		ldi r21,0
 2245 0598 60E0      		ldi r22,0
 2246 059a 70E0      		ldi r23,0
 2247 059c 80E0      		ldi r24,lo8(receivedBuffer)
 2248 059e 90E0      		ldi r25,hi8(receivedBuffer)
 2249 05a0 00D0      		rcall strtol
 2250               	.LVL258:
 432:main.c        **** 			if (portChar == 'A') {
 2251               		.loc 3 432 0
 2252 05a2 939A      		sbi 0x12,3
 433:main.c        **** 				PORTA &= ~(setValue);
 2253               		.loc 3 433 0
 2254 05a4 C134      		cpi r28,lo8(65)
 2255 05a6 01F4      		brne .L92
 434:main.c        **** 			}
 2256               		.loc 3 434 0
 2257 05a8 8BB3      		in r24,0x1b
 2258 05aa 6095      		com r22
 2259               	.LVL259:
 2260 05ac 6823      		and r22,r24
 2261               	.LVL260:
 2262 05ae 00C0      		rjmp .L145
 2263               	.LVL261:
 2264               	.L92:
 436:main.c        **** 				PORTB &= ~(setValue);
 2265               		.loc 3 436 0
 2266 05b0 C234      		cpi r28,lo8(66)
 2267 05b2 01F4      		brne .L94
 437:main.c        **** 			}
 2268               		.loc 3 437 0
 2269 05b4 88B3      		in r24,0x18
 2270 05b6 6095      		com r22
 2271               	.LVL262:
 2272 05b8 6823      		and r22,r24
 2273               	.LVL263:
 2274 05ba 00C0      		rjmp .L144
 2275               	.LVL264:
 2276               	.L94:
 439:main.c        **** 				PORTC &= ~(setValue);
 2277               		.loc 3 439 0
 2278 05bc C334      		cpi r28,lo8(67)
 2279 05be 01F4      		brne .L95
 440:main.c        **** 			}
 2280               		.loc 3 440 0
 2281 05c0 85B3      		in r24,0x15
 2282 05c2 6095      		com r22
 2283               	.LVL265:
 2284 05c4 6823      		and r22,r24
 2285               	.LVL266:
 2286 05c6 00C0      		rjmp .L143
 2287               	.LVL267:
 2288               	.L95:
 442:main.c        **** 				PORTD &= ~(setValue);
 2289               		.loc 3 442 0
 2290 05c8 C434      		cpi r28,lo8(68)
 2291 05ca 01F4      		brne .L96
 443:main.c        **** 			}
 2292               		.loc 3 443 0
 2293 05cc 82B3      		in r24,0x12
 2294 05ce 6095      		com r22
 2295               	.LVL268:
 2296 05d0 6823      		and r22,r24
 2297               	.LVL269:
 2298 05d2 00C0      		rjmp .L142
 2299               	.LVL270:
 2300               	.L96:
 445:main.c        **** 				PORTE &= ~(setValue);
 2301               		.loc 3 445 0
 2302 05d4 C534      		cpi r28,lo8(69)
 2303 05d6 01F0      		breq .+2
 2304 05d8 00C0      		rjmp .L105
 446:main.c        **** 			}
 2305               		.loc 3 446 0
 2306 05da 87B1      		in r24,0x7
 2307 05dc 6095      		com r22
 2308               	.LVL271:
 2309 05de 6823      		and r22,r24
 2310               	.LVL272:
 2311 05e0 00C0      		rjmp .L139
 2312               	.LVL273:
 2313               	.L91:
 2314               	.LBE166:
 452:main.c        **** 			char portChar = USART_Receive();			
 2315               		.loc 3 452 0
 2316 05e2 8834      		cpi r24,lo8(72)
 2317 05e4 01F4      		brne .L97
 2318               	.LBB167:
 453:main.c        **** 			usart_read_chars();
 2319               		.loc 3 453 0
 2320 05e6 00D0      		rcall USART_Receive
 2321               	.LVL274:
 2322 05e8 C82F      		mov r28,r24
 2323               	.LVL275:
 454:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2324               		.loc 3 454 0
 2325 05ea 00D0      		rcall usart_read_chars
 2326               	.LVL276:
 455:main.c        **** 			
 2327               		.loc 3 455 0
 2328 05ec 40E1      		ldi r20,lo8(16)
 2329 05ee 50E0      		ldi r21,0
 2330 05f0 60E0      		ldi r22,0
 2331 05f2 70E0      		ldi r23,0
 2332 05f4 80E0      		ldi r24,lo8(receivedBuffer)
 2333 05f6 90E0      		ldi r25,hi8(receivedBuffer)
 2334 05f8 00D0      		rcall strtol
 2335               	.LVL277:
 457:main.c        **** 			if (portChar == 'A') {
 2336               		.loc 3 457 0
 2337 05fa 939A      		sbi 0x12,3
 458:main.c        **** 				PORTA |= (setValue);
 2338               		.loc 3 458 0
 2339 05fc C134      		cpi r28,lo8(65)
 2340 05fe 01F4      		brne .L98
 459:main.c        **** 			}
 2341               		.loc 3 459 0
 2342 0600 8BB3      		in r24,0x1b
 2343 0602 682B      		or r22,r24
 2344               	.LVL278:
 2345               	.L145:
 2346 0604 6BBB      		out 0x1b,r22
 2347 0606 00C0      		rjmp .L105
 2348               	.LVL279:
 2349               	.L98:
 461:main.c        **** 				PORTB |= (setValue);
 2350               		.loc 3 461 0
 2351 0608 C234      		cpi r28,lo8(66)
 2352 060a 01F4      		brne .L100
 462:main.c        **** 			}
 2353               		.loc 3 462 0
 2354 060c 88B3      		in r24,0x18
 2355 060e 682B      		or r22,r24
 2356               	.LVL280:
 2357               	.L144:
 2358 0610 68BB      		out 0x18,r22
 2359 0612 00C0      		rjmp .L105
 2360               	.LVL281:
 2361               	.L100:
 464:main.c        **** 				PORTC |= (setValue);
 2362               		.loc 3 464 0
 2363 0614 C334      		cpi r28,lo8(67)
 2364 0616 01F4      		brne .L101
 465:main.c        **** 			}
 2365               		.loc 3 465 0
 2366 0618 85B3      		in r24,0x15
 2367 061a 682B      		or r22,r24
 2368               	.LVL282:
 2369               	.L143:
 2370 061c 65BB      		out 0x15,r22
 2371 061e 00C0      		rjmp .L105
 2372               	.LVL283:
 2373               	.L101:
 467:main.c        **** 				PORTD |= (setValue);
 2374               		.loc 3 467 0
 2375 0620 C434      		cpi r28,lo8(68)
 2376 0622 01F4      		brne .L102
 468:main.c        **** 			}
 2377               		.loc 3 468 0
 2378 0624 82B3      		in r24,0x12
 2379 0626 682B      		or r22,r24
 2380               	.LVL284:
 2381               	.L142:
 2382 0628 62BB      		out 0x12,r22
 2383 062a 00C0      		rjmp .L105
 2384               	.LVL285:
 2385               	.L102:
 470:main.c        **** 				PORTE |= (setValue);
 2386               		.loc 3 470 0
 2387 062c C534      		cpi r28,lo8(69)
 2388 062e 01F4      		brne .L105
 471:main.c        **** 			}
 2389               		.loc 3 471 0
 2390 0630 87B1      		in r24,0x7
 2391 0632 682B      		or r22,r24
 2392               	.LVL286:
 2393               	.L139:
 2394 0634 67B9      		out 0x7,r22
 2395 0636 00C0      		rjmp .L105
 2396               	.L97:
 2397               	.LBE167:
 477:main.c        **** 			char portChar = USART_Receive();			
 2398               		.loc 3 477 0
 2399 0638 8434      		cpi r24,lo8(68)
 2400 063a 01F4      		brne .L103
 2401               	.LBB168:
 478:main.c        **** 			
 2402               		.loc 3 478 0
 2403 063c 00D0      		rcall USART_Receive
 2404               	.LVL287:
 480:main.c        **** 			if (portChar == 'A') {
 2405               		.loc 3 480 0
 2406 063e 939A      		sbi 0x12,3
 481:main.c        **** 				USART_Transmit(PINA);
 2407               		.loc 3 481 0
 2408 0640 8134      		cpi r24,lo8(65)
 2409 0642 01F4      		brne .L104
 482:main.c        **** 			}
 2410               		.loc 3 482 0
 2411 0644 89B3      		in r24,0x19
 2412               	.LVL288:
 2413 0646 00C0      		rjmp .L136
 2414               	.LVL289:
 2415               	.L104:
 484:main.c        **** 				USART_Transmit(PINB);
 2416               		.loc 3 484 0
 2417 0648 8234      		cpi r24,lo8(66)
 2418 064a 01F4      		brne .L106
 485:main.c        **** 			}
 2419               		.loc 3 485 0
 2420 064c 86B3      		in r24,0x16
 2421               	.LVL290:
 2422 064e 00C0      		rjmp .L136
 2423               	.LVL291:
 2424               	.L106:
 487:main.c        **** 				USART_Transmit(PINC);
 2425               		.loc 3 487 0
 2426 0650 8334      		cpi r24,lo8(67)
 2427 0652 01F4      		brne .L107
 488:main.c        **** 			}
 2428               		.loc 3 488 0
 2429 0654 83B3      		in r24,0x13
 2430               	.LVL292:
 2431 0656 00C0      		rjmp .L136
 2432               	.LVL293:
 2433               	.L107:
 490:main.c        **** 				USART_Transmit(PIND);
 2434               		.loc 3 490 0
 2435 0658 8434      		cpi r24,lo8(68)
 2436 065a 01F4      		brne .L108
 491:main.c        **** 			}
 2437               		.loc 3 491 0
 2438 065c 80B3      		in r24,0x10
 2439               	.LVL294:
 2440 065e 00C0      		rjmp .L136
 2441               	.LVL295:
 2442               	.L108:
 493:main.c        **** 				USART_Transmit(PINE);
 2443               		.loc 3 493 0
 2444 0660 8534      		cpi r24,lo8(69)
 2445 0662 01F4      		brne .L105
 494:main.c        **** 			}
 2446               		.loc 3 494 0
 2447 0664 85B1      		in r24,0x5
 2448               	.LVL296:
 2449               	.L136:
 2450 0666 00D0      		rcall USART_Transmit
 2451               	.LVL297:
 2452               	.L105:
 496:main.c        **** 		}
 2453               		.loc 3 496 0
 2454 0668 9398      		cbi 0x12,3
 2455               	.LBE168:
 2456 066a 00C0      		rjmp .L39
 2457               	.LVL298:
 2458               	.L103:
 500:main.c        **** 			char commonChar = USART_Receive();
 2459               		.loc 3 500 0
 2460 066c 8D34      		cpi r24,lo8(77)
 2461 066e 01F4      		brne .L109
 2462               	.LBB169:
 501:main.c        **** 			if (commonChar == '1') {
 2463               		.loc 3 501 0
 2464 0670 00D0      		rcall USART_Receive
 2465               	.LVL299:
 502:main.c        **** 				resetCommonLines = 1;
 2466               		.loc 3 502 0
 2467 0672 8133      		cpi r24,lo8(49)
 2468 0674 01F4      		brne .L152
 503:main.c        **** 			}
 2469               		.loc 3 503 0
 2470 0676 7724      		clr r7
 2471 0678 7394      		inc r7
 2472 067a 00C0      		rjmp .L134
 2473               	.L152:
 505:main.c        **** 				resetCommonLines = 0;
 2474               		.loc 3 505 0
 2475 067c 8033      		cpi r24,lo8(48)
 2476 067e 01F0      		breq .+2
 2477 0680 00C0      		rjmp .L39
 506:main.c        **** 			}
 2478               		.loc 3 506 0
 2479 0682 712C      		mov r7,__zero_reg__
 2480 0684 00C0      		rjmp .L40
 2481               	.LVL300:
 2482               	.L109:
 2483               	.LBE169:
 511:main.c        **** 			USART_Transmit(PCB_VERSION);
 2484               		.loc 3 511 0
 2485 0686 8836      		cpi r24,lo8(104)
 2486 0688 01F4      		brne .L110
 512:main.c        **** 		}
 2487               		.loc 3 512 0
 2488 068a 84E6      		ldi r24,lo8(100)
 2489 068c 00C0      		rjmp .L135
 2490               	.L110:
 516:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2491               		.loc 3 516 0
 2492 068e 8635      		cpi r24,lo8(86)
 2493 0690 01F4      		brne .L111
 517:main.c        **** 		}
 2494               		.loc 3 517 0
 2495 0692 8FE0      		ldi r24,lo8(15)
 2496               	.LVL301:
 2497               	.L135:
 2498 0694 00D0      		rcall USART_Transmit
 2499               	.LVL302:
 2500 0696 00C0      		rjmp .L39
 2501               	.LVL303:
 2502               	.L111:
 521:main.c        **** 			usart_read_chars();
 2503               		.loc 3 521 0
 2504 0698 8A32      		cpi r24,lo8(42)
 2505 069a 01F0      		breq .+2
 2506 069c 00C0      		rjmp .L39
 2507               	.LBB170:
 522:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 2508               		.loc 3 522 0
 2509 069e 00D0      		rcall usart_read_chars
 2510               	.LVL304:
 523:main.c        **** 			if (resetValue == RESET_VALUE) {
 2511               		.loc 3 523 0
 2512 06a0 40E1      		ldi r20,lo8(16)
 2513 06a2 50E0      		ldi r21,0
 2514 06a4 60E0      		ldi r22,0
 2515 06a6 70E0      		ldi r23,0
 2516 06a8 80E0      		ldi r24,lo8(receivedBuffer)
 2517 06aa 90E0      		ldi r25,hi8(receivedBuffer)
 2518 06ac 00D0      		rcall strtol
 2519               	.LVL305:
 524:main.c        **** 				// Clear watchdog flag
 2520               		.loc 3 524 0
 2521 06ae 613E      		cpi r22,-31
 2522 06b0 754E      		sbci r23,-27
 2523 06b2 8740      		sbci r24,7
 2524 06b4 9105      		cpc r25,__zero_reg__
 2525 06b6 01F0      		breq .+2
 2526 06b8 00C0      		rjmp .L39
 526:main.c        **** 				
 2527               		.loc 3 526 0
 2528 06ba 84B7      		in r24,0x34
 2529 06bc 877F      		andi r24,lo8(-9)
 2530 06be 84BF      		out 0x34,r24
 529:main.c        **** 				
 2531               		.loc 3 529 0
 2532 06c0 31BC      		out 0x21,r3
 2533               		.loc 3 532 0
 2534 06c2 21BC      		out 0x21,r2
 2535               	.LVL306:
 2536               	.LBB115:
 2537               	.LBB114:
 2538               		.loc 4 105 0
 2539 06c4 C201      		movw r24,r4
 2540               	/* #APP */
 2541               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 2542 06c6 0197      		1: sbiw r24,1
 2543 06c8 01F4      		brne 1b
 2544               	 ;  0 "" 2
 2545               	.LVL307:
 2546               	/* #NOAPP */
 2547 06ca 00C0      		rjmp .L39
 2548               	.LBE114:
 2549               	.LBE115:
 2550               	.LBE170:
 2551               		.cfi_endproc
 2552               	.LFE27:
 2554               	.global	cartMode
 2555               		.data
 2558               	cartMode:
 2559 0000 01        		.byte	1
 2560               	.global	lastBankAccessed
 2561               		.section .bss
 2564               	lastBankAccessed:
 2565 0000 00        		.zero	1
 2566               	.global	flashBank1CommandWrites
 2569               	flashBank1CommandWrites:
 2570 0001 00        		.zero	1
 2571               		.comm	flashWriteCycle,12,1
 2572               		.comm	flashWriteWePin,1,1
 2573               		.comm	receivedChar,1,1
 2574               		.comm	receivedBuffer,256,1
 2575               		.text
 2576               	.Letext0:
 2577               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2578               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:274    .text:00000086 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:343    .text:000000b4 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:391    .text:000000ca gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:494    .text:00000108 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:595    .text:0000016c gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:2569   .bss:00000001 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:2564   .bss:00000000 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:726    .text:000001fa gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:897    .text:00000292 setup
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:1000   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccZGDy6v.s:2558   .data:00000000 cartMode

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
