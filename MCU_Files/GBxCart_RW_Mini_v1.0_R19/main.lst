   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW Mini
   3:setup.c       ****  PCB version: 1.0
   4:setup.c       ****  Firmware version: R19
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 22/09/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define ACTIVITY_LED PD3
  28:setup.c       **** 
  29:setup.c       **** #define WR_PIN PD6
  30:setup.c       **** #define RD_PIN PD5
  31:setup.c       **** #define CS_MREQ_PIN PD4
  32:setup.c       **** #define CS2_PIN PE2
  33:setup.c       **** #define AUDIO_PIN PE1
  34:setup.c       **** 
  35:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  36:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  37:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  38:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  39:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  40:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  41:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  42:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  43:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  44:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  45:setup.c       **** 
  46:setup.c       **** #define GB_MODE 1
  47:setup.c       **** 
  48:setup.c       **** // GB/GBC
  49:setup.c       **** #define PORT_ADDR7_0 PORTB
  50:setup.c       **** #define PORT_ADDR15_8 PORTA
  51:setup.c       **** #define PORT_DATA7_0 PORTC
  52:setup.c       **** 
  53:setup.c       **** #define DDR_ADDR7_0 DDRB
  54:setup.c       **** #define DDR_ADDR15_8 DDRA
  55:setup.c       **** #define DDR_DATA7_0 DDRC
  56:setup.c       **** 
  57:setup.c       **** #define PIN_ADDR7_0 PINB
  58:setup.c       **** #define PIN_ADDR15_8 PINA
  59:setup.c       **** #define PIN_DATA7_0 PINC
  60:setup.c       **** 
  61:setup.c       **** #define BANK_WRITE 0
  62:setup.c       **** #define MEMORY_WRITE 1
  63:setup.c       **** 
  64:setup.c       **** 
  65:setup.c       **** // GB/GBC commands
  66:setup.c       **** #define SET_START_ADDRESS 'A'
  67:setup.c       **** #define READ_ROM_RAM 'R'
  68:setup.c       **** #define READ_ROM_4000H 'Q'
  69:setup.c       **** #define WRITE_RAM 'W'
  70:setup.c       **** #define SET_BANK 'B'
  71:setup.c       **** #define GB_CART_MODE 'G'
  72:setup.c       **** 
  73:setup.c       **** // Flash Cart commands
  74:setup.c       **** #define GB_FLASH_WE_PIN 'P'
  75:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
  76:setup.c       **** 	#define WE_AS_WR_PIN 'W'
  77:setup.c       **** 
  78:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
  79:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
  80:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
  81:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
  82:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
  83:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
  84:setup.c       **** 
  85:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
  86:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
  87:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
  88:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
  89:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
  90:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
  91:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
  92:setup.c       **** 
  93:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
  94:setup.c       **** 
  95:setup.c       **** #define D0D1_NOT_SWAPPED 0
  96:setup.c       **** #define D0D1_SWAPPED 1
  97:setup.c       **** 
  98:setup.c       **** // General commands
  99:setup.c       **** #define SEND_ACK '1'
 100:setup.c       **** #define CART_MODE 'C'
 101:setup.c       **** #define SET_INPUT 'I'
 102:setup.c       **** #define SET_OUTPUT 'O'
 103:setup.c       **** #define SET_OUTPUT_LOW 'L'
 104:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 105:setup.c       **** #define READ_INPUT 'D'
 106:setup.c       **** #define RESET_COMMON_LINES 'M'
 107:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 108:setup.c       **** #define READ_PCB_VERSION 'h'
 109:setup.c       **** #define FAST_READ_CHECK '+'
 110:setup.c       **** 
 111:setup.c       **** #define RESET_AVR '*'
 112:setup.c       **** #define RESET_VALUE 0x7E5E1
 113:setup.c       **** 
 114:setup.c       **** 
 115:setup.c       **** char receivedBuffer[256];
 116:setup.c       **** char receivedChar;
 117:setup.c       **** 
 118:setup.c       **** char flashWriteWePin;
 119:setup.c       **** uint16_t flashWriteCycle[3][2];
 120:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 121:setup.c       **** uint8_t lastBankAccessed = 0;
 122:setup.c       **** volatile uint8_t writingTimedout = 0;
 123:setup.c       **** 
 124:setup.c       **** uint8_t cartMode = GB_MODE;
 125:setup.c       **** 
 126:setup.c       **** // Receive USART data
 127:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 127 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 128:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 128 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 129:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 129 0
  26 0004 8CB1      		in r24,0xc
 130:setup.c       **** }
  27               		.loc 1 130 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 131:setup.c       **** 
 132:setup.c       **** // Transmit USART data
 133:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 133 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 134:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 134 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 135:setup.c       **** 	UDR = data;
  47               		.loc 1 135 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 136:setup.c       **** }
 137:setup.c       **** 
 138:setup.c       **** // Read 1-256 bytes from the USART 
 139:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 139 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB89:
 140:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 140 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 140 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 141:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 141 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE89:
 142:setup.c       **** 	}
 143:setup.c       **** }
 106               		.loc 1 143 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 144:setup.c       **** 
 145:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 146:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 146 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 147:setup.c       **** 	int x = 0;
 148:setup.c       **** 	while (1) {
 149:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 149 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 150:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 150 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 151:setup.c       **** 			break;
 152:setup.c       **** 		}
 153:setup.c       **** 		x++;
 154:setup.c       **** 	}
 155:setup.c       **** }
 148               		.loc 1 155 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 156:setup.c       **** 
 157:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 158:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 158 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 159:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 159 0
 167 0050 3A9A      		sbi 0x7,2
 160:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 160 0
 169 0052 949A      		sbi 0x12,4
 161:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 161 0
 171 0054 959A      		sbi 0x12,5
 162:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 162 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 163:setup.c       **** }
 164:setup.c       **** 
 165:setup.c       **** 
 166:setup.c       **** 
 167:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 168:setup.c       **** 
 169:setup.c       **** // Set Gameboy mode
 170:setup.c       **** void gb_mode(void) {
 182               		.loc 1 170 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 171:setup.c       **** 	// Set inputs
 172:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 172 0
 189 005a 15BA      		out 0x15,__zero_reg__
 173:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 173 0
 191 005c 14BA      		out 0x14,__zero_reg__
 174:setup.c       **** 	
 175:setup.c       **** 	// Set outputs
 176:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 176 0
 193 005e 18BA      		out 0x18,__zero_reg__
 177:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 177 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 178:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 178 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 179:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 179 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 180:setup.c       **** }
 181:setup.c       **** 
 182:setup.c       **** // Set the 16 bit address on A15-0
 183:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 183 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 184:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 184 0
 217 006a 9BBB      		out 0x1b,r25
 185:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 185 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 186:setup.c       **** }
 187:setup.c       **** 
 188:setup.c       **** // Set the address and read a byte from the 8 bit data line
 189:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 189 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 190:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 190 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 191:setup.c       **** 	
 192:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 192 0
 239 0072 9498      		cbi 0x12,4
 193:setup.c       **** 	rdPin_low;
 240               		.loc 1 193 0
 241 0074 9598      		cbi 0x12,5
 194:setup.c       **** 	
 195:setup.c       **** 	asm volatile("nop"); // Delay a little (At 8MHz - minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 195 0
 243               	/* #APP */
 244               	 ;  195 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 196:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 196 0
 248               	 ;  196 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 197:setup.c       **** 	asm volatile("nop");
 251               		.loc 1 197 0
 252               	 ;  197 "setup.c" 1
 253 007a 0000      		nop
 254               	 ;  0 "" 2
 198:setup.c       **** 	asm volatile("nop");
 255               		.loc 1 198 0
 256               	 ;  198 "setup.c" 1
 257 007c 0000      		nop
 258               	 ;  0 "" 2
 199:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 259               		.loc 1 199 0
 260               	/* #NOAPP */
 261 007e 83B3      		in r24,0x13
 262               	.LVL17:
 200:setup.c       **** 	
 201:setup.c       **** 	rdPin_high;
 263               		.loc 1 201 0
 264 0080 959A      		sbi 0x12,5
 202:setup.c       **** 	cs_mreqPin_high;
 265               		.loc 1 202 0
 266 0082 949A      		sbi 0x12,4
 203:setup.c       **** 	
 204:setup.c       **** 	return data;
 205:setup.c       **** }
 267               		.loc 1 205 0
 268 0084 0895      		ret
 269               		.cfi_endproc
 270               	.LFE19:
 272               	.global	write_8bit_data
 274               	write_8bit_data:
 275               	.LFB20:
 206:setup.c       **** 
 207:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 208:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 276               		.loc 1 208 0
 277               		.cfi_startproc
 278               	.LVL18:
 279 0086 CF93      		push r28
 280               	.LCFI6:
 281               		.cfi_def_cfa_offset 3
 282               		.cfi_offset 28, -2
 283 0088 DF93      		push r29
 284               	.LCFI7:
 285               		.cfi_def_cfa_offset 4
 286               		.cfi_offset 29, -3
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 2 */
 290               	.L__stack_usage = 2
 291 008a D62F      		mov r29,r22
 292 008c C42F      		mov r28,r20
 209:setup.c       **** 	set_16bit_address(address);
 293               		.loc 1 209 0
 294 008e 00D0      		rcall set_16bit_address
 295               	.LVL19:
 210:setup.c       **** 	
 211:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 296               		.loc 1 211 0
 297 0090 8FEF      		ldi r24,lo8(-1)
 298 0092 84BB      		out 0x14,r24
 212:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 299               		.loc 1 212 0
 300 0094 D5BB      		out 0x15,r29
 213:setup.c       **** 	
 214:setup.c       **** 	// Pulse WR and mREQ if the type matches
 215:setup.c       **** 	wrPin_low;
 301               		.loc 1 215 0
 302 0096 9698      		cbi 0x12,6
 216:setup.c       **** 	if (type == MEMORY_WRITE) {
 303               		.loc 1 216 0
 304 0098 C130      		cpi r28,lo8(1)
 305 009a 01F4      		brne .L21
 217:setup.c       **** 		cs_mreqPin_low;
 306               		.loc 1 217 0
 307 009c 9498      		cbi 0x12,4
 308               	.L21:
 218:setup.c       **** 	}
 219:setup.c       **** 	
 220:setup.c       **** 	asm volatile("nop");
 309               		.loc 1 220 0
 310               	/* #APP */
 311               	 ;  220 "setup.c" 1
 312 009e 0000      		nop
 313               	 ;  0 "" 2
 221:setup.c       **** 	asm volatile("nop");
 314               		.loc 1 221 0
 315               	 ;  221 "setup.c" 1
 316 00a0 0000      		nop
 317               	 ;  0 "" 2
 222:setup.c       **** 	
 223:setup.c       **** 	if (type == MEMORY_WRITE) {
 318               		.loc 1 223 0
 319               	/* #NOAPP */
 320 00a2 C130      		cpi r28,lo8(1)
 321 00a4 01F4      		brne .L22
 224:setup.c       **** 		cs_mreqPin_high;
 322               		.loc 1 224 0
 323 00a6 949A      		sbi 0x12,4
 324               	.L22:
 225:setup.c       **** 	}
 226:setup.c       **** 	wrPin_high;
 325               		.loc 1 226 0
 326 00a8 969A      		sbi 0x12,6
 227:setup.c       **** 	
 228:setup.c       **** 	// Clear data outputs and set data pins as inputs
 229:setup.c       **** 	PORT_DATA7_0 = 0;
 327               		.loc 1 229 0
 328 00aa 15BA      		out 0x15,__zero_reg__
 230:setup.c       **** 	DDR_DATA7_0 = 0;
 329               		.loc 1 230 0
 330 00ac 14BA      		out 0x14,__zero_reg__
 331               	/* epilogue start */
 231:setup.c       **** }
 332               		.loc 1 231 0
 333 00ae DF91      		pop r29
 334               	.LVL20:
 335 00b0 CF91      		pop r28
 336               	.LVL21:
 337 00b2 0895      		ret
 338               		.cfi_endproc
 339               	.LFE20:
 341               	.global	gb_flash_read_byte
 343               	gb_flash_read_byte:
 344               	.LFB21:
 232:setup.c       **** 
 233:setup.c       **** 
 234:setup.c       **** 
 235:setup.c       **** // ---------- GB FLASH CARTS ----------
 236:setup.c       **** 
 237:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 238:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 345               		.loc 1 238 0
 346               		.cfi_startproc
 347               	.LVL22:
 348               	/* prologue: function */
 349               	/* frame size = 0 */
 350               	/* stack size = 0 */
 351               	.L__stack_usage = 0
 239:setup.c       **** 	PORT_DATA7_0 = 0;
 352               		.loc 1 239 0
 353 00b4 15BA      		out 0x15,__zero_reg__
 240:setup.c       **** 	DDR_DATA7_0 = 0;
 354               		.loc 1 240 0
 355 00b6 14BA      		out 0x14,__zero_reg__
 241:setup.c       **** 	
 242:setup.c       **** 	set_16bit_address(address);
 356               		.loc 1 242 0
 357 00b8 00D0      		rcall set_16bit_address
 358               	.LVL23:
 243:setup.c       **** 	
 244:setup.c       **** 	rdPin_low;
 359               		.loc 1 244 0
 360 00ba 9598      		cbi 0x12,5
 245:setup.c       **** 	asm volatile("nop"); // Delay a little
 361               		.loc 1 245 0
 362               	/* #APP */
 363               	 ;  245 "setup.c" 1
 364 00bc 0000      		nop
 365               	 ;  0 "" 2
 246:setup.c       **** 	asm volatile("nop");
 366               		.loc 1 246 0
 367               	 ;  246 "setup.c" 1
 368 00be 0000      		nop
 369               	 ;  0 "" 2
 247:setup.c       **** 	asm volatile("nop");
 370               		.loc 1 247 0
 371               	 ;  247 "setup.c" 1
 372 00c0 0000      		nop
 373               	 ;  0 "" 2
 248:setup.c       **** 	asm volatile("nop");
 374               		.loc 1 248 0
 375               	 ;  248 "setup.c" 1
 376 00c2 0000      		nop
 377               	 ;  0 "" 2
 249:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 378               		.loc 1 249 0
 379               	/* #NOAPP */
 380 00c4 83B3      		in r24,0x13
 381               	.LVL24:
 250:setup.c       **** 	rdPin_high;
 382               		.loc 1 250 0
 383 00c6 959A      		sbi 0x12,5
 251:setup.c       **** 	
 252:setup.c       **** 	return data;
 253:setup.c       **** }
 384               		.loc 1 253 0
 385 00c8 0895      		ret
 386               		.cfi_endproc
 387               	.LFE21:
 389               	.global	gb_flash_write_bus_cycle
 391               	gb_flash_write_bus_cycle:
 392               	.LFB22:
 254:setup.c       **** 
 255:setup.c       **** // Set the address and data for the write byte cycle to the flash
 256:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 393               		.loc 1 256 0
 394               		.cfi_startproc
 395               	.LVL25:
 396 00ca CF93      		push r28
 397               	.LCFI8:
 398               		.cfi_def_cfa_offset 3
 399               		.cfi_offset 28, -2
 400               	/* prologue: function */
 401               	/* frame size = 0 */
 402               	/* stack size = 1 */
 403               	.L__stack_usage = 1
 404 00cc C62F      		mov r28,r22
 257:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 405               		.loc 1 257 0
 406 00ce 2FEF      		ldi r18,lo8(-1)
 407 00d0 24BB      		out 0x14,r18
 258:setup.c       **** 	set_16bit_address(address);
 408               		.loc 1 258 0
 409 00d2 00D0      		rcall set_16bit_address
 410               	.LVL26:
 259:setup.c       **** 	PORT_DATA7_0 = data;
 411               		.loc 1 259 0
 412 00d4 C5BB      		out 0x15,r28
 260:setup.c       **** 	
 261:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 413               		.loc 1 261 0
 414 00d6 8091 0000 		lds r24,flashWriteWePin
 415 00da 8134      		cpi r24,lo8(65)
 416 00dc 01F4      		brne .L25
 262:setup.c       **** 		audioPin_low; // WE low
 417               		.loc 1 262 0
 418 00de 3998      		cbi 0x7,1
 263:setup.c       **** 		asm volatile("nop");
 419               		.loc 1 263 0
 420               	/* #APP */
 421               	 ;  263 "setup.c" 1
 422 00e0 0000      		nop
 423               	 ;  0 "" 2
 264:setup.c       **** 		asm volatile("nop");
 424               		.loc 1 264 0
 425               	 ;  264 "setup.c" 1
 426 00e2 0000      		nop
 427               	 ;  0 "" 2
 265:setup.c       **** 		asm volatile("nop");
 428               		.loc 1 265 0
 429               	 ;  265 "setup.c" 1
 430 00e4 0000      		nop
 431               	 ;  0 "" 2
 266:setup.c       **** 		asm volatile("nop");
 432               		.loc 1 266 0
 433               	 ;  266 "setup.c" 1
 434 00e6 0000      		nop
 435               	 ;  0 "" 2
 267:setup.c       **** 		asm volatile("nop");
 436               		.loc 1 267 0
 437               	 ;  267 "setup.c" 1
 438 00e8 0000      		nop
 439               	 ;  0 "" 2
 268:setup.c       **** 		asm volatile("nop");
 440               		.loc 1 268 0
 441               	 ;  268 "setup.c" 1
 442 00ea 0000      		nop
 443               	 ;  0 "" 2
 269:setup.c       **** 		audioPin_high; // WE high
 444               		.loc 1 269 0
 445               	/* #NOAPP */
 446 00ec 399A      		sbi 0x7,1
 447 00ee 00C0      		rjmp .L26
 448               	.L25:
 270:setup.c       **** 	}
 271:setup.c       **** 	else { // WR pin
 272:setup.c       **** 		wrPin_low; // WE low
 449               		.loc 1 272 0
 450 00f0 9698      		cbi 0x12,6
 273:setup.c       **** 		asm volatile("nop");
 451               		.loc 1 273 0
 452               	/* #APP */
 453               	 ;  273 "setup.c" 1
 454 00f2 0000      		nop
 455               	 ;  0 "" 2
 274:setup.c       **** 		asm volatile("nop");
 456               		.loc 1 274 0
 457               	 ;  274 "setup.c" 1
 458 00f4 0000      		nop
 459               	 ;  0 "" 2
 275:setup.c       **** 		asm volatile("nop");
 460               		.loc 1 275 0
 461               	 ;  275 "setup.c" 1
 462 00f6 0000      		nop
 463               	 ;  0 "" 2
 276:setup.c       **** 		asm volatile("nop");
 464               		.loc 1 276 0
 465               	 ;  276 "setup.c" 1
 466 00f8 0000      		nop
 467               	 ;  0 "" 2
 277:setup.c       **** 		asm volatile("nop");
 468               		.loc 1 277 0
 469               	 ;  277 "setup.c" 1
 470 00fa 0000      		nop
 471               	 ;  0 "" 2
 278:setup.c       **** 		asm volatile("nop");
 472               		.loc 1 278 0
 473               	 ;  278 "setup.c" 1
 474 00fc 0000      		nop
 475               	 ;  0 "" 2
 279:setup.c       **** 		wrPin_high; // WE high
 476               		.loc 1 279 0
 477               	/* #NOAPP */
 478 00fe 969A      		sbi 0x12,6
 479               	.L26:
 280:setup.c       **** 	}
 281:setup.c       **** 	
 282:setup.c       **** 	// Clear data outputs and set data pins as inputs
 283:setup.c       **** 	PORT_DATA7_0 = 0;
 480               		.loc 1 283 0
 481 0100 15BA      		out 0x15,__zero_reg__
 284:setup.c       **** 	DDR_DATA7_0 = 0;
 482               		.loc 1 284 0
 483 0102 14BA      		out 0x14,__zero_reg__
 484               	/* epilogue start */
 285:setup.c       **** }
 485               		.loc 1 285 0
 486 0104 CF91      		pop r28
 487               	.LVL27:
 488 0106 0895      		ret
 489               		.cfi_endproc
 490               	.LFE22:
 492               	.global	gb_flash_write_byte
 494               	gb_flash_write_byte:
 495               	.LFB23:
 286:setup.c       **** 
 287:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 288:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 496               		.loc 1 288 0
 497               		.cfi_startproc
 498               	.LVL28:
 499 0108 1F93      		push r17
 500               	.LCFI9:
 501               		.cfi_def_cfa_offset 3
 502               		.cfi_offset 17, -2
 503 010a CF93      		push r28
 504               	.LCFI10:
 505               		.cfi_def_cfa_offset 4
 506               		.cfi_offset 28, -3
 507 010c DF93      		push r29
 508               	.LCFI11:
 509               		.cfi_def_cfa_offset 5
 510               		.cfi_offset 29, -4
 511               	/* prologue: function */
 512               	/* frame size = 0 */
 513               	/* stack size = 3 */
 514               	.L__stack_usage = 3
 515 010e EC01      		movw r28,r24
 516 0110 162F      		mov r17,r22
 289:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 517               		.loc 1 289 0
 518 0112 6091 0000 		lds r22,flashWriteCycle+2
 519               	.LVL29:
 520 0116 8091 0000 		lds r24,flashWriteCycle
 521 011a 9091 0000 		lds r25,flashWriteCycle+1
 522               	.LVL30:
 523 011e 00D0      		rcall gb_flash_write_bus_cycle
 524               	.LVL31:
 290:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 525               		.loc 1 290 0
 526 0120 6091 0000 		lds r22,flashWriteCycle+6
 527 0124 8091 0000 		lds r24,flashWriteCycle+4
 528 0128 9091 0000 		lds r25,flashWriteCycle+4+1
 529 012c 00D0      		rcall gb_flash_write_bus_cycle
 530               	.LVL32:
 291:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 531               		.loc 1 291 0
 532 012e 6091 0000 		lds r22,flashWriteCycle+10
 533 0132 8091 0000 		lds r24,flashWriteCycle+8
 534 0136 9091 0000 		lds r25,flashWriteCycle+8+1
 535 013a 00D0      		rcall gb_flash_write_bus_cycle
 536               	.LVL33:
 292:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 537               		.loc 1 292 0
 538 013c 612F      		mov r22,r17
 539 013e CE01      		movw r24,r28
 540 0140 00D0      		rcall gb_flash_write_bus_cycle
 541               	.LVL34:
 542               	.LBB90:
 543               	.LBB91:
 544               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 545               		.loc 2 276 0
 546 0142 85E3      		ldi r24,lo8(53)
 547 0144 8A95      	1:	dec r24
 548 0146 01F4      		brne 1b
 549 0148 0000      		nop
 550               	.LVL35:
 551               	.LBE91:
 552               	.LBE90:
 293:setup.c       **** 	_delay_us(10); // Wait byte program time
 294:setup.c       **** 	
 295:setup.c       **** 	// Set data pins inputs
 296:setup.c       **** 	PORT_DATA7_0 = 0;
 553               		.loc 1 296 0
 554 014a 15BA      		out 0x15,__zero_reg__
 297:setup.c       **** 	DDR_DATA7_0 = 0;
 555               		.loc 1 297 0
 556 014c 14BA      		out 0x14,__zero_reg__
 298:setup.c       **** 	
 299:setup.c       **** 	// Verify data
 300:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 557               		.loc 1 300 0
 558 014e CE01      		movw r24,r28
 559 0150 00D0      		rcall gb_flash_read_byte
 560               	.LVL36:
 561               	.L28:
 301:setup.c       **** 	while (data != dataVerify) {
 562               		.loc 1 301 0
 563 0152 8117      		cp r24,r17
 564 0154 01F0      		breq .L27
 302:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 565               		.loc 1 302 0
 566 0156 CE01      		movw r24,r28
 567               	.LVL37:
 568 0158 00D0      		rcall gb_flash_read_byte
 569               	.LVL38:
 570               	.LBB92:
 571               	.LBB93:
 572               		.loc 2 276 0
 573 015a 9AE1      		ldi r25,lo8(26)
 574 015c 9A95      	1:	dec r25
 575 015e 01F4      		brne 1b
 576 0160 00C0      		rjmp .
 577               	.LVL39:
 578               	.LBE93:
 579               	.LBE92:
 303:setup.c       **** 		_delay_us(5);
 304:setup.c       **** 		if (writingTimedout == 1) {
 580               		.loc 1 304 0
 581 0162 9091 0000 		lds r25,writingTimedout
 582 0166 9130      		cpi r25,lo8(1)
 583 0168 01F4      		brne .L28
 584               	.L27:
 585               	/* epilogue start */
 305:setup.c       **** 			break;
 306:setup.c       **** 		}
 307:setup.c       **** 	}
 308:setup.c       **** }
 586               		.loc 1 308 0
 587 016a DF91      		pop r29
 588 016c CF91      		pop r28
 589               	.LVL40:
 590 016e 1F91      		pop r17
 591               	.LVL41:
 592 0170 0895      		ret
 593               		.cfi_endproc
 594               	.LFE23:
 596               	.global	gb_flash_write_byte_special
 598               	gb_flash_write_byte_special:
 599               	.LFB24:
 309:setup.c       **** 
 310:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 311:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 600               		.loc 1 311 0
 601               		.cfi_startproc
 602               	.LVL42:
 603 0172 1F93      		push r17
 604               	.LCFI12:
 605               		.cfi_def_cfa_offset 3
 606               		.cfi_offset 17, -2
 607 0174 CF93      		push r28
 608               	.LCFI13:
 609               		.cfi_def_cfa_offset 4
 610               		.cfi_offset 28, -3
 611 0176 DF93      		push r29
 612               	.LCFI14:
 613               		.cfi_def_cfa_offset 5
 614               		.cfi_offset 29, -4
 615               	/* prologue: function */
 616               	/* frame size = 0 */
 617               	/* stack size = 3 */
 618               	.L__stack_usage = 3
 619 0178 EC01      		movw r28,r24
 620 017a 162F      		mov r17,r22
 312:setup.c       **** 	// Set bank back
 313:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 621               		.loc 1 313 0
 622 017c 8091 0000 		lds r24,flashBank1CommandWrites
 623               	.LVL43:
 624 0180 8130      		cpi r24,lo8(1)
 625 0182 01F4      		brne .L33
 314:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 626               		.loc 1 314 0
 627 0184 40E0      		ldi r20,0
 628 0186 6091 0000 		lds r22,lastBankAccessed
 629               	.LVL44:
 630 018a 80E0      		ldi r24,0
 631 018c 91E2      		ldi r25,lo8(33)
 632 018e 00D0      		rcall write_8bit_data
 633               	.LVL45:
 634               	.LBB94:
 635               	.LBB95:
 636               		.loc 2 276 0
 637 0190 87EC      		ldi r24,lo8(199)
 638 0192 90E0      		ldi r25,hi8(199)
 639 0194 0197      	1:	sbiw r24,1
 640 0196 01F4      		brne 1b
 641 0198 00C0      		rjmp .
 642 019a 0000      		nop
 643               	.LVL46:
 644               	.L33:
 645               	.LBE95:
 646               	.LBE94:
 315:setup.c       **** 		_delay_us(50);
 316:setup.c       **** 	}
 317:setup.c       **** 	
 318:setup.c       **** 	// Write
 319:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 647               		.loc 1 319 0
 648 019c 6091 0000 		lds r22,flashWriteCycle+2
 649 01a0 8091 0000 		lds r24,flashWriteCycle
 650 01a4 9091 0000 		lds r25,flashWriteCycle+1
 651 01a8 00D0      		rcall gb_flash_write_bus_cycle
 652               	.LVL47:
 320:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 653               		.loc 1 320 0
 654 01aa 6091 0000 		lds r22,flashWriteCycle+6
 655 01ae 8091 0000 		lds r24,flashWriteCycle+4
 656 01b2 9091 0000 		lds r25,flashWriteCycle+4+1
 657 01b6 00D0      		rcall gb_flash_write_bus_cycle
 658               	.LVL48:
 321:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 659               		.loc 1 321 0
 660 01b8 6091 0000 		lds r22,flashWriteCycle+10
 661 01bc 8091 0000 		lds r24,flashWriteCycle+8
 662 01c0 9091 0000 		lds r25,flashWriteCycle+8+1
 663 01c4 00D0      		rcall gb_flash_write_bus_cycle
 664               	.LVL49:
 322:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 665               		.loc 1 322 0
 666 01c6 612F      		mov r22,r17
 667 01c8 CE01      		movw r24,r28
 668 01ca 00D0      		rcall gb_flash_write_bus_cycle
 669               	.LVL50:
 670               	.LBB96:
 671               	.LBB97:
 672               		.loc 2 276 0
 673 01cc 87EE      		ldi r24,lo8(999)
 674 01ce 93E0      		ldi r25,hi8(999)
 675 01d0 0197      	1:	sbiw r24,1
 676 01d2 01F4      		brne 1b
 677 01d4 00C0      		rjmp .
 678 01d6 0000      		nop
 679               	.LVL51:
 680               	.LBE97:
 681               	.LBE96:
 323:setup.c       **** 	_delay_us(250); // Wait byte program time
 324:setup.c       **** 	
 325:setup.c       **** 	// Set data pins inputs
 326:setup.c       **** 	PORT_DATA7_0 = 0;
 682               		.loc 1 326 0
 683 01d8 15BA      		out 0x15,__zero_reg__
 327:setup.c       **** 	DDR_DATA7_0 = 0;
 684               		.loc 1 327 0
 685 01da 14BA      		out 0x14,__zero_reg__
 328:setup.c       **** 	
 329:setup.c       **** 	// Pulse reset
 330:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 686               		.loc 1 330 0
 687 01dc 3A98      		cbi 0x7,2
 688               	.LVL52:
 689               	.LBB98:
 690               	.LBB99:
 691               		.loc 2 276 0
 692 01de 87EC      		ldi r24,lo8(199)
 693 01e0 90E0      		ldi r25,hi8(199)
 694 01e2 0197      	1:	sbiw r24,1
 695 01e4 01F4      		brne 1b
 696 01e6 00C0      		rjmp .
 697 01e8 0000      		nop
 698               	.LVL53:
 699               	.LBE99:
 700               	.LBE98:
 331:setup.c       **** 	_delay_us(50);
 332:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 701               		.loc 1 332 0
 702 01ea 3A9A      		sbi 0x7,2
 703               	.LVL54:
 704               	.LBB100:
 705               	.LBB101:
 706               		.loc 2 276 0
 707 01ec 87EC      		ldi r24,lo8(199)
 708 01ee 90E0      		ldi r25,hi8(199)
 709 01f0 0197      	1:	sbiw r24,1
 710 01f2 01F4      		brne 1b
 711 01f4 00C0      		rjmp .
 712 01f6 0000      		nop
 713               	.LVL55:
 714               	/* epilogue start */
 715               	.LBE101:
 716               	.LBE100:
 333:setup.c       **** 	_delay_us(50);
 334:setup.c       **** }
 717               		.loc 1 334 0
 718 01f8 DF91      		pop r29
 719 01fa CF91      		pop r28
 720               	.LVL56:
 721 01fc 1F91      		pop r17
 722               	.LVL57:
 723 01fe 0895      		ret
 724               		.cfi_endproc
 725               	.LFE24:
 727               	.global	gb_flash_write_byte_bank1_commands
 729               	gb_flash_write_byte_bank1_commands:
 730               	.LFB25:
 335:setup.c       **** 
 336:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 337:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 338:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 731               		.loc 1 338 0
 732               		.cfi_startproc
 733               	.LVL58:
 734 0200 FF92      		push r15
 735               	.LCFI15:
 736               		.cfi_def_cfa_offset 3
 737               		.cfi_offset 15, -2
 738 0202 0F93      		push r16
 739               	.LCFI16:
 740               		.cfi_def_cfa_offset 4
 741               		.cfi_offset 16, -3
 742 0204 1F93      		push r17
 743               	.LCFI17:
 744               		.cfi_def_cfa_offset 5
 745               		.cfi_offset 17, -4
 746 0206 CF93      		push r28
 747               	.LCFI18:
 748               		.cfi_def_cfa_offset 6
 749               		.cfi_offset 28, -5
 750 0208 DF93      		push r29
 751               	.LCFI19:
 752               		.cfi_def_cfa_offset 7
 753               		.cfi_offset 29, -6
 754               	/* prologue: function */
 755               	/* frame size = 0 */
 756               	/* stack size = 5 */
 757               	.L__stack_usage = 5
 758 020a EC01      		movw r28,r24
 759 020c 162F      		mov r17,r22
 339:setup.c       **** 	// Set bank 1
 340:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 760               		.loc 1 340 0
 761 020e FF24      		clr r15
 762 0210 FA94      		dec r15
 763 0212 F4BA      		out 0x14,r15
 764               	.LVL59:
 765               	.LBB102:
 766               	.LBB103:
 184:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 767               		.loc 1 184 0
 768 0214 01E2      		ldi r16,lo8(33)
 769 0216 0BBB      		out 0x1b,r16
 185:setup.c       **** }
 770               		.loc 1 185 0
 771 0218 18BA      		out 0x18,__zero_reg__
 772               	.LVL60:
 773               	.LBE103:
 774               	.LBE102:
 341:setup.c       **** 	set_16bit_address(0x2100);
 342:setup.c       **** 	PORT_DATA7_0 = 1;
 775               		.loc 1 342 0
 776 021a 81E0      		ldi r24,lo8(1)
 777               	.LVL61:
 778 021c 85BB      		out 0x15,r24
 343:setup.c       **** 	wrPin_low; // Pulse WR
 779               		.loc 1 343 0
 780 021e 9698      		cbi 0x12,6
 344:setup.c       **** 	asm volatile("nop");
 781               		.loc 1 344 0
 782               	/* #APP */
 783               	 ;  344 "setup.c" 1
 784 0220 0000      		nop
 785               	 ;  0 "" 2
 345:setup.c       **** 	asm volatile("nop");
 786               		.loc 1 345 0
 787               	 ;  345 "setup.c" 1
 788 0222 0000      		nop
 789               	 ;  0 "" 2
 346:setup.c       **** 	wrPin_high;
 790               		.loc 1 346 0
 791               	/* #NOAPP */
 792 0224 969A      		sbi 0x12,6
 347:setup.c       **** 	
 348:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 793               		.loc 1 348 0
 794 0226 6091 0000 		lds r22,flashWriteCycle+2
 795               	.LVL62:
 796 022a 8091 0000 		lds r24,flashWriteCycle
 797 022e 9091 0000 		lds r25,flashWriteCycle+1
 798 0232 00D0      		rcall gb_flash_write_bus_cycle
 799               	.LVL63:
 349:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 800               		.loc 1 349 0
 801 0234 6091 0000 		lds r22,flashWriteCycle+6
 802 0238 8091 0000 		lds r24,flashWriteCycle+4
 803 023c 9091 0000 		lds r25,flashWriteCycle+4+1
 804 0240 00D0      		rcall gb_flash_write_bus_cycle
 805               	.LVL64:
 350:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 806               		.loc 1 350 0
 807 0242 6091 0000 		lds r22,flashWriteCycle+10
 808 0246 8091 0000 		lds r24,flashWriteCycle+8
 809 024a 9091 0000 		lds r25,flashWriteCycle+8+1
 810 024e 00D0      		rcall gb_flash_write_bus_cycle
 811               	.LVL65:
 351:setup.c       **** 	
 352:setup.c       **** 	
 353:setup.c       **** 	// Set bank back
 354:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 812               		.loc 1 354 0
 813 0250 F4BA      		out 0x14,r15
 814               	.LVL66:
 815               	.LBB104:
 816               	.LBB105:
 184:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 817               		.loc 1 184 0
 818 0252 0BBB      		out 0x1b,r16
 185:setup.c       **** }
 819               		.loc 1 185 0
 820 0254 18BA      		out 0x18,__zero_reg__
 821               	.LVL67:
 822               	.LBE105:
 823               	.LBE104:
 355:setup.c       **** 	set_16bit_address(0x2100);
 356:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 824               		.loc 1 356 0
 825 0256 8091 0000 		lds r24,lastBankAccessed
 826 025a 85BB      		out 0x15,r24
 357:setup.c       **** 	wrPin_low; // Pulse WR
 827               		.loc 1 357 0
 828 025c 9698      		cbi 0x12,6
 358:setup.c       **** 	asm volatile("nop");
 829               		.loc 1 358 0
 830               	/* #APP */
 831               	 ;  358 "setup.c" 1
 832 025e 0000      		nop
 833               	 ;  0 "" 2
 359:setup.c       **** 	asm volatile("nop");
 834               		.loc 1 359 0
 835               	 ;  359 "setup.c" 1
 836 0260 0000      		nop
 837               	 ;  0 "" 2
 360:setup.c       **** 	wrPin_high;
 838               		.loc 1 360 0
 839               	/* #NOAPP */
 840 0262 969A      		sbi 0x12,6
 361:setup.c       **** 	
 362:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 841               		.loc 1 362 0
 842 0264 612F      		mov r22,r17
 843 0266 CE01      		movw r24,r28
 844 0268 00D0      		rcall gb_flash_write_bus_cycle
 845               	.LVL68:
 846               	.LBB106:
 847               	.LBB107:
 848               		.loc 2 276 0
 849 026a 85E3      		ldi r24,lo8(53)
 850 026c 8A95      	1:	dec r24
 851 026e 01F4      		brne 1b
 852 0270 0000      		nop
 853               	.LVL69:
 854               	.LBE107:
 855               	.LBE106:
 363:setup.c       **** 	_delay_us(10); // Wait byte program time
 364:setup.c       **** 	
 365:setup.c       **** 	// Set data pins inputs
 366:setup.c       **** 	PORT_DATA7_0 = 0;
 856               		.loc 1 366 0
 857 0272 15BA      		out 0x15,__zero_reg__
 367:setup.c       **** 	DDR_DATA7_0 = 0;
 858               		.loc 1 367 0
 859 0274 14BA      		out 0x14,__zero_reg__
 368:setup.c       **** 	
 369:setup.c       **** 	// Verify data
 370:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 860               		.loc 1 370 0
 861 0276 CE01      		movw r24,r28
 862 0278 00D0      		rcall gb_flash_read_byte
 863               	.LVL70:
 864               	.L35:
 371:setup.c       **** 	while (data != dataVerify) {
 865               		.loc 1 371 0
 866 027a 8117      		cp r24,r17
 867 027c 01F0      		breq .L34
 372:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 868               		.loc 1 372 0
 869 027e CE01      		movw r24,r28
 870               	.LVL71:
 871 0280 00D0      		rcall gb_flash_read_byte
 872               	.LVL72:
 873               	.LBB108:
 874               	.LBB109:
 875               		.loc 2 276 0
 876 0282 9AE1      		ldi r25,lo8(26)
 877 0284 9A95      	1:	dec r25
 878 0286 01F4      		brne 1b
 879 0288 00C0      		rjmp .
 880               	.LVL73:
 881               	.LBE109:
 882               	.LBE108:
 373:setup.c       **** 		_delay_us(5);
 374:setup.c       **** 		if (writingTimedout == 1) {
 883               		.loc 1 374 0
 884 028a 9091 0000 		lds r25,writingTimedout
 885 028e 9130      		cpi r25,lo8(1)
 886 0290 01F4      		brne .L35
 887               	.L34:
 888               	/* epilogue start */
 375:setup.c       **** 			break;
 376:setup.c       **** 		}
 377:setup.c       **** 	}
 378:setup.c       **** }
 889               		.loc 1 378 0
 890 0292 DF91      		pop r29
 891 0294 CF91      		pop r28
 892               	.LVL74:
 893 0296 1F91      		pop r17
 894               	.LVL75:
 895 0298 0F91      		pop r16
 896 029a FF90      		pop r15
 897 029c 0895      		ret
 898               		.cfi_endproc
 899               	.LFE25:
 901               	.global	start_timeout_timer
 903               	start_timeout_timer:
 904               	.LFB26:
 379:setup.c       **** 
 380:setup.c       **** // Timeout for ~500ms when flashing carts
 381:setup.c       **** void start_timeout_timer(void) {
 905               		.loc 1 381 0
 906               		.cfi_startproc
 907               	/* prologue: function */
 908               	/* frame size = 0 */
 909               	/* stack size = 0 */
 910               	.L__stack_usage = 0
 382:setup.c       **** 	writingTimedout = 0;
 911               		.loc 1 382 0
 912 029e 1092 0000 		sts writingTimedout,__zero_reg__
 383:setup.c       **** 	TCNT1 = 0;
 913               		.loc 1 383 0
 914 02a2 1DBC      		out 0x2c+1,__zero_reg__
 915 02a4 1CBC      		out 0x2c,__zero_reg__
 384:setup.c       **** 	TCCR1B |= (1<<CS11) | (1<<CS10);
 916               		.loc 1 384 0
 917 02a6 8EB5      		in r24,0x2e
 918 02a8 8360      		ori r24,lo8(3)
 919 02aa 8EBD      		out 0x2e,r24
 920 02ac 0895      		ret
 921               		.cfi_endproc
 922               	.LFE26:
 924               	.global	stop_timeout_timer
 926               	stop_timeout_timer:
 927               	.LFB27:
 385:setup.c       **** }
 386:setup.c       **** 
 387:setup.c       **** // Stop the flash timeout timer
 388:setup.c       **** void stop_timeout_timer(void) {
 928               		.loc 1 388 0
 929               		.cfi_startproc
 930               	/* prologue: function */
 931               	/* frame size = 0 */
 932               	/* stack size = 0 */
 933               	.L__stack_usage = 0
 389:setup.c       **** 	writingTimedout = 0;
 934               		.loc 1 389 0
 935 02ae 1092 0000 		sts writingTimedout,__zero_reg__
 390:setup.c       **** 	TCNT1 = 0;
 936               		.loc 1 390 0
 937 02b2 1DBC      		out 0x2c+1,__zero_reg__
 938 02b4 1CBC      		out 0x2c,__zero_reg__
 391:setup.c       **** 	TCCR1B = 0;
 939               		.loc 1 391 0
 940 02b6 1EBC      		out 0x2e,__zero_reg__
 392:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 941               		.loc 1 392 0
 942 02b8 9398      		cbi 0x12,3
 943 02ba 0895      		ret
 944               		.cfi_endproc
 945               	.LFE27:
 947               	.global	check_if_timed_out
 949               	check_if_timed_out:
 950               	.LFB28:
 393:setup.c       **** }
 394:setup.c       **** 
 395:setup.c       **** void check_if_timed_out(void) {
 951               		.loc 1 395 0
 952               		.cfi_startproc
 953               	/* prologue: function */
 954               	/* frame size = 0 */
 955               	/* stack size = 0 */
 956               	.L__stack_usage = 0
 396:setup.c       **** 	if (writingTimedout == 0) {
 957               		.loc 1 396 0
 958 02bc 8091 0000 		lds r24,writingTimedout
 959 02c0 8111      		cpse r24,__zero_reg__
 960 02c2 00C0      		rjmp .L41
 961               	.LBB112:
 962               	.LBB113:
 397:setup.c       **** 		stop_timeout_timer();		
 963               		.loc 1 397 0
 964 02c4 00D0      		rcall stop_timeout_timer
 965               	.LVL76:
 398:setup.c       **** 		USART_Transmit(SEND_ACK); // Send back acknowledgement
 966               		.loc 1 398 0
 967 02c6 81E3      		ldi r24,lo8(49)
 968 02c8 00D0      		rcall USART_Transmit
 969               	.LVL77:
 399:setup.c       **** 		PORTD &= ~(1<<ACTIVITY_LED);
 970               		.loc 1 399 0
 971 02ca 9398      		cbi 0x12,3
 972               	.L41:
 973 02cc 0895      		ret
 974               	.LBE113:
 975               	.LBE112:
 976               		.cfi_endproc
 977               	.LFE28:
 979               	.global	setup
 981               	setup:
 982               	.LFB29:
 400:setup.c       **** 	}
 401:setup.c       **** }
 402:setup.c       **** 
 403:setup.c       **** 
 404:setup.c       **** // Setup
 405:setup.c       **** void setup(void) {
 983               		.loc 1 405 0
 984               		.cfi_startproc
 985               	/* prologue: function */
 986               	/* frame size = 0 */
 987               	/* stack size = 0 */
 988               	.L__stack_usage = 0
 406:setup.c       **** 	// Turn off watchdog
 407:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 989               		.loc 1 407 0
 990 02ce 84B7      		in r24,0x34
 991 02d0 877F      		andi r24,lo8(-9)
 992 02d2 84BF      		out 0x34,r24
 408:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 993               		.loc 1 408 0
 994 02d4 88E1      		ldi r24,lo8(24)
 995 02d6 81BD      		out 0x21,r24
 409:setup.c       **** 	WDTCR = 0;
 996               		.loc 1 409 0
 997 02d8 11BC      		out 0x21,__zero_reg__
 410:setup.c       **** 	
 411:setup.c       **** 	// Reset common lines
 412:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 998               		.loc 1 412 0
 999 02da 00D0      		rcall rd_wr_csmreq_cs2_reset
 1000               	.LVL78:
 413:setup.c       **** 	
 414:setup.c       **** 	// Set outputs
 415:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN);
 1001               		.loc 1 415 0
 1002 02dc 81B3      		in r24,0x11
 1003 02de 8867      		ori r24,lo8(120)
 1004 02e0 81BB      		out 0x11,r24
 416:setup.c       **** 	DDRE |= (1<<CS2_PIN);
 1005               		.loc 1 416 0
 1006 02e2 329A      		sbi 0x6,2
 417:setup.c       **** 	
 418:setup.c       **** 	// Pull ups
 419:setup.c       **** 	PORTE |= (1<<PE0);
 1007               		.loc 1 419 0
 1008 02e4 389A      		sbi 0x7,0
 420:setup.c       **** 	PORTD |= (1<<PD7) | (1<<PD2);
 1009               		.loc 1 420 0
 1010 02e6 82B3      		in r24,0x12
 1011 02e8 8468      		ori r24,lo8(-124)
 1012 02ea 82BB      		out 0x12,r24
 421:setup.c       **** 	
 422:setup.c       **** 	// Set all pins as inputs
 423:setup.c       **** 	PORT_DATA7_0 = 0;
 1013               		.loc 1 423 0
 1014 02ec 15BA      		out 0x15,__zero_reg__
 424:setup.c       **** 	DDR_DATA7_0 = 0;
 1015               		.loc 1 424 0
 1016 02ee 14BA      		out 0x14,__zero_reg__
 425:setup.c       **** 	PORT_ADDR7_0 = 0;
 1017               		.loc 1 425 0
 1018 02f0 18BA      		out 0x18,__zero_reg__
 426:setup.c       **** 	DDR_ADDR7_0 = 0;
 1019               		.loc 1 426 0
 1020 02f2 17BA      		out 0x17,__zero_reg__
 427:setup.c       **** 	PORT_ADDR15_8 = 0;
 1021               		.loc 1 427 0
 1022 02f4 1BBA      		out 0x1b,__zero_reg__
 428:setup.c       **** 	DDR_ADDR15_8 = 0;
 1023               		.loc 1 428 0
 1024 02f6 1ABA      		out 0x1a,__zero_reg__
 429:setup.c       **** 	
 430:setup.c       **** 	// Set Reset low for 50ms to reset the cart (also for CPLD carts to initialise properly)
 431:setup.c       **** 	cs2Pin_low;
 1025               		.loc 1 431 0
 1026 02f8 3A98      		cbi 0x7,2
 1027               	.LVL79:
 1028               	.LBB114:
 1029               	.LBB115:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1030               		.loc 2 187 0
 1031 02fa 2FEF      		ldi r18,lo8(159999)
 1032 02fc 80E7      		ldi r24,hi8(159999)
 1033 02fe 92E0      		ldi r25,hlo8(159999)
 1034 0300 2150      	1:	subi r18,1
 1035 0302 8040      		sbci r24,0
 1036 0304 9040      		sbci r25,0
 1037 0306 01F4      		brne 1b
 1038 0308 00C0      		rjmp .
 1039 030a 0000      		nop
 1040               	.LVL80:
 1041               	.LBE115:
 1042               	.LBE114:
 432:setup.c       **** 	_delay_ms(50);
 433:setup.c       **** 	cs2Pin_high;
 1043               		.loc 1 433 0
 1044 030c 3A9A      		sbi 0x7,2
 434:setup.c       **** 	
 435:setup.c       **** 	// Light LED
 436:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 1045               		.loc 1 436 0
 1046 030e 939A      		sbi 0x12,3
 1047               	.LVL81:
 1048               	.LBB116:
 1049               	.LBB117:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1050               		.loc 2 187 0
 1051 0310 2FEF      		ldi r18,lo8(1599999)
 1052 0312 89E6      		ldi r24,hi8(1599999)
 1053 0314 98E1      		ldi r25,hlo8(1599999)
 1054 0316 2150      	1:	subi r18,1
 1055 0318 8040      		sbci r24,0
 1056 031a 9040      		sbci r25,0
 1057 031c 01F4      		brne 1b
 1058 031e 00C0      		rjmp .
 1059 0320 0000      		nop
 1060               	.LVL82:
 1061               	.LBE117:
 1062               	.LBE116:
 437:setup.c       **** 	_delay_ms(500);
 438:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 1063               		.loc 1 438 0
 1064 0322 9398      		cbi 0x12,3
 439:setup.c       **** 	
 440:setup.c       **** 	// Setup USART
 441:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 1065               		.loc 1 441 0
 1066 0324 19B8      		out 0x9,__zero_reg__
 442:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 1067               		.loc 1 442 0
 1068 0326 539A      		sbi 0xa,3
 443:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 1069               		.loc 1 443 0
 1070 0328 549A      		sbi 0xa,4
 444:setup.c       **** 	
 445:setup.c       **** 	// Timer1 setup
 446:setup.c       **** 	TIMSK |= (1<<TOIE1);
 1071               		.loc 1 446 0
 1072 032a 89B7      		in r24,0x39
 1073 032c 8068      		ori r24,lo8(-128)
 1074 032e 89BF      		out 0x39,r24
 447:setup.c       **** 	TCNT1 = 0;
 1075               		.loc 1 447 0
 1076 0330 1DBC      		out 0x2c+1,__zero_reg__
 1077 0332 1CBC      		out 0x2c,__zero_reg__
 448:setup.c       **** 	
 449:setup.c       **** 	// Turn on interrupts
 450:setup.c       **** 	sei();
 1078               		.loc 1 450 0
 1079               	/* #APP */
 1080               	 ;  450 "setup.c" 1
 1081 0334 7894      		sei
 1082               	 ;  0 "" 2
 1083               	/* #NOAPP */
 1084 0336 0895      		ret
 1085               		.cfi_endproc
 1086               	.LFE29:
 1088               		.section	.text.startup,"ax",@progbits
 1089               	.global	main
 1091               	main:
 1092               	.LFB30:
 1093               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW Mini
   3:main.c        ****  PCB version: 1.0
   4:main.c        ****  Firmware version: R19
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 22/09/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW Mini allows you to dump your Gameboy/Gameboy Colour games ROM, save the RAM, write to t
  10:main.c        ****  write to certain Gameboy flash carts. GBA carts are not supported, please check out the non-Mini v
  11:main.c        ****  
  12:main.c        ****  The ATmega8515 talks to the cartridge and interfaces with the CH340G serial to USB converter with 
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 16MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BO
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.x_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart Mini RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  */
  28:main.c        **** 
  29:main.c        **** // ATmega8515L Pin Map
  30:main.c        **** //
  31:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  32:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  33:main.c        **** // 
  34:main.c        **** // Gameboy / Gameboy Colour
  35:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** #define F_CPU 16000000 // 16 MHz
  39:main.c        **** #define PCB_VERSION 100 // Mini v1.0
  40:main.c        **** #define FIRMWARE_VERSION 19
  41:main.c        **** 
  42:main.c        **** #include <avr/io.h>
  43:main.c        **** #include <avr/wdt.h>
  44:main.c        **** #include <avr/eeprom.h>
  45:main.c        **** #include <avr/interrupt.h>
  46:main.c        **** #include <avr/sleep.h>
  47:main.c        **** #include <util/delay.h>
  48:main.c        **** #include <stdlib.h>
  49:main.c        **** #include <string.h>
  50:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  51:main.c        **** 
  52:main.c        **** 
  53:main.c        **** int main(void) {
 1094               		.loc 3 53 0
 1095               		.cfi_startproc
 1096               	/* prologue: function */
 1097               	/* frame size = 0 */
 1098               	/* stack size = 0 */
 1099               	.L__stack_usage = 0
  54:main.c        **** 	setup();
 1100               		.loc 3 54 0
 1101 0000 00D0      		rcall setup
 1102               	.LVL83:
  55:main.c        **** 	
  56:main.c        **** 	uint32_t address = 0;
  57:main.c        **** 	uint8_t resetCommonLines = 1;
 1103               		.loc 3 57 0
 1104 0002 5524      		clr r5
 1105 0004 5394      		inc r5
  56:main.c        **** 	uint8_t resetCommonLines = 1;
 1106               		.loc 3 56 0
 1107 0006 C12C      		mov r12,__zero_reg__
 1108 0008 D12C      		mov r13,__zero_reg__
 1109 000a 7601      		movw r14,r12
 1110               	.LBB118:
 1111               	.LBB119:
 1112               	.LBB120:
 1113               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 1114               		.loc 4 105 0
 1115 000c 2224      		clr r2
 1116 000e 2A94      		dec r2
 1117 0010 322C      		mov r3,r2
 1118               	.LBE120:
 1119               	.LBE119:
 1120               	.LBE118:
 1121               	.LBB123:
  58:main.c        **** 	
  59:main.c        **** 	while(1) {
  60:main.c        **** 		if (resetCommonLines == 1) {
  61:main.c        **** 			rd_wr_csmreq_cs2_reset();
  62:main.c        **** 		}
  63:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
  64:main.c        **** 		
  65:main.c        **** 		
  66:main.c        **** 		// Return the cart mode in use
  67:main.c        **** 		if (receivedChar == CART_MODE) {
  68:main.c        **** 			USART_Transmit(cartMode);
  69:main.c        **** 			stop_timeout_timer();
  70:main.c        **** 		}
  71:main.c        **** 		
  72:main.c        **** 		// Change to GB mode or GBA mode if requested
  73:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
  74:main.c        **** 			gb_mode();
  75:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
  76:main.c        **** 			stop_timeout_timer();
  77:main.c        **** 		}
  78:main.c        **** 		
  79:main.c        **** 		// Set address
  80:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
  81:main.c        **** 			usart_read_chars(); // Read start address
  82:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
  83:main.c        **** 		}
  84:main.c        **** 		
  85:main.c        **** 		
  86:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
  87:main.c        **** 		
  88:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
  89:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
  90:main.c        **** 			gb_mode();
  91:main.c        **** 			receivedChar = '1';
  92:main.c        **** 			while (receivedChar == '1') {
  93:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
  94:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
  95:main.c        **** 					USART_Transmit(read_8bit_data(address));
  96:main.c        **** 					address++;
  97:main.c        **** 				}
  98:main.c        **** 				
  99:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 100:main.c        **** 				receivedChar = USART_Receive();
 101:main.c        **** 			}
 102:main.c        **** 		}
 103:main.c        **** 		
 104:main.c        **** 		// Read and send 0x4000 bytes of data
 105:main.c        **** 		else if (receivedChar == READ_ROM_4000H) {
 106:main.c        **** 			gb_mode();
 107:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 108:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 109:main.c        **** 				USART_Transmit(read_8bit_data(address));
 110:main.c        **** 				address++;
 111:main.c        **** 			}
 112:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 113:main.c        **** 		}
 114:main.c        **** 		
 115:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 116:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 117:main.c        **** 			gb_mode();
 118:main.c        **** 			
 119:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 120:main.c        **** 			usart_read_bytes(64);
 121:main.c        **** 			
 122:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 123:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 124:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 125:main.c        **** 				address++;
 126:main.c        **** 			}
 127:main.c        **** 			
 128:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 129:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 130:main.c        **** 		}
 131:main.c        **** 		
 132:main.c        **** 		// Set bank address and write a byte
 133:main.c        **** 		else if (receivedChar == SET_BANK) {
 134:main.c        **** 			gb_mode();
 135:main.c        **** 			
 136:main.c        **** 			usart_read_chars(); // Read start address
 137:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 138:main.c        **** 			
 139:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 140:main.c        **** 			if (receivedChar == 'B') {
 141:main.c        **** 				usart_read_chars(); // Read data
 142:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 143:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 144:main.c        **** 				
 145:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 146:main.c        **** 			}
 147:main.c        **** 		}
 148:main.c        **** 		
 149:main.c        **** 		
 150:main.c        **** 		// ---------- GB FLASH CARTS ----------
 151:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 152:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 153:main.c        **** 			flashWriteWePin = USART_Receive();
 154:main.c        **** 			
 155:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 156:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 157:main.c        **** 				audioPin_high;
 158:main.c        **** 			}
 159:main.c        **** 		}
 160:main.c        **** 		
 161:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 162:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 163:main.c        **** 			flashBank1CommandWrites = 1;
 164:main.c        **** 		}
 165:main.c        **** 		
 166:main.c        **** 		// Load the program method to use
 167:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 168:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 169:main.c        **** 				usart_read_chars(); // Address
 170:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 171:main.c        **** 				USART_Transmit(SEND_ACK);
 172:main.c        **** 				
 173:main.c        **** 				usart_read_chars(); // Data
 174:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 175:main.c        **** 				USART_Transmit(SEND_ACK);
 176:main.c        **** 			}
 177:main.c        **** 		}
 178:main.c        **** 		
 179:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 180:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 181:main.c        **** 			usart_read_chars(); // Read address
 182:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 183:main.c        **** 			
 184:main.c        **** 			usart_read_chars(); // Read data byte
 185:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 186:main.c        **** 			
 187:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 188:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 189:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 190:main.c        **** 			
 191:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 192:main.c        **** 		}
 193:main.c        **** 		
 194:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 195:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 196:main.c        **** 			usart_read_bytes(64);
 197:main.c        **** 			start_timeout_timer();
 198:main.c        **** 			
 199:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 200:main.c        **** 			if (flashBank1CommandWrites == 0) {
 201:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 202:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 203:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 204:main.c        **** 					}
 205:main.c        **** 					address++;
 206:main.c        **** 				}
 207:main.c        **** 			}
 208:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 209:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 210:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 211:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 212:main.c        **** 					}
 213:main.c        **** 					address++;
 214:main.c        **** 				}
 215:main.c        **** 			}
 216:main.c        **** 			
 217:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 218:main.c        **** 		}
 219:main.c        **** 		
 220:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 221:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 222:main.c        **** 			usart_read_bytes(32);
 223:main.c        **** 			start_timeout_timer();
 224:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 225:main.c        **** 			
 226:main.c        **** 			// Setup buffered write
 227:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 228:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 229:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 230:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 231:main.c        **** 			_delay_us(1);
 232:main.c        **** 			
 233:main.c        **** 			// Write data
 234:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 235:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 236:main.c        **** 				address++;
 237:main.c        **** 			}
 238:main.c        **** 			
 239:main.c        **** 			// Write buffer to flash
 240:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 241:main.c        **** 			_delay_us(200);
 242:main.c        **** 			
 243:main.c        **** 			// Verify last byte written
 244:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 245:main.c        **** 			uint8_t verifyCount = 0;
 246:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 247:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 248:main.c        **** 				_delay_us(5);
 249:main.c        **** 				verifyCount++;
 250:main.c        **** 				if (writingTimedout == 1) {
 251:main.c        **** 					break;
 252:main.c        **** 				}
 253:main.c        **** 			}
 254:main.c        **** 			
 255:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 256:main.c        **** 		}
 257:main.c        **** 		
 258:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 259:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 260:main.c        **** 			usart_read_bytes(64);
 261:main.c        **** 			start_timeout_timer();
 262:main.c        **** 			
 263:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 264:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 265:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 266:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 267:main.c        **** 				}
 268:main.c        **** 				address++;
 269:main.c        **** 			}
 270:main.c        **** 			
 271:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 272:main.c        **** 		}
 273:main.c        **** 		
 274:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 275:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 276:main.c        **** 			usart_read_bytes(256);
 277:main.c        **** 			start_timeout_timer();
 278:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 279:main.c        **** 			
 280:main.c        **** 			// Setup buffered write
 281:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 282:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 283:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 284:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 285:main.c        **** 			_delay_us(50);
 286:main.c        **** 			
 287:main.c        **** 			// Write data
 288:main.c        **** 			for (int x = 0; x < 256; x++) {
 289:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 290:main.c        **** 				address++;
 291:main.c        **** 			}
 292:main.c        **** 			
 293:main.c        **** 			// Write buffer to flash
 294:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 295:main.c        **** 			
 296:main.c        **** 			// Verify last byte written
 297:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 298:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 299:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 300:main.c        **** 				_delay_us(5);
 301:main.c        **** 				if (writingTimedout == 1) {
 302:main.c        **** 					break;
 303:main.c        **** 				}
 304:main.c        **** 			}
 305:main.c        **** 			
 306:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 307:main.c        **** 		}
 308:main.c        **** 		
 309:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 310:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 311:main.c        **** 			usart_read_bytes(128);
 312:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 313:main.c        **** 			
 314:main.c        **** 			// Enable flash chip access
 315:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 316:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 317:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 318:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 319:main.c        **** 			_delay_us(5);
 320:main.c        **** 			
 321:main.c        **** 			// Re-Enable writes to MBC registers
 322:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 323:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 324:main.c        **** 			_delay_us(5);
 325:main.c        **** 			
 326:main.c        **** 			// Bank 1 for commands
 327:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 328:main.c        **** 			_delay_us(5);
 329:main.c        **** 			
 330:main.c        **** 			
 331:main.c        **** 			// Write setup
 332:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 333:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 334:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 335:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 336:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 337:main.c        **** 			_delay_us(5);
 338:main.c        **** 			
 339:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 340:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 341:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 342:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 343:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 344:main.c        **** 			_delay_us(5);
 345:main.c        **** 			
 346:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 347:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 348:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 349:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 350:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 351:main.c        **** 			_delay_us(5);
 352:main.c        **** 			
 353:main.c        **** 			// Set bank back
 354:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 355:main.c        **** 			_delay_us(5);
 356:main.c        **** 			
 357:main.c        **** 			// Disable writes to MBC registers
 358:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 359:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 360:main.c        **** 			_delay_us(5);
 361:main.c        **** 			
 362:main.c        **** 			// Undo Wakeup
 363:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 364:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 365:main.c        **** 			_delay_us(5);
 366:main.c        **** 			
 367:main.c        **** 			
 368:main.c        **** 			// Write data
 369:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 370:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 371:main.c        **** 				_delay_us(5);
 372:main.c        **** 				address++;
 373:main.c        **** 			}
 374:main.c        **** 			
 375:main.c        **** 			// Write buffer to flash
 376:main.c        **** 			address--;
 377:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 378:main.c        **** 			address++;
 379:main.c        **** 			_delay_ms(10);
 380:main.c        **** 			
 381:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 382:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 383:main.c        **** 		}
 384:main.c        **** 		
 385:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 386:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 387:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 388:main.c        **** 			usart_read_bytes(32);
 389:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 390:main.c        **** 			
 391:main.c        **** 			// Setup buffered write
 392:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 393:main.c        **** 			
 394:main.c        **** 			// Wait until ready
 395:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 396:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 397:main.c        **** 			
 398:main.c        **** 			// Set buffer size
 399:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 400:main.c        **** 			
 401:main.c        **** 			// Write data to buffer
 402:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 403:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 404:main.c        **** 				address++;
 405:main.c        **** 			}
 406:main.c        **** 			
 407:main.c        **** 			// Write buffer to flash
 408:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 409:main.c        **** 			_delay_us(196);
 410:main.c        **** 			
 411:main.c        **** 			// Wait until ready
 412:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 413:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 414:main.c        **** 			
 415:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 416:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 417:main.c        **** 		}
 418:main.c        **** 		
 419:main.c        **** 		
 420:main.c        **** 		// ---------- General commands ----------
 421:main.c        **** 		// Set any pin as input/output
 422:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 423:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 424:main.c        **** 			char portChar = USART_Receive();
 425:main.c        **** 			usart_read_chars();
 426:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 427:main.c        **** 			
 428:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 429:main.c        **** 			if (receivedChar == SET_INPUT) {
 430:main.c        **** 				if (portChar == 'A') {
 431:main.c        **** 					DDRA &= ~(setValue);
 432:main.c        **** 				}
 433:main.c        **** 				else if (portChar == 'B') {
 434:main.c        **** 					DDRB &= ~(setValue);
 435:main.c        **** 				}
 436:main.c        **** 				else if (portChar == 'C') {
 437:main.c        **** 					DDRC &= ~(setValue);
 438:main.c        **** 				}
 439:main.c        **** 				else if (portChar == 'D') {
 440:main.c        **** 					DDRD &= ~(setValue);
 441:main.c        **** 				}
 442:main.c        **** 				else if (portChar == 'E') {
 443:main.c        **** 					DDRE &= ~(setValue);
 444:main.c        **** 				}
 445:main.c        **** 			}
 446:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 447:main.c        **** 				if (portChar == 'A') {
 448:main.c        **** 					DDRA |= (setValue);
 449:main.c        **** 				}
 450:main.c        **** 				else if (portChar == 'B') {
 451:main.c        **** 					DDRB |= (setValue);
 452:main.c        **** 				}
 453:main.c        **** 				else if (portChar == 'C') {
 454:main.c        **** 					DDRC |= (setValue);
 455:main.c        **** 				}
 456:main.c        **** 				else if (portChar == 'D') {
 457:main.c        **** 					DDRD |= (setValue);
 458:main.c        **** 				}
 459:main.c        **** 				else if (portChar == 'E') {
 460:main.c        **** 					DDRE |= (setValue);
 461:main.c        **** 				}
 462:main.c        **** 			}
 463:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 464:main.c        **** 		}
 465:main.c        **** 		
 466:main.c        **** 		// Set pin output as low
 467:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 468:main.c        **** 			char portChar = USART_Receive();			
 469:main.c        **** 			usart_read_chars();
 470:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 471:main.c        **** 			
 472:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 473:main.c        **** 			if (portChar == 'A') {
 474:main.c        **** 				PORTA &= ~(setValue);
 475:main.c        **** 			}
 476:main.c        **** 			else if (portChar == 'B') {
 477:main.c        **** 				PORTB &= ~(setValue);
 478:main.c        **** 			}
 479:main.c        **** 			else if (portChar == 'C') {
 480:main.c        **** 				PORTC &= ~(setValue);
 481:main.c        **** 			}
 482:main.c        **** 			else if (portChar == 'D') {
 483:main.c        **** 				PORTD &= ~(setValue);
 484:main.c        **** 			}
 485:main.c        **** 			else if (portChar == 'E') {
 486:main.c        **** 				PORTE &= ~(setValue);
 487:main.c        **** 			}
 488:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 489:main.c        **** 		}
 490:main.c        **** 		
 491:main.c        **** 		// Set pin output as high
 492:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 493:main.c        **** 			char portChar = USART_Receive();			
 494:main.c        **** 			usart_read_chars();
 495:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 496:main.c        **** 			
 497:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 498:main.c        **** 			if (portChar == 'A') {
 499:main.c        **** 				PORTA |= (setValue);
 500:main.c        **** 			}
 501:main.c        **** 			else if (portChar == 'B') {
 502:main.c        **** 				PORTB |= (setValue);
 503:main.c        **** 			}
 504:main.c        **** 			else if (portChar == 'C') {
 505:main.c        **** 				PORTC |= (setValue);
 506:main.c        **** 			}
 507:main.c        **** 			else if (portChar == 'D') {
 508:main.c        **** 				PORTD |= (setValue);
 509:main.c        **** 			}
 510:main.c        **** 			else if (portChar == 'E') {
 511:main.c        **** 				PORTE |= (setValue);
 512:main.c        **** 			}
 513:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 514:main.c        **** 		}
 515:main.c        **** 		
 516:main.c        **** 		// Read all pins of a PORT and return the value
 517:main.c        **** 		else if (receivedChar == READ_INPUT) {
 518:main.c        **** 			char portChar = USART_Receive();			
 519:main.c        **** 			
 520:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 521:main.c        **** 			if (portChar == 'A') {
 522:main.c        **** 				USART_Transmit(PINA);
 523:main.c        **** 			}
 524:main.c        **** 			else if (portChar == 'B') {
 525:main.c        **** 				USART_Transmit(PINB);
 526:main.c        **** 			}
 527:main.c        **** 			else if (portChar == 'C') {
 528:main.c        **** 				USART_Transmit(PINC);
 529:main.c        **** 			}
 530:main.c        **** 			else if (portChar == 'D') {
 531:main.c        **** 				USART_Transmit(PIND);
 532:main.c        **** 			}
 533:main.c        **** 			else if (portChar == 'E') {
 534:main.c        **** 				USART_Transmit(PINE);
 535:main.c        **** 			}
 536:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 537:main.c        **** 		}
 538:main.c        **** 		
 539:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
 540:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 541:main.c        **** 			char commonChar = USART_Receive();
 542:main.c        **** 			if (commonChar == '1') {
 543:main.c        **** 				resetCommonLines = 1;
 1122               		.loc 3 543 0
 1123 0012 4424      		clr r4
 1124 0014 4394      		inc r4
 1125 0016 20E0      		ldi r18,lo8(receivedBuffer+128)
 1126 0018 622E      		mov r6,r18
 1127 001a 20E0      		ldi r18,hi8(receivedBuffer+128)
 1128 001c 722E      		mov r7,r18
 1129               	.LVL84:
 1130               	.L45:
 1131               	.LBE123:
  60:main.c        **** 			rd_wr_csmreq_cs2_reset();
 1132               		.loc 3 60 0
 1133 001e 21E0      		ldi r18,lo8(1)
 1134 0020 5212      		cpse r5,r18
 1135 0022 00C0      		rjmp .L46
 1136               	.LVL85:
 1137               	.L155:
  61:main.c        **** 		}
 1138               		.loc 3 61 0
 1139 0024 00D0      		rcall rd_wr_csmreq_cs2_reset
 1140               	.LVL86:
 1141               	.L46:
  63:main.c        **** 		
 1142               		.loc 3 63 0
 1143 0026 00D0      		rcall USART_Receive
 1144               	.LVL87:
 1145 0028 8093 0000 		sts receivedChar,r24
  67:main.c        **** 			USART_Transmit(cartMode);
 1146               		.loc 3 67 0
 1147 002c 8334      		cpi r24,lo8(67)
 1148 002e 01F4      		brne .L47
  68:main.c        **** 			stop_timeout_timer();
 1149               		.loc 3 68 0
 1150 0030 8091 0000 		lds r24,cartMode
 1151 0034 00D0      		rcall USART_Transmit
 1152               	.LVL88:
 1153 0036 00C0      		rjmp .L156
 1154               	.L47:
  73:main.c        **** 			gb_mode();
 1155               		.loc 3 73 0
 1156 0038 8734      		cpi r24,lo8(71)
 1157 003a 01F4      		brne .L49
  74:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
 1158               		.loc 3 74 0
 1159 003c 00D0      		rcall gb_mode
 1160               	.LVL89:
  75:main.c        **** 			stop_timeout_timer();
 1161               		.loc 3 75 0
 1162 003e 1092 0000 		sts flashBank1CommandWrites,__zero_reg__
 1163               	.L156:
  76:main.c        **** 		}
 1164               		.loc 3 76 0
 1165 0042 00D0      		rcall stop_timeout_timer
 1166               	.LVL90:
 1167 0044 00C0      		rjmp .L45
 1168               	.L49:
  80:main.c        **** 			usart_read_chars(); // Read start address
 1169               		.loc 3 80 0
 1170 0046 8134      		cpi r24,lo8(65)
 1171 0048 01F4      		brne .L50
  81:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1172               		.loc 3 81 0
 1173 004a 00D0      		rcall usart_read_chars
 1174               	.LVL91:
  82:main.c        **** 		}
 1175               		.loc 3 82 0
 1176 004c 40E1      		ldi r20,lo8(16)
 1177 004e 50E0      		ldi r21,0
 1178 0050 60E0      		ldi r22,0
 1179 0052 70E0      		ldi r23,0
 1180 0054 80E0      		ldi r24,lo8(receivedBuffer)
 1181 0056 90E0      		ldi r25,hi8(receivedBuffer)
 1182 0058 00D0      		rcall strtol
 1183               	.LVL92:
 1184 005a 6B01      		movw r12,r22
 1185 005c 7C01      		movw r14,r24
 1186               	.LVL93:
 1187 005e 00C0      		rjmp .L45
 1188               	.L50:
  89:main.c        **** 			gb_mode();
 1189               		.loc 3 89 0
 1190 0060 8235      		cpi r24,lo8(82)
 1191 0062 01F4      		brne .L51
  90:main.c        **** 			receivedChar = '1';
 1192               		.loc 3 90 0
 1193 0064 00D0      		rcall gb_mode
 1194               	.LVL94:
  91:main.c        **** 			while (receivedChar == '1') {
 1195               		.loc 3 91 0
 1196 0066 81E3      		ldi r24,lo8(49)
 1197               	.LVL95:
 1198               	.L160:
 100:main.c        **** 			}
 1199               		.loc 3 100 0
 1200 0068 8093 0000 		sts receivedChar,r24
 1201               	.LVL96:
  92:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 1202               		.loc 3 92 0
 1203 006c 8091 0000 		lds r24,receivedChar
 1204 0070 8133      		cpi r24,lo8(49)
 1205 0072 01F4      		brne .L45
  93:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1206               		.loc 3 93 0
 1207 0074 939A      		sbi 0x12,3
 1208               	.LVL97:
 1209 0076 C0E0      		ldi r28,0
 1210 0078 D0E0      		ldi r29,0
 1211               	.LVL98:
 1212               	.L53:
 1213               	.LBB124:
  95:main.c        **** 					address++;
 1214               		.loc 3 95 0 discriminator 3
 1215 007a CE01      		movw r24,r28
 1216 007c 8C0D      		add r24,r12
 1217 007e 9D1D      		adc r25,r13
 1218 0080 00D0      		rcall read_8bit_data
 1219               	.LVL99:
 1220 0082 00D0      		rcall USART_Transmit
 1221               	.LVL100:
 1222 0084 2196      		adiw r28,1
 1223               	.LVL101:
  94:main.c        **** 					USART_Transmit(read_8bit_data(address));
 1224               		.loc 3 94 0 discriminator 3
 1225 0086 C034      		cpi r28,64
 1226 0088 D105      		cpc r29,__zero_reg__
 1227 008a 01F4      		brne .L53
 1228 008c 80E4      		ldi r24,64
 1229 008e C80E      		add r12,r24
 1230 0090 D11C      		adc r13,__zero_reg__
 1231 0092 E11C      		adc r14,__zero_reg__
 1232 0094 F11C      		adc r15,__zero_reg__
 1233               	.LBE124:
  99:main.c        **** 				receivedChar = USART_Receive();
 1234               		.loc 3 99 0
 1235 0096 9398      		cbi 0x12,3
 100:main.c        **** 			}
 1236               		.loc 3 100 0
 1237 0098 00D0      		rcall USART_Receive
 1238               	.LVL102:
 1239 009a 00C0      		rjmp .L160
 1240               	.LVL103:
 1241               	.L51:
 105:main.c        **** 			gb_mode();
 1242               		.loc 3 105 0
 1243 009c 8135      		cpi r24,lo8(81)
 1244 009e 01F4      		brne .L55
 106:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1245               		.loc 3 106 0
 1246 00a0 00D0      		rcall gb_mode
 1247               	.LVL104:
 107:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 1248               		.loc 3 107 0
 1249 00a2 939A      		sbi 0x12,3
 1250               	.LVL105:
 1251               	.LBB125:
 108:main.c        **** 				USART_Transmit(read_8bit_data(address));
 1252               		.loc 3 108 0
 1253 00a4 C0E0      		ldi r28,0
 1254 00a6 D0E0      		ldi r29,0
 1255               	.LVL106:
 1256               	.L56:
 109:main.c        **** 				address++;
 1257               		.loc 3 109 0 discriminator 3
 1258 00a8 CE01      		movw r24,r28
 1259 00aa 8C0D      		add r24,r12
 1260 00ac 9D1D      		adc r25,r13
 1261 00ae 00D0      		rcall read_8bit_data
 1262               	.LVL107:
 1263 00b0 00D0      		rcall USART_Transmit
 1264               	.LVL108:
 108:main.c        **** 				USART_Transmit(read_8bit_data(address));
 1265               		.loc 3 108 0 discriminator 3
 1266 00b2 2196      		adiw r28,1
 1267               	.LVL109:
 1268 00b4 C115      		cp r28,__zero_reg__
 1269 00b6 90E4      		ldi r25,64
 1270 00b8 D907      		cpc r29,r25
 1271 00ba 01F4      		brne .L56
 1272 00bc E0E4      		ldi r30,64
 1273 00be DE0E      		add r13,r30
 1274 00c0 E11C      		adc r14,__zero_reg__
 1275 00c2 F11C      		adc r15,__zero_reg__
 1276 00c4 00C0      		rjmp .L157
 1277               	.LVL110:
 1278               	.L55:
 1279               	.LBE125:
 116:main.c        **** 			gb_mode();
 1280               		.loc 3 116 0
 1281 00c6 8735      		cpi r24,lo8(87)
 1282 00c8 01F4      		brne .L57
 117:main.c        **** 			
 1283               		.loc 3 117 0
 1284 00ca 00D0      		rcall gb_mode
 1285               	.LVL111:
 120:main.c        **** 			
 1286               		.loc 3 120 0
 1287 00cc 80E4      		ldi r24,lo8(64)
 1288 00ce 90E0      		ldi r25,0
 1289 00d0 00D0      		rcall usart_read_bytes
 1290               	.LVL112:
 122:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1291               		.loc 3 122 0
 1292 00d2 939A      		sbi 0x12,3
 1293               	.LVL113:
 1294 00d4 00E0      		ldi r16,lo8(receivedBuffer)
 1295 00d6 10E0      		ldi r17,hi8(receivedBuffer)
 1296 00d8 C0E0      		ldi r28,0
 1297 00da D0E0      		ldi r29,0
 1298               	.LVL114:
 1299               	.L58:
 1300               	.LBB126:
 124:main.c        **** 				address++;
 1301               		.loc 3 124 0 discriminator 3
 1302 00dc F801      		movw r30,r16
 1303 00de 6191      		ld r22,Z+
 1304 00e0 8F01      		movw r16,r30
 1305 00e2 CE01      		movw r24,r28
 1306 00e4 8C0D      		add r24,r12
 1307 00e6 9D1D      		adc r25,r13
 1308 00e8 41E0      		ldi r20,lo8(1)
 1309 00ea 00D0      		rcall write_8bit_data
 1310               	.LVL115:
 1311 00ec 2196      		adiw r28,1
 1312               	.LVL116:
 123:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 1313               		.loc 3 123 0 discriminator 3
 1314 00ee C034      		cpi r28,64
 1315 00f0 D105      		cpc r29,__zero_reg__
 1316 00f2 01F4      		brne .L58
 1317 00f4 F0E4      		ldi r31,64
 1318 00f6 CF0E      		add r12,r31
 1319 00f8 D11C      		adc r13,__zero_reg__
 1320 00fa E11C      		adc r14,__zero_reg__
 1321 00fc F11C      		adc r15,__zero_reg__
 1322 00fe 00C0      		rjmp .L162
 1323               	.LVL117:
 1324               	.L57:
 1325               	.LBE126:
 133:main.c        **** 			gb_mode();
 1326               		.loc 3 133 0
 1327 0100 8234      		cpi r24,lo8(66)
 1328 0102 01F4      		brne .L59
 1329               	.LBB127:
 134:main.c        **** 			
 1330               		.loc 3 134 0
 1331 0104 00D0      		rcall gb_mode
 1332               	.LVL118:
 136:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 1333               		.loc 3 136 0
 1334 0106 00D0      		rcall usart_read_chars
 1335               	.LVL119:
 137:main.c        **** 			
 1336               		.loc 3 137 0
 1337 0108 40E1      		ldi r20,lo8(16)
 1338 010a 50E0      		ldi r21,0
 1339 010c 60E0      		ldi r22,0
 1340 010e 70E0      		ldi r23,0
 1341 0110 80E0      		ldi r24,lo8(receivedBuffer)
 1342 0112 90E0      		ldi r25,hi8(receivedBuffer)
 1343 0114 00D0      		rcall strtol
 1344               	.LVL120:
 1345 0116 4B01      		movw r8,r22
 1346 0118 5C01      		movw r10,r24
 1347               	.LVL121:
 139:main.c        **** 			if (receivedChar == 'B') {
 1348               		.loc 3 139 0
 1349 011a 00D0      		rcall USART_Receive
 1350               	.LVL122:
 1351 011c 8093 0000 		sts receivedChar,r24
 140:main.c        **** 				usart_read_chars(); // Read data
 1352               		.loc 3 140 0
 1353 0120 8234      		cpi r24,lo8(66)
 1354 0122 01F0      		breq .+2
 1355 0124 00C0      		rjmp .L45
 1356               	.LBB128:
 141:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 1357               		.loc 3 141 0
 1358 0126 00D0      		rcall usart_read_chars
 1359               	.LVL123:
 142:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 1360               		.loc 3 142 0
 1361 0128 80E0      		ldi r24,lo8(receivedBuffer)
 1362 012a 90E0      		ldi r25,hi8(receivedBuffer)
 1363 012c 00D0      		rcall atoi
 1364               	.LVL124:
 143:main.c        **** 				
 1365               		.loc 3 143 0
 1366 012e 8093 0000 		sts lastBankAccessed,r24
 145:main.c        **** 			}
 1367               		.loc 3 145 0
 1368 0132 40E0      		ldi r20,0
 1369 0134 682F      		mov r22,r24
 1370 0136 C401      		movw r24,r8
 1371               	.LVL125:
 1372 0138 00D0      		rcall write_8bit_data
 1373               	.LVL126:
 1374 013a 00C0      		rjmp .L45
 1375               	.LVL127:
 1376               	.L59:
 1377               	.LBE128:
 1378               	.LBE127:
 152:main.c        **** 			flashWriteWePin = USART_Receive();
 1379               		.loc 3 152 0
 1380 013c 8035      		cpi r24,lo8(80)
 1381 013e 01F4      		brne .L60
 153:main.c        **** 			
 1382               		.loc 3 153 0
 1383 0140 00D0      		rcall USART_Receive
 1384               	.LVL128:
 1385 0142 8093 0000 		sts flashWriteWePin,r24
 155:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 1386               		.loc 3 155 0
 1387 0146 8134      		cpi r24,lo8(65)
 1388 0148 01F0      		breq .+2
 1389 014a 00C0      		rjmp .L45
 156:main.c        **** 				audioPin_high;
 1390               		.loc 3 156 0
 1391 014c 319A      		sbi 0x6,1
 157:main.c        **** 			}
 1392               		.loc 3 157 0
 1393 014e 399A      		sbi 0x7,1
 1394 0150 00C0      		rjmp .L45
 1395               	.L60:
 162:main.c        **** 			flashBank1CommandWrites = 1;
 1396               		.loc 3 162 0
 1397 0152 8E34      		cpi r24,lo8(78)
 1398 0154 01F4      		brne .L61
 163:main.c        **** 		}
 1399               		.loc 3 163 0
 1400 0156 4092 0000 		sts flashBank1CommandWrites,r4
 1401 015a 00C0      		rjmp .L45
 1402               	.L61:
 167:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 1403               		.loc 3 167 0
 1404 015c 8534      		cpi r24,lo8(69)
 1405 015e 01F4      		brne .L62
 1406 0160 C0E0      		ldi r28,lo8(flashWriteCycle)
 1407 0162 D0E0      		ldi r29,hi8(flashWriteCycle)
 1408               	.L63:
 1409               	.LBB129:
 169:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 1410               		.loc 3 169 0 discriminator 3
 1411 0164 00D0      		rcall usart_read_chars
 1412               	.LVL129:
 170:main.c        **** 				USART_Transmit(SEND_ACK);
 1413               		.loc 3 170 0 discriminator 3
 1414 0166 40E1      		ldi r20,lo8(16)
 1415 0168 50E0      		ldi r21,0
 1416 016a 60E0      		ldi r22,0
 1417 016c 70E0      		ldi r23,0
 1418 016e 80E0      		ldi r24,lo8(receivedBuffer)
 1419 0170 90E0      		ldi r25,hi8(receivedBuffer)
 1420 0172 00D0      		rcall strtol
 1421               	.LVL130:
 1422 0174 7983      		std Y+1,r23
 1423 0176 6883      		st Y,r22
 171:main.c        **** 				
 1424               		.loc 3 171 0 discriminator 3
 1425 0178 81E3      		ldi r24,lo8(49)
 1426 017a 00D0      		rcall USART_Transmit
 1427               	.LVL131:
 173:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 1428               		.loc 3 173 0 discriminator 3
 1429 017c 00D0      		rcall usart_read_chars
 1430               	.LVL132:
 174:main.c        **** 				USART_Transmit(SEND_ACK);
 1431               		.loc 3 174 0 discriminator 3
 1432 017e 40E1      		ldi r20,lo8(16)
 1433 0180 50E0      		ldi r21,0
 1434 0182 60E0      		ldi r22,0
 1435 0184 70E0      		ldi r23,0
 1436 0186 80E0      		ldi r24,lo8(receivedBuffer)
 1437 0188 90E0      		ldi r25,hi8(receivedBuffer)
 1438 018a 00D0      		rcall strtol
 1439               	.LVL133:
 1440 018c 7B83      		std Y+3,r23
 1441 018e 6A83      		std Y+2,r22
 175:main.c        **** 			}
 1442               		.loc 3 175 0 discriminator 3
 1443 0190 81E3      		ldi r24,lo8(49)
 1444 0192 00D0      		rcall USART_Transmit
 1445               	.LVL134:
 1446 0194 2496      		adiw r28,4
 168:main.c        **** 				usart_read_chars(); // Address
 1447               		.loc 3 168 0 discriminator 3
 1448 0196 80E0      		ldi r24,lo8(flashWriteCycle+12)
 1449 0198 90E0      		ldi r25,hi8(flashWriteCycle+12)
 1450 019a 8C17      		cp r24,r28
 1451 019c 9D07      		cpc r25,r29
 1452 019e 01F4      		brne .L63
 1453 01a0 00C0      		rjmp .L45
 1454               	.L62:
 1455               	.LBE129:
 180:main.c        **** 			usart_read_chars(); // Read address
 1456               		.loc 3 180 0
 1457 01a2 8634      		cpi r24,lo8(70)
 1458 01a4 01F4      		brne .L64
 1459               	.LBB130:
 181:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 1460               		.loc 3 181 0
 1461 01a6 00D0      		rcall usart_read_chars
 1462               	.LVL135:
 182:main.c        **** 			
 1463               		.loc 3 182 0
 1464 01a8 40E1      		ldi r20,lo8(16)
 1465 01aa 50E0      		ldi r21,0
 1466 01ac 60E0      		ldi r22,0
 1467 01ae 70E0      		ldi r23,0
 1468 01b0 80E0      		ldi r24,lo8(receivedBuffer)
 1469 01b2 90E0      		ldi r25,hi8(receivedBuffer)
 1470 01b4 00D0      		rcall strtol
 1471               	.LVL136:
 1472 01b6 4B01      		movw r8,r22
 1473 01b8 5C01      		movw r10,r24
 1474               	.LVL137:
 184:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 1475               		.loc 3 184 0
 1476 01ba 00D0      		rcall usart_read_chars
 1477               	.LVL138:
 185:main.c        **** 			
 1478               		.loc 3 185 0
 1479 01bc 40E1      		ldi r20,lo8(16)
 1480 01be 50E0      		ldi r21,0
 1481 01c0 60E0      		ldi r22,0
 1482 01c2 70E0      		ldi r23,0
 1483 01c4 80E0      		ldi r24,lo8(receivedBuffer)
 1484 01c6 90E0      		ldi r25,hi8(receivedBuffer)
 1485 01c8 00D0      		rcall strtol
 1486               	.LVL139:
 187:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 1487               		.loc 3 187 0
 1488 01ca 939A      		sbi 0x12,3
 188:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 1489               		.loc 3 188 0
 1490 01cc C401      		movw r24,r8
 1491 01ce 00D0      		rcall gb_flash_write_bus_cycle
 1492               	.LVL140:
 1493               	.L162:
 189:main.c        **** 			
 1494               		.loc 3 189 0
 1495 01d0 9398      		cbi 0x12,3
 191:main.c        **** 		}
 1496               		.loc 3 191 0
 1497 01d2 81E3      		ldi r24,lo8(49)
 1498 01d4 00C0      		rjmp .L158
 1499               	.LVL141:
 1500               	.L64:
 1501               	.LBE130:
 195:main.c        **** 			usart_read_bytes(64);
 1502               		.loc 3 195 0
 1503 01d6 8435      		cpi r24,lo8(84)
 1504 01d8 01F4      		brne .L65
 196:main.c        **** 			start_timeout_timer();
 1505               		.loc 3 196 0
 1506 01da 80E4      		ldi r24,lo8(64)
 1507 01dc 90E0      		ldi r25,0
 1508 01de 00D0      		rcall usart_read_bytes
 1509               	.LVL142:
 197:main.c        **** 			
 1510               		.loc 3 197 0
 1511 01e0 00D0      		rcall start_timeout_timer
 1512               	.LVL143:
 199:main.c        **** 			if (flashBank1CommandWrites == 0) {
 1513               		.loc 3 199 0
 1514 01e2 939A      		sbi 0x12,3
 200:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 1515               		.loc 3 200 0
 1516 01e4 8091 0000 		lds r24,flashBank1CommandWrites
 1517 01e8 00E0      		ldi r16,lo8(receivedBuffer)
 1518 01ea 10E0      		ldi r17,hi8(receivedBuffer)
 1519 01ec C0E0      		ldi r28,0
 1520 01ee D0E0      		ldi r29,0
 1521 01f0 8111      		cpse r24,__zero_reg__
 1522 01f2 00C0      		rjmp .L71
 1523               	.LVL144:
 1524               	.L68:
 1525               	.LBB131:
 202:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 1526               		.loc 3 202 0
 1527 01f4 F801      		movw r30,r16
 1528 01f6 6191      		ld r22,Z+
 1529 01f8 8F01      		movw r16,r30
 1530 01fa 6F3F      		cpi r22,lo8(-1)
 1531 01fc 01F0      		breq .L67
 203:main.c        **** 					}
 1532               		.loc 3 203 0
 1533 01fe CE01      		movw r24,r28
 1534 0200 8C0D      		add r24,r12
 1535 0202 9D1D      		adc r25,r13
 1536 0204 00D0      		rcall gb_flash_write_byte
 1537               	.LVL145:
 1538               	.L67:
 1539 0206 2196      		adiw r28,1
 1540               	.LVL146:
 201:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1541               		.loc 3 201 0 discriminator 2
 1542 0208 C034      		cpi r28,64
 1543 020a D105      		cpc r29,__zero_reg__
 1544 020c 01F4      		brne .L68
 1545 020e 00C0      		rjmp .L161
 1546               	.LVL147:
 1547               	.L70:
 1548 0210 2196      		adiw r28,1
 1549               	.LVL148:
 1550               	.LBE131:
 1551               	.LBB132:
 209:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 1552               		.loc 3 209 0 discriminator 2
 1553 0212 C034      		cpi r28,64
 1554 0214 D105      		cpc r29,__zero_reg__
 1555 0216 01F4      		brne .+2
 1556 0218 00C0      		rjmp .L161
 1557               	.LVL149:
 1558               	.L71:
 210:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 1559               		.loc 3 210 0
 1560 021a F801      		movw r30,r16
 1561 021c 6191      		ld r22,Z+
 1562 021e 8F01      		movw r16,r30
 1563 0220 6F3F      		cpi r22,lo8(-1)
 1564 0222 01F0      		breq .L70
 211:main.c        **** 					}
 1565               		.loc 3 211 0
 1566 0224 CE01      		movw r24,r28
 1567 0226 8C0D      		add r24,r12
 1568 0228 9D1D      		adc r25,r13
 1569 022a 00D0      		rcall gb_flash_write_byte_bank1_commands
 1570               	.LVL150:
 1571 022c 00C0      		rjmp .L70
 1572               	.LVL151:
 1573               	.L65:
 1574               	.LBE132:
 221:main.c        **** 			usart_read_bytes(32);
 1575               		.loc 3 221 0
 1576 022e 8935      		cpi r24,lo8(89)
 1577 0230 01F0      		breq .+2
 1578 0232 00C0      		rjmp .L72
 1579               	.LBB133:
 222:main.c        **** 			start_timeout_timer();
 1580               		.loc 3 222 0
 1581 0234 80E2      		ldi r24,lo8(32)
 1582 0236 90E0      		ldi r25,0
 1583 0238 00D0      		rcall usart_read_bytes
 1584               	.LVL152:
 223:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1585               		.loc 3 223 0
 1586 023a 00D0      		rcall start_timeout_timer
 1587               	.LVL153:
 224:main.c        **** 			
 1588               		.loc 3 224 0
 1589 023c 939A      		sbi 0x12,3
 227:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 1590               		.loc 3 227 0
 1591 023e 6AEA      		ldi r22,lo8(-86)
 1592 0240 8AEA      		ldi r24,lo8(-86)
 1593 0242 9AE0      		ldi r25,lo8(10)
 1594 0244 00D0      		rcall gb_flash_write_bus_cycle
 1595               	.LVL154:
 228:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 1596               		.loc 3 228 0
 1597 0246 65E5      		ldi r22,lo8(85)
 1598 0248 85E5      		ldi r24,lo8(85)
 1599 024a 95E0      		ldi r25,lo8(5)
 1600 024c 00D0      		rcall gb_flash_write_bus_cycle
 1601               	.LVL155:
 229:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 1602               		.loc 3 229 0
 1603 024e 5601      		movw r10,r12
 1604 0250 65E2      		ldi r22,lo8(37)
 1605 0252 C601      		movw r24,r12
 1606 0254 00D0      		rcall gb_flash_write_bus_cycle
 1607               	.LVL156:
 230:main.c        **** 			_delay_us(1);
 1608               		.loc 3 230 0
 1609 0256 6FE1      		ldi r22,lo8(31)
 1610 0258 C601      		movw r24,r12
 1611 025a 00D0      		rcall gb_flash_write_bus_cycle
 1612               	.LVL157:
 1613               	.LBB134:
 1614               	.LBB135:
 1615               		.loc 2 276 0
 1616 025c 25E0      		ldi r18,lo8(5)
 1617 025e 2A95      	1:	dec r18
 1618 0260 01F4      		brne 1b
 1619 0262 0000      		nop
 1620               	.LVL158:
 1621 0264 00E0      		ldi r16,lo8(receivedBuffer)
 1622 0266 10E0      		ldi r17,hi8(receivedBuffer)
 1623 0268 C0E0      		ldi r28,0
 1624 026a D0E0      		ldi r29,0
 1625               	.LVL159:
 1626               	.L73:
 1627               	.LBE135:
 1628               	.LBE134:
 1629               	.LBB136:
 235:main.c        **** 				address++;
 1630               		.loc 3 235 0 discriminator 3
 1631 026c F801      		movw r30,r16
 1632 026e 6191      		ld r22,Z+
 1633 0270 8F01      		movw r16,r30
 1634 0272 C501      		movw r24,r10
 1635 0274 8C0F      		add r24,r28
 1636 0276 9D1F      		adc r25,r29
 1637 0278 00D0      		rcall gb_flash_write_bus_cycle
 1638               	.LVL160:
 1639 027a 2196      		adiw r28,1
 1640               	.LVL161:
 234:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1641               		.loc 3 234 0 discriminator 3
 1642 027c C032      		cpi r28,32
 1643 027e D105      		cpc r29,__zero_reg__
 1644 0280 01F4      		brne .L73
 1645 0282 F0E2      		ldi r31,32
 1646 0284 CF0E      		add r12,r31
 1647 0286 D11C      		adc r13,__zero_reg__
 1648 0288 E11C      		adc r14,__zero_reg__
 1649 028a F11C      		adc r15,__zero_reg__
 1650               	.LBE136:
 240:main.c        **** 			_delay_us(200);
 1651               		.loc 3 240 0
 1652 028c C601      		movw r24,r12
 1653 028e 8097      		sbiw r24,32
 1654 0290 69E2      		ldi r22,lo8(41)
 1655 0292 00D0      		rcall gb_flash_write_bus_cycle
 1656               	.LVL162:
 1657               	.LBB137:
 1658               	.LBB138:
 1659               		.loc 2 276 0
 1660 0294 8FE1      		ldi r24,lo8(799)
 1661 0296 93E0      		ldi r25,hi8(799)
 1662 0298 0197      	1:	sbiw r24,1
 1663 029a 01F4      		brne 1b
 1664 029c 00C0      		rjmp .
 1665 029e 0000      		nop
 1666               	.LVL163:
 1667               	.LBE138:
 1668               	.LBE137:
 244:main.c        **** 			uint8_t verifyCount = 0;
 1669               		.loc 3 244 0
 1670 02a0 E601      		movw r28,r12
 1671               	.LVL164:
 1672 02a2 2197      		sbiw r28,1
 1673 02a4 CE01      		movw r24,r28
 1674 02a6 00D0      		rcall gb_flash_read_byte
 1675               	.LVL165:
 1676               	.L74:
 246:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1677               		.loc 3 246 0
 1678 02a8 9091 0000 		lds r25,receivedBuffer+31
 1679 02ac 8917      		cp r24,r25
 1680 02ae 01F4      		brne .+2
 1681 02b0 00C0      		rjmp .L84
 247:main.c        **** 				_delay_us(5);
 1682               		.loc 3 247 0
 1683 02b2 CE01      		movw r24,r28
 1684               	.LVL166:
 1685 02b4 00D0      		rcall gb_flash_read_byte
 1686               	.LVL167:
 1687               	.LBB139:
 1688               	.LBB140:
 1689               		.loc 2 276 0
 1690 02b6 9AE1      		ldi r25,lo8(26)
 1691 02b8 9A95      	1:	dec r25
 1692 02ba 01F4      		brne 1b
 1693 02bc 00C0      		rjmp .
 1694               	.LVL168:
 1695               	.LBE140:
 1696               	.LBE139:
 250:main.c        **** 					break;
 1697               		.loc 3 250 0
 1698 02be 9091 0000 		lds r25,writingTimedout
 1699 02c2 9130      		cpi r25,lo8(1)
 1700 02c4 01F4      		brne .L74
 1701 02c6 00C0      		rjmp .L84
 1702               	.LVL169:
 1703               	.L72:
 1704               	.LBE133:
 259:main.c        **** 			usart_read_bytes(64);
 1705               		.loc 3 259 0
 1706 02c8 8A34      		cpi r24,lo8(74)
 1707 02ca 01F4      		brne .L77
 260:main.c        **** 			start_timeout_timer();
 1708               		.loc 3 260 0
 1709 02cc 80E4      		ldi r24,lo8(64)
 1710 02ce 90E0      		ldi r25,0
 1711 02d0 00D0      		rcall usart_read_bytes
 1712               	.LVL170:
 261:main.c        **** 			
 1713               		.loc 3 261 0
 1714 02d2 00D0      		rcall start_timeout_timer
 1715               	.LVL171:
 263:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 1716               		.loc 3 263 0
 1717 02d4 939A      		sbi 0x12,3
 1718               	.LVL172:
 1719 02d6 00E0      		ldi r16,lo8(receivedBuffer)
 1720 02d8 10E0      		ldi r17,hi8(receivedBuffer)
 1721 02da C0E0      		ldi r28,0
 1722 02dc D0E0      		ldi r29,0
 1723               	.LVL173:
 1724               	.L79:
 1725               	.LBB141:
 265:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 1726               		.loc 3 265 0
 1727 02de F801      		movw r30,r16
 1728 02e0 6191      		ld r22,Z+
 1729 02e2 8F01      		movw r16,r30
 1730 02e4 6F3F      		cpi r22,lo8(-1)
 1731 02e6 01F0      		breq .L78
 266:main.c        **** 				}
 1732               		.loc 3 266 0
 1733 02e8 CE01      		movw r24,r28
 1734 02ea 8C0D      		add r24,r12
 1735 02ec 9D1D      		adc r25,r13
 1736 02ee 00D0      		rcall gb_flash_write_byte_special
 1737               	.LVL174:
 1738               	.L78:
 1739 02f0 2196      		adiw r28,1
 1740               	.LVL175:
 264:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 1741               		.loc 3 264 0 discriminator 2
 1742 02f2 C034      		cpi r28,64
 1743 02f4 D105      		cpc r29,__zero_reg__
 1744 02f6 01F4      		brne .L79
 1745               	.LVL176:
 1746               	.L161:
 1747 02f8 F0E4      		ldi r31,64
 1748 02fa CF0E      		add r12,r31
 1749 02fc D11C      		adc r13,__zero_reg__
 1750 02fe E11C      		adc r14,__zero_reg__
 1751 0300 F11C      		adc r15,__zero_reg__
 1752 0302 00C0      		rjmp .L84
 1753               	.LVL177:
 1754               	.L77:
 1755               	.LBE141:
 275:main.c        **** 			usart_read_bytes(256);
 1756               		.loc 3 275 0
 1757 0304 8835      		cpi r24,lo8(88)
 1758 0306 01F0      		breq .+2
 1759 0308 00C0      		rjmp .L80
 1760               	.LBB142:
 276:main.c        **** 			start_timeout_timer();
 1761               		.loc 3 276 0
 1762 030a 80E0      		ldi r24,0
 1763 030c 91E0      		ldi r25,lo8(1)
 1764 030e 00D0      		rcall usart_read_bytes
 1765               	.LVL178:
 277:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1766               		.loc 3 277 0
 1767 0310 00D0      		rcall start_timeout_timer
 1768               	.LVL179:
 278:main.c        **** 			
 1769               		.loc 3 278 0
 1770 0312 939A      		sbi 0x12,3
 281:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 1771               		.loc 3 281 0
 1772 0314 69EA      		ldi r22,lo8(-87)
 1773 0316 8AEA      		ldi r24,lo8(-86)
 1774 0318 9AE0      		ldi r25,lo8(10)
 1775 031a 00D0      		rcall gb_flash_write_bus_cycle
 1776               	.LVL180:
 282:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 1777               		.loc 3 282 0
 1778 031c 66E5      		ldi r22,lo8(86)
 1779 031e 85E5      		ldi r24,lo8(85)
 1780 0320 95E0      		ldi r25,lo8(5)
 1781 0322 00D0      		rcall gb_flash_write_bus_cycle
 1782               	.LVL181:
 283:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 1783               		.loc 3 283 0
 1784 0324 5601      		movw r10,r12
 1785 0326 66E2      		ldi r22,lo8(38)
 1786 0328 C601      		movw r24,r12
 1787 032a 00D0      		rcall gb_flash_write_bus_cycle
 1788               	.LVL182:
 284:main.c        **** 			_delay_us(50);
 1789               		.loc 3 284 0
 1790 032c 6FEF      		ldi r22,lo8(-1)
 1791 032e C601      		movw r24,r12
 1792 0330 00D0      		rcall gb_flash_write_bus_cycle
 1793               	.LVL183:
 1794               	.LBB143:
 1795               	.LBB144:
 1796               		.loc 2 276 0
 1797 0332 87EC      		ldi r24,lo8(199)
 1798 0334 90E0      		ldi r25,hi8(199)
 1799 0336 0197      	1:	sbiw r24,1
 1800 0338 01F4      		brne 1b
 1801 033a 00C0      		rjmp .
 1802 033c 0000      		nop
 1803               	.LVL184:
 1804 033e 00E0      		ldi r16,lo8(receivedBuffer)
 1805 0340 10E0      		ldi r17,hi8(receivedBuffer)
 1806               	.LBE144:
 1807               	.LBE143:
 1808               	.LBB145:
 288:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1809               		.loc 3 288 0
 1810 0342 C0E0      		ldi r28,0
 1811 0344 D0E0      		ldi r29,0
 1812               	.LVL185:
 1813               	.L81:
 289:main.c        **** 				address++;
 1814               		.loc 3 289 0 discriminator 3
 1815 0346 F801      		movw r30,r16
 1816 0348 6191      		ld r22,Z+
 1817 034a 8F01      		movw r16,r30
 1818 034c CE01      		movw r24,r28
 1819 034e 8A0D      		add r24,r10
 1820 0350 9B1D      		adc r25,r11
 1821 0352 00D0      		rcall gb_flash_write_bus_cycle
 1822               	.LVL186:
 288:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 1823               		.loc 3 288 0 discriminator 3
 1824 0354 2196      		adiw r28,1
 1825               	.LVL187:
 1826 0356 C115      		cp r28,__zero_reg__
 1827 0358 F1E0      		ldi r31,1
 1828 035a DF07      		cpc r29,r31
 1829 035c 01F4      		brne .L81
 1830 035e 2FEF      		ldi r18,-1
 1831 0360 D21A      		sub r13,r18
 1832 0362 E20A      		sbc r14,r18
 1833 0364 F20A      		sbc r15,r18
 1834               	.LBE145:
 294:main.c        **** 			
 1835               		.loc 3 294 0
 1836 0366 C601      		movw r24,r12
 1837 0368 9A95      		dec r25
 1838 036a 6AE2      		ldi r22,lo8(42)
 1839 036c 00D0      		rcall gb_flash_write_bus_cycle
 1840               	.LVL188:
 297:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 1841               		.loc 3 297 0
 1842 036e E601      		movw r28,r12
 1843               	.LVL189:
 1844 0370 2197      		sbiw r28,1
 1845 0372 CE01      		movw r24,r28
 1846 0374 00D0      		rcall gb_flash_read_byte
 1847               	.LVL190:
 1848               	.L82:
 298:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 1849               		.loc 3 298 0
 1850 0376 9091 0000 		lds r25,receivedBuffer+255
 1851 037a 8917      		cp r24,r25
 1852 037c 01F0      		breq .L84
 299:main.c        **** 				_delay_us(5);
 1853               		.loc 3 299 0
 1854 037e CE01      		movw r24,r28
 1855               	.LVL191:
 1856 0380 00D0      		rcall gb_flash_read_byte
 1857               	.LVL192:
 1858               	.LBB146:
 1859               	.LBB147:
 1860               		.loc 2 276 0
 1861 0382 9AE1      		ldi r25,lo8(26)
 1862 0384 9A95      	1:	dec r25
 1863 0386 01F4      		brne 1b
 1864 0388 00C0      		rjmp .
 1865               	.LVL193:
 1866               	.LBE147:
 1867               	.LBE146:
 301:main.c        **** 					break;
 1868               		.loc 3 301 0
 1869 038a 9091 0000 		lds r25,writingTimedout
 1870 038e 9130      		cpi r25,lo8(1)
 1871 0390 01F4      		brne .L82
 1872               	.LVL194:
 1873               	.L84:
 306:main.c        **** 		}
 1874               		.loc 3 306 0
 1875 0392 00D0      		rcall check_if_timed_out
 1876               	.LVL195:
 1877               	.LBE142:
 1878 0394 00C0      		rjmp .L45
 1879               	.LVL196:
 1880               	.L80:
 310:main.c        **** 			usart_read_bytes(128);
 1881               		.loc 3 310 0
 1882 0396 8A35      		cpi r24,lo8(90)
 1883 0398 01F0      		breq .+2
 1884 039a 00C0      		rjmp .L85
 311:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 1885               		.loc 3 311 0
 1886 039c 80E8      		ldi r24,lo8(-128)
 1887 039e 90E0      		ldi r25,0
 1888 03a0 00D0      		rcall usart_read_bytes
 1889               	.LVL197:
 312:main.c        **** 			
 1890               		.loc 3 312 0
 1891 03a2 939A      		sbi 0x12,3
 315:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 1892               		.loc 3 315 0
 1893 03a4 69E0      		ldi r22,lo8(9)
 1894 03a6 80E2      		ldi r24,lo8(32)
 1895 03a8 91E0      		ldi r25,lo8(1)
 1896 03aa 00D0      		rcall gb_flash_write_bus_cycle
 1897               	.LVL198:
 316:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 1898               		.loc 3 316 0
 1899 03ac 6AEA      		ldi r22,lo8(-86)
 1900 03ae 81E2      		ldi r24,lo8(33)
 1901 03b0 91E0      		ldi r25,lo8(1)
 1902 03b2 00D0      		rcall gb_flash_write_bus_cycle
 1903               	.LVL199:
 317:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1904               		.loc 3 317 0
 1905 03b4 65E5      		ldi r22,lo8(85)
 1906 03b6 82E2      		ldi r24,lo8(34)
 1907 03b8 91E0      		ldi r25,lo8(1)
 1908 03ba 00D0      		rcall gb_flash_write_bus_cycle
 1909               	.LVL200:
 318:main.c        **** 			_delay_us(5);
 1910               		.loc 3 318 0
 1911 03bc 65EA      		ldi r22,lo8(-91)
 1912 03be 8FE3      		ldi r24,lo8(63)
 1913 03c0 91E0      		ldi r25,lo8(1)
 1914 03c2 00D0      		rcall gb_flash_write_bus_cycle
 1915               	.LVL201:
 1916               	.LBB148:
 1917               	.LBB149:
 1918               		.loc 2 276 0
 1919 03c4 EAE1      		ldi r30,lo8(26)
 1920 03c6 EA95      	1:	dec r30
 1921 03c8 01F4      		brne 1b
 1922 03ca 00C0      		rjmp .
 1923               	.LVL202:
 1924               	.LBE149:
 1925               	.LBE148:
 322:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 1926               		.loc 3 322 0
 1927 03cc 61E1      		ldi r22,lo8(17)
 1928 03ce 80E2      		ldi r24,lo8(32)
 1929 03d0 91E0      		ldi r25,lo8(1)
 1930 03d2 00D0      		rcall gb_flash_write_bus_cycle
 1931               	.LVL203:
 323:main.c        **** 			_delay_us(5);
 1932               		.loc 3 323 0
 1933 03d4 65EA      		ldi r22,lo8(-91)
 1934 03d6 8FE3      		ldi r24,lo8(63)
 1935 03d8 91E0      		ldi r25,lo8(1)
 1936 03da 00D0      		rcall gb_flash_write_bus_cycle
 1937               	.LVL204:
 1938               	.LBB150:
 1939               	.LBB151:
 1940               		.loc 2 276 0
 1941 03dc FAE1      		ldi r31,lo8(26)
 1942 03de FA95      	1:	dec r31
 1943 03e0 01F4      		brne 1b
 1944 03e2 00C0      		rjmp .
 1945               	.LVL205:
 1946               	.LBE151:
 1947               	.LBE150:
 327:main.c        **** 			_delay_us(5);
 1948               		.loc 3 327 0
 1949 03e4 61E0      		ldi r22,lo8(1)
 1950 03e6 80E0      		ldi r24,0
 1951 03e8 91E2      		ldi r25,lo8(33)
 1952 03ea 00D0      		rcall gb_flash_write_bus_cycle
 1953               	.LVL206:
 1954               	.LBB152:
 1955               	.LBB153:
 1956               		.loc 2 276 0
 1957 03ec 2AE1      		ldi r18,lo8(26)
 1958 03ee 2A95      	1:	dec r18
 1959 03f0 01F4      		brne 1b
 1960 03f2 00C0      		rjmp .
 1961               	.LVL207:
 1962               	.LBE153:
 1963               	.LBE152:
 332:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 1964               		.loc 3 332 0
 1965 03f4 6FE0      		ldi r22,lo8(15)
 1966 03f6 80E2      		ldi r24,lo8(32)
 1967 03f8 91E0      		ldi r25,lo8(1)
 1968 03fa 00D0      		rcall gb_flash_write_bus_cycle
 1969               	.LVL208:
 333:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 1970               		.loc 3 333 0
 1971 03fc 65E5      		ldi r22,lo8(85)
 1972 03fe 85E2      		ldi r24,lo8(37)
 1973 0400 91E0      		ldi r25,lo8(1)
 1974 0402 00D0      		rcall gb_flash_write_bus_cycle
 1975               	.LVL209:
 334:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 1976               		.loc 3 334 0
 1977 0404 65E5      		ldi r22,lo8(85)
 1978 0406 86E2      		ldi r24,lo8(38)
 1979 0408 91E0      		ldi r25,lo8(1)
 1980 040a 00D0      		rcall gb_flash_write_bus_cycle
 1981               	.LVL210:
 335:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 1982               		.loc 3 335 0
 1983 040c 6AEA      		ldi r22,lo8(-86)
 1984 040e 87E2      		ldi r24,lo8(39)
 1985 0410 91E0      		ldi r25,lo8(1)
 1986 0412 00D0      		rcall gb_flash_write_bus_cycle
 1987               	.LVL211:
 336:main.c        **** 			_delay_us(5);
 1988               		.loc 3 336 0
 1989 0414 65EA      		ldi r22,lo8(-91)
 1990 0416 8FE3      		ldi r24,lo8(63)
 1991 0418 91E0      		ldi r25,lo8(1)
 1992 041a 00D0      		rcall gb_flash_write_bus_cycle
 1993               	.LVL212:
 1994               	.LBB154:
 1995               	.LBB155:
 1996               		.loc 2 276 0
 1997 041c 8AE1      		ldi r24,lo8(26)
 1998 041e 8A95      	1:	dec r24
 1999 0420 01F4      		brne 1b
 2000 0422 00C0      		rjmp .
 2001               	.LVL213:
 2002               	.LBE155:
 2003               	.LBE154:
 339:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 2004               		.loc 3 339 0
 2005 0424 6FE0      		ldi r22,lo8(15)
 2006 0426 80E2      		ldi r24,lo8(32)
 2007 0428 91E0      		ldi r25,lo8(1)
 2008 042a 00D0      		rcall gb_flash_write_bus_cycle
 2009               	.LVL214:
 340:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 2010               		.loc 3 340 0
 2011 042c 6AE2      		ldi r22,lo8(42)
 2012 042e 85E2      		ldi r24,lo8(37)
 2013 0430 91E0      		ldi r25,lo8(1)
 2014 0432 00D0      		rcall gb_flash_write_bus_cycle
 2015               	.LVL215:
 341:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 2016               		.loc 3 341 0
 2017 0434 6AEA      		ldi r22,lo8(-86)
 2018 0436 86E2      		ldi r24,lo8(38)
 2019 0438 91E0      		ldi r25,lo8(1)
 2020 043a 00D0      		rcall gb_flash_write_bus_cycle
 2021               	.LVL216:
 342:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 2022               		.loc 3 342 0
 2023 043c 65E5      		ldi r22,lo8(85)
 2024 043e 87E2      		ldi r24,lo8(39)
 2025 0440 91E0      		ldi r25,lo8(1)
 2026 0442 00D0      		rcall gb_flash_write_bus_cycle
 2027               	.LVL217:
 343:main.c        **** 			_delay_us(5);
 2028               		.loc 3 343 0
 2029 0444 65EA      		ldi r22,lo8(-91)
 2030 0446 8FE3      		ldi r24,lo8(63)
 2031 0448 91E0      		ldi r25,lo8(1)
 2032 044a 00D0      		rcall gb_flash_write_bus_cycle
 2033               	.LVL218:
 2034               	.LBB156:
 2035               	.LBB157:
 2036               		.loc 2 276 0
 2037 044c 9AE1      		ldi r25,lo8(26)
 2038 044e 9A95      	1:	dec r25
 2039 0450 01F4      		brne 1b
 2040 0452 00C0      		rjmp .
 2041               	.LVL219:
 2042               	.LBE157:
 2043               	.LBE156:
 346:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 2044               		.loc 3 346 0
 2045 0454 6FE0      		ldi r22,lo8(15)
 2046 0456 80E2      		ldi r24,lo8(32)
 2047 0458 91E0      		ldi r25,lo8(1)
 2048 045a 00D0      		rcall gb_flash_write_bus_cycle
 2049               	.LVL220:
 347:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 2050               		.loc 3 347 0
 2051 045c 65E5      		ldi r22,lo8(85)
 2052 045e 85E2      		ldi r24,lo8(37)
 2053 0460 91E0      		ldi r25,lo8(1)
 2054 0462 00D0      		rcall gb_flash_write_bus_cycle
 2055               	.LVL221:
 348:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 2056               		.loc 3 348 0
 2057 0464 65E5      		ldi r22,lo8(85)
 2058 0466 86E2      		ldi r24,lo8(38)
 2059 0468 91E0      		ldi r25,lo8(1)
 2060 046a 00D0      		rcall gb_flash_write_bus_cycle
 2061               	.LVL222:
 349:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 2062               		.loc 3 349 0
 2063 046c 60EA      		ldi r22,lo8(-96)
 2064 046e 87E2      		ldi r24,lo8(39)
 2065 0470 91E0      		ldi r25,lo8(1)
 2066 0472 00D0      		rcall gb_flash_write_bus_cycle
 2067               	.LVL223:
 350:main.c        **** 			_delay_us(5);
 2068               		.loc 3 350 0
 2069 0474 65EA      		ldi r22,lo8(-91)
 2070 0476 8FE3      		ldi r24,lo8(63)
 2071 0478 91E0      		ldi r25,lo8(1)
 2072 047a 00D0      		rcall gb_flash_write_bus_cycle
 2073               	.LVL224:
 2074               	.LBB158:
 2075               	.LBB159:
 2076               		.loc 2 276 0
 2077 047c EAE1      		ldi r30,lo8(26)
 2078 047e EA95      	1:	dec r30
 2079 0480 01F4      		brne 1b
 2080 0482 00C0      		rjmp .
 2081               	.LVL225:
 2082               	.LBE159:
 2083               	.LBE158:
 354:main.c        **** 			_delay_us(5);
 2084               		.loc 3 354 0
 2085 0484 40E0      		ldi r20,0
 2086 0486 6091 0000 		lds r22,lastBankAccessed
 2087 048a 80E0      		ldi r24,0
 2088 048c 91E2      		ldi r25,lo8(33)
 2089 048e 00D0      		rcall write_8bit_data
 2090               	.LVL226:
 2091               	.LBB160:
 2092               	.LBB161:
 2093               		.loc 2 276 0
 2094 0490 FAE1      		ldi r31,lo8(26)
 2095 0492 FA95      	1:	dec r31
 2096 0494 01F4      		brne 1b
 2097 0496 00C0      		rjmp .
 2098               	.LVL227:
 2099               	.LBE161:
 2100               	.LBE160:
 358:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 2101               		.loc 3 358 0
 2102 0498 60E1      		ldi r22,lo8(16)
 2103 049a 80E2      		ldi r24,lo8(32)
 2104 049c 91E0      		ldi r25,lo8(1)
 2105 049e 00D0      		rcall gb_flash_write_bus_cycle
 2106               	.LVL228:
 359:main.c        **** 			_delay_us(5);
 2107               		.loc 3 359 0
 2108 04a0 65EA      		ldi r22,lo8(-91)
 2109 04a2 8FE3      		ldi r24,lo8(63)
 2110 04a4 91E0      		ldi r25,lo8(1)
 2111 04a6 00D0      		rcall gb_flash_write_bus_cycle
 2112               	.LVL229:
 2113               	.LBB162:
 2114               	.LBB163:
 2115               		.loc 2 276 0
 2116 04a8 2AE1      		ldi r18,lo8(26)
 2117 04aa 2A95      	1:	dec r18
 2118 04ac 01F4      		brne 1b
 2119 04ae 00C0      		rjmp .
 2120               	.LVL230:
 2121               	.LBE163:
 2122               	.LBE162:
 363:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 2123               		.loc 3 363 0
 2124 04b0 68E0      		ldi r22,lo8(8)
 2125 04b2 80E2      		ldi r24,lo8(32)
 2126 04b4 91E0      		ldi r25,lo8(1)
 2127 04b6 00D0      		rcall gb_flash_write_bus_cycle
 2128               	.LVL231:
 364:main.c        **** 			_delay_us(5);
 2129               		.loc 3 364 0
 2130 04b8 65EA      		ldi r22,lo8(-91)
 2131 04ba 8FE3      		ldi r24,lo8(63)
 2132 04bc 91E0      		ldi r25,lo8(1)
 2133 04be 00D0      		rcall gb_flash_write_bus_cycle
 2134               	.LVL232:
 2135               	.LBB164:
 2136               	.LBB165:
 2137               		.loc 2 276 0
 2138 04c0 8AE1      		ldi r24,lo8(26)
 2139 04c2 8A95      	1:	dec r24
 2140 04c4 01F4      		brne 1b
 2141 04c6 00C0      		rjmp .
 2142               	.LVL233:
 2143 04c8 C0E0      		ldi r28,lo8(receivedBuffer)
 2144 04ca D0E0      		ldi r29,hi8(receivedBuffer)
 2145               	.L86:
 2146               	.LBE165:
 2147               	.LBE164:
 2148               	.LBB166:
 369:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2149               		.loc 3 369 0 discriminator 1
 2150 04cc 6C16      		cp r6,r28
 2151 04ce 7D06      		cpc r7,r29
 2152 04d0 01F0      		breq .L174
 370:main.c        **** 				_delay_us(5);
 2153               		.loc 3 370 0 discriminator 3
 2154 04d2 6991      		ld r22,Y+
 2155 04d4 C601      		movw r24,r12
 2156 04d6 00D0      		rcall gb_flash_write_bus_cycle
 2157               	.LVL234:
 2158               	.LBB167:
 2159               	.LBB168:
 2160               		.loc 2 276 0 discriminator 3
 2161 04d8 9AE1      		ldi r25,lo8(26)
 2162 04da 9A95      	1:	dec r25
 2163 04dc 01F4      		brne 1b
 2164 04de 00C0      		rjmp .
 2165               	.LVL235:
 2166               	.LBE168:
 2167               	.LBE167:
 372:main.c        **** 			}
 2168               		.loc 3 372 0 discriminator 3
 2169 04e0 EFEF      		ldi r30,-1
 2170 04e2 CE1A      		sub r12,r30
 2171 04e4 DE0A      		sbc r13,r30
 2172 04e6 EE0A      		sbc r14,r30
 2173 04e8 FE0A      		sbc r15,r30
 2174               	.LVL236:
 2175 04ea 00C0      		rjmp .L86
 2176               	.L174:
 2177               	.LVL237:
 2178               	.LBE166:
 377:main.c        **** 			address++;
 2179               		.loc 3 377 0
 2180 04ec 6FEF      		ldi r22,lo8(-1)
 2181 04ee D701      		movw r26,r14
 2182 04f0 C601      		movw r24,r12
 2183 04f2 0197      		sbiw r24,1
 2184 04f4 A109      		sbc r26,__zero_reg__
 2185 04f6 B109      		sbc r27,__zero_reg__
 2186               	.LVL238:
 2187 04f8 00D0      		rcall gb_flash_write_bus_cycle
 2188               	.LVL239:
 2189               	.LBB169:
 2190               	.LBB170:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2191               		.loc 2 187 0
 2192 04fa 8FE3      		ldi r24,lo8(-25537)
 2193 04fc 9CE9      		ldi r25,hi8(-25537)
 2194 04fe 0197      	1:	sbiw r24,1
 2195 0500 01F4      		brne 1b
 2196 0502 00C0      		rjmp .
 2197 0504 0000      		nop
 2198               	.LVL240:
 2199               	.L159:
 2200               	.LBE170:
 2201               	.LBE169:
 381:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 2202               		.loc 3 381 0
 2203 0506 81E3      		ldi r24,lo8(49)
 2204               	.L163:
 2205 0508 00D0      		rcall USART_Transmit
 2206               	.LVL241:
 2207               	.L157:
 382:main.c        **** 		}
 2208               		.loc 3 382 0
 2209 050a 9398      		cbi 0x12,3
 2210 050c 00C0      		rjmp .L45
 2211               	.LVL242:
 2212               	.L85:
 387:main.c        **** 			usart_read_bytes(32);
 2213               		.loc 3 387 0
 2214 050e 8937      		cpi r24,lo8(121)
 2215 0510 01F4      		brne .L88
 388:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2216               		.loc 3 388 0
 2217 0512 80E2      		ldi r24,lo8(32)
 2218 0514 90E0      		ldi r25,0
 2219 0516 00D0      		rcall usart_read_bytes
 2220               	.LVL243:
 389:main.c        **** 			
 2221               		.loc 3 389 0
 2222 0518 939A      		sbi 0x12,3
 392:main.c        **** 			
 2223               		.loc 3 392 0
 2224 051a 8601      		movw r16,r12
 2225 051c 68EE      		ldi r22,lo8(-24)
 2226 051e C601      		movw r24,r12
 2227 0520 00D0      		rcall gb_flash_write_bus_cycle
 2228               	.LVL244:
 2229               	.L89:
 396:main.c        **** 			
 2230               		.loc 3 396 0 discriminator 1
 2231 0522 C801      		movw r24,r16
 2232 0524 00D0      		rcall gb_flash_read_byte
 2233               	.LVL245:
 2234 0526 8038      		cpi r24,lo8(-128)
 2235 0528 01F4      		brne .L89
 399:main.c        **** 			
 2236               		.loc 3 399 0
 2237 052a 6FE1      		ldi r22,lo8(31)
 2238 052c C801      		movw r24,r16
 2239 052e 00D0      		rcall gb_flash_write_bus_cycle
 2240               	.LVL246:
 2241 0530 80E0      		ldi r24,lo8(receivedBuffer)
 2242 0532 A82E      		mov r10,r24
 2243 0534 80E0      		ldi r24,hi8(receivedBuffer)
 2244 0536 B82E      		mov r11,r24
 2245 0538 C0E0      		ldi r28,0
 2246 053a D0E0      		ldi r29,0
 2247               	.LVL247:
 2248               	.L90:
 2249               	.LBB171:
 403:main.c        **** 				address++;
 2250               		.loc 3 403 0 discriminator 3
 2251 053c F501      		movw r30,r10
 2252 053e 6191      		ld r22,Z+
 2253 0540 5F01      		movw r10,r30
 2254 0542 CE01      		movw r24,r28
 2255 0544 800F      		add r24,r16
 2256 0546 911F      		adc r25,r17
 2257 0548 00D0      		rcall gb_flash_write_bus_cycle
 2258               	.LVL248:
 2259 054a 2196      		adiw r28,1
 2260               	.LVL249:
 402:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 2261               		.loc 3 402 0 discriminator 3
 2262 054c C032      		cpi r28,32
 2263 054e D105      		cpc r29,__zero_reg__
 2264 0550 01F4      		brne .L90
 2265 0552 F0E2      		ldi r31,32
 2266 0554 CF0E      		add r12,r31
 2267 0556 D11C      		adc r13,__zero_reg__
 2268 0558 E11C      		adc r14,__zero_reg__
 2269 055a F11C      		adc r15,__zero_reg__
 2270               	.LBE171:
 408:main.c        **** 			_delay_us(196);
 2271               		.loc 3 408 0
 2272 055c E601      		movw r28,r12
 2273               	.LVL250:
 2274 055e A097      		sbiw r28,32
 2275 0560 60ED      		ldi r22,lo8(-48)
 2276 0562 CE01      		movw r24,r28
 2277 0564 00D0      		rcall gb_flash_write_bus_cycle
 2278               	.LVL251:
 2279               	.LBB172:
 2280               	.LBB173:
 2281               		.loc 2 276 0
 2282 0566 8FE0      		ldi r24,lo8(783)
 2283 0568 93E0      		ldi r25,hi8(783)
 2284 056a 0197      	1:	sbiw r24,1
 2285 056c 01F4      		brne 1b
 2286 056e 00C0      		rjmp .
 2287 0570 0000      		nop
 2288               	.L91:
 2289               	.LBE173:
 2290               	.LBE172:
 413:main.c        **** 			
 2291               		.loc 3 413 0 discriminator 1
 2292 0572 CE01      		movw r24,r28
 2293 0574 00D0      		rcall gb_flash_read_byte
 2294               	.LVL252:
 2295 0576 8038      		cpi r24,lo8(-128)
 2296 0578 01F4      		brne .L91
 2297 057a 00C0      		rjmp .L159
 2298               	.LVL253:
 2299               	.L88:
 423:main.c        **** 			char portChar = USART_Receive();
 2300               		.loc 3 423 0
 2301 057c 8934      		cpi r24,lo8(73)
 2302 057e 01F0      		breq .L92
 423:main.c        **** 			char portChar = USART_Receive();
 2303               		.loc 3 423 0 is_stmt 0 discriminator 1
 2304 0580 8F34      		cpi r24,lo8(79)
 2305 0582 01F0      		breq .+2
 2306 0584 00C0      		rjmp .L93
 2307               	.L92:
 2308               	.LBB174:
 424:main.c        **** 			usart_read_chars();
 2309               		.loc 3 424 0 is_stmt 1
 2310 0586 00D0      		rcall USART_Receive
 2311               	.LVL254:
 2312 0588 C82F      		mov r28,r24
 2313               	.LVL255:
 425:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2314               		.loc 3 425 0
 2315 058a 00D0      		rcall usart_read_chars
 2316               	.LVL256:
 426:main.c        **** 			
 2317               		.loc 3 426 0
 2318 058c 40E1      		ldi r20,lo8(16)
 2319 058e 50E0      		ldi r21,0
 2320 0590 60E0      		ldi r22,0
 2321 0592 70E0      		ldi r23,0
 2322 0594 80E0      		ldi r24,lo8(receivedBuffer)
 2323 0596 90E0      		ldi r25,hi8(receivedBuffer)
 2324 0598 00D0      		rcall strtol
 2325               	.LVL257:
 428:main.c        **** 			if (receivedChar == SET_INPUT) {
 2326               		.loc 3 428 0
 2327 059a 939A      		sbi 0x12,3
 429:main.c        **** 				if (portChar == 'A') {
 2328               		.loc 3 429 0
 2329 059c 8091 0000 		lds r24,receivedChar
 2330 05a0 8934      		cpi r24,lo8(73)
 2331 05a2 01F4      		brne .L94
 430:main.c        **** 					DDRA &= ~(setValue);
 2332               		.loc 3 430 0
 2333 05a4 C134      		cpi r28,lo8(65)
 2334 05a6 01F4      		brne .L95
 431:main.c        **** 				}
 2335               		.loc 3 431 0
 2336 05a8 8AB3      		in r24,0x1a
 2337 05aa 6095      		com r22
 2338               	.LVL258:
 2339 05ac 6823      		and r22,r24
 2340               	.LVL259:
 2341 05ae 00C0      		rjmp .L165
 2342               	.LVL260:
 2343               	.L95:
 433:main.c        **** 					DDRB &= ~(setValue);
 2344               		.loc 3 433 0
 2345 05b0 C234      		cpi r28,lo8(66)
 2346 05b2 01F4      		brne .L97
 434:main.c        **** 				}
 2347               		.loc 3 434 0
 2348 05b4 87B3      		in r24,0x17
 2349 05b6 6095      		com r22
 2350               	.LVL261:
 2351 05b8 6823      		and r22,r24
 2352               	.LVL262:
 2353 05ba 00C0      		rjmp .L166
 2354               	.LVL263:
 2355               	.L97:
 436:main.c        **** 					DDRC &= ~(setValue);
 2356               		.loc 3 436 0
 2357 05bc C334      		cpi r28,lo8(67)
 2358 05be 01F4      		brne .L98
 437:main.c        **** 				}
 2359               		.loc 3 437 0
 2360 05c0 84B3      		in r24,0x14
 2361 05c2 6095      		com r22
 2362               	.LVL264:
 2363 05c4 6823      		and r22,r24
 2364               	.LVL265:
 2365 05c6 00C0      		rjmp .L167
 2366               	.LVL266:
 2367               	.L98:
 439:main.c        **** 					DDRD &= ~(setValue);
 2368               		.loc 3 439 0
 2369 05c8 C434      		cpi r28,lo8(68)
 2370 05ca 01F4      		brne .L99
 440:main.c        **** 				}
 2371               		.loc 3 440 0
 2372 05cc 81B3      		in r24,0x11
 2373 05ce 6095      		com r22
 2374               	.LVL267:
 2375 05d0 6823      		and r22,r24
 2376               	.LVL268:
 2377 05d2 00C0      		rjmp .L168
 2378               	.LVL269:
 2379               	.L99:
 442:main.c        **** 					DDRE &= ~(setValue);
 2380               		.loc 3 442 0
 2381 05d4 C534      		cpi r28,lo8(69)
 2382 05d6 01F0      		breq .+2
 2383 05d8 00C0      		rjmp .L157
 443:main.c        **** 				}
 2384               		.loc 3 443 0
 2385 05da 86B1      		in r24,0x6
 2386 05dc 6095      		com r22
 2387               	.LVL270:
 2388 05de 6823      		and r22,r24
 2389               	.LVL271:
 2390 05e0 00C0      		rjmp .L169
 2391               	.LVL272:
 2392               	.L94:
 446:main.c        **** 				if (portChar == 'A') {
 2393               		.loc 3 446 0
 2394 05e2 8F34      		cpi r24,lo8(79)
 2395 05e4 01F0      		breq .+2
 2396 05e6 00C0      		rjmp .L157
 447:main.c        **** 					DDRA |= (setValue);
 2397               		.loc 3 447 0
 2398 05e8 C134      		cpi r28,lo8(65)
 2399 05ea 01F4      		brne .L100
 448:main.c        **** 				}
 2400               		.loc 3 448 0
 2401 05ec 8AB3      		in r24,0x1a
 2402 05ee 682B      		or r22,r24
 2403               	.LVL273:
 2404               	.L165:
 2405 05f0 6ABB      		out 0x1a,r22
 2406 05f2 00C0      		rjmp .L157
 2407               	.LVL274:
 2408               	.L100:
 450:main.c        **** 					DDRB |= (setValue);
 2409               		.loc 3 450 0
 2410 05f4 C234      		cpi r28,lo8(66)
 2411 05f6 01F4      		brne .L101
 451:main.c        **** 				}
 2412               		.loc 3 451 0
 2413 05f8 87B3      		in r24,0x17
 2414 05fa 682B      		or r22,r24
 2415               	.LVL275:
 2416               	.L166:
 2417 05fc 67BB      		out 0x17,r22
 2418 05fe 00C0      		rjmp .L157
 2419               	.LVL276:
 2420               	.L101:
 453:main.c        **** 					DDRC |= (setValue);
 2421               		.loc 3 453 0
 2422 0600 C334      		cpi r28,lo8(67)
 2423 0602 01F4      		brne .L102
 454:main.c        **** 				}
 2424               		.loc 3 454 0
 2425 0604 84B3      		in r24,0x14
 2426 0606 682B      		or r22,r24
 2427               	.LVL277:
 2428               	.L167:
 2429 0608 64BB      		out 0x14,r22
 2430 060a 00C0      		rjmp .L157
 2431               	.LVL278:
 2432               	.L102:
 456:main.c        **** 					DDRD |= (setValue);
 2433               		.loc 3 456 0
 2434 060c C434      		cpi r28,lo8(68)
 2435 060e 01F4      		brne .L103
 457:main.c        **** 				}
 2436               		.loc 3 457 0
 2437 0610 81B3      		in r24,0x11
 2438 0612 682B      		or r22,r24
 2439               	.LVL279:
 2440               	.L168:
 2441 0614 61BB      		out 0x11,r22
 2442 0616 00C0      		rjmp .L157
 2443               	.LVL280:
 2444               	.L103:
 459:main.c        **** 					DDRE |= (setValue);
 2445               		.loc 3 459 0
 2446 0618 C534      		cpi r28,lo8(69)
 2447 061a 01F0      		breq .+2
 2448 061c 00C0      		rjmp .L157
 460:main.c        **** 				}
 2449               		.loc 3 460 0
 2450 061e 86B1      		in r24,0x6
 2451 0620 682B      		or r22,r24
 2452               	.LVL281:
 2453               	.L169:
 2454 0622 66B9      		out 0x6,r22
 2455 0624 00C0      		rjmp .L157
 2456               	.LVL282:
 2457               	.L93:
 2458               	.LBE174:
 467:main.c        **** 			char portChar = USART_Receive();			
 2459               		.loc 3 467 0
 2460 0626 8C34      		cpi r24,lo8(76)
 2461 0628 01F4      		brne .L104
 2462               	.LBB175:
 468:main.c        **** 			usart_read_chars();
 2463               		.loc 3 468 0
 2464 062a 00D0      		rcall USART_Receive
 2465               	.LVL283:
 2466 062c C82F      		mov r28,r24
 2467               	.LVL284:
 469:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2468               		.loc 3 469 0
 2469 062e 00D0      		rcall usart_read_chars
 2470               	.LVL285:
 470:main.c        **** 			
 2471               		.loc 3 470 0
 2472 0630 40E1      		ldi r20,lo8(16)
 2473 0632 50E0      		ldi r21,0
 2474 0634 60E0      		ldi r22,0
 2475 0636 70E0      		ldi r23,0
 2476 0638 80E0      		ldi r24,lo8(receivedBuffer)
 2477 063a 90E0      		ldi r25,hi8(receivedBuffer)
 2478 063c 00D0      		rcall strtol
 2479               	.LVL286:
 472:main.c        **** 			if (portChar == 'A') {
 2480               		.loc 3 472 0
 2481 063e 939A      		sbi 0x12,3
 473:main.c        **** 				PORTA &= ~(setValue);
 2482               		.loc 3 473 0
 2483 0640 C134      		cpi r28,lo8(65)
 2484 0642 01F4      		brne .L105
 474:main.c        **** 			}
 2485               		.loc 3 474 0
 2486 0644 8BB3      		in r24,0x1b
 2487 0646 6095      		com r22
 2488               	.LVL287:
 2489 0648 6823      		and r22,r24
 2490               	.LVL288:
 2491 064a 00C0      		rjmp .L170
 2492               	.LVL289:
 2493               	.L105:
 476:main.c        **** 				PORTB &= ~(setValue);
 2494               		.loc 3 476 0
 2495 064c C234      		cpi r28,lo8(66)
 2496 064e 01F4      		brne .L107
 477:main.c        **** 			}
 2497               		.loc 3 477 0
 2498 0650 88B3      		in r24,0x18
 2499 0652 6095      		com r22
 2500               	.LVL290:
 2501 0654 6823      		and r22,r24
 2502               	.LVL291:
 2503 0656 00C0      		rjmp .L173
 2504               	.LVL292:
 2505               	.L107:
 479:main.c        **** 				PORTC &= ~(setValue);
 2506               		.loc 3 479 0
 2507 0658 C334      		cpi r28,lo8(67)
 2508 065a 01F4      		brne .L108
 480:main.c        **** 			}
 2509               		.loc 3 480 0
 2510 065c 85B3      		in r24,0x15
 2511 065e 6095      		com r22
 2512               	.LVL293:
 2513 0660 6823      		and r22,r24
 2514               	.LVL294:
 2515 0662 00C0      		rjmp .L172
 2516               	.LVL295:
 2517               	.L108:
 482:main.c        **** 				PORTD &= ~(setValue);
 2518               		.loc 3 482 0
 2519 0664 C434      		cpi r28,lo8(68)
 2520 0666 01F4      		brne .L109
 483:main.c        **** 			}
 2521               		.loc 3 483 0
 2522 0668 82B3      		in r24,0x12
 2523 066a 6095      		com r22
 2524               	.LVL296:
 2525 066c 6823      		and r22,r24
 2526               	.LVL297:
 2527 066e 00C0      		rjmp .L171
 2528               	.LVL298:
 2529               	.L109:
 485:main.c        **** 				PORTE &= ~(setValue);
 2530               		.loc 3 485 0
 2531 0670 C534      		cpi r28,lo8(69)
 2532 0672 01F0      		breq .+2
 2533 0674 00C0      		rjmp .L157
 486:main.c        **** 			}
 2534               		.loc 3 486 0
 2535 0676 87B1      		in r24,0x7
 2536 0678 6095      		com r22
 2537               	.LVL299:
 2538 067a 6823      		and r22,r24
 2539               	.LVL300:
 2540 067c 00C0      		rjmp .L164
 2541               	.LVL301:
 2542               	.L104:
 2543               	.LBE175:
 492:main.c        **** 			char portChar = USART_Receive();			
 2544               		.loc 3 492 0
 2545 067e 8834      		cpi r24,lo8(72)
 2546 0680 01F4      		brne .L110
 2547               	.LBB176:
 493:main.c        **** 			usart_read_chars();
 2548               		.loc 3 493 0
 2549 0682 00D0      		rcall USART_Receive
 2550               	.LVL302:
 2551 0684 C82F      		mov r28,r24
 2552               	.LVL303:
 494:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 2553               		.loc 3 494 0
 2554 0686 00D0      		rcall usart_read_chars
 2555               	.LVL304:
 495:main.c        **** 			
 2556               		.loc 3 495 0
 2557 0688 40E1      		ldi r20,lo8(16)
 2558 068a 50E0      		ldi r21,0
 2559 068c 60E0      		ldi r22,0
 2560 068e 70E0      		ldi r23,0
 2561 0690 80E0      		ldi r24,lo8(receivedBuffer)
 2562 0692 90E0      		ldi r25,hi8(receivedBuffer)
 2563 0694 00D0      		rcall strtol
 2564               	.LVL305:
 497:main.c        **** 			if (portChar == 'A') {
 2565               		.loc 3 497 0
 2566 0696 939A      		sbi 0x12,3
 498:main.c        **** 				PORTA |= (setValue);
 2567               		.loc 3 498 0
 2568 0698 C134      		cpi r28,lo8(65)
 2569 069a 01F4      		brne .L111
 499:main.c        **** 			}
 2570               		.loc 3 499 0
 2571 069c 8BB3      		in r24,0x1b
 2572 069e 682B      		or r22,r24
 2573               	.LVL306:
 2574               	.L170:
 2575 06a0 6BBB      		out 0x1b,r22
 2576 06a2 00C0      		rjmp .L157
 2577               	.LVL307:
 2578               	.L111:
 501:main.c        **** 				PORTB |= (setValue);
 2579               		.loc 3 501 0
 2580 06a4 C234      		cpi r28,lo8(66)
 2581 06a6 01F4      		brne .L113
 502:main.c        **** 			}
 2582               		.loc 3 502 0
 2583 06a8 88B3      		in r24,0x18
 2584 06aa 682B      		or r22,r24
 2585               	.LVL308:
 2586               	.L173:
 2587 06ac 68BB      		out 0x18,r22
 2588 06ae 00C0      		rjmp .L157
 2589               	.LVL309:
 2590               	.L113:
 504:main.c        **** 				PORTC |= (setValue);
 2591               		.loc 3 504 0
 2592 06b0 C334      		cpi r28,lo8(67)
 2593 06b2 01F4      		brne .L114
 505:main.c        **** 			}
 2594               		.loc 3 505 0
 2595 06b4 85B3      		in r24,0x15
 2596 06b6 682B      		or r22,r24
 2597               	.LVL310:
 2598               	.L172:
 2599 06b8 65BB      		out 0x15,r22
 2600 06ba 00C0      		rjmp .L157
 2601               	.LVL311:
 2602               	.L114:
 507:main.c        **** 				PORTD |= (setValue);
 2603               		.loc 3 507 0
 2604 06bc C434      		cpi r28,lo8(68)
 2605 06be 01F4      		brne .L115
 508:main.c        **** 			}
 2606               		.loc 3 508 0
 2607 06c0 82B3      		in r24,0x12
 2608 06c2 682B      		or r22,r24
 2609               	.LVL312:
 2610               	.L171:
 2611 06c4 62BB      		out 0x12,r22
 2612 06c6 00C0      		rjmp .L157
 2613               	.LVL313:
 2614               	.L115:
 510:main.c        **** 				PORTE |= (setValue);
 2615               		.loc 3 510 0
 2616 06c8 C534      		cpi r28,lo8(69)
 2617 06ca 01F0      		breq .+2
 2618 06cc 00C0      		rjmp .L157
 511:main.c        **** 			}
 2619               		.loc 3 511 0
 2620 06ce 87B1      		in r24,0x7
 2621 06d0 682B      		or r22,r24
 2622               	.LVL314:
 2623               	.L164:
 2624 06d2 67B9      		out 0x7,r22
 2625 06d4 00C0      		rjmp .L157
 2626               	.L110:
 2627               	.LBE176:
 517:main.c        **** 			char portChar = USART_Receive();			
 2628               		.loc 3 517 0
 2629 06d6 8434      		cpi r24,lo8(68)
 2630 06d8 01F4      		brne .L116
 2631               	.LBB177:
 518:main.c        **** 			
 2632               		.loc 3 518 0
 2633 06da 00D0      		rcall USART_Receive
 2634               	.LVL315:
 520:main.c        **** 			if (portChar == 'A') {
 2635               		.loc 3 520 0
 2636 06dc 939A      		sbi 0x12,3
 521:main.c        **** 				USART_Transmit(PINA);
 2637               		.loc 3 521 0
 2638 06de 8134      		cpi r24,lo8(65)
 2639 06e0 01F4      		brne .L117
 522:main.c        **** 			}
 2640               		.loc 3 522 0
 2641 06e2 89B3      		in r24,0x19
 2642               	.LVL316:
 2643 06e4 00C0      		rjmp .L163
 2644               	.LVL317:
 2645               	.L117:
 524:main.c        **** 				USART_Transmit(PINB);
 2646               		.loc 3 524 0
 2647 06e6 8234      		cpi r24,lo8(66)
 2648 06e8 01F4      		brne .L119
 525:main.c        **** 			}
 2649               		.loc 3 525 0
 2650 06ea 86B3      		in r24,0x16
 2651               	.LVL318:
 2652 06ec 00C0      		rjmp .L163
 2653               	.LVL319:
 2654               	.L119:
 527:main.c        **** 				USART_Transmit(PINC);
 2655               		.loc 3 527 0
 2656 06ee 8334      		cpi r24,lo8(67)
 2657 06f0 01F4      		brne .L120
 528:main.c        **** 			}
 2658               		.loc 3 528 0
 2659 06f2 83B3      		in r24,0x13
 2660               	.LVL320:
 2661 06f4 00C0      		rjmp .L163
 2662               	.LVL321:
 2663               	.L120:
 530:main.c        **** 				USART_Transmit(PIND);
 2664               		.loc 3 530 0
 2665 06f6 8434      		cpi r24,lo8(68)
 2666 06f8 01F4      		brne .L121
 531:main.c        **** 			}
 2667               		.loc 3 531 0
 2668 06fa 80B3      		in r24,0x10
 2669               	.LVL322:
 2670 06fc 00C0      		rjmp .L163
 2671               	.LVL323:
 2672               	.L121:
 533:main.c        **** 				USART_Transmit(PINE);
 2673               		.loc 3 533 0
 2674 06fe 8534      		cpi r24,lo8(69)
 2675 0700 01F0      		breq .+2
 2676 0702 00C0      		rjmp .L157
 534:main.c        **** 			}
 2677               		.loc 3 534 0
 2678 0704 85B1      		in r24,0x5
 2679               	.LVL324:
 2680 0706 00C0      		rjmp .L163
 2681               	.L116:
 2682               	.LBE177:
 540:main.c        **** 			char commonChar = USART_Receive();
 2683               		.loc 3 540 0
 2684 0708 8D34      		cpi r24,lo8(77)
 2685 070a 01F4      		brne .L122
 2686               	.LBB178:
 541:main.c        **** 			if (commonChar == '1') {
 2687               		.loc 3 541 0
 2688 070c 00D0      		rcall USART_Receive
 2689               	.LVL325:
 542:main.c        **** 				resetCommonLines = 1;
 2690               		.loc 3 542 0
 2691 070e 8133      		cpi r24,lo8(49)
 2692 0710 01F4      		brne .L175
 2693               		.loc 3 543 0
 2694 0712 5524      		clr r5
 2695 0714 5394      		inc r5
 2696 0716 00C0      		rjmp .L155
 2697               	.L175:
 544:main.c        **** 			}
 545:main.c        **** 			else if (commonChar == '0') {
 2698               		.loc 3 545 0
 2699 0718 8033      		cpi r24,lo8(48)
 2700 071a 01F0      		breq .+2
 2701 071c 00C0      		rjmp .L45
 546:main.c        **** 				resetCommonLines = 0;
 2702               		.loc 3 546 0
 2703 071e 512C      		mov r5,__zero_reg__
 2704 0720 00C0      		rjmp .L46
 2705               	.LVL326:
 2706               	.L122:
 2707               	.LBE178:
 547:main.c        **** 			}
 548:main.c        **** 		}
 549:main.c        **** 		
 550:main.c        **** 		// Send back the PCB version number
 551:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 2708               		.loc 3 551 0
 2709 0722 8836      		cpi r24,lo8(104)
 2710 0724 01F4      		brne .L123
 552:main.c        **** 			USART_Transmit(PCB_VERSION);
 2711               		.loc 3 552 0
 2712 0726 84E6      		ldi r24,lo8(100)
 2713 0728 00C0      		rjmp .L158
 2714               	.L123:
 553:main.c        **** 		}
 554:main.c        **** 		
 555:main.c        **** 		// Send back the firmware version number
 556:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 2715               		.loc 3 556 0
 2716 072a 8635      		cpi r24,lo8(86)
 2717 072c 01F4      		brne .L124
 557:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 2718               		.loc 3 557 0
 2719 072e 83E1      		ldi r24,lo8(19)
 2720               	.LVL327:
 2721               	.L158:
 2722 0730 00D0      		rcall USART_Transmit
 2723               	.LVL328:
 2724 0732 00C0      		rjmp .L45
 2725               	.LVL329:
 2726               	.L124:
 558:main.c        **** 		}
 559:main.c        **** 		
 560:main.c        **** 		// Send back 32KB for a speed test
 561:main.c        **** 		else if (receivedChar == FAST_READ_CHECK) {
 2727               		.loc 3 561 0
 2728 0734 8B32      		cpi r24,lo8(43)
 2729 0736 01F4      		brne .L125
 2730 0738 C0E0      		ldi r28,0
 2731 073a D0E4      		ldi r29,lo8(64)
 2732               	.L126:
 2733               	.LVL330:
 2734               	.LBB179:
 562:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 563:main.c        **** 				USART_Transmit('1');
 2735               		.loc 3 563 0 discriminator 3
 2736 073c 81E3      		ldi r24,lo8(49)
 2737 073e 00D0      		rcall USART_Transmit
 2738               	.LVL331:
 564:main.c        **** 				USART_Transmit('0');
 2739               		.loc 3 564 0 discriminator 3
 2740 0740 80E3      		ldi r24,lo8(48)
 2741 0742 00D0      		rcall USART_Transmit
 2742               	.LVL332:
 2743 0744 2197      		sbiw r28,1
 2744               	.LVL333:
 562:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2745               		.loc 3 562 0 discriminator 3
 2746 0746 01F4      		brne .L126
 2747 0748 00C0      		rjmp .L45
 2748               	.LVL334:
 2749               	.L125:
 2750               	.LBE179:
 565:main.c        **** 			}
 566:main.c        **** 		}
 567:main.c        **** 		
 568:main.c        **** 		// Reset the AVR if it matches the number
 569:main.c        **** 		else if (receivedChar == RESET_AVR) {
 2751               		.loc 3 569 0
 2752 074a 8A32      		cpi r24,lo8(42)
 2753 074c 01F0      		breq .+2
 2754 074e 00C0      		rjmp .L45
 2755               	.LBB180:
 570:main.c        **** 			usart_read_chars();
 2756               		.loc 3 570 0
 2757 0750 00D0      		rcall usart_read_chars
 2758               	.LVL335:
 571:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 2759               		.loc 3 571 0
 2760 0752 40E1      		ldi r20,lo8(16)
 2761 0754 50E0      		ldi r21,0
 2762 0756 60E0      		ldi r22,0
 2763 0758 70E0      		ldi r23,0
 2764 075a 80E0      		ldi r24,lo8(receivedBuffer)
 2765 075c 90E0      		ldi r25,hi8(receivedBuffer)
 2766 075e 00D0      		rcall strtol
 2767               	.LVL336:
 572:main.c        **** 			if (resetValue == RESET_VALUE) {
 2768               		.loc 3 572 0
 2769 0760 613E      		cpi r22,-31
 2770 0762 754E      		sbci r23,-27
 2771 0764 8740      		sbci r24,7
 2772 0766 9105      		cpc r25,__zero_reg__
 2773 0768 01F0      		breq .+2
 2774 076a 00C0      		rjmp .L45
 573:main.c        **** 				// Clear watchdog flag
 574:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 2775               		.loc 3 574 0
 2776 076c 84B7      		in r24,0x34
 2777 076e 877F      		andi r24,lo8(-9)
 2778 0770 84BF      		out 0x34,r24
 575:main.c        **** 				
 576:main.c        **** 				// Start timed sequence
 577:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 2779               		.loc 3 577 0
 2780 0772 F8E1      		ldi r31,lo8(24)
 2781 0774 F1BD      		out 0x21,r31
 578:main.c        **** 				
 579:main.c        **** 				// Reset in 250 ms
 580:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 2782               		.loc 3 580 0
 2783 0776 2CE0      		ldi r18,lo8(12)
 2784 0778 21BD      		out 0x21,r18
 2785               	.LVL337:
 2786               	.LBB122:
 2787               	.LBB121:
 2788               		.loc 4 105 0
 2789 077a C101      		movw r24,r2
 2790               	/* #APP */
 2791               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 2792 077c 0197      		1: sbiw r24,1
 2793 077e 01F4      		brne 1b
 2794               	 ;  0 "" 2
 2795               	.LVL338:
 2796               	/* #NOAPP */
 2797 0780 00C0      		rjmp .L45
 2798               	.LBE121:
 2799               	.LBE122:
 2800               	.LBE180:
 2801               		.cfi_endproc
 2802               	.LFE30:
 2804               		.text
 2805               	.global	__vector_6
 2807               	__vector_6:
 2808               	.LFB31:
 581:main.c        **** 				
 582:main.c        **** 				// Wait for reset
 583:main.c        **** 				_delay_loop_2(65535);
 584:main.c        **** 			}
 585:main.c        **** 		}
 586:main.c        **** 	}
 587:main.c        **** }
 588:main.c        **** 
 589:main.c        **** // Timeout after ~500ms which also blinks the LED
 590:main.c        **** ISR(TIMER1_OVF_vect) {
 2809               		.loc 3 590 0
 2810               		.cfi_startproc
 2811 0338 1F92      		push r1
 2812               	.LCFI20:
 2813               		.cfi_def_cfa_offset 3
 2814               		.cfi_offset 1, -2
 2815 033a 0F92      		push r0
 2816               	.LCFI21:
 2817               		.cfi_def_cfa_offset 4
 2818               		.cfi_offset 0, -3
 2819 033c 0FB6      		in r0,__SREG__
 2820 033e 0F92      		push r0
 2821 0340 1124      		clr __zero_reg__
 2822 0342 8F93      		push r24
 2823               	.LCFI22:
 2824               		.cfi_def_cfa_offset 5
 2825               		.cfi_offset 24, -4
 2826 0344 9F93      		push r25
 2827               	.LCFI23:
 2828               		.cfi_def_cfa_offset 6
 2829               		.cfi_offset 25, -5
 2830               	/* prologue: Signal */
 2831               	/* frame size = 0 */
 2832               	/* stack size = 5 */
 2833               	.L__stack_usage = 5
 591:main.c        **** 	PORTD ^= (1<<ACTIVITY_LED);
 2834               		.loc 3 591 0
 2835 0346 92B3      		in r25,0x12
 2836 0348 88E0      		ldi r24,lo8(8)
 2837 034a 8927      		eor r24,r25
 2838 034c 82BB      		out 0x12,r24
 592:main.c        **** 	writingTimedout = 1;
 2839               		.loc 3 592 0
 2840 034e 81E0      		ldi r24,lo8(1)
 2841 0350 8093 0000 		sts writingTimedout,r24
 2842               	/* epilogue start */
 593:main.c        **** }...
 2843               		.loc 3 593 0
 2844 0354 9F91      		pop r25
 2845 0356 8F91      		pop r24
 2846 0358 0F90      		pop r0
 2847 035a 0FBE      		out __SREG__,r0
 2848 035c 0F90      		pop r0
 2849 035e 1F90      		pop r1
 2850 0360 1895      		reti
 2851               		.cfi_endproc
 2852               	.LFE31:
 2854               	.global	cartMode
 2855               		.data
 2858               	cartMode:
 2859 0000 01        		.byte	1
 2860               	.global	writingTimedout
 2861               		.section .bss
 2864               	writingTimedout:
 2865 0000 00        		.zero	1
 2866               	.global	lastBankAccessed
 2869               	lastBankAccessed:
 2870 0001 00        		.zero	1
 2871               	.global	flashBank1CommandWrites
 2874               	flashBank1CommandWrites:
 2875 0002 00        		.zero	1
 2876               		.comm	flashWriteCycle,12,1
 2877               		.comm	flashWriteWePin,1,1
 2878               		.comm	receivedChar,1,1
 2879               		.comm	receivedBuffer,256,1
 2880               		.text
 2881               	.Letext0:
 2882               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 2883               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:274    .text:00000086 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:343    .text:000000b4 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:391    .text:000000ca gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:494    .text:00000108 gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:2864   .bss:00000000 writingTimedout
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:598    .text:00000172 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:2874   .bss:00000002 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:2869   .bss:00000001 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:729    .text:00000200 gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:903    .text:0000029e start_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:926    .text:000002ae stop_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:949    .text:000002bc check_if_timed_out
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:981    .text:000002ce setup
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:1091   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:2858   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccvD8jEa.s:2807   .text:00000338 __vector_6

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
