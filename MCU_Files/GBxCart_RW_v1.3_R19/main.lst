   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	USART_Receive
  12               	USART_Receive:
  13               	.LFB12:
  14               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  GBxCart RW
   3:setup.c       ****  PCB version: 1.3
   4:setup.c       ****  Firmware version: R19
   5:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:setup.c       ****  Created: 7/11/2016
   7:setup.c       ****  Last Modified: 20/08/2020
   8:setup.c       ****  
   9:setup.c       ****  */
  10:setup.c       ****  
  11:setup.c       **** #ifndef cbi
  12:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  13:setup.c       **** #endif
  14:setup.c       **** #ifndef sbi
  15:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  16:setup.c       **** #endif
  17:setup.c       **** 
  18:setup.c       **** #ifndef NULL
  19:setup.c       **** #define NULL ((void *)0)
  20:setup.c       **** #endif
  21:setup.c       **** 
  22:setup.c       **** #define LOW 0
  23:setup.c       **** #define HIGH 1
  24:setup.c       **** #define false 0
  25:setup.c       **** #define true 1
  26:setup.c       **** 
  27:setup.c       **** #define VOLTAGE_SELECT PD2
  28:setup.c       **** #define ACTIVITY_LED PD3
  29:setup.c       **** #define LED_5V PD7
  30:setup.c       **** #define LED_3V PE0
  31:setup.c       **** 
  32:setup.c       **** #define WR_PIN PD6
  33:setup.c       **** #define RD_PIN PD5
  34:setup.c       **** #define CS_MREQ_PIN PD4
  35:setup.c       **** #define CS2_PIN PE2
  36:setup.c       **** #define AUDIO_PIN PE1
  37:setup.c       **** 
  38:setup.c       **** #define wrPin_high	PORTD |= (1<<WR_PIN);
  39:setup.c       **** #define wrPin_low		PORTD &= ~(1<<WR_PIN);
  40:setup.c       **** #define rdPin_high	PORTD |= (1<<RD_PIN);
  41:setup.c       **** #define rdPin_low		PORTD &= ~(1<<RD_PIN);
  42:setup.c       **** #define cs_mreqPin_high		PORTD |= (1<<CS_MREQ_PIN);
  43:setup.c       **** #define cs_mreqPin_low		PORTD &= ~(1<<CS_MREQ_PIN);
  44:setup.c       **** #define cs2Pin_high		PORTE |= (1<<CS2_PIN);
  45:setup.c       **** #define cs2Pin_low		PORTE &= ~(1<<CS2_PIN);
  46:setup.c       **** #define audioPin_high	PORTE |= (1<<AUDIO_PIN);
  47:setup.c       **** #define audioPin_low		PORTE &= ~(1<<AUDIO_PIN);
  48:setup.c       **** 
  49:setup.c       **** #define GB_MODE 1
  50:setup.c       **** #define GBA_MODE 2
  51:setup.c       **** 
  52:setup.c       **** // GB/GBC
  53:setup.c       **** #define PORT_ADDR7_0 PORTB
  54:setup.c       **** #define PORT_ADDR15_8 PORTA
  55:setup.c       **** #define PORT_DATA7_0 PORTC
  56:setup.c       **** 
  57:setup.c       **** #define DDR_ADDR7_0 DDRB
  58:setup.c       **** #define DDR_ADDR15_8 DDRA
  59:setup.c       **** #define DDR_DATA7_0 DDRC
  60:setup.c       **** 
  61:setup.c       **** #define PIN_ADDR7_0 PINB
  62:setup.c       **** #define PIN_ADDR15_8 PINA
  63:setup.c       **** #define PIN_DATA7_0 PINC
  64:setup.c       **** 
  65:setup.c       **** #define BANK_WRITE 0
  66:setup.c       **** #define MEMORY_WRITE 1
  67:setup.c       **** 
  68:setup.c       **** // GBA
  69:setup.c       **** #define EEPROM_WRITE 1
  70:setup.c       **** #define EEPROM_READ 0
  71:setup.c       **** 
  72:setup.c       **** #define EEPROM_NONE 0
  73:setup.c       **** #define EEPROM_4KBIT 1
  74:setup.c       **** #define EEPROM_64KBIT 2
  75:setup.c       **** 
  76:setup.c       **** #define AD0 PB0
  77:setup.c       **** #define ad0Pin_high		PORTB |= (1<<AD0);
  78:setup.c       **** #define ad0Pin_low		PORTB &= ~(1<<AD0);
  79:setup.c       **** 
  80:setup.c       **** #define A23 PC7
  81:setup.c       **** #define a23Pin_high		PORTC |= (1<<A23);
  82:setup.c       **** #define a23Pin_low		PORTC &= ~(1<<A23);
  83:setup.c       **** 
  84:setup.c       **** #define GBA_DDR_ROM_ADDR7_0 DDRB
  85:setup.c       **** #define GBA_DDR_ROM_ADDR15_8 DDRA
  86:setup.c       **** #define GBA_DDR_ROM_ADDR23_16 DDRC
  87:setup.c       **** #define GBA_DDR_ROM_DATA7_0 DDRB
  88:setup.c       **** #define GBA_DDR_ROM_DATA15_8 DDRA
  89:setup.c       **** #define GBA_DDR_RAM_DATA7_0 DDRC
  90:setup.c       **** #define GBA_DDR_EEPROM_DATA7_0 DDRB
  91:setup.c       **** 
  92:setup.c       **** #define GBA_PORT_ROM_ADDR7_0 PORTB
  93:setup.c       **** #define GBA_PORT_ROM_ADDR15_8 PORTA
  94:setup.c       **** #define GBA_PORT_ROM_ADDR23_16 PORTC
  95:setup.c       **** #define GBA_PORT_ROM_DATA7_0 PORTB
  96:setup.c       **** #define GBA_PORT_ROM_DATA15_8 PORTA
  97:setup.c       **** #define GBA_PORT_RAM_DATA7_0 PORTC
  98:setup.c       **** #define GBA_PORT_EEPROM_DATA7_0 PORTB
  99:setup.c       **** 
 100:setup.c       **** #define GBA_PIN_ROM_DATA7_0 PINB
 101:setup.c       **** #define GBA_PIN_ROM_DATA15_8 PINA
 102:setup.c       **** #define GBA_PIN_RAM_DATA7_0 PINC
 103:setup.c       **** #define GBA_PIN_EEPROM_DATA7_0 PINB
 104:setup.c       **** 
 105:setup.c       **** // GB/GBC commands
 106:setup.c       **** #define SET_START_ADDRESS 'A'
 107:setup.c       **** #define READ_ROM_RAM 'R'
 108:setup.c       **** #define READ_ROM_4000H 'Q'
 109:setup.c       **** #define WRITE_RAM 'W'
 110:setup.c       **** #define SET_BANK 'B'
 111:setup.c       **** #define GB_CART_MODE 'G'
 112:setup.c       **** 
 113:setup.c       **** // GBA commands
 114:setup.c       **** #define GBA_READ_ROM 'r'
 115:setup.c       **** #define GBA_READ_ROM_256BYTE 'j'
 116:setup.c       **** #define GBA_READ_ROM_8000H 'Z'
 117:setup.c       **** #define GBA_READ_SRAM 'm'
 118:setup.c       **** #define GBA_WRITE_SRAM 'w'
 119:setup.c       **** #define GBA_WRITE_ONE_BYTE_SRAM 'o'
 120:setup.c       **** #define GBA_CART_MODE 'g'
 121:setup.c       **** 
 122:setup.c       **** #define GBA_FLASH_READ_ID 'i'
 123:setup.c       **** #define GBA_FLASH_SET_BANK 'k'
 124:setup.c       **** #define GBA_FLASH_4K_SECTOR_ERASE 's'
 125:setup.c       **** #define GBA_FLASH_WRITE_BYTE 'b'
 126:setup.c       **** #define GBA_FLASH_WRITE_ATMEL 'a'
 127:setup.c       **** 
 128:setup.c       **** #define GBA_SET_EEPROM_SIZE 'S'
 129:setup.c       **** #define GBA_READ_EEPROM 'e'
 130:setup.c       **** #define GBA_WRITE_EEPROM 'p'
 131:setup.c       **** 
 132:setup.c       **** // Flash Cart commands
 133:setup.c       **** #define GB_FLASH_WE_PIN 'P'
 134:setup.c       **** 	#define WE_AS_AUDIO_PIN 'A'
 135:setup.c       **** 	#define WE_AS_WR_PIN 'W'
 136:setup.c       **** 
 137:setup.c       **** #define GB_FLASH_PROGRAM_METHOD 'E'
 138:setup.c       **** 	#define GB_FLASH_PROGRAM_555 0
 139:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA 1
 140:setup.c       **** 	#define GB_FLASH_PROGRAM_555_BIT01_SWAPPED 2
 141:setup.c       **** 	#define GB_FLASH_PROGRAM_AAA_BIT01_SWAPPED 3
 142:setup.c       **** 	#define GB_FLASH_PROGRAM_5555 4
 143:setup.c       **** 
 144:setup.c       **** #define GB_FLASH_WRITE_BYTE 'F'
 145:setup.c       **** #define GB_FLASH_WRITE_BUFFERED_32BYTE 'Y'
 146:setup.c       **** #define GB_FLASH_WRITE_64BYTE 'T'
 147:setup.c       **** #define GB_FLASH_WRITE_64BYTE_PULSE_RESET 'J'
 148:setup.c       **** #define GB_FLASH_WRITE_256BYTE 'X'
 149:setup.c       **** #define GB_FLASH_WRITE_NP_128BYTE 'Z'
 150:setup.c       **** #define GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE 'y'
 151:setup.c       **** 
 152:setup.c       **** #define GB_FLASH_BANK_1_COMMAND_WRITES 'N'
 153:setup.c       **** 
 154:setup.c       **** #define GBA_FLASH_CART_WRITE_BYTE 'n'
 155:setup.c       **** #define GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 'q'
 156:setup.c       **** #define GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1 't'
 157:setup.c       **** #define GBA_FLASH_WRITE_256BYTE 'f'
 158:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE 'l'
 159:setup.c       **** #define GBA_FLASH_WRITE_INTEL_64BYTE_WORD 'u'
 160:setup.c       **** #define GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE 'v'
 161:setup.c       **** #define GBA_FLASH_WRITE_SHARP_64BYTE 'x'
 162:setup.c       **** 
 163:setup.c       **** #define D0D1_NOT_SWAPPED 0
 164:setup.c       **** #define D0D1_SWAPPED 1
 165:setup.c       **** 
 166:setup.c       **** // General commands
 167:setup.c       **** #define SEND_ACK '1'
 168:setup.c       **** #define CART_MODE 'C'
 169:setup.c       **** #define SET_INPUT 'I'
 170:setup.c       **** #define SET_OUTPUT 'O'
 171:setup.c       **** #define SET_OUTPUT_LOW 'L'
 172:setup.c       **** #define SET_OUTPUT_HIGH 'H'
 173:setup.c       **** #define READ_INPUT 'D'
 174:setup.c       **** #define RESET_COMMON_LINES 'M'
 175:setup.c       **** #define READ_FIRMWARE_VERSION 'V'
 176:setup.c       **** #define READ_PCB_VERSION 'h'
 177:setup.c       **** #define FAST_READ_CHECK '+'
 178:setup.c       **** #define VOLTAGE_3_3V '3'
 179:setup.c       **** #define VOLTAGE_5V '5'
 180:setup.c       **** 
 181:setup.c       **** #define RESET_AVR '*'
 182:setup.c       **** #define RESET_VALUE 0x7E5E1
 183:setup.c       **** 
 184:setup.c       **** 
 185:setup.c       **** char receivedBuffer[256];
 186:setup.c       **** char receivedChar;
 187:setup.c       **** uint8_t eepromBuffer[8];
 188:setup.c       **** uint8_t flashChipIdBuffer[2];
 189:setup.c       **** 
 190:setup.c       **** char flashWriteWePin;
 191:setup.c       **** uint16_t flashWriteCycle[3][2];
 192:setup.c       **** uint8_t flashBank1CommandWrites = 0;
 193:setup.c       **** uint8_t lastBankAccessed = 0;
 194:setup.c       **** volatile uint8_t writingTimedout = 0;
 195:setup.c       **** 
 196:setup.c       **** uint8_t cartMode = GBA_MODE;
 197:setup.c       **** 
 198:setup.c       **** // Receive USART data
 199:setup.c       **** uint8_t USART_Receive(void) {
  15               		.loc 1 199 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  21               	.L2:
 200:setup.c       **** 	while ( !(UCSRA & (1<<RXC)) ); // Wait for data to be received
  22               		.loc 1 200 0 discriminator 1
  23 0000 5F9B      		sbis 0xb,7
  24 0002 00C0      		rjmp .L2
 201:setup.c       **** 	return UDR; // Get and return received data from buffer
  25               		.loc 1 201 0
  26 0004 8CB1      		in r24,0xc
 202:setup.c       **** }
  27               		.loc 1 202 0
  28 0006 0895      		ret
  29               		.cfi_endproc
  30               	.LFE12:
  32               	.global	USART_Transmit
  34               	USART_Transmit:
  35               	.LFB13:
 203:setup.c       **** 
 204:setup.c       **** // Transmit USART data
 205:setup.c       **** void USART_Transmit(unsigned char data) {
  36               		.loc 1 205 0
  37               		.cfi_startproc
  38               	/* prologue: function */
  39               	/* frame size = 0 */
  40               	/* stack size = 0 */
  41               	.L__stack_usage = 0
  42               	.LVL0:
  43               	.L6:
 206:setup.c       **** 	while ( !( UCSRA & (1<<UDRE)) ); // Wait for empty transmit buffer
  44               		.loc 1 206 0 discriminator 1
  45 0008 5D9B      		sbis 0xb,5
  46 000a 00C0      		rjmp .L6
 207:setup.c       **** 	UDR = data;
  47               		.loc 1 207 0
  48 000c 8CB9      		out 0xc,r24
  49 000e 0895      		ret
  50               		.cfi_endproc
  51               	.LFE13:
  53               	.global	usart_read_bytes
  55               	usart_read_bytes:
  56               	.LFB14:
 208:setup.c       **** }
 209:setup.c       **** 
 210:setup.c       **** // Read 1-256 bytes from the USART 
 211:setup.c       **** void usart_read_bytes(int count) {
  57               		.loc 1 211 0
  58               		.cfi_startproc
  59               	.LVL1:
  60 0010 0F93      		push r16
  61               	.LCFI0:
  62               		.cfi_def_cfa_offset 3
  63               		.cfi_offset 16, -2
  64 0012 1F93      		push r17
  65               	.LCFI1:
  66               		.cfi_def_cfa_offset 4
  67               		.cfi_offset 17, -3
  68 0014 CF93      		push r28
  69               	.LCFI2:
  70               		.cfi_def_cfa_offset 5
  71               		.cfi_offset 28, -4
  72 0016 DF93      		push r29
  73               	.LCFI3:
  74               		.cfi_def_cfa_offset 6
  75               		.cfi_offset 29, -5
  76               	/* prologue: function */
  77               	/* frame size = 0 */
  78               	/* stack size = 4 */
  79               	.L__stack_usage = 4
  80 0018 8C01      		movw r16,r24
  81               	.LVL2:
  82               	.LBB147:
 212:setup.c       **** 	for (int x = 0; x < count; x++) {
  83               		.loc 1 212 0
  84 001a C0E0      		ldi r28,lo8(receivedBuffer)
  85 001c D0E0      		ldi r29,hi8(receivedBuffer)
  86               	.LVL3:
  87               	.L10:
  88               		.loc 1 212 0 is_stmt 0 discriminator 1
  89 001e CE01      		movw r24,r28
  90 0020 8050      		subi r24,lo8(receivedBuffer)
  91 0022 9040      		sbci r25,hi8(receivedBuffer)
  92               	.LVL4:
  93 0024 8017      		cp r24,r16
  94 0026 9107      		cpc r25,r17
  95 0028 04F4      		brge .L12
 213:setup.c       **** 		receivedBuffer[x] = USART_Receive();
  96               		.loc 1 213 0 is_stmt 1 discriminator 3
  97 002a 00D0      		rcall USART_Receive
  98               	.LVL5:
  99 002c 8993      		st Y+,r24
 100               	.LVL6:
 101 002e 00C0      		rjmp .L10
 102               	.LVL7:
 103               	.L12:
 104               	/* epilogue start */
 105               	.LBE147:
 214:setup.c       **** 	}
 215:setup.c       **** }
 106               		.loc 1 215 0
 107 0030 DF91      		pop r29
 108 0032 CF91      		pop r28
 109 0034 1F91      		pop r17
 110 0036 0F91      		pop r16
 111               	.LVL8:
 112 0038 0895      		ret
 113               		.cfi_endproc
 114               	.LFE14:
 116               	.global	usart_read_chars
 118               	usart_read_chars:
 119               	.LFB15:
 216:setup.c       **** 
 217:setup.c       **** // Read the USART until a 0 (string terminator byte) is received
 218:setup.c       **** void usart_read_chars(void) {
 120               		.loc 1 218 0
 121               		.cfi_startproc
 122 003a CF93      		push r28
 123               	.LCFI4:
 124               		.cfi_def_cfa_offset 3
 125               		.cfi_offset 28, -2
 126 003c DF93      		push r29
 127               	.LCFI5:
 128               		.cfi_def_cfa_offset 4
 129               		.cfi_offset 29, -3
 130               	/* prologue: function */
 131               	/* frame size = 0 */
 132               	/* stack size = 2 */
 133               	.L__stack_usage = 2
 134               	.LVL9:
 135 003e C0E0      		ldi r28,lo8(receivedBuffer)
 136 0040 D0E0      		ldi r29,hi8(receivedBuffer)
 137               	.LVL10:
 138               	.L14:
 219:setup.c       **** 	int x = 0;
 220:setup.c       **** 	while (1) {
 221:setup.c       **** 		receivedBuffer[x] = USART_Receive();
 139               		.loc 1 221 0
 140 0042 00D0      		rcall USART_Receive
 141               	.LVL11:
 142 0044 8993      		st Y+,r24
 143               	.LVL12:
 222:setup.c       **** 		if (receivedBuffer[x] == 0) {
 144               		.loc 1 222 0
 145 0046 8111      		cpse r24,__zero_reg__
 146 0048 00C0      		rjmp .L14
 147               	/* epilogue start */
 223:setup.c       **** 			break;
 224:setup.c       **** 		}
 225:setup.c       **** 		x++;
 226:setup.c       **** 	}
 227:setup.c       **** }
 148               		.loc 1 227 0
 149 004a DF91      		pop r29
 150 004c CF91      		pop r28
 151               	.LVL13:
 152 004e 0895      		ret
 153               		.cfi_endproc
 154               	.LFE15:
 156               	.global	rd_wr_csmreq_cs2_reset
 158               	rd_wr_csmreq_cs2_reset:
 159               	.LFB16:
 228:setup.c       **** 
 229:setup.c       **** // Turn RD, WR, CS/MREQ and CS2 to high so they are deselected (reset state)
 230:setup.c       **** void rd_wr_csmreq_cs2_reset(void) {
 160               		.loc 1 230 0
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 231:setup.c       **** 	cs2Pin_high; // CS2 off
 166               		.loc 1 231 0
 167 0050 3A9A      		sbi 0x7,2
 232:setup.c       **** 	cs_mreqPin_high; // CS/MREQ off
 168               		.loc 1 232 0
 169 0052 949A      		sbi 0x12,4
 233:setup.c       **** 	rdPin_high; // RD off
 170               		.loc 1 233 0
 171 0054 959A      		sbi 0x12,5
 234:setup.c       **** 	wrPin_high; // WR off
 172               		.loc 1 234 0
 173 0056 969A      		sbi 0x12,6
 174 0058 0895      		ret
 175               		.cfi_endproc
 176               	.LFE16:
 178               	.global	gb_mode
 180               	gb_mode:
 181               	.LFB17:
 235:setup.c       **** }
 236:setup.c       **** 
 237:setup.c       **** 
 238:setup.c       **** 
 239:setup.c       **** // ****** Gameboy / Gameboy Colour functions ******
 240:setup.c       **** 
 241:setup.c       **** // Set Gameboy mode
 242:setup.c       **** void gb_mode(void) {
 182               		.loc 1 242 0
 183               		.cfi_startproc
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 243:setup.c       **** 	// Set inputs
 244:setup.c       **** 	PORT_DATA7_0 = 0;
 188               		.loc 1 244 0
 189 005a 15BA      		out 0x15,__zero_reg__
 245:setup.c       **** 	DDR_DATA7_0 = 0;
 190               		.loc 1 245 0
 191 005c 14BA      		out 0x14,__zero_reg__
 246:setup.c       **** 	
 247:setup.c       **** 	// Set outputs
 248:setup.c       **** 	PORT_ADDR7_0 = 0;
 192               		.loc 1 248 0
 193 005e 18BA      		out 0x18,__zero_reg__
 249:setup.c       **** 	PORT_ADDR15_8 = 0;
 194               		.loc 1 249 0
 195 0060 1BBA      		out 0x1b,__zero_reg__
 250:setup.c       **** 	DDR_ADDR7_0 = 0xFF;
 196               		.loc 1 250 0
 197 0062 8FEF      		ldi r24,lo8(-1)
 198 0064 87BB      		out 0x17,r24
 251:setup.c       **** 	DDR_ADDR15_8 = 0xFF;
 199               		.loc 1 251 0
 200 0066 8ABB      		out 0x1a,r24
 201 0068 0895      		ret
 202               		.cfi_endproc
 203               	.LFE17:
 205               	.global	set_16bit_address
 207               	set_16bit_address:
 208               	.LFB18:
 252:setup.c       **** }
 253:setup.c       **** 
 254:setup.c       **** // Set the 16 bit address on A15-0
 255:setup.c       **** void set_16bit_address(uint16_t address) {
 209               		.loc 1 255 0
 210               		.cfi_startproc
 211               	.LVL14:
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 256:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 216               		.loc 1 256 0
 217 006a 9BBB      		out 0x1b,r25
 257:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 218               		.loc 1 257 0
 219 006c 88BB      		out 0x18,r24
 220 006e 0895      		ret
 221               		.cfi_endproc
 222               	.LFE18:
 224               	.global	read_8bit_data
 226               	read_8bit_data:
 227               	.LFB19:
 258:setup.c       **** }
 259:setup.c       **** 
 260:setup.c       **** // Set the address and read a byte from the 8 bit data line
 261:setup.c       **** uint8_t read_8bit_data(uint16_t address) {
 228               		.loc 1 261 0
 229               		.cfi_startproc
 230               	.LVL15:
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
 262:setup.c       **** 	set_16bit_address(address);
 235               		.loc 1 262 0
 236 0070 00D0      		rcall set_16bit_address
 237               	.LVL16:
 263:setup.c       **** 	
 264:setup.c       **** 	cs_mreqPin_low;
 238               		.loc 1 264 0
 239 0072 9498      		cbi 0x12,4
 265:setup.c       **** 	rdPin_low;
 240               		.loc 1 265 0
 241 0074 9598      		cbi 0x12,5
 266:setup.c       **** 	
 267:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 1 nops, 2 nops for GB camera)
 242               		.loc 1 267 0
 243               	/* #APP */
 244               	 ;  267 "setup.c" 1
 245 0076 0000      		nop
 246               	 ;  0 "" 2
 268:setup.c       **** 	asm volatile("nop");
 247               		.loc 1 268 0
 248               	 ;  268 "setup.c" 1
 249 0078 0000      		nop
 250               	 ;  0 "" 2
 269:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 251               		.loc 1 269 0
 252               	/* #NOAPP */
 253 007a 83B3      		in r24,0x13
 254               	.LVL17:
 270:setup.c       **** 	
 271:setup.c       **** 	rdPin_high;
 255               		.loc 1 271 0
 256 007c 959A      		sbi 0x12,5
 272:setup.c       **** 	cs_mreqPin_high;
 257               		.loc 1 272 0
 258 007e 949A      		sbi 0x12,4
 273:setup.c       **** 	
 274:setup.c       **** 	return data;
 275:setup.c       **** }
 259               		.loc 1 275 0
 260 0080 0895      		ret
 261               		.cfi_endproc
 262               	.LFE19:
 264               	.global	write_8bit_data
 266               	write_8bit_data:
 267               	.LFB20:
 276:setup.c       **** 
 277:setup.c       **** // Set the address and write a byte to the 8 bit data line and pulse cs/mREQ if writing to RAM
 278:setup.c       **** void write_8bit_data(uint16_t address, uint8_t data, uint8_t type) {
 268               		.loc 1 278 0
 269               		.cfi_startproc
 270               	.LVL18:
 271 0082 CF93      		push r28
 272               	.LCFI6:
 273               		.cfi_def_cfa_offset 3
 274               		.cfi_offset 28, -2
 275 0084 DF93      		push r29
 276               	.LCFI7:
 277               		.cfi_def_cfa_offset 4
 278               		.cfi_offset 29, -3
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 2 */
 282               	.L__stack_usage = 2
 283 0086 D62F      		mov r29,r22
 284 0088 C42F      		mov r28,r20
 279:setup.c       **** 	set_16bit_address(address);
 285               		.loc 1 279 0
 286 008a 00D0      		rcall set_16bit_address
 287               	.LVL19:
 280:setup.c       **** 	
 281:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 288               		.loc 1 281 0
 289 008c 8FEF      		ldi r24,lo8(-1)
 290 008e 84BB      		out 0x14,r24
 282:setup.c       **** 	PORT_DATA7_0 = data; // Set data
 291               		.loc 1 282 0
 292 0090 D5BB      		out 0x15,r29
 283:setup.c       **** 	
 284:setup.c       **** 	// Pulse WR and mREQ if the type matches
 285:setup.c       **** 	wrPin_low;
 293               		.loc 1 285 0
 294 0092 9698      		cbi 0x12,6
 286:setup.c       **** 	if (type == MEMORY_WRITE) {
 295               		.loc 1 286 0
 296 0094 C130      		cpi r28,lo8(1)
 297 0096 01F4      		brne .L21
 287:setup.c       **** 		cs_mreqPin_low;
 298               		.loc 1 287 0
 299 0098 9498      		cbi 0x12,4
 300               	.L21:
 288:setup.c       **** 	}
 289:setup.c       **** 	
 290:setup.c       **** 	asm volatile("nop");
 301               		.loc 1 290 0
 302               	/* #APP */
 303               	 ;  290 "setup.c" 1
 304 009a 0000      		nop
 305               	 ;  0 "" 2
 291:setup.c       **** 	
 292:setup.c       **** 	if (type == MEMORY_WRITE) {
 306               		.loc 1 292 0
 307               	/* #NOAPP */
 308 009c C130      		cpi r28,lo8(1)
 309 009e 01F4      		brne .L22
 293:setup.c       **** 		cs_mreqPin_high;
 310               		.loc 1 293 0
 311 00a0 949A      		sbi 0x12,4
 312               	.L22:
 294:setup.c       **** 	}
 295:setup.c       **** 	wrPin_high;
 313               		.loc 1 295 0
 314 00a2 969A      		sbi 0x12,6
 296:setup.c       **** 	
 297:setup.c       **** 	// Clear data outputs and set data pins as inputs
 298:setup.c       **** 	PORT_DATA7_0 = 0;
 315               		.loc 1 298 0
 316 00a4 15BA      		out 0x15,__zero_reg__
 299:setup.c       **** 	DDR_DATA7_0 = 0;
 317               		.loc 1 299 0
 318 00a6 14BA      		out 0x14,__zero_reg__
 319               	/* epilogue start */
 300:setup.c       **** }
 320               		.loc 1 300 0
 321 00a8 DF91      		pop r29
 322               	.LVL20:
 323 00aa CF91      		pop r28
 324               	.LVL21:
 325 00ac 0895      		ret
 326               		.cfi_endproc
 327               	.LFE20:
 329               	.global	gba_mode
 331               	gba_mode:
 332               	.LFB21:
 301:setup.c       **** 
 302:setup.c       **** 
 303:setup.c       **** 
 304:setup.c       **** // ****** Gameboy Advance functions ****** 
 305:setup.c       **** 
 306:setup.c       **** // Set GBA mode
 307:setup.c       **** void gba_mode(void) {
 333               		.loc 1 307 0
 334               		.cfi_startproc
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 308:setup.c       **** 	// Set outputs for reading ROM addresses as default
 309:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 339               		.loc 1 309 0
 340 00ae 18BA      		out 0x18,__zero_reg__
 310:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 341               		.loc 1 310 0
 342 00b0 1BBA      		out 0x1b,__zero_reg__
 311:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 343               		.loc 1 311 0
 344 00b2 15BA      		out 0x15,__zero_reg__
 312:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 345               		.loc 1 312 0
 346 00b4 8FEF      		ldi r24,lo8(-1)
 347 00b6 87BB      		out 0x17,r24
 313:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 348               		.loc 1 313 0
 349 00b8 8ABB      		out 0x1a,r24
 314:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 350               		.loc 1 314 0
 351 00ba 84BB      		out 0x14,r24
 352 00bc 0895      		ret
 353               		.cfi_endproc
 354               	.LFE21:
 356               	.global	gba_set_24bit_address
 358               	gba_set_24bit_address:
 359               	.LFB22:
 315:setup.c       **** }
 316:setup.c       **** 
 317:setup.c       **** // Set the 24 bit address on A23-0
 318:setup.c       **** void gba_set_24bit_address(uint32_t address) {	
 360               		.loc 1 318 0
 361               		.cfi_startproc
 362               	.LVL22:
 363 00be 0F93      		push r16
 364               	.LCFI8:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 16, -2
 367 00c0 1F93      		push r17
 368               	.LCFI9:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 17, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 319:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0; // Set 0-23 address lines low and set as outputs
 375               		.loc 1 319 0
 376 00c2 15BA      		out 0x15,__zero_reg__
 320:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0;
 377               		.loc 1 320 0
 378 00c4 1BBA      		out 0x1b,__zero_reg__
 321:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 379               		.loc 1 321 0
 380 00c6 18BA      		out 0x18,__zero_reg__
 322:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 381               		.loc 1 322 0
 382 00c8 2FEF      		ldi r18,lo8(-1)
 383 00ca 24BB      		out 0x14,r18
 323:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 384               		.loc 1 323 0
 385 00cc 2ABB      		out 0x1a,r18
 324:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 386               		.loc 1 324 0
 387 00ce 27BB      		out 0x17,r18
 325:setup.c       **** 	
 326:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 388               		.loc 1 326 0
 389 00d0 8C01      		movw r16,r24
 390 00d2 2227      		clr r18
 391 00d4 3327      		clr r19
 392 00d6 05BB      		out 0x15,r16
 327:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 393               		.loc 1 327 0
 394 00d8 072F      		mov r16,r23
 395 00da 182F      		mov r17,r24
 396 00dc 292F      		mov r18,r25
 397 00de 3327      		clr r19
 398 00e0 0BBB      		out 0x1b,r16
 328:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 399               		.loc 1 328 0
 400 00e2 68BB      		out 0x18,r22
 401               	/* epilogue start */
 329:setup.c       **** }
 402               		.loc 1 329 0
 403 00e4 1F91      		pop r17
 404 00e6 0F91      		pop r16
 405 00e8 0895      		ret
 406               		.cfi_endproc
 407               	.LFE22:
 409               	.global	gba_read_16bit_data
 411               	gba_read_16bit_data:
 412               	.LFB23:
 330:setup.c       **** 
 331:setup.c       **** 
 332:setup.c       **** 
 333:setup.c       **** // ---------- ROM/SRAM ----------
 334:setup.c       **** 
 335:setup.c       **** // Read a byte from the 16 bit data line non-sequentially
 336:setup.c       **** uint16_t gba_read_16bit_data(uint32_t address) {
 413               		.loc 1 336 0
 414               		.cfi_startproc
 415               	.LVL23:
 416               	/* prologue: function */
 417               	/* frame size = 0 */
 418               	/* stack size = 0 */
 419               	.L__stack_usage = 0
 337:setup.c       **** 	gba_set_24bit_address(address);
 420               		.loc 1 337 0
 421 00ea 00D0      		rcall gba_set_24bit_address
 422               	.LVL24:
 338:setup.c       **** 	
 339:setup.c       **** 	cs_mreqPin_low;
 423               		.loc 1 339 0
 424 00ec 9498      		cbi 0x12,4
 340:setup.c       **** 	
 341:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0; // Set A16-A0 address lines low and set as inputs for the data to be re
 425               		.loc 1 341 0
 426 00ee 1BBA      		out 0x1b,__zero_reg__
 342:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0;
 427               		.loc 1 342 0
 428 00f0 18BA      		out 0x18,__zero_reg__
 343:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0;
 429               		.loc 1 343 0
 430 00f2 1ABA      		out 0x1a,__zero_reg__
 344:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0;
 431               		.loc 1 344 0
 432 00f4 17BA      		out 0x17,__zero_reg__
 345:setup.c       **** 	
 346:setup.c       **** 	rdPin_low;
 433               		.loc 1 346 0
 434 00f6 9598      		cbi 0x12,5
 347:setup.c       **** 	asm volatile("nop");
 435               		.loc 1 347 0
 436               	/* #APP */
 437               	 ;  347 "setup.c" 1
 438 00f8 0000      		nop
 439               	 ;  0 "" 2
 348:setup.c       **** 	
 349:setup.c       **** 	uint16_t data = (GBA_PIN_ROM_DATA15_8 << 8) | GBA_PIN_ROM_DATA7_0; // Read data
 440               		.loc 1 349 0
 441               	/* #NOAPP */
 442 00fa 29B3      		in r18,0x19
 443 00fc 86B3      		in r24,0x16
 444               	.LVL25:
 350:setup.c       **** 	
 351:setup.c       **** 	rdPin_high;
 445               		.loc 1 351 0
 446 00fe 959A      		sbi 0x12,5
 352:setup.c       **** 	cs_mreqPin_high;
 447               		.loc 1 352 0
 448 0100 949A      		sbi 0x12,4
 353:setup.c       **** 	
 354:setup.c       **** 	return data;
 449               		.loc 1 354 0
 450 0102 90E0      		ldi r25,0
 355:setup.c       **** }
 451               		.loc 1 355 0
 452 0104 922B      		or r25,r18
 453 0106 0895      		ret
 454               		.cfi_endproc
 455               	.LFE23:
 457               	.global	gba_read_ram_8bit_data
 459               	gba_read_ram_8bit_data:
 460               	.LFB24:
 356:setup.c       **** 
 357:setup.c       **** // Set the address and read a byte from the 8 bit data line
 358:setup.c       **** uint8_t gba_read_ram_8bit_data(uint16_t address) {
 461               		.loc 1 358 0
 462               		.cfi_startproc
 463               	.LVL26:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 359:setup.c       **** 	set_16bit_address(address);
 468               		.loc 1 359 0
 469 0108 00D0      		rcall set_16bit_address
 470               	.LVL27:
 360:setup.c       **** 	
 361:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 471               		.loc 1 361 0
 472 010a 3A98      		cbi 0x7,2
 362:setup.c       **** 	rdPin_low;
 473               		.loc 1 362 0
 474 010c 9598      		cbi 0x12,5
 363:setup.c       **** 	
 364:setup.c       **** 	asm volatile("nop"); // Delay a little (minimum needed is 2)
 475               		.loc 1 364 0
 476               	/* #APP */
 477               	 ;  364 "setup.c" 1
 478 010e 0000      		nop
 479               	 ;  0 "" 2
 365:setup.c       **** 	asm volatile("nop");
 480               		.loc 1 365 0
 481               	 ;  365 "setup.c" 1
 482 0110 0000      		nop
 483               	 ;  0 "" 2
 366:setup.c       **** 	
 367:setup.c       **** 	uint8_t data = GBA_PIN_RAM_DATA7_0; // Read data
 484               		.loc 1 367 0
 485               	/* #NOAPP */
 486 0112 83B3      		in r24,0x13
 487               	.LVL28:
 368:setup.c       **** 	
 369:setup.c       **** 	rdPin_high;
 488               		.loc 1 369 0
 489 0114 959A      		sbi 0x12,5
 370:setup.c       **** 	cs2Pin_high;
 490               		.loc 1 370 0
 491 0116 3A9A      		sbi 0x7,2
 371:setup.c       **** 	
 372:setup.c       **** 	return data;
 373:setup.c       **** }
 492               		.loc 1 373 0
 493 0118 0895      		ret
 494               		.cfi_endproc
 495               	.LFE24:
 497               	.global	gba_write_ram_8bit_data
 499               	gba_write_ram_8bit_data:
 500               	.LFB25:
 374:setup.c       **** 
 375:setup.c       **** // Set the address and write a byte to the 8 bit data line 
 376:setup.c       **** void gba_write_ram_8bit_data(uint16_t address, uint8_t data) {
 501               		.loc 1 376 0
 502               		.cfi_startproc
 503               	.LVL29:
 504 011a CF93      		push r28
 505               	.LCFI10:
 506               		.cfi_def_cfa_offset 3
 507               		.cfi_offset 28, -2
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 1 */
 511               	.L__stack_usage = 1
 512 011c C62F      		mov r28,r22
 377:setup.c       **** 	set_16bit_address(address);
 513               		.loc 1 377 0
 514 011e 00D0      		rcall set_16bit_address
 515               	.LVL30:
 378:setup.c       **** 	
 379:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 516               		.loc 1 379 0
 517 0120 8FEF      		ldi r24,lo8(-1)
 518 0122 84BB      		out 0x14,r24
 380:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data; // Set data
 519               		.loc 1 380 0
 520 0124 C5BB      		out 0x15,r28
 381:setup.c       **** 	
 382:setup.c       **** 	cs2Pin_low; // CS2 pin low for SRAM/Flash select
 521               		.loc 1 382 0
 522 0126 3A98      		cbi 0x7,2
 383:setup.c       **** 	wrPin_low; // Pulse WR
 523               		.loc 1 383 0
 524 0128 9698      		cbi 0x12,6
 384:setup.c       **** 	
 385:setup.c       **** 	asm volatile("nop");
 525               		.loc 1 385 0
 526               	/* #APP */
 527               	 ;  385 "setup.c" 1
 528 012a 0000      		nop
 529               	 ;  0 "" 2
 386:setup.c       **** 	asm volatile("nop");
 530               		.loc 1 386 0
 531               	 ;  386 "setup.c" 1
 532 012c 0000      		nop
 533               	 ;  0 "" 2
 387:setup.c       **** 	
 388:setup.c       **** 	wrPin_high;
 534               		.loc 1 388 0
 535               	/* #NOAPP */
 536 012e 969A      		sbi 0x12,6
 389:setup.c       **** 	cs2Pin_high;
 537               		.loc 1 389 0
 538 0130 3A9A      		sbi 0x7,2
 390:setup.c       **** 	
 391:setup.c       **** 	// Clear data outputs and set data pins as inputs
 392:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 539               		.loc 1 392 0
 540 0132 15BA      		out 0x15,__zero_reg__
 393:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 541               		.loc 1 393 0
 542 0134 14BA      		out 0x14,__zero_reg__
 543               	/* epilogue start */
 394:setup.c       **** }
 544               		.loc 1 394 0
 545 0136 CF91      		pop r28
 546               	.LVL31:
 547 0138 0895      		ret
 548               		.cfi_endproc
 549               	.LFE25:
 551               	.global	gba_eeprom_mode
 553               	gba_eeprom_mode:
 554               	.LFB26:
 395:setup.c       **** 
 396:setup.c       **** 
 397:setup.c       **** 
 398:setup.c       **** // ---------- EEPROM ----------
 399:setup.c       **** 
 400:setup.c       **** // Set address/data all high (includes AD0/A23)
 401:setup.c       **** void gba_eeprom_mode (void) {
 555               		.loc 1 401 0
 556               		.cfi_startproc
 557               	/* prologue: function */
 558               	/* frame size = 0 */
 559               	/* stack size = 0 */
 560               	.L__stack_usage = 0
 402:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 561               		.loc 1 402 0
 562 013a 8FEF      		ldi r24,lo8(-1)
 563 013c 87BB      		out 0x17,r24
 403:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 564               		.loc 1 403 0
 565 013e 8ABB      		out 0x1a,r24
 404:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 566               		.loc 1 404 0
 567 0140 84BB      		out 0x14,r24
 405:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x80;
 568               		.loc 1 405 0
 569 0142 90E8      		ldi r25,lo8(-128)
 570 0144 98BB      		out 0x18,r25
 406:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0xFF;
 571               		.loc 1 406 0
 572 0146 8BBB      		out 0x1b,r24
 407:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0xFF;
 573               		.loc 1 407 0
 574 0148 85BB      		out 0x15,r24
 575 014a 0895      		ret
 576               		.cfi_endproc
 577               	.LFE26:
 579               	.global	gba_eeprom_set_address
 581               	gba_eeprom_set_address:
 582               	.LFB27:
 408:setup.c       **** }
 409:setup.c       **** 
 410:setup.c       **** // Send out EEPROM address serially (WR clock, AD0 data out)
 411:setup.c       **** void gba_eeprom_set_address(uint16_t address, uint8_t eepromSize, uint8_t command) {
 583               		.loc 1 411 0
 584               		.cfi_startproc
 585               	.LVL32:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 412:setup.c       **** 	cs_mreqPin_low;
 590               		.loc 1 412 0
 591 014c 9498      		cbi 0x12,4
 592               	.LVL33:
 413:setup.c       **** 	
 414:setup.c       **** 	int8_t x = 0;
 415:setup.c       **** 	if (eepromSize == EEPROM_64KBIT) {
 593               		.loc 1 415 0
 594 014e 6230      		cpi r22,lo8(2)
 595 0150 01F4      		brne .L30
 416:setup.c       **** 		if (command == EEPROM_READ) {
 596               		.loc 1 416 0
 597 0152 4111      		cpse r20,__zero_reg__
 598 0154 00C0      		rjmp .L31
 417:setup.c       **** 			address |= (1<<15) | (1<<14); // Set upper 2 bits high for read request
 599               		.loc 1 417 0
 600 0156 906C      		ori r25,192
 601               	.LVL34:
 602               	.L40:
 418:setup.c       **** 		}
 419:setup.c       **** 		else {
 420:setup.c       **** 			address |= (1<<15); // Set upper 1 bit high for write request
 421:setup.c       **** 		}
 422:setup.c       **** 		x = 15;
 603               		.loc 1 422 0
 604 0158 2FE0      		ldi r18,lo8(15)
 605               	.L33:
 606               	.LVL35:
 423:setup.c       **** 	}
 424:setup.c       **** 	else {
 425:setup.c       **** 		if (command == EEPROM_READ) {
 426:setup.c       **** 			address |= (1<<7) | (1<<6);
 427:setup.c       **** 		}
 428:setup.c       **** 		else {
 429:setup.c       **** 			address |= (1<<7);
 430:setup.c       **** 		}
 431:setup.c       **** 		x = 7;
 432:setup.c       **** 	}
 433:setup.c       **** 	
 434:setup.c       **** 	// Loop through address, 8 or 16 bits depending on EEPROM (includes the 2 bits for request type)
 435:setup.c       **** 	while (x >= 0) {
 436:setup.c       **** 		if (address & (1<<x)) {
 607               		.loc 1 436 0
 608 015a E1E0      		ldi r30,lo8(1)
 609 015c F0E0      		ldi r31,0
 610 015e 00C0      		rjmp .L32
 611               	.LVL36:
 612               	.L31:
 420:setup.c       **** 		}
 613               		.loc 1 420 0
 614 0160 9068      		ori r25,128
 615               	.LVL37:
 616 0162 00C0      		rjmp .L40
 617               	.L30:
 425:setup.c       **** 			address |= (1<<7) | (1<<6);
 618               		.loc 1 425 0
 619 0164 4111      		cpse r20,__zero_reg__
 620 0166 00C0      		rjmp .L34
 426:setup.c       **** 		}
 621               		.loc 1 426 0
 622 0168 806C      		ori r24,192
 623               	.LVL38:
 624 016a 00C0      		rjmp .L39
 625               	.L34:
 429:setup.c       **** 		}
 626               		.loc 1 429 0
 627 016c 8068      		ori r24,128
 628               	.LVL39:
 629               	.L39:
 431:setup.c       **** 	}
 630               		.loc 1 431 0
 631 016e 27E0      		ldi r18,lo8(7)
 632 0170 00C0      		rjmp .L33
 633               	.LVL40:
 634               	.L35:
 437:setup.c       **** 			ad0Pin_high;
 438:setup.c       **** 		}
 439:setup.c       **** 		else {
 440:setup.c       **** 			ad0Pin_low;
 635               		.loc 1 440 0
 636 0172 C098      		cbi 0x18,0
 637               	.L36:
 441:setup.c       **** 		}
 442:setup.c       **** 		
 443:setup.c       **** 		wrPin_low; // CLK
 638               		.loc 1 443 0
 639 0174 9698      		cbi 0x12,6
 444:setup.c       **** 		asm ("nop");
 640               		.loc 1 444 0
 641               	/* #APP */
 642               	 ;  444 "setup.c" 1
 643 0176 0000      		nop
 644               	 ;  0 "" 2
 445:setup.c       **** 		asm ("nop");
 645               		.loc 1 445 0
 646               	 ;  445 "setup.c" 1
 647 0178 0000      		nop
 648               	 ;  0 "" 2
 446:setup.c       **** 		wrPin_high; 
 649               		.loc 1 446 0
 650               	/* #NOAPP */
 651 017a 969A      		sbi 0x12,6
 447:setup.c       **** 		asm ("nop");
 652               		.loc 1 447 0
 653               	/* #APP */
 654               	 ;  447 "setup.c" 1
 655 017c 0000      		nop
 656               	 ;  0 "" 2
 448:setup.c       **** 		asm ("nop");
 657               		.loc 1 448 0
 658               	 ;  448 "setup.c" 1
 659 017e 0000      		nop
 660               	 ;  0 "" 2
 661               	/* #NOAPP */
 662 0180 2150      		subi r18,lo8(-(-1))
 663               	.LVL41:
 435:setup.c       **** 		if (address & (1<<x)) {
 664               		.loc 1 435 0
 665 0182 27FD      		sbrc r18,7
 666 0184 00C0      		rjmp .L41
 667               	.L32:
 436:setup.c       **** 			ad0Pin_high;
 668               		.loc 1 436 0
 669 0186 BF01      		movw r22,r30
 670 0188 022E      		mov r0,r18
 671 018a 00C0      		rjmp 2f
 672               		1:
 673 018c 660F      		lsl r22
 674 018e 771F      		rol r23
 675               		2:
 676 0190 0A94      		dec r0
 677 0192 02F4      		brpl 1b
 678 0194 6823      		and r22,r24
 679 0196 7923      		and r23,r25
 680 0198 672B      		or r22,r23
 681 019a 01F0      		breq .L35
 437:setup.c       **** 		}
 682               		.loc 1 437 0
 683 019c C09A      		sbi 0x18,0
 684 019e 00C0      		rjmp .L36
 685               	.L41:
 449:setup.c       **** 		
 450:setup.c       **** 		x--;
 451:setup.c       **** 	}
 452:setup.c       **** 	
 453:setup.c       **** 	// Only send stop bit (0) and WR/CS high if reading, as writing is done in 1 continuous chunk
 454:setup.c       **** 	if (command == EEPROM_READ) {  
 686               		.loc 1 454 0
 687 01a0 4111      		cpse r20,__zero_reg__
 688 01a2 00C0      		rjmp .L29
 455:setup.c       **** 		ad0Pin_low;
 689               		.loc 1 455 0
 690 01a4 C098      		cbi 0x18,0
 456:setup.c       **** 		asm ("nop");
 691               		.loc 1 456 0
 692               	/* #APP */
 693               	 ;  456 "setup.c" 1
 694 01a6 0000      		nop
 695               	 ;  0 "" 2
 457:setup.c       **** 		wrPin_low;
 696               		.loc 1 457 0
 697               	/* #NOAPP */
 698 01a8 9698      		cbi 0x12,6
 458:setup.c       **** 		asm ("nop");
 699               		.loc 1 458 0
 700               	/* #APP */
 701               	 ;  458 "setup.c" 1
 702 01aa 0000      		nop
 703               	 ;  0 "" 2
 459:setup.c       **** 		asm ("nop");
 704               		.loc 1 459 0
 705               	 ;  459 "setup.c" 1
 706 01ac 0000      		nop
 707               	 ;  0 "" 2
 460:setup.c       **** 		
 461:setup.c       **** 		wrPin_high;
 708               		.loc 1 461 0
 709               	/* #NOAPP */
 710 01ae 969A      		sbi 0x12,6
 462:setup.c       **** 		cs_mreqPin_high;
 711               		.loc 1 462 0
 712 01b0 949A      		sbi 0x12,4
 713               	.L29:
 714 01b2 0895      		ret
 715               		.cfi_endproc
 716               	.LFE27:
 718               	.global	gba_eeprom_read
 720               	gba_eeprom_read:
 721               	.LFB28:
 463:setup.c       **** 	}
 464:setup.c       **** }
 465:setup.c       **** 
 466:setup.c       **** // Read 8 bytes from the EEPROM address, data is valid on rising edge
 467:setup.c       **** void gba_eeprom_read(uint16_t address, uint8_t eepromSize) {
 722               		.loc 1 467 0
 723               		.cfi_startproc
 724               	.LVL42:
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 0 */
 728               	.L__stack_usage = 0
 468:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_READ);
 729               		.loc 1 468 0
 730 01b4 40E0      		ldi r20,0
 731 01b6 00D0      		rcall gba_eeprom_set_address
 732               	.LVL43:
 469:setup.c       **** 	
 470:setup.c       **** 	// Set AD0 pin as input
 471:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 &= ~(1<<AD0);
 733               		.loc 1 471 0
 734 01b8 C098      		cbi 0x18,0
 472:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 &= ~(1<<AD0);
 735               		.loc 1 472 0
 736 01ba B898      		cbi 0x17,0
 473:setup.c       **** 	
 474:setup.c       **** 	cs_mreqPin_low;
 737               		.loc 1 474 0
 738 01bc 9498      		cbi 0x12,4
 739               	.LVL44:
 740 01be 84E0      		ldi r24,lo8(4)
 741               	.LVL45:
 742               	.L43:
 743               	.LBB148:
 475:setup.c       **** 	
 476:setup.c       **** 	// Ignore first 4 bits
 477:setup.c       **** 	for (int8_t x = 0; x < 4; x++) {
 478:setup.c       **** 		rdPin_low; // CLK
 744               		.loc 1 478 0 discriminator 3
 745 01c0 9598      		cbi 0x12,5
 479:setup.c       **** 		asm ("nop");
 746               		.loc 1 479 0 discriminator 3
 747               	/* #APP */
 748               	 ;  479 "setup.c" 1
 749 01c2 0000      		nop
 750               	 ;  0 "" 2
 480:setup.c       **** 		asm ("nop");
 751               		.loc 1 480 0 discriminator 3
 752               	 ;  480 "setup.c" 1
 753 01c4 0000      		nop
 754               	 ;  0 "" 2
 481:setup.c       **** 		rdPin_high; 
 755               		.loc 1 481 0 discriminator 3
 756               	/* #NOAPP */
 757 01c6 959A      		sbi 0x12,5
 482:setup.c       **** 		asm ("nop");
 758               		.loc 1 482 0 discriminator 3
 759               	/* #APP */
 760               	 ;  482 "setup.c" 1
 761 01c8 0000      		nop
 762               	 ;  0 "" 2
 483:setup.c       **** 		asm ("nop");
 763               		.loc 1 483 0 discriminator 3
 764               	 ;  483 "setup.c" 1
 765 01ca 0000      		nop
 766               	 ;  0 "" 2
 767               	.LVL46:
 768               	/* #NOAPP */
 769 01cc 8150      		subi r24,lo8(-(-1))
 770               	.LVL47:
 477:setup.c       **** 		rdPin_low; // CLK
 771               		.loc 1 477 0 discriminator 3
 772 01ce 01F4      		brne .L43
 773 01d0 E0E0      		ldi r30,lo8(eepromBuffer)
 774 01d2 F0E0      		ldi r31,hi8(eepromBuffer)
 775               	.LBE148:
 776               	.LBB149:
 777               	.LBB150:
 778               	.LBB151:
 484:setup.c       **** 	}
 485:setup.c       **** 	
 486:setup.c       **** 	// Read out 64 bits
 487:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 488:setup.c       **** 		uint8_t data = 0;
 489:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 490:setup.c       **** 			rdPin_low; // CLK
 491:setup.c       **** 			asm ("nop");
 492:setup.c       **** 			asm ("nop");
 493:setup.c       **** 			rdPin_high;
 494:setup.c       **** 			
 495:setup.c       **** 			if (GBA_PIN_EEPROM_DATA7_0 & (1<<AD0)) {
 496:setup.c       **** 				data |= (1<<x);
 779               		.loc 1 496 0
 780 01d4 41E0      		ldi r20,lo8(1)
 781 01d6 50E0      		ldi r21,0
 782               	.LVL48:
 783               	.L44:
 784               	.LBE151:
 785               	.LBE150:
 786               	.LBE149:
 474:setup.c       **** 	
 787               		.loc 1 474 0
 788 01d8 87E0      		ldi r24,lo8(7)
 789 01da 90E0      		ldi r25,0
 790 01dc 20E0      		ldi r18,0
 791               	.LVL49:
 792               	.L46:
 793               	.LBB154:
 794               	.LBB153:
 795               	.LBB152:
 490:setup.c       **** 			asm ("nop");
 796               		.loc 1 490 0
 797 01de 9598      		cbi 0x12,5
 491:setup.c       **** 			asm ("nop");
 798               		.loc 1 491 0
 799               	/* #APP */
 800               	 ;  491 "setup.c" 1
 801 01e0 0000      		nop
 802               	 ;  0 "" 2
 492:setup.c       **** 			rdPin_high;
 803               		.loc 1 492 0
 804               	 ;  492 "setup.c" 1
 805 01e2 0000      		nop
 806               	 ;  0 "" 2
 493:setup.c       **** 			
 807               		.loc 1 493 0
 808               	/* #NOAPP */
 809 01e4 959A      		sbi 0x12,5
 495:setup.c       **** 				data |= (1<<x);
 810               		.loc 1 495 0
 811 01e6 B09B      		sbis 0x16,0
 812 01e8 00C0      		rjmp .L45
 813               		.loc 1 496 0
 814 01ea BA01      		movw r22,r20
 815 01ec 082E      		mov r0,r24
 816 01ee 00C0      		rjmp 2f
 817               		1:
 818 01f0 660F      		lsl r22
 819               		2:
 820 01f2 0A94      		dec r0
 821 01f4 02F4      		brpl 1b
 822 01f6 262B      		or r18,r22
 823               	.LVL50:
 824               	.L45:
 825               	.LVL51:
 826 01f8 0197      		sbiw r24,1
 827 01fa 00F4      		brcc .L46
 828               	.LBE152:
 497:setup.c       **** 			}
 498:setup.c       **** 		}
 499:setup.c       **** 		eepromBuffer[c] = data;
 829               		.loc 1 499 0 discriminator 2
 830 01fc 2193      		st Z+,r18
 831               	.LVL52:
 832               	.LBE153:
 487:setup.c       **** 		uint8_t data = 0;
 833               		.loc 1 487 0 discriminator 2
 834 01fe 80E0      		ldi r24,hi8(eepromBuffer+8)
 835 0200 E030      		cpi r30,lo8(eepromBuffer+8)
 836 0202 F807      		cpc r31,r24
 837               	.LVL53:
 838 0204 01F4      		brne .L44
 839               	.LBE154:
 500:setup.c       **** 	}
 501:setup.c       **** 	
 502:setup.c       **** 	cs_mreqPin_high;
 840               		.loc 1 502 0
 841 0206 949A      		sbi 0x12,4
 503:setup.c       **** 	
 504:setup.c       **** 	// Set AD0 pin as output
 505:setup.c       **** 	GBA_PORT_EEPROM_DATA7_0 |= (1<<AD0);
 842               		.loc 1 505 0
 843 0208 C09A      		sbi 0x18,0
 506:setup.c       **** 	GBA_DDR_EEPROM_DATA7_0 |= (1<<AD0);
 844               		.loc 1 506 0
 845 020a B89A      		sbi 0x17,0
 846 020c 0895      		ret
 847               		.cfi_endproc
 848               	.LFE28:
 850               	.global	gba_eeprom_write
 852               	gba_eeprom_write:
 853               	.LFB29:
 507:setup.c       **** }
 508:setup.c       **** 
 509:setup.c       **** // Write 8 bytes to the EEPROM address
 510:setup.c       **** void gba_eeprom_write(uint16_t address, uint8_t eepromSize) {
 854               		.loc 1 510 0
 855               		.cfi_startproc
 856               	.LVL54:
 857               	/* prologue: function */
 858               	/* frame size = 0 */
 859               	/* stack size = 0 */
 860               	.L__stack_usage = 0
 511:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 861               		.loc 1 511 0
 862 020e 41E0      		ldi r20,lo8(1)
 863 0210 00D0      		rcall gba_eeprom_set_address
 864               	.LVL55:
 865 0212 E0E0      		ldi r30,lo8(eepromBuffer)
 866 0214 F0E0      		ldi r31,hi8(eepromBuffer)
 867 0216 48E0      		ldi r20,lo8(8)
 868               	.LVL56:
 869               	.L54:
 510:setup.c       **** 	gba_eeprom_set_address(address, eepromSize, EEPROM_WRITE);
 870               		.loc 1 510 0
 871 0218 27E0      		ldi r18,lo8(7)
 872 021a 30E0      		ldi r19,0
 873               	.LVL57:
 874               	.L57:
 875               	.LBB155:
 876               	.LBB156:
 512:setup.c       **** 	
 513:setup.c       **** 	// Write 64 bits
 514:setup.c       **** 	for (uint8_t c = 0; c < 8; c++) {
 515:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 516:setup.c       **** 			if (eepromBuffer[c] & (1<<x)) {
 877               		.loc 1 516 0
 878 021c 8081      		ld r24,Z
 879 021e 90E0      		ldi r25,0
 880 0220 022E      		mov r0,r18
 881 0222 00C0      		rjmp 2f
 882               		1:
 883 0224 9595      		asr r25
 884 0226 8795      		ror r24
 885               		2:
 886 0228 0A94      		dec r0
 887 022a 02F4      		brpl 1b
 888 022c 80FF      		sbrs r24,0
 889 022e 00C0      		rjmp .L55
 517:setup.c       **** 				ad0Pin_high;
 890               		.loc 1 517 0
 891 0230 C09A      		sbi 0x18,0
 892 0232 00C0      		rjmp .L56
 893               	.L55:
 518:setup.c       **** 			}
 519:setup.c       **** 			else {
 520:setup.c       **** 				ad0Pin_low;
 894               		.loc 1 520 0
 895 0234 C098      		cbi 0x18,0
 896               	.L56:
 521:setup.c       **** 			}
 522:setup.c       **** 			
 523:setup.c       **** 			wrPin_low; // CLK
 897               		.loc 1 523 0 discriminator 2
 898 0236 9698      		cbi 0x12,6
 524:setup.c       **** 			asm ("nop");
 899               		.loc 1 524 0 discriminator 2
 900               	/* #APP */
 901               	 ;  524 "setup.c" 1
 902 0238 0000      		nop
 903               	 ;  0 "" 2
 525:setup.c       **** 			asm ("nop");
 904               		.loc 1 525 0 discriminator 2
 905               	 ;  525 "setup.c" 1
 906 023a 0000      		nop
 907               	 ;  0 "" 2
 526:setup.c       **** 			wrPin_high; 
 908               		.loc 1 526 0 discriminator 2
 909               	/* #NOAPP */
 910 023c 969A      		sbi 0x12,6
 527:setup.c       **** 			asm ("nop");
 911               		.loc 1 527 0 discriminator 2
 912               	/* #APP */
 913               	 ;  527 "setup.c" 1
 914 023e 0000      		nop
 915               	 ;  0 "" 2
 528:setup.c       **** 			asm ("nop");
 916               		.loc 1 528 0 discriminator 2
 917               	 ;  528 "setup.c" 1
 918 0240 0000      		nop
 919               	 ;  0 "" 2
 920               	.LVL58:
 921               	/* #NOAPP */
 922               	.LVL59:
 923 0242 2150      		subi r18,1
 924 0244 3109      		sbc r19,__zero_reg__
 925 0246 00F4      		brcc .L57
 926 0248 4150      		subi r20,lo8(-(-1))
 927 024a 3196      		adiw r30,1
 928               	.LVL60:
 929               	.LBE156:
 514:setup.c       **** 		for (int8_t x = 7; x >= 0; x--) {
 930               		.loc 1 514 0 discriminator 2
 931 024c 4111      		cpse r20,__zero_reg__
 932 024e 00C0      		rjmp .L54
 933               	.LBE155:
 529:setup.c       **** 		}
 530:setup.c       **** 	}
 531:setup.c       **** 	
 532:setup.c       **** 	// Last bit low
 533:setup.c       **** 	ad0Pin_low;
 934               		.loc 1 533 0
 935 0250 C098      		cbi 0x18,0
 534:setup.c       **** 	wrPin_low; // CLK
 936               		.loc 1 534 0
 937 0252 9698      		cbi 0x12,6
 535:setup.c       **** 	asm ("nop");
 938               		.loc 1 535 0
 939               	/* #APP */
 940               	 ;  535 "setup.c" 1
 941 0254 0000      		nop
 942               	 ;  0 "" 2
 536:setup.c       **** 	asm ("nop");
 943               		.loc 1 536 0
 944               	 ;  536 "setup.c" 1
 945 0256 0000      		nop
 946               	 ;  0 "" 2
 537:setup.c       **** 	wrPin_high; 
 947               		.loc 1 537 0
 948               	/* #NOAPP */
 949 0258 969A      		sbi 0x12,6
 538:setup.c       **** 	asm ("nop");
 950               		.loc 1 538 0
 951               	/* #APP */
 952               	 ;  538 "setup.c" 1
 953 025a 0000      		nop
 954               	 ;  0 "" 2
 539:setup.c       **** 	asm ("nop");
 955               		.loc 1 539 0
 956               	 ;  539 "setup.c" 1
 957 025c 0000      		nop
 958               	 ;  0 "" 2
 540:setup.c       **** 	
 541:setup.c       **** 	cs_mreqPin_high;
 959               		.loc 1 541 0
 960               	/* #NOAPP */
 961 025e 949A      		sbi 0x12,4
 962 0260 0895      		ret
 963               		.cfi_endproc
 964               	.LFE29:
 966               	.global	flash_write_bus_cycle
 968               	flash_write_bus_cycle:
 969               	.LFB30:
 542:setup.c       **** }
 543:setup.c       **** 
 544:setup.c       **** 
 545:setup.c       **** 
 546:setup.c       **** // ---------- FLASH ----------
 547:setup.c       **** 
 548:setup.c       **** // Set the address and data for the write byte cycle to the flash
 549:setup.c       **** void flash_write_bus_cycle(uint16_t address, uint8_t data) {
 970               		.loc 1 549 0
 971               		.cfi_startproc
 972               	.LVL61:
 973 0262 CF93      		push r28
 974               	.LCFI11:
 975               		.cfi_def_cfa_offset 3
 976               		.cfi_offset 28, -2
 977               	/* prologue: function */
 978               	/* frame size = 0 */
 979               	/* stack size = 1 */
 980               	.L__stack_usage = 1
 981 0264 C62F      		mov r28,r22
 550:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0xFF; // Set data pins as outputs
 982               		.loc 1 550 0
 983 0266 2FEF      		ldi r18,lo8(-1)
 984 0268 24BB      		out 0x14,r18
 551:setup.c       **** 	set_16bit_address(address);
 985               		.loc 1 551 0
 986 026a 00D0      		rcall set_16bit_address
 987               	.LVL62:
 552:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = data;
 988               		.loc 1 552 0
 989 026c C5BB      		out 0x15,r28
 553:setup.c       **** 	
 554:setup.c       **** 	cs2Pin_low;
 990               		.loc 1 554 0
 991 026e 3A98      		cbi 0x7,2
 555:setup.c       **** 	wrPin_low;
 992               		.loc 1 555 0
 993 0270 9698      		cbi 0x12,6
 556:setup.c       **** 	asm volatile("nop");
 994               		.loc 1 556 0
 995               	/* #APP */
 996               	 ;  556 "setup.c" 1
 997 0272 0000      		nop
 998               	 ;  0 "" 2
 557:setup.c       **** 	cs2Pin_high;
 999               		.loc 1 557 0
 1000               	/* #NOAPP */
 1001 0274 3A9A      		sbi 0x7,2
 558:setup.c       **** 	wrPin_high;
 1002               		.loc 1 558 0
 1003 0276 969A      		sbi 0x12,6
 1004               	/* epilogue start */
 559:setup.c       **** }
 1005               		.loc 1 559 0
 1006 0278 CF91      		pop r28
 1007               	.LVL63:
 1008 027a 0895      		ret
 1009               		.cfi_endproc
 1010               	.LFE30:
 1012               	.global	flash_read_chip_id
 1014               	flash_read_chip_id:
 1015               	.LFB31:
 560:setup.c       **** 
 561:setup.c       **** // Read the flash manufacturer and device ID (Software ID)
 562:setup.c       **** void flash_read_chip_id(void) {
 1016               		.loc 1 562 0
 1017               		.cfi_startproc
 1018 027c CF93      		push r28
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 3
 1021               		.cfi_offset 28, -2
 1022 027e DF93      		push r29
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 4
 1025               		.cfi_offset 29, -3
 1026               	/* prologue: function */
 1027               	/* frame size = 0 */
 1028               	/* stack size = 2 */
 1029               	.L__stack_usage = 2
 563:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1030               		.loc 1 563 0
 1031 0280 6AEA      		ldi r22,lo8(-86)
 1032 0282 85E5      		ldi r24,lo8(85)
 1033 0284 95E5      		ldi r25,lo8(85)
 1034 0286 00D0      		rcall flash_write_bus_cycle
 1035               	.LVL64:
 564:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1036               		.loc 1 564 0
 1037 0288 65E5      		ldi r22,lo8(85)
 1038 028a 8AEA      		ldi r24,lo8(-86)
 1039 028c 9AE2      		ldi r25,lo8(42)
 1040 028e 00D0      		rcall flash_write_bus_cycle
 1041               	.LVL65:
 565:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x90); // Software ID entry
 1042               		.loc 1 565 0
 1043 0290 60E9      		ldi r22,lo8(-112)
 1044 0292 85E5      		ldi r24,lo8(85)
 1045 0294 95E5      		ldi r25,lo8(85)
 1046 0296 00D0      		rcall flash_write_bus_cycle
 1047               	.LVL66:
 1048               	.LBB157:
 1049               	.LBB158:
 1050               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1051               		.loc 2 187 0
 1052 0298 8FE3      		ldi r24,lo8(-25537)
 1053 029a 9CE9      		ldi r25,hi8(-25537)
 1054 029c 0197      	1:	sbiw r24,1
 1055 029e 01F4      		brne 1b
 1056 02a0 00C0      		rjmp .
 1057 02a2 0000      		nop
 1058               	.LVL67:
 1059               	.LBE158:
 1060               	.LBE157:
 566:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 567:setup.c       **** 	
 568:setup.c       **** 	// Set data as inputs
 569:setup.c       **** 	GBA_PORT_RAM_DATA7_0 = 0;
 1061               		.loc 1 569 0
 1062 02a4 15BA      		out 0x15,__zero_reg__
 570:setup.c       **** 	GBA_DDR_RAM_DATA7_0 = 0;
 1063               		.loc 1 570 0
 1064 02a6 14BA      		out 0x14,__zero_reg__
 571:setup.c       **** 	
 572:setup.c       **** 	// Read and transmit the 2 bytes
 573:setup.c       **** 	flashChipIdBuffer[0] = gba_read_ram_8bit_data(0x0000);
 1065               		.loc 1 573 0
 1066 02a8 80E0      		ldi r24,0
 1067 02aa 90E0      		ldi r25,0
 1068 02ac 00D0      		rcall gba_read_ram_8bit_data
 1069               	.LVL68:
 1070 02ae C0E0      		ldi r28,lo8(flashChipIdBuffer)
 1071 02b0 D0E0      		ldi r29,hi8(flashChipIdBuffer)
 1072 02b2 8883      		st Y,r24
 574:setup.c       **** 	flashChipIdBuffer[1] = gba_read_ram_8bit_data(0x0001);
 1073               		.loc 1 574 0
 1074 02b4 81E0      		ldi r24,lo8(1)
 1075 02b6 90E0      		ldi r25,0
 1076 02b8 00D0      		rcall gba_read_ram_8bit_data
 1077               	.LVL69:
 1078 02ba 8983      		std Y+1,r24
 575:setup.c       **** 	
 576:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1079               		.loc 1 576 0
 1080 02bc 6AEA      		ldi r22,lo8(-86)
 1081 02be 85E5      		ldi r24,lo8(85)
 1082 02c0 95E5      		ldi r25,lo8(85)
 1083 02c2 00D0      		rcall flash_write_bus_cycle
 1084               	.LVL70:
 577:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1085               		.loc 1 577 0
 1086 02c4 65E5      		ldi r22,lo8(85)
 1087 02c6 8AEA      		ldi r24,lo8(-86)
 1088 02c8 9AE2      		ldi r25,lo8(42)
 1089 02ca 00D0      		rcall flash_write_bus_cycle
 1090               	.LVL71:
 578:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xF0); // Software ID exit
 1091               		.loc 1 578 0
 1092 02cc 60EF      		ldi r22,lo8(-16)
 1093 02ce 85E5      		ldi r24,lo8(85)
 1094 02d0 95E5      		ldi r25,lo8(85)
 1095 02d2 00D0      		rcall flash_write_bus_cycle
 1096               	.LVL72:
 1097               	.LBB159:
 1098               	.LBB160:
 1099               		.loc 2 187 0
 1100 02d4 8FE3      		ldi r24,lo8(-25537)
 1101 02d6 9CE9      		ldi r25,hi8(-25537)
 1102 02d8 0197      	1:	sbiw r24,1
 1103 02da 01F4      		brne 1b
 1104 02dc 00C0      		rjmp .
 1105 02de 0000      		nop
 1106               	.LVL73:
 1107               	/* epilogue start */
 1108               	.LBE160:
 1109               	.LBE159:
 579:setup.c       **** 	_delay_ms(20); // Wait a little (for Atmel chip)
 580:setup.c       **** }
 1110               		.loc 1 580 0
 1111 02e0 DF91      		pop r29
 1112 02e2 CF91      		pop r28
 1113 02e4 0895      		ret
 1114               		.cfi_endproc
 1115               	.LFE31:
 1117               	.global	flash_switch_bank
 1119               	flash_switch_bank:
 1120               	.LFB32:
 581:setup.c       **** 
 582:setup.c       **** // Switch banks on the Flash
 583:setup.c       **** void flash_switch_bank(uint8_t bank) {
 1121               		.loc 1 583 0
 1122               		.cfi_startproc
 1123               	.LVL74:
 1124 02e6 CF93      		push r28
 1125               	.LCFI14:
 1126               		.cfi_def_cfa_offset 3
 1127               		.cfi_offset 28, -2
 1128               	/* prologue: function */
 1129               	/* frame size = 0 */
 1130               	/* stack size = 1 */
 1131               	.L__stack_usage = 1
 1132 02e8 C82F      		mov r28,r24
 584:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1133               		.loc 1 584 0
 1134 02ea 6AEA      		ldi r22,lo8(-86)
 1135 02ec 85E5      		ldi r24,lo8(85)
 1136 02ee 95E5      		ldi r25,lo8(85)
 1137               	.LVL75:
 1138 02f0 00D0      		rcall flash_write_bus_cycle
 1139               	.LVL76:
 585:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1140               		.loc 1 585 0
 1141 02f2 65E5      		ldi r22,lo8(85)
 1142 02f4 8AEA      		ldi r24,lo8(-86)
 1143 02f6 9AE2      		ldi r25,lo8(42)
 1144 02f8 00D0      		rcall flash_write_bus_cycle
 1145               	.LVL77:
 586:setup.c       **** 	
 587:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xB0);
 1146               		.loc 1 587 0
 1147 02fa 60EB      		ldi r22,lo8(-80)
 1148 02fc 85E5      		ldi r24,lo8(85)
 1149 02fe 95E5      		ldi r25,lo8(85)
 1150 0300 00D0      		rcall flash_write_bus_cycle
 1151               	.LVL78:
 588:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1152               		.loc 1 588 0
 1153 0302 6C2F      		mov r22,r28
 1154 0304 80E0      		ldi r24,0
 1155 0306 90E0      		ldi r25,0
 1156               	/* epilogue start */
 589:setup.c       **** }
 1157               		.loc 1 589 0
 1158 0308 CF91      		pop r28
 1159               	.LVL79:
 588:setup.c       **** 	flash_write_bus_cycle(0x0000, bank);
 1160               		.loc 1 588 0
 1161 030a 00C0      		rjmp flash_write_bus_cycle
 1162               	.LVL80:
 1163               		.cfi_endproc
 1164               	.LFE32:
 1166               	.global	flash_erase_4k_sector
 1168               	flash_erase_4k_sector:
 1169               	.LFB33:
 590:setup.c       **** 
 591:setup.c       **** // Erase 4K sector on Flash, expects first sector to start at 0, left shifts by 12 (A15-A12 to sele
 592:setup.c       **** // Takes 25ms after last command to erase sector
 593:setup.c       **** void flash_erase_4k_sector(uint8_t sector) {
 1170               		.loc 1 593 0
 1171               		.cfi_startproc
 1172               	.LVL81:
 1173 030c CF93      		push r28
 1174               	.LCFI15:
 1175               		.cfi_def_cfa_offset 3
 1176               		.cfi_offset 28, -2
 1177               	/* prologue: function */
 1178               	/* frame size = 0 */
 1179               	/* stack size = 1 */
 1180               	.L__stack_usage = 1
 1181 030e C82F      		mov r28,r24
 594:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1182               		.loc 1 594 0
 1183 0310 6AEA      		ldi r22,lo8(-86)
 1184 0312 85E5      		ldi r24,lo8(85)
 1185 0314 95E5      		ldi r25,lo8(85)
 1186               	.LVL82:
 1187 0316 00D0      		rcall flash_write_bus_cycle
 1188               	.LVL83:
 595:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1189               		.loc 1 595 0
 1190 0318 65E5      		ldi r22,lo8(85)
 1191 031a 8AEA      		ldi r24,lo8(-86)
 1192 031c 9AE2      		ldi r25,lo8(42)
 1193 031e 00D0      		rcall flash_write_bus_cycle
 1194               	.LVL84:
 596:setup.c       **** 	flash_write_bus_cycle(0x5555, 0x80);
 1195               		.loc 1 596 0
 1196 0320 60E8      		ldi r22,lo8(-128)
 1197 0322 85E5      		ldi r24,lo8(85)
 1198 0324 95E5      		ldi r25,lo8(85)
 1199 0326 00D0      		rcall flash_write_bus_cycle
 1200               	.LVL85:
 597:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1201               		.loc 1 597 0
 1202 0328 6AEA      		ldi r22,lo8(-86)
 1203 032a 85E5      		ldi r24,lo8(85)
 1204 032c 95E5      		ldi r25,lo8(85)
 1205 032e 00D0      		rcall flash_write_bus_cycle
 1206               	.LVL86:
 598:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1207               		.loc 1 598 0
 1208 0330 65E5      		ldi r22,lo8(85)
 1209 0332 8AEA      		ldi r24,lo8(-86)
 1210 0334 9AE2      		ldi r25,lo8(42)
 1211 0336 00D0      		rcall flash_write_bus_cycle
 1212               	.LVL87:
 599:setup.c       **** 	
 600:setup.c       **** 	flash_write_bus_cycle((uint16_t) sector << 12, 0x30);
 1213               		.loc 1 600 0
 1214 0338 60E3      		ldi r22,lo8(48)
 1215 033a 80E0      		ldi r24,0
 1216 033c 9C2F      		mov r25,r28
 1217 033e 9295      		swap r25
 1218 0340 907F      		andi r25,lo8(-16)
 1219 0342 00D0      		rcall flash_write_bus_cycle
 1220               	.LVL88:
 1221               	.LBB161:
 1222               	.LBB162:
 1223               		.loc 2 187 0
 1224 0344 8FE4      		ldi r24,lo8(-15537)
 1225 0346 93EC      		ldi r25,hi8(-15537)
 1226 0348 0197      	1:	sbiw r24,1
 1227 034a 01F4      		brne 1b
 1228 034c 00C0      		rjmp .
 1229 034e 0000      		nop
 1230               	.LVL89:
 1231               	/* epilogue start */
 1232               	.LBE162:
 1233               	.LBE161:
 601:setup.c       **** 	_delay_ms(25); // Wait 25ms for sector erase
 602:setup.c       **** }
 1234               		.loc 1 602 0
 1235 0350 CF91      		pop r28
 1236               	.LVL90:
 1237 0352 0895      		ret
 1238               		.cfi_endproc
 1239               	.LFE33:
 1241               	.global	flash_write_byte
 1243               	flash_write_byte:
 1244               	.LFB34:
 603:setup.c       **** 
 604:setup.c       **** // Write a single byte to the Flash address
 605:setup.c       **** // Takes 20us to program Flash
 606:setup.c       **** void flash_write_byte(uint16_t address, uint8_t data) {
 1245               		.loc 1 606 0
 1246               		.cfi_startproc
 1247               	.LVL91:
 1248 0354 1F93      		push r17
 1249               	.LCFI16:
 1250               		.cfi_def_cfa_offset 3
 1251               		.cfi_offset 17, -2
 1252 0356 CF93      		push r28
 1253               	.LCFI17:
 1254               		.cfi_def_cfa_offset 4
 1255               		.cfi_offset 28, -3
 1256 0358 DF93      		push r29
 1257               	.LCFI18:
 1258               		.cfi_def_cfa_offset 5
 1259               		.cfi_offset 29, -4
 1260               	/* prologue: function */
 1261               	/* frame size = 0 */
 1262               	/* stack size = 3 */
 1263               	.L__stack_usage = 3
 1264 035a EC01      		movw r28,r24
 1265 035c 162F      		mov r17,r22
 607:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1266               		.loc 1 607 0
 1267 035e 6AEA      		ldi r22,lo8(-86)
 1268               	.LVL92:
 1269 0360 85E5      		ldi r24,lo8(85)
 1270 0362 95E5      		ldi r25,lo8(85)
 1271               	.LVL93:
 1272 0364 00D0      		rcall flash_write_bus_cycle
 1273               	.LVL94:
 608:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1274               		.loc 1 608 0
 1275 0366 65E5      		ldi r22,lo8(85)
 1276 0368 8AEA      		ldi r24,lo8(-86)
 1277 036a 9AE2      		ldi r25,lo8(42)
 1278 036c 00D0      		rcall flash_write_bus_cycle
 1279               	.LVL95:
 609:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1280               		.loc 1 609 0
 1281 036e 60EA      		ldi r22,lo8(-96)
 1282 0370 85E5      		ldi r24,lo8(85)
 1283 0372 95E5      		ldi r25,lo8(85)
 1284 0374 00D0      		rcall flash_write_bus_cycle
 1285               	.LVL96:
 610:setup.c       **** 	
 611:setup.c       **** 	flash_write_bus_cycle(address, data);
 1286               		.loc 1 611 0
 1287 0376 612F      		mov r22,r17
 1288 0378 CE01      		movw r24,r28
 1289 037a 00D0      		rcall flash_write_bus_cycle
 1290               	.LVL97:
 1291               	.LBB163:
 1292               	.LBB164:
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1293               		.loc 2 276 0
 1294 037c 85E3      		ldi r24,lo8(53)
 1295 037e 8A95      	1:	dec r24
 1296 0380 01F4      		brne 1b
 1297 0382 0000      		nop
 1298               	.LVL98:
 1299               	/* epilogue start */
 1300               	.LBE164:
 1301               	.LBE163:
 612:setup.c       **** 	_delay_us(20); // Wait byte program time
 613:setup.c       **** }
 1302               		.loc 1 613 0
 1303 0384 DF91      		pop r29
 1304 0386 CF91      		pop r28
 1305               	.LVL99:
 1306 0388 1F91      		pop r17
 1307               	.LVL100:
 1308 038a 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE34:
 1312               	.global	flash_write_sector
 1314               	flash_write_sector:
 1315               	.LFB35:
 614:setup.c       **** 
 615:setup.c       **** // Write a sector (128 bytes) to the Atmel flash
 616:setup.c       **** // Takes 20ms for write cycle
 617:setup.c       **** void flash_write_sector(uint16_t sector) {
 1316               		.loc 1 617 0
 1317               		.cfi_startproc
 1318               	.LVL101:
 1319 038c EF92      		push r14
 1320               	.LCFI19:
 1321               		.cfi_def_cfa_offset 3
 1322               		.cfi_offset 14, -2
 1323 038e FF92      		push r15
 1324               	.LCFI20:
 1325               		.cfi_def_cfa_offset 4
 1326               		.cfi_offset 15, -3
 1327 0390 0F93      		push r16
 1328               	.LCFI21:
 1329               		.cfi_def_cfa_offset 5
 1330               		.cfi_offset 16, -4
 1331 0392 1F93      		push r17
 1332               	.LCFI22:
 1333               		.cfi_def_cfa_offset 6
 1334               		.cfi_offset 17, -5
 1335 0394 CF93      		push r28
 1336               	.LCFI23:
 1337               		.cfi_def_cfa_offset 7
 1338               		.cfi_offset 28, -6
 1339 0396 DF93      		push r29
 1340               	.LCFI24:
 1341               		.cfi_def_cfa_offset 8
 1342               		.cfi_offset 29, -7
 1343               	/* prologue: function */
 1344               	/* frame size = 0 */
 1345               	/* stack size = 6 */
 1346               	.L__stack_usage = 6
 1347 0398 8C01      		movw r16,r24
 618:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xAA);
 1348               		.loc 1 618 0
 1349 039a 6AEA      		ldi r22,lo8(-86)
 1350 039c 85E5      		ldi r24,lo8(85)
 1351 039e 95E5      		ldi r25,lo8(85)
 1352               	.LVL102:
 1353 03a0 00D0      		rcall flash_write_bus_cycle
 1354               	.LVL103:
 619:setup.c       **** 	flash_write_bus_cycle(0x2AAA, 0x55);
 1355               		.loc 1 619 0
 1356 03a2 65E5      		ldi r22,lo8(85)
 1357 03a4 8AEA      		ldi r24,lo8(-86)
 1358 03a6 9AE2      		ldi r25,lo8(42)
 1359 03a8 00D0      		rcall flash_write_bus_cycle
 1360               	.LVL104:
 620:setup.c       **** 	flash_write_bus_cycle(0x5555, 0xA0);
 1361               		.loc 1 620 0
 1362 03aa 60EA      		ldi r22,lo8(-96)
 1363 03ac 85E5      		ldi r24,lo8(85)
 1364 03ae 95E5      		ldi r25,lo8(85)
 1365 03b0 00D0      		rcall flash_write_bus_cycle
 1366               	.LVL105:
 1367               	.LBB165:
 621:setup.c       **** 	
 622:setup.c       **** 	// Write the bytes (A0-A6 byte address, A7-A15 sector address)
 623:setup.c       **** 	for (uint8_t x = 0; x < 128; x++) {
 624:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1368               		.loc 1 624 0
 1369 03b2 1695      		lsr r17
 1370 03b4 102F      		mov r17,r16
 1371 03b6 0027      		clr r16
 1372 03b8 1795      		ror r17
 1373 03ba 0795      		ror r16
 1374               	.LVL106:
 1375 03bc 90E0      		ldi r25,lo8(receivedBuffer)
 1376 03be E92E      		mov r14,r25
 1377 03c0 90E0      		ldi r25,hi8(receivedBuffer)
 1378 03c2 F92E      		mov r15,r25
 1379 03c4 C0E0      		ldi r28,0
 1380 03c6 D0E0      		ldi r29,0
 1381               	.LVL107:
 1382               	.L66:
 1383               		.loc 1 624 0 is_stmt 0 discriminator 3
 1384 03c8 F701      		movw r30,r14
 1385 03ca 6191      		ld r22,Z+
 1386 03cc 7F01      		movw r14,r30
 1387 03ce CE01      		movw r24,r28
 1388 03d0 802B      		or r24,r16
 1389 03d2 912B      		or r25,r17
 1390 03d4 00D0      		rcall flash_write_bus_cycle
 1391               	.LVL108:
 1392 03d6 2196      		adiw r28,1
 1393               	.LVL109:
 623:setup.c       **** 		flash_write_bus_cycle((uint16_t) (sector << 7) | (uint16_t) x, receivedBuffer[x]);
 1394               		.loc 1 623 0 is_stmt 1 discriminator 3
 1395 03d8 C038      		cpi r28,-128
 1396 03da D105      		cpc r29,__zero_reg__
 1397 03dc 01F4      		brne .L66
 1398               	.LVL110:
 1399               	.LBE165:
 1400               	.LBB166:
 1401               	.LBB167:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 1402               		.loc 2 187 0
 1403 03de 8FE3      		ldi r24,lo8(-25537)
 1404 03e0 9CE9      		ldi r25,hi8(-25537)
 1405 03e2 0197      	1:	sbiw r24,1
 1406 03e4 01F4      		brne 1b
 1407 03e6 00C0      		rjmp .
 1408 03e8 0000      		nop
 1409               	.LVL111:
 1410               	/* epilogue start */
 1411               	.LBE167:
 1412               	.LBE166:
 625:setup.c       **** 	}
 626:setup.c       **** 	_delay_ms(20); // Wait sector program time
 627:setup.c       **** }
 1413               		.loc 1 627 0
 1414 03ea DF91      		pop r29
 1415 03ec CF91      		pop r28
 1416               	.LVL112:
 1417 03ee 1F91      		pop r17
 1418 03f0 0F91      		pop r16
 1419 03f2 FF90      		pop r15
 1420 03f4 EF90      		pop r14
 1421 03f6 0895      		ret
 1422               		.cfi_endproc
 1423               	.LFE35:
 1425               	.global	gb_flash_read_byte
 1427               	gb_flash_read_byte:
 1428               	.LFB36:
 628:setup.c       **** 
 629:setup.c       **** 
 630:setup.c       **** 
 631:setup.c       **** // ---------- GB FLASH CARTS ----------
 632:setup.c       **** 
 633:setup.c       **** // Read a byte from the flash (No CS pin pulse)
 634:setup.c       **** uint8_t gb_flash_read_byte(uint16_t address) {
 1429               		.loc 1 634 0
 1430               		.cfi_startproc
 1431               	.LVL113:
 1432               	/* prologue: function */
 1433               	/* frame size = 0 */
 1434               	/* stack size = 0 */
 1435               	.L__stack_usage = 0
 635:setup.c       **** 	PORT_DATA7_0 = 0;
 1436               		.loc 1 635 0
 1437 03f8 15BA      		out 0x15,__zero_reg__
 636:setup.c       **** 	DDR_DATA7_0 = 0;
 1438               		.loc 1 636 0
 1439 03fa 14BA      		out 0x14,__zero_reg__
 637:setup.c       **** 	
 638:setup.c       **** 	set_16bit_address(address);
 1440               		.loc 1 638 0
 1441 03fc 00D0      		rcall set_16bit_address
 1442               	.LVL114:
 639:setup.c       **** 	
 640:setup.c       **** 	rdPin_low;
 1443               		.loc 1 640 0
 1444 03fe 9598      		cbi 0x12,5
 641:setup.c       **** 	asm volatile("nop"); // Delay a little
 1445               		.loc 1 641 0
 1446               	/* #APP */
 1447               	 ;  641 "setup.c" 1
 1448 0400 0000      		nop
 1449               	 ;  0 "" 2
 642:setup.c       **** 	asm volatile("nop");
 1450               		.loc 1 642 0
 1451               	 ;  642 "setup.c" 1
 1452 0402 0000      		nop
 1453               	 ;  0 "" 2
 643:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1454               		.loc 1 643 0
 1455               	/* #NOAPP */
 1456 0404 83B3      		in r24,0x13
 1457               	.LVL115:
 644:setup.c       **** 	rdPin_high;
 1458               		.loc 1 644 0
 1459 0406 959A      		sbi 0x12,5
 645:setup.c       **** 	
 646:setup.c       **** 	return data;
 647:setup.c       **** }
 1460               		.loc 1 647 0
 1461 0408 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE36:
 1465               	.global	gb_flash_read_byte_fast
 1467               	gb_flash_read_byte_fast:
 1468               	.LFB37:
 648:setup.c       **** 
 649:setup.c       **** // No setting address or outputs, assuming already set
 650:setup.c       **** uint8_t gb_flash_read_byte_fast(void) {
 1469               		.loc 1 650 0
 1470               		.cfi_startproc
 1471               	/* prologue: function */
 1472               	/* frame size = 0 */
 1473               	/* stack size = 0 */
 1474               	.L__stack_usage = 0
 651:setup.c       **** 	rdPin_low;
 1475               		.loc 1 651 0
 1476 040a 9598      		cbi 0x12,5
 652:setup.c       **** 	asm volatile("nop"); // Delay a little
 1477               		.loc 1 652 0
 1478               	/* #APP */
 1479               	 ;  652 "setup.c" 1
 1480 040c 0000      		nop
 1481               	 ;  0 "" 2
 653:setup.c       **** 	asm volatile("nop");
 1482               		.loc 1 653 0
 1483               	 ;  653 "setup.c" 1
 1484 040e 0000      		nop
 1485               	 ;  0 "" 2
 654:setup.c       **** 	uint8_t data = PIN_DATA7_0; // Read data
 1486               		.loc 1 654 0
 1487               	/* #NOAPP */
 1488 0410 83B3      		in r24,0x13
 1489               	.LVL116:
 655:setup.c       **** 	rdPin_high;
 1490               		.loc 1 655 0
 1491 0412 959A      		sbi 0x12,5
 656:setup.c       **** 	
 657:setup.c       **** 	return data;
 658:setup.c       **** }
 1492               		.loc 1 658 0
 1493 0414 0895      		ret
 1494               		.cfi_endproc
 1495               	.LFE37:
 1497               	.global	gb_flash_write_bus_cycle
 1499               	gb_flash_write_bus_cycle:
 1500               	.LFB38:
 659:setup.c       **** 
 660:setup.c       **** // Set the address and data for the write byte cycle to the flash
 661:setup.c       **** void gb_flash_write_bus_cycle(uint16_t address, uint8_t data) {
 1501               		.loc 1 661 0
 1502               		.cfi_startproc
 1503               	.LVL117:
 1504 0416 CF93      		push r28
 1505               	.LCFI25:
 1506               		.cfi_def_cfa_offset 3
 1507               		.cfi_offset 28, -2
 1508               	/* prologue: function */
 1509               	/* frame size = 0 */
 1510               	/* stack size = 1 */
 1511               	.L__stack_usage = 1
 1512 0418 C62F      		mov r28,r22
 662:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1513               		.loc 1 662 0
 1514 041a 2FEF      		ldi r18,lo8(-1)
 1515 041c 24BB      		out 0x14,r18
 663:setup.c       **** 	set_16bit_address(address);
 1516               		.loc 1 663 0
 1517 041e 00D0      		rcall set_16bit_address
 1518               	.LVL118:
 664:setup.c       **** 	PORT_DATA7_0 = data;
 1519               		.loc 1 664 0
 1520 0420 C5BB      		out 0x15,r28
 665:setup.c       **** 	
 666:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1521               		.loc 1 666 0
 1522 0422 8091 0000 		lds r24,flashWriteWePin
 1523 0426 8134      		cpi r24,lo8(65)
 1524 0428 01F4      		brne .L71
 667:setup.c       **** 		audioPin_low; // WE low
 1525               		.loc 1 667 0
 1526 042a 3998      		cbi 0x7,1
 668:setup.c       **** 		asm volatile("nop");
 1527               		.loc 1 668 0
 1528               	/* #APP */
 1529               	 ;  668 "setup.c" 1
 1530 042c 0000      		nop
 1531               	 ;  0 "" 2
 669:setup.c       **** 		asm volatile("nop");
 1532               		.loc 1 669 0
 1533               	 ;  669 "setup.c" 1
 1534 042e 0000      		nop
 1535               	 ;  0 "" 2
 670:setup.c       **** 		asm volatile("nop");
 1536               		.loc 1 670 0
 1537               	 ;  670 "setup.c" 1
 1538 0430 0000      		nop
 1539               	 ;  0 "" 2
 671:setup.c       **** 		audioPin_high; // WE high
 1540               		.loc 1 671 0
 1541               	/* #NOAPP */
 1542 0432 399A      		sbi 0x7,1
 1543 0434 00C0      		rjmp .L72
 1544               	.L71:
 672:setup.c       **** 	}
 673:setup.c       **** 	else { // WR pin
 674:setup.c       **** 		wrPin_low; // WE low
 1545               		.loc 1 674 0
 1546 0436 9698      		cbi 0x12,6
 675:setup.c       **** 		asm volatile("nop");
 1547               		.loc 1 675 0
 1548               	/* #APP */
 1549               	 ;  675 "setup.c" 1
 1550 0438 0000      		nop
 1551               	 ;  0 "" 2
 676:setup.c       **** 		asm volatile("nop");
 1552               		.loc 1 676 0
 1553               	 ;  676 "setup.c" 1
 1554 043a 0000      		nop
 1555               	 ;  0 "" 2
 677:setup.c       **** 		asm volatile("nop");
 1556               		.loc 1 677 0
 1557               	 ;  677 "setup.c" 1
 1558 043c 0000      		nop
 1559               	 ;  0 "" 2
 678:setup.c       **** 		wrPin_high; // WE high
 1560               		.loc 1 678 0
 1561               	/* #NOAPP */
 1562 043e 969A      		sbi 0x12,6
 1563               	.L72:
 679:setup.c       **** 	}
 680:setup.c       **** 	
 681:setup.c       **** 	// Clear data outputs and set data pins as inputs
 682:setup.c       **** 	PORT_DATA7_0 = 0;
 1564               		.loc 1 682 0
 1565 0440 15BA      		out 0x15,__zero_reg__
 683:setup.c       **** 	DDR_DATA7_0 = 0;
 1566               		.loc 1 683 0
 1567 0442 14BA      		out 0x14,__zero_reg__
 1568               	/* epilogue start */
 684:setup.c       **** }
 1569               		.loc 1 684 0
 1570 0444 CF91      		pop r28
 1571               	.LVL119:
 1572 0446 0895      		ret
 1573               		.cfi_endproc
 1574               	.LFE38:
 1576               	.global	gb_flash_write_bus_cycle_fast
 1578               	gb_flash_write_bus_cycle_fast:
 1579               	.LFB39:
 685:setup.c       **** 
 686:setup.c       **** void gb_flash_write_bus_cycle_fast(uint16_t address, uint8_t data) {
 1580               		.loc 1 686 0
 1581               		.cfi_startproc
 1582               	.LVL120:
 1583               	/* prologue: function */
 1584               	/* frame size = 0 */
 1585               	/* stack size = 0 */
 1586               	.L__stack_usage = 0
 687:setup.c       **** 	PORT_ADDR15_8 = (address >> 8);
 1587               		.loc 1 687 0
 1588 0448 9BBB      		out 0x1b,r25
 688:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1589               		.loc 1 688 0
 1590 044a 88BB      		out 0x18,r24
 689:setup.c       **** 	PORT_DATA7_0 = data;
 1591               		.loc 1 689 0
 1592 044c 65BB      		out 0x15,r22
 690:setup.c       **** 	
 691:setup.c       **** 	if (flashWriteWePin == WE_AS_AUDIO_PIN) { // Audio pin
 1593               		.loc 1 691 0
 1594 044e 8091 0000 		lds r24,flashWriteWePin
 1595               	.LVL121:
 1596 0452 8134      		cpi r24,lo8(65)
 1597 0454 01F4      		brne .L74
 1598               	.LVL122:
 1599               	.LBB170:
 1600               	.LBB171:
 692:setup.c       **** 		audioPin_low; // WE low
 1601               		.loc 1 692 0
 1602 0456 3998      		cbi 0x7,1
 693:setup.c       **** 		asm volatile("nop");
 1603               		.loc 1 693 0
 1604               	/* #APP */
 1605               	 ;  693 "setup.c" 1
 1606 0458 0000      		nop
 1607               	 ;  0 "" 2
 694:setup.c       **** 		asm volatile("nop");
 1608               		.loc 1 694 0
 1609               	 ;  694 "setup.c" 1
 1610 045a 0000      		nop
 1611               	 ;  0 "" 2
 695:setup.c       **** 		asm volatile("nop");
 1612               		.loc 1 695 0
 1613               	 ;  695 "setup.c" 1
 1614 045c 0000      		nop
 1615               	 ;  0 "" 2
 696:setup.c       **** 		audioPin_high; // WE high
 1616               		.loc 1 696 0
 1617               	/* #NOAPP */
 1618 045e 399A      		sbi 0x7,1
 1619 0460 0895      		ret
 1620               	.LVL123:
 1621               	.L74:
 1622               	.LBE171:
 1623               	.LBE170:
 697:setup.c       **** 	}
 698:setup.c       **** 	else { // WR pin
 699:setup.c       **** 		wrPin_low; // WE low
 1624               		.loc 1 699 0
 1625 0462 9698      		cbi 0x12,6
 700:setup.c       **** 		asm volatile("nop");
 1626               		.loc 1 700 0
 1627               	/* #APP */
 1628               	 ;  700 "setup.c" 1
 1629 0464 0000      		nop
 1630               	 ;  0 "" 2
 701:setup.c       **** 		asm volatile("nop");
 1631               		.loc 1 701 0
 1632               	 ;  701 "setup.c" 1
 1633 0466 0000      		nop
 1634               	 ;  0 "" 2
 702:setup.c       **** 		asm volatile("nop");
 1635               		.loc 1 702 0
 1636               	 ;  702 "setup.c" 1
 1637 0468 0000      		nop
 1638               	 ;  0 "" 2
 703:setup.c       **** 		wrPin_high; // WE high
 1639               		.loc 1 703 0
 1640               	/* #NOAPP */
 1641 046a 969A      		sbi 0x12,6
 1642 046c 0895      		ret
 1643               		.cfi_endproc
 1644               	.LFE39:
 1646               	.global	gb_flash_write_byte
 1648               	gb_flash_write_byte:
 1649               	.LFB40:
 704:setup.c       **** 	}
 705:setup.c       **** }
 706:setup.c       **** 
 707:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte.
 708:setup.c       **** void gb_flash_write_byte(uint16_t address, uint8_t data) {
 1650               		.loc 1 708 0
 1651               		.cfi_startproc
 1652               	.LVL124:
 1653 046e 0F93      		push r16
 1654               	.LCFI26:
 1655               		.cfi_def_cfa_offset 3
 1656               		.cfi_offset 16, -2
 1657 0470 1F93      		push r17
 1658               	.LCFI27:
 1659               		.cfi_def_cfa_offset 4
 1660               		.cfi_offset 17, -3
 1661 0472 CF93      		push r28
 1662               	.LCFI28:
 1663               		.cfi_def_cfa_offset 5
 1664               		.cfi_offset 28, -4
 1665               	/* prologue: function */
 1666               	/* frame size = 0 */
 1667               	/* stack size = 3 */
 1668               	.L__stack_usage = 3
 1669 0474 8C01      		movw r16,r24
 1670 0476 C62F      		mov r28,r22
 709:setup.c       **** 	DDR_DATA7_0 = 0xFF; // Set data pins as outputs
 1671               		.loc 1 709 0
 1672 0478 8FEF      		ldi r24,lo8(-1)
 1673               	.LVL125:
 1674 047a 84BB      		out 0x14,r24
 710:setup.c       **** 	
 711:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1675               		.loc 1 711 0
 1676 047c 6091 0000 		lds r22,flashWriteCycle+2
 1677               	.LVL126:
 1678 0480 8091 0000 		lds r24,flashWriteCycle
 1679 0484 9091 0000 		lds r25,flashWriteCycle+1
 1680 0488 00D0      		rcall gb_flash_write_bus_cycle_fast
 1681               	.LVL127:
 712:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1682               		.loc 1 712 0
 1683 048a 6091 0000 		lds r22,flashWriteCycle+6
 1684 048e 8091 0000 		lds r24,flashWriteCycle+4
 1685 0492 9091 0000 		lds r25,flashWriteCycle+4+1
 1686 0496 00D0      		rcall gb_flash_write_bus_cycle_fast
 1687               	.LVL128:
 713:setup.c       **** 	gb_flash_write_bus_cycle_fast(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1688               		.loc 1 713 0
 1689 0498 6091 0000 		lds r22,flashWriteCycle+10
 1690 049c 8091 0000 		lds r24,flashWriteCycle+8
 1691 04a0 9091 0000 		lds r25,flashWriteCycle+8+1
 1692 04a4 00D0      		rcall gb_flash_write_bus_cycle_fast
 1693               	.LVL129:
 714:setup.c       **** 	gb_flash_write_bus_cycle_fast(address, data);
 1694               		.loc 1 714 0
 1695 04a6 6C2F      		mov r22,r28
 1696 04a8 C801      		movw r24,r16
 1697 04aa 00D0      		rcall gb_flash_write_bus_cycle_fast
 1698               	.LVL130:
 1699               	.LBB172:
 1700               	.LBB173:
 1701               		.loc 2 276 0
 1702 04ac 8DE0      		ldi r24,lo8(13)
 1703 04ae 8A95      	1:	dec r24
 1704 04b0 01F4      		brne 1b
 1705 04b2 0000      		nop
 1706               	.LVL131:
 1707               	.LBE173:
 1708               	.LBE172:
 715:setup.c       **** 	_delay_us(5); // Wait byte program time
 716:setup.c       **** 	
 717:setup.c       **** 	// Set data pins inputs
 718:setup.c       **** 	PORT_DATA7_0 = 0;
 1709               		.loc 1 718 0
 1710 04b4 15BA      		out 0x15,__zero_reg__
 719:setup.c       **** 	DDR_DATA7_0 = 0;
 1711               		.loc 1 719 0
 1712 04b6 14BA      		out 0x14,__zero_reg__
 720:setup.c       **** 	
 721:setup.c       **** 	// Verify data
 722:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte_fast();
 1713               		.loc 1 722 0
 1714 04b8 00D0      		rcall gb_flash_read_byte_fast
 1715               	.LVL132:
 1716               	.L77:
 723:setup.c       **** 	while (data != dataVerify) {
 1717               		.loc 1 723 0
 1718 04ba 8C17      		cp r24,r28
 1719 04bc 01F0      		breq .L76
 724:setup.c       **** 		dataVerify = gb_flash_read_byte_fast();
 1720               		.loc 1 724 0
 1721 04be 00D0      		rcall gb_flash_read_byte_fast
 1722               	.LVL133:
 1723               	.LBB174:
 1724               	.LBB175:
 1725               		.loc 2 276 0
 1726 04c0 92E0      		ldi r25,lo8(2)
 1727 04c2 9A95      	1:	dec r25
 1728 04c4 01F4      		brne 1b
 1729 04c6 00C0      		rjmp .
 1730               	.LVL134:
 1731               	.LBE175:
 1732               	.LBE174:
 725:setup.c       **** 		_delay_us(1);
 726:setup.c       **** 		if (writingTimedout == 1) {
 1733               		.loc 1 726 0
 1734 04c8 9091 0000 		lds r25,writingTimedout
 1735 04cc 9130      		cpi r25,lo8(1)
 1736 04ce 01F4      		brne .L77
 1737               	.L76:
 1738               	/* epilogue start */
 727:setup.c       **** 			break;
 728:setup.c       **** 		}
 729:setup.c       **** 	}
 730:setup.c       **** }
 1739               		.loc 1 730 0
 1740 04d0 CF91      		pop r28
 1741               	.LVL135:
 1742 04d2 1F91      		pop r17
 1743 04d4 0F91      		pop r16
 1744               	.LVL136:
 1745 04d6 0895      		ret
 1746               		.cfi_endproc
 1747               	.LFE40:
 1749               	.global	gb_flash_write_byte_special
 1751               	gb_flash_write_byte_special:
 1752               	.LFB41:
 731:setup.c       **** 
 732:setup.c       **** // Set the bank, write a single byte to the Flash address and pulse the reset pin
 733:setup.c       **** void gb_flash_write_byte_special(uint16_t address, uint8_t data) {
 1753               		.loc 1 733 0
 1754               		.cfi_startproc
 1755               	.LVL137:
 1756 04d8 1F93      		push r17
 1757               	.LCFI29:
 1758               		.cfi_def_cfa_offset 3
 1759               		.cfi_offset 17, -2
 1760 04da CF93      		push r28
 1761               	.LCFI30:
 1762               		.cfi_def_cfa_offset 4
 1763               		.cfi_offset 28, -3
 1764 04dc DF93      		push r29
 1765               	.LCFI31:
 1766               		.cfi_def_cfa_offset 5
 1767               		.cfi_offset 29, -4
 1768               	/* prologue: function */
 1769               	/* frame size = 0 */
 1770               	/* stack size = 3 */
 1771               	.L__stack_usage = 3
 1772 04de EC01      		movw r28,r24
 1773 04e0 162F      		mov r17,r22
 734:setup.c       **** 	// Set bank back
 735:setup.c       **** 	if (flashBank1CommandWrites == 1) {
 1774               		.loc 1 735 0
 1775 04e2 8091 0000 		lds r24,flashBank1CommandWrites
 1776               	.LVL138:
 1777 04e6 8130      		cpi r24,lo8(1)
 1778 04e8 01F4      		brne .L82
 736:setup.c       **** 		write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 1779               		.loc 1 736 0
 1780 04ea 40E0      		ldi r20,0
 1781 04ec 6091 0000 		lds r22,lastBankAccessed
 1782               	.LVL139:
 1783 04f0 80E0      		ldi r24,0
 1784 04f2 91E2      		ldi r25,lo8(33)
 1785 04f4 00D0      		rcall write_8bit_data
 1786               	.LVL140:
 1787               	.LBB176:
 1788               	.LBB177:
 1789               		.loc 2 276 0
 1790 04f6 85E8      		ldi r24,lo8(-123)
 1791 04f8 8A95      	1:	dec r24
 1792 04fa 01F4      		brne 1b
 1793 04fc 0000      		nop
 1794               	.LVL141:
 1795               	.L82:
 1796               	.LBE177:
 1797               	.LBE176:
 737:setup.c       **** 		_delay_us(50);
 738:setup.c       **** 	}
 739:setup.c       **** 	
 740:setup.c       **** 	// Write
 741:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1798               		.loc 1 741 0
 1799 04fe 6091 0000 		lds r22,flashWriteCycle+2
 1800 0502 8091 0000 		lds r24,flashWriteCycle
 1801 0506 9091 0000 		lds r25,flashWriteCycle+1
 1802 050a 00D0      		rcall gb_flash_write_bus_cycle
 1803               	.LVL142:
 742:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1804               		.loc 1 742 0
 1805 050c 6091 0000 		lds r22,flashWriteCycle+6
 1806 0510 8091 0000 		lds r24,flashWriteCycle+4
 1807 0514 9091 0000 		lds r25,flashWriteCycle+4+1
 1808 0518 00D0      		rcall gb_flash_write_bus_cycle
 1809               	.LVL143:
 743:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1810               		.loc 1 743 0
 1811 051a 6091 0000 		lds r22,flashWriteCycle+10
 1812 051e 8091 0000 		lds r24,flashWriteCycle+8
 1813 0522 9091 0000 		lds r25,flashWriteCycle+8+1
 1814 0526 00D0      		rcall gb_flash_write_bus_cycle
 1815               	.LVL144:
 744:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1816               		.loc 1 744 0
 1817 0528 612F      		mov r22,r17
 1818 052a CE01      		movw r24,r28
 1819 052c 00D0      		rcall gb_flash_write_bus_cycle
 1820               	.LVL145:
 1821               	.LBB178:
 1822               	.LBB179:
 1823               		.loc 2 276 0
 1824 052e 83EF      		ldi r24,lo8(499)
 1825 0530 91E0      		ldi r25,hi8(499)
 1826 0532 0197      	1:	sbiw r24,1
 1827 0534 01F4      		brne 1b
 1828 0536 00C0      		rjmp .
 1829 0538 0000      		nop
 1830               	.LVL146:
 1831               	.LBE179:
 1832               	.LBE178:
 745:setup.c       **** 	_delay_us(250); // Wait byte program time
 746:setup.c       **** 	
 747:setup.c       **** 	// Set data pins inputs
 748:setup.c       **** 	PORT_DATA7_0 = 0;
 1833               		.loc 1 748 0
 1834 053a 15BA      		out 0x15,__zero_reg__
 749:setup.c       **** 	DDR_DATA7_0 = 0;
 1835               		.loc 1 749 0
 1836 053c 14BA      		out 0x14,__zero_reg__
 750:setup.c       **** 	
 751:setup.c       **** 	// Pulse reset
 752:setup.c       **** 	PORTE &= ~(1<<CS2_PIN);
 1837               		.loc 1 752 0
 1838 053e 3A98      		cbi 0x7,2
 1839               	.LVL147:
 1840               	.LBB180:
 1841               	.LBB181:
 1842               		.loc 2 276 0
 1843 0540 95E8      		ldi r25,lo8(-123)
 1844 0542 9A95      	1:	dec r25
 1845 0544 01F4      		brne 1b
 1846 0546 0000      		nop
 1847               	.LVL148:
 1848               	.LBE181:
 1849               	.LBE180:
 753:setup.c       **** 	_delay_us(50);
 754:setup.c       **** 	PORTE |= (1<<CS2_PIN);
 1850               		.loc 1 754 0
 1851 0548 3A9A      		sbi 0x7,2
 1852               	.LVL149:
 1853               	.LBB182:
 1854               	.LBB183:
 1855               		.loc 2 276 0
 1856 054a 85E8      		ldi r24,lo8(-123)
 1857 054c 8A95      	1:	dec r24
 1858 054e 01F4      		brne 1b
 1859 0550 0000      		nop
 1860               	.LVL150:
 1861               	/* epilogue start */
 1862               	.LBE183:
 1863               	.LBE182:
 755:setup.c       **** 	_delay_us(50);
 756:setup.c       **** }
 1864               		.loc 1 756 0
 1865 0552 DF91      		pop r29
 1866 0554 CF91      		pop r28
 1867               	.LVL151:
 1868 0556 1F91      		pop r17
 1869               	.LVL152:
 1870 0558 0895      		ret
 1871               		.cfi_endproc
 1872               	.LFE41:
 1874               	.global	gb_flash_write_byte_bank1_commands
 1876               	gb_flash_write_byte_bank1_commands:
 1877               	.LFB42:
 757:setup.c       **** 
 758:setup.c       **** // Write a single byte to the Flash address. Takes 10-50us to program each byte. 
 759:setup.c       **** // Switch to bank 1 to issue flash commands, then switch back to the bank we were at before
 760:setup.c       **** void gb_flash_write_byte_bank1_commands(uint16_t address, uint8_t data) {
 1878               		.loc 1 760 0
 1879               		.cfi_startproc
 1880               	.LVL153:
 1881 055a FF92      		push r15
 1882               	.LCFI32:
 1883               		.cfi_def_cfa_offset 3
 1884               		.cfi_offset 15, -2
 1885 055c 0F93      		push r16
 1886               	.LCFI33:
 1887               		.cfi_def_cfa_offset 4
 1888               		.cfi_offset 16, -3
 1889 055e 1F93      		push r17
 1890               	.LCFI34:
 1891               		.cfi_def_cfa_offset 5
 1892               		.cfi_offset 17, -4
 1893 0560 CF93      		push r28
 1894               	.LCFI35:
 1895               		.cfi_def_cfa_offset 6
 1896               		.cfi_offset 28, -5
 1897 0562 DF93      		push r29
 1898               	.LCFI36:
 1899               		.cfi_def_cfa_offset 7
 1900               		.cfi_offset 29, -6
 1901               	/* prologue: function */
 1902               	/* frame size = 0 */
 1903               	/* stack size = 5 */
 1904               	.L__stack_usage = 5
 1905 0564 EC01      		movw r28,r24
 1906 0566 162F      		mov r17,r22
 761:setup.c       **** 	// Set bank 1
 762:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1907               		.loc 1 762 0
 1908 0568 FF24      		clr r15
 1909 056a FA94      		dec r15
 1910 056c F4BA      		out 0x14,r15
 1911               	.LVL154:
 1912               	.LBB184:
 1913               	.LBB185:
 256:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1914               		.loc 1 256 0
 1915 056e 01E2      		ldi r16,lo8(33)
 1916 0570 0BBB      		out 0x1b,r16
 257:setup.c       **** }
 1917               		.loc 1 257 0
 1918 0572 18BA      		out 0x18,__zero_reg__
 1919               	.LVL155:
 1920               	.LBE185:
 1921               	.LBE184:
 763:setup.c       **** 	set_16bit_address(0x2100);
 764:setup.c       **** 	PORT_DATA7_0 = 1;
 1922               		.loc 1 764 0
 1923 0574 81E0      		ldi r24,lo8(1)
 1924               	.LVL156:
 1925 0576 85BB      		out 0x15,r24
 765:setup.c       **** 	wrPin_low; // Pulse WR
 1926               		.loc 1 765 0
 1927 0578 9698      		cbi 0x12,6
 766:setup.c       **** 	asm volatile("nop");
 1928               		.loc 1 766 0
 1929               	/* #APP */
 1930               	 ;  766 "setup.c" 1
 1931 057a 0000      		nop
 1932               	 ;  0 "" 2
 767:setup.c       **** 	wrPin_high;
 1933               		.loc 1 767 0
 1934               	/* #NOAPP */
 1935 057c 969A      		sbi 0x12,6
 768:setup.c       **** 	
 769:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[0][0], flashWriteCycle[0][1]);
 1936               		.loc 1 769 0
 1937 057e 6091 0000 		lds r22,flashWriteCycle+2
 1938               	.LVL157:
 1939 0582 8091 0000 		lds r24,flashWriteCycle
 1940 0586 9091 0000 		lds r25,flashWriteCycle+1
 1941 058a 00D0      		rcall gb_flash_write_bus_cycle
 1942               	.LVL158:
 770:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[1][0], flashWriteCycle[1][1]);
 1943               		.loc 1 770 0
 1944 058c 6091 0000 		lds r22,flashWriteCycle+6
 1945 0590 8091 0000 		lds r24,flashWriteCycle+4
 1946 0594 9091 0000 		lds r25,flashWriteCycle+4+1
 1947 0598 00D0      		rcall gb_flash_write_bus_cycle
 1948               	.LVL159:
 771:setup.c       **** 	gb_flash_write_bus_cycle(flashWriteCycle[2][0], flashWriteCycle[2][1]);
 1949               		.loc 1 771 0
 1950 059a 6091 0000 		lds r22,flashWriteCycle+10
 1951 059e 8091 0000 		lds r24,flashWriteCycle+8
 1952 05a2 9091 0000 		lds r25,flashWriteCycle+8+1
 1953 05a6 00D0      		rcall gb_flash_write_bus_cycle
 1954               	.LVL160:
 772:setup.c       **** 	
 773:setup.c       **** 	
 774:setup.c       **** 	// Set bank back
 775:setup.c       **** 	DDR_DATA7_0 = 0xFF;
 1955               		.loc 1 775 0
 1956 05a8 F4BA      		out 0x14,r15
 1957               	.LVL161:
 1958               	.LBB186:
 1959               	.LBB187:
 256:setup.c       **** 	PORT_ADDR7_0 = (address & 0xFF);
 1960               		.loc 1 256 0
 1961 05aa 0BBB      		out 0x1b,r16
 257:setup.c       **** }
 1962               		.loc 1 257 0
 1963 05ac 18BA      		out 0x18,__zero_reg__
 1964               	.LVL162:
 1965               	.LBE187:
 1966               	.LBE186:
 776:setup.c       **** 	set_16bit_address(0x2100);
 777:setup.c       **** 	PORT_DATA7_0 = lastBankAccessed;
 1967               		.loc 1 777 0
 1968 05ae 8091 0000 		lds r24,lastBankAccessed
 1969 05b2 85BB      		out 0x15,r24
 778:setup.c       **** 	wrPin_low; // Pulse WR
 1970               		.loc 1 778 0
 1971 05b4 9698      		cbi 0x12,6
 779:setup.c       **** 	asm volatile("nop");
 1972               		.loc 1 779 0
 1973               	/* #APP */
 1974               	 ;  779 "setup.c" 1
 1975 05b6 0000      		nop
 1976               	 ;  0 "" 2
 780:setup.c       **** 	wrPin_high;
 1977               		.loc 1 780 0
 1978               	/* #NOAPP */
 1979 05b8 969A      		sbi 0x12,6
 781:setup.c       **** 	
 782:setup.c       **** 	gb_flash_write_bus_cycle(address, data);
 1980               		.loc 1 782 0
 1981 05ba 612F      		mov r22,r17
 1982 05bc CE01      		movw r24,r28
 1983 05be 00D0      		rcall gb_flash_write_bus_cycle
 1984               	.LVL163:
 1985               	.LBB188:
 1986               	.LBB189:
 1987               		.loc 2 276 0
 1988 05c0 8AE1      		ldi r24,lo8(26)
 1989 05c2 8A95      	1:	dec r24
 1990 05c4 01F4      		brne 1b
 1991 05c6 00C0      		rjmp .
 1992               	.LVL164:
 1993               	.LBE189:
 1994               	.LBE188:
 783:setup.c       **** 	_delay_us(10); // Wait byte program time
 784:setup.c       **** 	
 785:setup.c       **** 	// Set data pins inputs
 786:setup.c       **** 	PORT_DATA7_0 = 0;
 1995               		.loc 1 786 0
 1996 05c8 15BA      		out 0x15,__zero_reg__
 787:setup.c       **** 	DDR_DATA7_0 = 0;
 1997               		.loc 1 787 0
 1998 05ca 14BA      		out 0x14,__zero_reg__
 788:setup.c       **** 	
 789:setup.c       **** 	// Verify data
 790:setup.c       **** 	uint8_t dataVerify = gb_flash_read_byte(address);
 1999               		.loc 1 790 0
 2000 05cc CE01      		movw r24,r28
 2001 05ce 00D0      		rcall gb_flash_read_byte
 2002               	.LVL165:
 2003               	.L84:
 791:setup.c       **** 	while (data != dataVerify) {
 2004               		.loc 1 791 0
 2005 05d0 8117      		cp r24,r17
 2006 05d2 01F0      		breq .L83
 792:setup.c       **** 		dataVerify = gb_flash_read_byte(address);
 2007               		.loc 1 792 0
 2008 05d4 CE01      		movw r24,r28
 2009               	.LVL166:
 2010 05d6 00D0      		rcall gb_flash_read_byte
 2011               	.LVL167:
 2012               	.LBB190:
 2013               	.LBB191:
 2014               		.loc 2 276 0
 2015 05d8 9DE0      		ldi r25,lo8(13)
 2016 05da 9A95      	1:	dec r25
 2017 05dc 01F4      		brne 1b
 2018 05de 0000      		nop
 2019               	.LVL168:
 2020               	.LBE191:
 2021               	.LBE190:
 793:setup.c       **** 		_delay_us(5);
 794:setup.c       **** 		if (writingTimedout == 1) {
 2022               		.loc 1 794 0
 2023 05e0 9091 0000 		lds r25,writingTimedout
 2024 05e4 9130      		cpi r25,lo8(1)
 2025 05e6 01F4      		brne .L84
 2026               	.L83:
 2027               	/* epilogue start */
 795:setup.c       **** 			break;
 796:setup.c       **** 		}
 797:setup.c       **** 	}
 798:setup.c       **** }
 2028               		.loc 1 798 0
 2029 05e8 DF91      		pop r29
 2030 05ea CF91      		pop r28
 2031               	.LVL169:
 2032 05ec 1F91      		pop r17
 2033               	.LVL170:
 2034 05ee 0F91      		pop r16
 2035 05f0 FF90      		pop r15
 2036 05f2 0895      		ret
 2037               		.cfi_endproc
 2038               	.LFE42:
 2040               	.global	gba_flash_write_bus_cycle
 2042               	gba_flash_write_bus_cycle:
 2043               	.LFB43:
 799:setup.c       **** 
 800:setup.c       **** 
 801:setup.c       **** 
 802:setup.c       **** // ---------- GBA FLASH CARTS ----------
 803:setup.c       **** 
 804:setup.c       **** // Set the 24 bit address and 16 bit data for the write byte cycle to the flash (pulse WR pin)
 805:setup.c       **** void gba_flash_write_bus_cycle(uint32_t address, uint16_t data) {
 2044               		.loc 1 805 0
 2045               		.cfi_startproc
 2046               	.LVL171:
 2047 05f4 0F93      		push r16
 2048               	.LCFI37:
 2049               		.cfi_def_cfa_offset 3
 2050               		.cfi_offset 16, -2
 2051 05f6 1F93      		push r17
 2052               	.LCFI38:
 2053               		.cfi_def_cfa_offset 4
 2054               		.cfi_offset 17, -3
 2055               	/* prologue: function */
 2056               	/* frame size = 0 */
 2057               	/* stack size = 2 */
 2058               	.L__stack_usage = 2
 806:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = (address >> 16);
 2059               		.loc 1 806 0
 2060 05f8 8C01      		movw r16,r24
 2061 05fa 2227      		clr r18
 2062 05fc 3327      		clr r19
 2063 05fe 05BB      		out 0x15,r16
 807:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = (address >> 8);
 2064               		.loc 1 807 0
 2065 0600 072F      		mov r16,r23
 2066 0602 182F      		mov r17,r24
 2067 0604 292F      		mov r18,r25
 2068 0606 3327      		clr r19
 2069 0608 0BBB      		out 0x1b,r16
 808:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = (address & 0xFF);
 2070               		.loc 1 808 0
 2071 060a 68BB      		out 0x18,r22
 809:setup.c       **** 	
 810:setup.c       **** 	cs_mreqPin_low;
 2072               		.loc 1 810 0
 2073 060c 9498      		cbi 0x12,4
 811:setup.c       **** 	
 812:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = data >> 8; // Set data
 2074               		.loc 1 812 0
 2075 060e 5BBB      		out 0x1b,r21
 813:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = data & 0xFF;
 2076               		.loc 1 813 0
 2077 0610 48BB      		out 0x18,r20
 814:setup.c       **** 	
 815:setup.c       **** 	wrPin_low;
 2078               		.loc 1 815 0
 2079 0612 9698      		cbi 0x12,6
 816:setup.c       **** 	asm volatile("nop");
 2080               		.loc 1 816 0
 2081               	/* #APP */
 2082               	 ;  816 "setup.c" 1
 2083 0614 0000      		nop
 2084               	 ;  0 "" 2
 817:setup.c       **** 	asm volatile("nop");
 2085               		.loc 1 817 0
 2086               	 ;  817 "setup.c" 1
 2087 0616 0000      		nop
 2088               	 ;  0 "" 2
 818:setup.c       **** 	asm volatile("nop");
 2089               		.loc 1 818 0
 2090               	 ;  818 "setup.c" 1
 2091 0618 0000      		nop
 2092               	 ;  0 "" 2
 819:setup.c       **** 	wrPin_high;
 2093               		.loc 1 819 0
 2094               	/* #NOAPP */
 2095 061a 969A      		sbi 0x12,6
 820:setup.c       **** 	cs_mreqPin_high;
 2096               		.loc 1 820 0
 2097 061c 949A      		sbi 0x12,4
 2098               	/* epilogue start */
 821:setup.c       **** }
 2099               		.loc 1 821 0
 2100 061e 1F91      		pop r17
 2101 0620 0F91      		pop r16
 2102 0622 0895      		ret
 2103               		.cfi_endproc
 2104               	.LFE43:
 2106               	.global	gba_flash_write_cycle_start_swapped
 2108               	gba_flash_write_cycle_start_swapped:
 2109               	.LFB44:
 822:setup.c       **** 
 823:setup.c       **** // Send the first 3 write cycles to the flash (swapped D0/D1)
 824:setup.c       **** void gba_flash_write_cycle_start_swapped(void) {
 2110               		.loc 1 824 0
 2111               		.cfi_startproc
 2112               	/* prologue: function */
 2113               	/* frame size = 0 */
 2114               	/* stack size = 0 */
 2115               	.L__stack_usage = 0
 825:setup.c       **** 	// Set outputs
 826:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2116               		.loc 1 826 0
 2117 0624 8FEF      		ldi r24,lo8(-1)
 2118 0626 84BB      		out 0x14,r24
 827:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2119               		.loc 1 827 0
 2120 0628 8ABB      		out 0x1a,r24
 828:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2121               		.loc 1 828 0
 2122 062a 87BB      		out 0x17,r24
 829:setup.c       **** 	
 830:setup.c       **** 	// 0x555, 0xA9
 831:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2123               		.loc 1 831 0
 2124 062c 15BA      		out 0x15,__zero_reg__
 832:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2125               		.loc 1 832 0
 2126 062e 95E0      		ldi r25,lo8(5)
 2127 0630 9BBB      		out 0x1b,r25
 833:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2128               		.loc 1 833 0
 2129 0632 85E5      		ldi r24,lo8(85)
 2130 0634 88BB      		out 0x18,r24
 834:setup.c       **** 	cs_mreqPin_low;
 2131               		.loc 1 834 0
 2132 0636 9498      		cbi 0x12,4
 835:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2133               		.loc 1 835 0
 2134 0638 1BBA      		out 0x1b,__zero_reg__
 836:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA9;
 2135               		.loc 1 836 0
 2136 063a 29EA      		ldi r18,lo8(-87)
 2137 063c 28BB      		out 0x18,r18
 837:setup.c       **** 	wrPin_low;
 2138               		.loc 1 837 0
 2139 063e 9698      		cbi 0x12,6
 838:setup.c       **** 	asm volatile("nop");
 2140               		.loc 1 838 0
 2141               	/* #APP */
 2142               	 ;  838 "setup.c" 1
 2143 0640 0000      		nop
 2144               	 ;  0 "" 2
 839:setup.c       **** 	asm volatile("nop");
 2145               		.loc 1 839 0
 2146               	 ;  839 "setup.c" 1
 2147 0642 0000      		nop
 2148               	 ;  0 "" 2
 840:setup.c       **** 	asm volatile("nop");
 2149               		.loc 1 840 0
 2150               	 ;  840 "setup.c" 1
 2151 0644 0000      		nop
 2152               	 ;  0 "" 2
 841:setup.c       **** 	wrPin_high;
 2153               		.loc 1 841 0
 2154               	/* #NOAPP */
 2155 0646 969A      		sbi 0x12,6
 842:setup.c       **** 	cs_mreqPin_high;
 2156               		.loc 1 842 0
 2157 0648 949A      		sbi 0x12,4
 843:setup.c       **** 	
 844:setup.c       **** 	// 0x2AA, 0x56
 845:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2158               		.loc 1 845 0
 2159 064a 15BA      		out 0x15,__zero_reg__
 846:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2160               		.loc 1 846 0
 2161 064c 22E0      		ldi r18,lo8(2)
 2162 064e 2BBB      		out 0x1b,r18
 847:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2163               		.loc 1 847 0
 2164 0650 2AEA      		ldi r18,lo8(-86)
 2165 0652 28BB      		out 0x18,r18
 848:setup.c       **** 	cs_mreqPin_low;
 2166               		.loc 1 848 0
 2167 0654 9498      		cbi 0x12,4
 849:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2168               		.loc 1 849 0
 2169 0656 1BBA      		out 0x1b,__zero_reg__
 850:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x56;
 2170               		.loc 1 850 0
 2171 0658 26E5      		ldi r18,lo8(86)
 2172 065a 28BB      		out 0x18,r18
 851:setup.c       **** 	wrPin_low;
 2173               		.loc 1 851 0
 2174 065c 9698      		cbi 0x12,6
 852:setup.c       **** 	asm volatile("nop");
 2175               		.loc 1 852 0
 2176               	/* #APP */
 2177               	 ;  852 "setup.c" 1
 2178 065e 0000      		nop
 2179               	 ;  0 "" 2
 853:setup.c       **** 	asm volatile("nop");
 2180               		.loc 1 853 0
 2181               	 ;  853 "setup.c" 1
 2182 0660 0000      		nop
 2183               	 ;  0 "" 2
 854:setup.c       **** 	asm volatile("nop");
 2184               		.loc 1 854 0
 2185               	 ;  854 "setup.c" 1
 2186 0662 0000      		nop
 2187               	 ;  0 "" 2
 855:setup.c       **** 	wrPin_high;
 2188               		.loc 1 855 0
 2189               	/* #NOAPP */
 2190 0664 969A      		sbi 0x12,6
 856:setup.c       **** 	cs_mreqPin_high;
 2191               		.loc 1 856 0
 2192 0666 949A      		sbi 0x12,4
 857:setup.c       **** 	
 858:setup.c       **** 	// 0x555, 0xA0;
 859:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2193               		.loc 1 859 0
 2194 0668 15BA      		out 0x15,__zero_reg__
 860:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2195               		.loc 1 860 0
 2196 066a 9BBB      		out 0x1b,r25
 861:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2197               		.loc 1 861 0
 2198 066c 88BB      		out 0x18,r24
 862:setup.c       **** 	cs_mreqPin_low;
 2199               		.loc 1 862 0
 2200 066e 9498      		cbi 0x12,4
 863:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2201               		.loc 1 863 0
 2202 0670 1BBA      		out 0x1b,__zero_reg__
 864:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2203               		.loc 1 864 0
 2204 0672 80EA      		ldi r24,lo8(-96)
 2205 0674 88BB      		out 0x18,r24
 865:setup.c       **** 	wrPin_low;
 2206               		.loc 1 865 0
 2207 0676 9698      		cbi 0x12,6
 866:setup.c       **** 	asm volatile("nop");
 2208               		.loc 1 866 0
 2209               	/* #APP */
 2210               	 ;  866 "setup.c" 1
 2211 0678 0000      		nop
 2212               	 ;  0 "" 2
 867:setup.c       **** 	asm volatile("nop");
 2213               		.loc 1 867 0
 2214               	 ;  867 "setup.c" 1
 2215 067a 0000      		nop
 2216               	 ;  0 "" 2
 868:setup.c       **** 	asm volatile("nop");
 2217               		.loc 1 868 0
 2218               	 ;  868 "setup.c" 1
 2219 067c 0000      		nop
 2220               	 ;  0 "" 2
 869:setup.c       **** 	wrPin_high;
 2221               		.loc 1 869 0
 2222               	/* #NOAPP */
 2223 067e 969A      		sbi 0x12,6
 870:setup.c       **** 	cs_mreqPin_high;
 2224               		.loc 1 870 0
 2225 0680 949A      		sbi 0x12,4
 2226 0682 0895      		ret
 2227               		.cfi_endproc
 2228               	.LFE44:
 2230               	.global	gba_flash_write_cycle_start
 2232               	gba_flash_write_cycle_start:
 2233               	.LFB45:
 871:setup.c       **** }
 872:setup.c       **** 
 873:setup.c       **** 
 874:setup.c       **** // Send the first 3 write cycles to the flash
 875:setup.c       **** void gba_flash_write_cycle_start(void) {
 2234               		.loc 1 875 0
 2235               		.cfi_startproc
 2236               	/* prologue: function */
 2237               	/* frame size = 0 */
 2238               	/* stack size = 0 */
 2239               	.L__stack_usage = 0
 876:setup.c       **** 	// Set outputs
 877:setup.c       **** 	GBA_DDR_ROM_ADDR23_16 = 0xFF;
 2240               		.loc 1 877 0
 2241 0684 8FEF      		ldi r24,lo8(-1)
 2242 0686 84BB      		out 0x14,r24
 878:setup.c       **** 	GBA_DDR_ROM_ADDR15_8 = 0xFF;
 2243               		.loc 1 878 0
 2244 0688 8ABB      		out 0x1a,r24
 879:setup.c       **** 	GBA_DDR_ROM_ADDR7_0 = 0xFF;
 2245               		.loc 1 879 0
 2246 068a 87BB      		out 0x17,r24
 880:setup.c       **** 	
 881:setup.c       **** 	// 0x555, 0xAA
 882:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2247               		.loc 1 882 0
 2248 068c 15BA      		out 0x15,__zero_reg__
 883:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2249               		.loc 1 883 0
 2250 068e 95E0      		ldi r25,lo8(5)
 2251 0690 9BBB      		out 0x1b,r25
 884:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2252               		.loc 1 884 0
 2253 0692 85E5      		ldi r24,lo8(85)
 2254 0694 88BB      		out 0x18,r24
 885:setup.c       **** 	cs_mreqPin_low;
 2255               		.loc 1 885 0
 2256 0696 9498      		cbi 0x12,4
 886:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2257               		.loc 1 886 0
 2258 0698 1BBA      		out 0x1b,__zero_reg__
 887:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xAA;
 2259               		.loc 1 887 0
 2260 069a 2AEA      		ldi r18,lo8(-86)
 2261 069c 28BB      		out 0x18,r18
 888:setup.c       **** 	wrPin_low;
 2262               		.loc 1 888 0
 2263 069e 9698      		cbi 0x12,6
 889:setup.c       **** 	asm volatile("nop");
 2264               		.loc 1 889 0
 2265               	/* #APP */
 2266               	 ;  889 "setup.c" 1
 2267 06a0 0000      		nop
 2268               	 ;  0 "" 2
 890:setup.c       **** 	asm volatile("nop");
 2269               		.loc 1 890 0
 2270               	 ;  890 "setup.c" 1
 2271 06a2 0000      		nop
 2272               	 ;  0 "" 2
 891:setup.c       **** 	asm volatile("nop");
 2273               		.loc 1 891 0
 2274               	 ;  891 "setup.c" 1
 2275 06a4 0000      		nop
 2276               	 ;  0 "" 2
 892:setup.c       **** 	wrPin_high;
 2277               		.loc 1 892 0
 2278               	/* #NOAPP */
 2279 06a6 969A      		sbi 0x12,6
 893:setup.c       **** 	cs_mreqPin_high;
 2280               		.loc 1 893 0
 2281 06a8 949A      		sbi 0x12,4
 894:setup.c       **** 	
 895:setup.c       **** 	// 0x2AA, 0x55
 896:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2282               		.loc 1 896 0
 2283 06aa 15BA      		out 0x15,__zero_reg__
 897:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x02;
 2284               		.loc 1 897 0
 2285 06ac 32E0      		ldi r19,lo8(2)
 2286 06ae 3BBB      		out 0x1b,r19
 898:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0xAA;
 2287               		.loc 1 898 0
 2288 06b0 28BB      		out 0x18,r18
 899:setup.c       **** 	cs_mreqPin_low;
 2289               		.loc 1 899 0
 2290 06b2 9498      		cbi 0x12,4
 900:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2291               		.loc 1 900 0
 2292 06b4 1BBA      		out 0x1b,__zero_reg__
 901:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0x55;
 2293               		.loc 1 901 0
 2294 06b6 88BB      		out 0x18,r24
 902:setup.c       **** 	wrPin_low;
 2295               		.loc 1 902 0
 2296 06b8 9698      		cbi 0x12,6
 903:setup.c       **** 	asm volatile("nop");
 2297               		.loc 1 903 0
 2298               	/* #APP */
 2299               	 ;  903 "setup.c" 1
 2300 06ba 0000      		nop
 2301               	 ;  0 "" 2
 904:setup.c       **** 	asm volatile("nop");
 2302               		.loc 1 904 0
 2303               	 ;  904 "setup.c" 1
 2304 06bc 0000      		nop
 2305               	 ;  0 "" 2
 905:setup.c       **** 	asm volatile("nop");
 2306               		.loc 1 905 0
 2307               	 ;  905 "setup.c" 1
 2308 06be 0000      		nop
 2309               	 ;  0 "" 2
 906:setup.c       **** 	wrPin_high;
 2310               		.loc 1 906 0
 2311               	/* #NOAPP */
 2312 06c0 969A      		sbi 0x12,6
 907:setup.c       **** 	cs_mreqPin_high;
 2313               		.loc 1 907 0
 2314 06c2 949A      		sbi 0x12,4
 908:setup.c       **** 	
 909:setup.c       **** 	// 0x555, 0xA0;
 910:setup.c       **** 	GBA_PORT_ROM_ADDR23_16 = 0;
 2315               		.loc 1 910 0
 2316 06c4 15BA      		out 0x15,__zero_reg__
 911:setup.c       **** 	GBA_PORT_ROM_ADDR15_8 = 0x05;
 2317               		.loc 1 911 0
 2318 06c6 9BBB      		out 0x1b,r25
 912:setup.c       **** 	GBA_PORT_ROM_ADDR7_0 = 0x55;
 2319               		.loc 1 912 0
 2320 06c8 88BB      		out 0x18,r24
 913:setup.c       **** 	cs_mreqPin_low;
 2321               		.loc 1 913 0
 2322 06ca 9498      		cbi 0x12,4
 914:setup.c       **** 	GBA_PORT_ROM_DATA15_8 = 0; // Set data
 2323               		.loc 1 914 0
 2324 06cc 1BBA      		out 0x1b,__zero_reg__
 915:setup.c       **** 	GBA_PORT_ROM_DATA7_0 = 0xA0;
 2325               		.loc 1 915 0
 2326 06ce 80EA      		ldi r24,lo8(-96)
 2327 06d0 88BB      		out 0x18,r24
 916:setup.c       **** 	wrPin_low;
 2328               		.loc 1 916 0
 2329 06d2 9698      		cbi 0x12,6
 917:setup.c       **** 	asm volatile("nop");
 2330               		.loc 1 917 0
 2331               	/* #APP */
 2332               	 ;  917 "setup.c" 1
 2333 06d4 0000      		nop
 2334               	 ;  0 "" 2
 918:setup.c       **** 	asm volatile("nop");
 2335               		.loc 1 918 0
 2336               	 ;  918 "setup.c" 1
 2337 06d6 0000      		nop
 2338               	 ;  0 "" 2
 919:setup.c       **** 	asm volatile("nop");
 2339               		.loc 1 919 0
 2340               	 ;  919 "setup.c" 1
 2341 06d8 0000      		nop
 2342               	 ;  0 "" 2
 920:setup.c       **** 	wrPin_high;
 2343               		.loc 1 920 0
 2344               	/* #NOAPP */
 2345 06da 969A      		sbi 0x12,6
 921:setup.c       **** 	cs_mreqPin_high;
 2346               		.loc 1 921 0
 2347 06dc 949A      		sbi 0x12,4
 2348 06de 0895      		ret
 2349               		.cfi_endproc
 2350               	.LFE45:
 2352               	.global	gba_flash_write_byte
 2354               	gba_flash_write_byte:
 2355               	.LFB46:
 922:setup.c       **** }	
 923:setup.c       **** 
 924:setup.c       **** 
 925:setup.c       **** // Write 2 bytes to the Flash address. Time to wait depends on Flash, we will query it to verify th
 926:setup.c       **** // Address is divided by 2 as we are in GBA mode. 
 927:setup.c       **** void gba_flash_write_byte(uint32_t address, uint16_t data, uint8_t isD0D1Swapped) {
 2356               		.loc 1 927 0
 2357               		.cfi_startproc
 2358               	.LVL172:
 2359 06e0 CF92      		push r12
 2360               	.LCFI39:
 2361               		.cfi_def_cfa_offset 3
 2362               		.cfi_offset 12, -2
 2363 06e2 DF92      		push r13
 2364               	.LCFI40:
 2365               		.cfi_def_cfa_offset 4
 2366               		.cfi_offset 13, -3
 2367 06e4 EF92      		push r14
 2368               	.LCFI41:
 2369               		.cfi_def_cfa_offset 5
 2370               		.cfi_offset 14, -4
 2371 06e6 FF92      		push r15
 2372               	.LCFI42:
 2373               		.cfi_def_cfa_offset 6
 2374               		.cfi_offset 15, -5
 2375 06e8 CF93      		push r28
 2376               	.LCFI43:
 2377               		.cfi_def_cfa_offset 7
 2378               		.cfi_offset 28, -6
 2379 06ea DF93      		push r29
 2380               	.LCFI44:
 2381               		.cfi_def_cfa_offset 8
 2382               		.cfi_offset 29, -7
 2383               	/* prologue: function */
 2384               	/* frame size = 0 */
 2385               	/* stack size = 6 */
 2386               	.L__stack_usage = 6
 2387 06ec 6B01      		movw r12,r22
 2388 06ee 7C01      		movw r14,r24
 2389 06f0 EA01      		movw r28,r20
 928:setup.c       **** 	if (isD0D1Swapped == 0) {
 2390               		.loc 1 928 0
 2391 06f2 2111      		cpse r18,__zero_reg__
 2392 06f4 00C0      		rjmp .L92
 929:setup.c       **** 		gba_flash_write_cycle_start();
 2393               		.loc 1 929 0
 2394 06f6 00D0      		rcall gba_flash_write_cycle_start
 2395               	.LVL173:
 2396 06f8 00C0      		rjmp .L93
 2397               	.LVL174:
 2398               	.L92:
 930:setup.c       **** 	}
 931:setup.c       **** 	else {
 932:setup.c       **** 		gba_flash_write_cycle_start_swapped();
 2399               		.loc 1 932 0
 2400 06fa 00D0      		rcall gba_flash_write_cycle_start_swapped
 2401               	.LVL175:
 2402               	.L93:
 933:setup.c       **** 	}
 934:setup.c       **** 	gba_flash_write_bus_cycle(address, data);
 2403               		.loc 1 934 0
 2404 06fc AE01      		movw r20,r28
 2405 06fe C701      		movw r24,r14
 2406 0700 B601      		movw r22,r12
 2407 0702 00D0      		rcall gba_flash_write_bus_cycle
 2408               	.LVL176:
 2409               	.LBB192:
 2410               	.LBB193:
 2411               		.loc 2 276 0
 2412 0704 25E0      		ldi r18,lo8(5)
 2413 0706 2A95      	1:	dec r18
 2414 0708 01F4      		brne 1b
 2415 070a 0000      		nop
 2416               	.LVL177:
 2417               	.LBE193:
 2418               	.LBE192:
 935:setup.c       **** 	_delay_us(2); // Wait byte program time
 936:setup.c       **** 	
 937:setup.c       **** 	// Verify data
 938:setup.c       **** 	uint16_t dataVerify = gba_read_16bit_data(address);
 2419               		.loc 1 938 0
 2420 070c C701      		movw r24,r14
 2421 070e B601      		movw r22,r12
 2422 0710 00D0      		rcall gba_read_16bit_data
 2423               	.LVL178:
 2424               	.L94:
 939:setup.c       **** 	while (data != dataVerify) {
 2425               		.loc 1 939 0
 2426 0712 8C17      		cp r24,r28
 2427 0714 9D07      		cpc r25,r29
 2428 0716 01F0      		breq .L91
 940:setup.c       **** 		dataVerify = gba_read_16bit_data(address);
 2429               		.loc 1 940 0
 2430 0718 C701      		movw r24,r14
 2431 071a B601      		movw r22,r12
 2432 071c 00D0      		rcall gba_read_16bit_data
 2433               	.LVL179:
 2434               	.LBB194:
 2435               	.LBB195:
 2436               		.loc 2 276 0
 2437 071e 25E0      		ldi r18,lo8(5)
 2438 0720 2A95      	1:	dec r18
 2439 0722 01F4      		brne 1b
 2440 0724 0000      		nop
 2441               	.LVL180:
 2442               	.LBE195:
 2443               	.LBE194:
 941:setup.c       **** 		_delay_us(2);
 942:setup.c       **** 		if (writingTimedout == 1) {
 2444               		.loc 1 942 0
 2445 0726 2091 0000 		lds r18,writingTimedout
 2446 072a 2130      		cpi r18,lo8(1)
 2447 072c 01F4      		brne .L94
 2448               	.L91:
 2449               	/* epilogue start */
 943:setup.c       **** 			break;
 944:setup.c       **** 		}
 945:setup.c       **** 	}
 946:setup.c       **** }
 2450               		.loc 1 946 0
 2451 072e DF91      		pop r29
 2452 0730 CF91      		pop r28
 2453               	.LVL181:
 2454 0732 FF90      		pop r15
 2455 0734 EF90      		pop r14
 2456 0736 DF90      		pop r13
 2457 0738 CF90      		pop r12
 2458               	.LVL182:
 2459 073a 0895      		ret
 2460               		.cfi_endproc
 2461               	.LFE46:
 2463               	.global	start_timeout_timer
 2465               	start_timeout_timer:
 2466               	.LFB47:
 947:setup.c       **** 
 948:setup.c       **** // Timeout for ~500ms when flashing carts
 949:setup.c       **** void start_timeout_timer(void) {
 2467               		.loc 1 949 0
 2468               		.cfi_startproc
 2469               	/* prologue: function */
 2470               	/* frame size = 0 */
 2471               	/* stack size = 0 */
 2472               	.L__stack_usage = 0
 950:setup.c       **** 	writingTimedout = 0;
 2473               		.loc 1 950 0
 2474 073c 1092 0000 		sts writingTimedout,__zero_reg__
 951:setup.c       **** 	TCNT1 = 0;
 2475               		.loc 1 951 0
 2476 0740 1DBC      		out 0x2c+1,__zero_reg__
 2477 0742 1CBC      		out 0x2c,__zero_reg__
 952:setup.c       **** 	TCCR1B |= (1<<CS11) | (1<<CS10);
 2478               		.loc 1 952 0
 2479 0744 8EB5      		in r24,0x2e
 2480 0746 8360      		ori r24,lo8(3)
 2481 0748 8EBD      		out 0x2e,r24
 2482 074a 0895      		ret
 2483               		.cfi_endproc
 2484               	.LFE47:
 2486               	.global	stop_timeout_timer
 2488               	stop_timeout_timer:
 2489               	.LFB48:
 953:setup.c       **** }
 954:setup.c       **** 
 955:setup.c       **** // Stop the flash timeout timer
 956:setup.c       **** void stop_timeout_timer(void) {
 2490               		.loc 1 956 0
 2491               		.cfi_startproc
 2492               	/* prologue: function */
 2493               	/* frame size = 0 */
 2494               	/* stack size = 0 */
 2495               	.L__stack_usage = 0
 957:setup.c       **** 	writingTimedout = 0;
 2496               		.loc 1 957 0
 2497 074c 1092 0000 		sts writingTimedout,__zero_reg__
 958:setup.c       **** 	TCNT1 = 0;
 2498               		.loc 1 958 0
 2499 0750 1DBC      		out 0x2c+1,__zero_reg__
 2500 0752 1CBC      		out 0x2c,__zero_reg__
 959:setup.c       **** 	TCCR1B = 0;
 2501               		.loc 1 959 0
 2502 0754 1EBC      		out 0x2e,__zero_reg__
 960:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2503               		.loc 1 960 0
 2504 0756 9398      		cbi 0x12,3
 2505 0758 0895      		ret
 2506               		.cfi_endproc
 2507               	.LFE48:
 2509               	.global	check_if_timed_out
 2511               	check_if_timed_out:
 2512               	.LFB49:
 961:setup.c       **** }
 962:setup.c       **** 
 963:setup.c       **** void check_if_timed_out(void) {
 2513               		.loc 1 963 0
 2514               		.cfi_startproc
 2515               	/* prologue: function */
 2516               	/* frame size = 0 */
 2517               	/* stack size = 0 */
 2518               	.L__stack_usage = 0
 964:setup.c       **** 	if (writingTimedout == 0) {
 2519               		.loc 1 964 0
 2520 075a 8091 0000 		lds r24,writingTimedout
 2521 075e 8111      		cpse r24,__zero_reg__
 2522 0760 00C0      		rjmp .L100
 2523               	.LBB198:
 2524               	.LBB199:
 965:setup.c       **** 		stop_timeout_timer();		
 2525               		.loc 1 965 0
 2526 0762 00D0      		rcall stop_timeout_timer
 2527               	.LVL183:
 966:setup.c       **** 		USART_Transmit(SEND_ACK); // Send back acknowledgement
 2528               		.loc 1 966 0
 2529 0764 81E3      		ldi r24,lo8(49)
 2530 0766 00D0      		rcall USART_Transmit
 2531               	.LVL184:
 967:setup.c       **** 		PORTD &= ~(1<<ACTIVITY_LED);
 2532               		.loc 1 967 0
 2533 0768 9398      		cbi 0x12,3
 2534               	.L100:
 2535 076a 0895      		ret
 2536               	.LBE199:
 2537               	.LBE198:
 2538               		.cfi_endproc
 2539               	.LFE49:
 2541               	.global	setup
 2543               	setup:
 2544               	.LFB50:
 968:setup.c       **** 	}
 969:setup.c       **** }
 970:setup.c       **** 
 971:setup.c       **** 
 972:setup.c       **** // Setup
 973:setup.c       **** void setup(void) {
 2545               		.loc 1 973 0
 2546               		.cfi_startproc
 2547               	/* prologue: function */
 2548               	/* frame size = 0 */
 2549               	/* stack size = 0 */
 2550               	.L__stack_usage = 0
 974:setup.c       **** 	// Turn off watchdog
 975:setup.c       **** 	MCUCSR &= ~(1<<WDRF);
 2551               		.loc 1 975 0
 2552 076c 84B7      		in r24,0x34
 2553 076e 877F      		andi r24,lo8(-9)
 2554 0770 84BF      		out 0x34,r24
 976:setup.c       **** 	WDTCR = (1<<WDCE) | (1<<WDE);
 2555               		.loc 1 976 0
 2556 0772 88E1      		ldi r24,lo8(24)
 2557 0774 81BD      		out 0x21,r24
 977:setup.c       **** 	WDTCR = 0;
 2558               		.loc 1 977 0
 2559 0776 11BC      		out 0x21,__zero_reg__
 978:setup.c       **** 	
 979:setup.c       **** 	// Reset common lines
 980:setup.c       **** 	rd_wr_csmreq_cs2_reset();
 2560               		.loc 1 980 0
 2561 0778 00D0      		rcall rd_wr_csmreq_cs2_reset
 2562               	.LVL185:
 981:setup.c       **** 	
 982:setup.c       **** 	// Set outputs
 983:setup.c       **** 	DDRD |= (1<<ACTIVITY_LED) | (1<<WR_PIN) | (1<<RD_PIN) | (1<<CS_MREQ_PIN) | (1<<LED_5V) | (1<<VOLTA
 2563               		.loc 1 983 0
 2564 077a 81B3      		in r24,0x11
 2565 077c 8C6F      		ori r24,lo8(-4)
 2566 077e 81BB      		out 0x11,r24
 984:setup.c       **** 	DDRE |= (1<<CS2_PIN) | (1<<LED_3V);
 2567               		.loc 1 984 0
 2568 0780 86B1      		in r24,0x6
 2569 0782 8560      		ori r24,lo8(5)
 2570 0784 86B9      		out 0x6,r24
 985:setup.c       **** 	
 986:setup.c       **** 	// Set all pins as inputs
 987:setup.c       **** 	PORT_DATA7_0 = 0;
 2571               		.loc 1 987 0
 2572 0786 15BA      		out 0x15,__zero_reg__
 988:setup.c       **** 	DDR_DATA7_0 = 0;
 2573               		.loc 1 988 0
 2574 0788 14BA      		out 0x14,__zero_reg__
 989:setup.c       **** 	PORT_ADDR7_0 = 0;
 2575               		.loc 1 989 0
 2576 078a 18BA      		out 0x18,__zero_reg__
 990:setup.c       **** 	DDR_ADDR7_0 = 0;
 2577               		.loc 1 990 0
 2578 078c 17BA      		out 0x17,__zero_reg__
 991:setup.c       **** 	PORT_ADDR15_8 = 0;
 2579               		.loc 1 991 0
 2580 078e 1BBA      		out 0x1b,__zero_reg__
 992:setup.c       **** 	DDR_ADDR15_8 = 0;
 2581               		.loc 1 992 0
 2582 0790 1ABA      		out 0x1a,__zero_reg__
 993:setup.c       **** 	
 994:setup.c       **** 	// Light up 3.3V or 5V
 995:setup.c       **** 	if (cartMode == GB_MODE) {
 2583               		.loc 1 995 0
 2584 0792 8091 0000 		lds r24,cartMode
 2585 0796 8130      		cpi r24,lo8(1)
 2586 0798 01F4      		brne .L103
 996:setup.c       **** 		PORTD |= (1<<LED_5V);
 2587               		.loc 1 996 0
 2588 079a 979A      		sbi 0x12,7
 997:setup.c       **** 		PORTE &= ~(1<<LED_3V);
 2589               		.loc 1 997 0
 2590 079c 3898      		cbi 0x7,0
 2591 079e 00C0      		rjmp .L104
 2592               	.L103:
 998:setup.c       **** 	}
 999:setup.c       **** 	else {
1000:setup.c       **** 		PORTE |= (1<<LED_3V);
 2593               		.loc 1 1000 0
 2594 07a0 389A      		sbi 0x7,0
1001:setup.c       **** 		PORTD &= ~(1<<LED_5V);
 2595               		.loc 1 1001 0
 2596 07a2 9798      		cbi 0x12,7
 2597               	.L104:
1002:setup.c       **** 	}
1003:setup.c       **** 	
1004:setup.c       **** 	// Light LED
1005:setup.c       **** 	PORTD |= (1<<ACTIVITY_LED);
 2598               		.loc 1 1005 0
 2599 07a4 939A      		sbi 0x12,3
 2600               	.LVL186:
 2601               	.LBB200:
 2602               	.LBB201:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 2603               		.loc 2 187 0
 2604 07a6 2FEF      		ldi r18,lo8(799999)
 2605 07a8 84E3      		ldi r24,hi8(799999)
 2606 07aa 9CE0      		ldi r25,hlo8(799999)
 2607 07ac 2150      	1:	subi r18,1
 2608 07ae 8040      		sbci r24,0
 2609 07b0 9040      		sbci r25,0
 2610 07b2 01F4      		brne 1b
 2611 07b4 00C0      		rjmp .
 2612 07b6 0000      		nop
 2613               	.LVL187:
 2614               	.LBE201:
 2615               	.LBE200:
1006:setup.c       **** 	_delay_ms(500);
1007:setup.c       **** 	PORTD &= ~(1<<ACTIVITY_LED);
 2616               		.loc 1 1007 0
 2617 07b8 9398      		cbi 0x12,3
1008:setup.c       **** 	
1009:setup.c       **** 	// Setup USART
1010:setup.c       **** 	UBRRL = 0; // 1Mbps Baud rate
 2618               		.loc 1 1010 0
 2619 07ba 19B8      		out 0x9,__zero_reg__
1011:setup.c       **** 	sbi(UCSRA, U2X); // Double rate
 2620               		.loc 1 1011 0
 2621 07bc 599A      		sbi 0xb,1
1012:setup.c       **** 	sbi(UCSRB, TXEN); // Transmitter enable
 2622               		.loc 1 1012 0
 2623 07be 539A      		sbi 0xa,3
1013:setup.c       **** 	sbi(UCSRB, RXEN); // Receiver enable
 2624               		.loc 1 1013 0
 2625 07c0 549A      		sbi 0xa,4
1014:setup.c       **** 	
1015:setup.c       **** 	// Timer1 setup
1016:setup.c       **** 	TIMSK |= (1<<TOIE1);
 2626               		.loc 1 1016 0
 2627 07c2 89B7      		in r24,0x39
 2628 07c4 8068      		ori r24,lo8(-128)
 2629 07c6 89BF      		out 0x39,r24
1017:setup.c       **** 	TCNT1 = 0;
 2630               		.loc 1 1017 0
 2631 07c8 1DBC      		out 0x2c+1,__zero_reg__
 2632 07ca 1CBC      		out 0x2c,__zero_reg__
1018:setup.c       **** 	
1019:setup.c       **** 	// Turn on interrupts
1020:setup.c       **** 	sei();
 2633               		.loc 1 1020 0
 2634               	/* #APP */
 2635               	 ;  1020 "setup.c" 1
 2636 07cc 7894      		sei
 2637               	 ;  0 "" 2
 2638               	/* #NOAPP */
 2639 07ce 0895      		ret
 2640               		.cfi_endproc
 2641               	.LFE50:
 2643               		.section	.text.startup,"ax",@progbits
 2644               	.global	main
 2646               	main:
 2647               	.LFB51:
 2648               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  GBxCart RW
   3:main.c        ****  PCB version: 1.3
   4:main.c        ****  Firmware version: R19
   5:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   6:main.c        ****  Created: 7/11/2016
   7:main.c        ****  Last Modified: 20/08/2020
   8:main.c        ****  
   9:main.c        ****  GBxCart RW allows you to dump your Gameboy/Gameboy Colour/Gameboy Advance games ROM, save the RAM,
  10:main.c        ****  write to certain Gameboy/Gameboy Advance flash carts.
  11:main.c        ****  
  12:main.c        ****  The ATmega8515L talks to the cartridge and interfaces with the CH340G serial to USB converter with
  13:main.c        ****  
  14:main.c        ****  
  15:main.c        ****  Set fuse bits: External 8MHz crystal, divide clock by 8 is off, boot loader is on (512 bytes), BOD
  16:main.c        ****  avrdude -p atmega8515 -c usbasp -U lfuse:w:0xaf:m -U hfuse:w:0xda:m
  17:main.c        ****  
  18:main.c        ****  Program the TinySafeBoot boot loader (modified ASM code, watchdog reset will act as a hardware res
  19:main.c        ****  avrdude -p atmega8515 -c usbasp -U flash:w:GBxCart_RW_v1.x_Rx\tsb\tsb_m8515_d0d1_resetwdt.hex
  20:main.c        ****  
  21:main.c        ****  Program GBxCart RW through TinySafeBoot
  22:main.c        ****  tsb com16:57600 fw GBxCart_RW_v1.x_Rx\main.hex
  23:main.c        ****  
  24:main.c        ****  Set TinySafeBoot delay time to 25 (T 25), gives ~0.5s in bootloader
  25:main.c        ****  tsb com16:9600 T 25
  26:main.c        ****  
  27:main.c        ****  */
  28:main.c        **** 
  29:main.c        **** // ATmega8515L Pin Map
  30:main.c        **** //
  31:main.c        **** // VCC (5)			GND (6)			XTAL (7 ,8)		Activity LED PD3 (9)				Switch sense PD2 (8)
  32:main.c        **** // SCK PB7 (3)		MOSI PB5 (1)	MISO PB6 (2)	RST (4)		RXD PD0 (5)			TXD PD1 (7)
  33:main.c        **** // 
  34:main.c        **** // Gameboy / Gameboy Colour
  35:main.c        **** // A0-A7 PB0-7 (40-44, 1-3) 		A8-A15 PA0-7 (37-30)			D0-D7 PC0-7 (18-25)		Audio PE1 (27)
  36:main.c        **** // 
  37:main.c        **** // Gameboy Advance
  38:main.c        **** // AD0-AD7 PB0-7 (40-44, 1-3) 	AD8-AD15 PA0-7 (37-30)		A16-23 / D0-D7 PC0-7 (19-26)
  39:main.c        **** // *WR PD6 (13)						*RD PD5 (14)					*MREQ/CS PD4 (15)			CS2/RST PE2 (16)
  40:main.c        **** 
  41:main.c        **** #define F_CPU 8000000 // 8 MHz
  42:main.c        **** #define PCB_VERSION 4
  43:main.c        **** #define FIRMWARE_VERSION 19
  44:main.c        **** 
  45:main.c        **** #include <avr/io.h>
  46:main.c        **** #include <avr/wdt.h>
  47:main.c        **** #include <avr/eeprom.h>
  48:main.c        **** #include <avr/interrupt.h>
  49:main.c        **** #include <avr/sleep.h>
  50:main.c        **** #include <util/delay.h>
  51:main.c        **** #include <stdlib.h>
  52:main.c        **** #include <string.h>
  53:main.c        **** #include "setup.c" // See defines, variables, constants, functions here
  54:main.c        **** 
  55:main.c        **** 
  56:main.c        **** int main(void) {
 2649               		.loc 3 56 0
 2650               		.cfi_startproc
 2651 0000 CF93      		push r28
 2652               	.LCFI45:
 2653               		.cfi_def_cfa_offset 3
 2654               		.cfi_offset 28, -2
 2655 0002 DF93      		push r29
 2656               	.LCFI46:
 2657               		.cfi_def_cfa_offset 4
 2658               		.cfi_offset 29, -3
 2659 0004 CDB7      		in r28,__SP_L__
 2660 0006 DEB7      		in r29,__SP_H__
 2661               	.LCFI47:
 2662               		.cfi_def_cfa_register 28
 2663 0008 2897      		sbiw r28,8
 2664               	.LCFI48:
 2665               		.cfi_def_cfa_offset 12
 2666 000a 0FB6      		in __tmp_reg__,__SREG__
 2667 000c F894      		cli
 2668 000e DEBF      		out __SP_H__,r29
 2669 0010 0FBE      		out __SREG__,__tmp_reg__
 2670 0012 CDBF      		out __SP_L__,r28
 2671               	/* prologue: function */
 2672               	/* frame size = 8 */
 2673               	/* stack size = 10 */
 2674               	.L__stack_usage = 10
  57:main.c        **** 	setup();
 2675               		.loc 3 57 0
 2676 0014 00D0      		rcall setup
 2677               	.LVL188:
  58:main.c        **** 	
  59:main.c        **** 	uint32_t address = 0;
  60:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
  61:main.c        **** 	uint8_t resetCommonLines = 1;
 2678               		.loc 3 61 0
 2679 0016 21E0      		ldi r18,lo8(1)
 2680 0018 2D83      		std Y+5,r18
  60:main.c        **** 	uint8_t resetCommonLines = 1;
 2681               		.loc 3 60 0
 2682 001a 81E0      		ldi r24,lo8(1)
 2683 001c 8887      		std Y+8,r24
  59:main.c        **** 	uint8_t eepromSize = EEPROM_4KBIT;
 2684               		.loc 3 59 0
 2685 001e C12C      		mov r12,__zero_reg__
 2686 0020 D12C      		mov r13,__zero_reg__
 2687 0022 7601      		movw r14,r12
 2688               	.LVL189:
 2689               	.L106:
  62:main.c        **** 	
  63:main.c        **** 	while(1) {
  64:main.c        **** 		if (resetCommonLines == 1) {
 2690               		.loc 3 64 0
 2691 0024 AD81      		ldd r26,Y+5
 2692 0026 A130      		cpi r26,lo8(1)
 2693 0028 01F4      		brne .L107
 2694               	.LVL190:
 2695               	.L313:
  65:main.c        **** 			rd_wr_csmreq_cs2_reset();
 2696               		.loc 3 65 0
 2697 002a 00D0      		rcall rd_wr_csmreq_cs2_reset
 2698               	.LVL191:
 2699               	.L107:
  66:main.c        **** 		}
  67:main.c        **** 		receivedChar = USART_Receive(); // Wait for 1 byte of data
 2700               		.loc 3 67 0
 2701 002c 00D0      		rcall USART_Receive
 2702               	.LVL192:
 2703 002e 8093 0000 		sts receivedChar,r24
  68:main.c        **** 		
  69:main.c        **** 		// Return the cart mode in use
  70:main.c        **** 		if (receivedChar == CART_MODE) {
 2704               		.loc 3 70 0
 2705 0032 8334      		cpi r24,lo8(67)
 2706 0034 01F4      		brne .L108
  71:main.c        **** 			USART_Transmit(cartMode);
 2707               		.loc 3 71 0
 2708 0036 8091 0000 		lds r24,cartMode
 2709 003a 00C0      		rjmp .L315
 2710               	.L108:
  72:main.c        **** 		}
  73:main.c        **** 		
  74:main.c        **** 		// Change to GB mode or GBA mode if requested
  75:main.c        **** 		else if (receivedChar == GB_CART_MODE) {
 2711               		.loc 3 75 0
 2712 003c 8734      		cpi r24,lo8(71)
 2713 003e 01F4      		brne .L110
  76:main.c        **** 			gb_mode();
 2714               		.loc 3 76 0
 2715 0040 00D0      		rcall gb_mode
 2716               	.LVL193:
  77:main.c        **** 			stop_timeout_timer();
 2717               		.loc 3 77 0
 2718 0042 00D0      		rcall stop_timeout_timer
 2719               	.LVL194:
  78:main.c        **** 			flashBank1CommandWrites = 0; // Reset back to normal
 2720               		.loc 3 78 0
 2721 0044 1092 0000 		sts flashBank1CommandWrites,__zero_reg__
 2722 0048 00C0      		rjmp .L106
 2723               	.L110:
  79:main.c        **** 		}
  80:main.c        **** 		else if (receivedChar == GBA_CART_MODE) {
 2724               		.loc 3 80 0
 2725 004a 8736      		cpi r24,lo8(103)
 2726 004c 01F4      		brne .L111
  81:main.c        **** 			gba_mode();
 2727               		.loc 3 81 0
 2728 004e 00D0      		rcall gba_mode
 2729               	.LVL195:
 2730 0050 00C0      		rjmp .L316
 2731               	.L111:
  82:main.c        **** 			stop_timeout_timer();
  83:main.c        **** 		}
  84:main.c        **** 		
  85:main.c        **** 		// Switch voltage if requested
  86:main.c        **** 		else if (receivedChar == VOLTAGE_3_3V) {
 2732               		.loc 3 86 0
 2733 0052 8333      		cpi r24,lo8(51)
 2734 0054 01F4      		brne .L112
  87:main.c        **** 			PORTD &= ~(1<<VOLTAGE_SELECT);
 2735               		.loc 3 87 0
 2736 0056 9298      		cbi 0x12,2
  88:main.c        **** 			cartMode = GBA_MODE;
 2737               		.loc 3 88 0
 2738 0058 82E0      		ldi r24,lo8(2)
 2739 005a 8093 0000 		sts cartMode,r24
  89:main.c        **** 			PORTE |= (1<<LED_3V);
 2740               		.loc 3 89 0
 2741 005e 389A      		sbi 0x7,0
  90:main.c        **** 			PORTD &= ~(1<<LED_5V);
 2742               		.loc 3 90 0
 2743 0060 9798      		cbi 0x12,7
 2744               	.L316:
  91:main.c        **** 			stop_timeout_timer();
 2745               		.loc 3 91 0
 2746 0062 00D0      		rcall stop_timeout_timer
 2747               	.LVL196:
 2748 0064 00C0      		rjmp .L106
 2749               	.L112:
  92:main.c        **** 		}
  93:main.c        **** 		else if (receivedChar == VOLTAGE_5V) {
 2750               		.loc 3 93 0
 2751 0066 8533      		cpi r24,lo8(53)
 2752 0068 01F4      		brne .L113
  94:main.c        **** 			PORTD |= (1<<VOLTAGE_SELECT);
 2753               		.loc 3 94 0
 2754 006a 929A      		sbi 0x12,2
  95:main.c        **** 			cartMode = GB_MODE;
 2755               		.loc 3 95 0
 2756 006c 81E0      		ldi r24,lo8(1)
 2757 006e 8093 0000 		sts cartMode,r24
  96:main.c        **** 			PORTD |= (1<<LED_5V);
 2758               		.loc 3 96 0
 2759 0072 979A      		sbi 0x12,7
  97:main.c        **** 			PORTE &= ~(1<<LED_3V);
 2760               		.loc 3 97 0
 2761 0074 3898      		cbi 0x7,0
 2762 0076 00C0      		rjmp .L316
 2763               	.L113:
  98:main.c        **** 			stop_timeout_timer();
  99:main.c        **** 		}
 100:main.c        **** 		
 101:main.c        **** 		
 102:main.c        **** 		// ****** Gameboy / Gameboy Colour ******
 103:main.c        **** 		
 104:main.c        **** 		// Set address
 105:main.c        **** 		else if (receivedChar == SET_START_ADDRESS) {
 2764               		.loc 3 105 0
 2765 0078 8134      		cpi r24,lo8(65)
 2766 007a 01F4      		brne .L114
 106:main.c        **** 			usart_read_chars(); // Read start address
 2767               		.loc 3 106 0
 2768 007c 00D0      		rcall usart_read_chars
 2769               	.LVL197:
 107:main.c        **** 			address = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2770               		.loc 3 107 0
 2771 007e 40E1      		ldi r20,lo8(16)
 2772 0080 50E0      		ldi r21,0
 2773 0082 60E0      		ldi r22,0
 2774 0084 70E0      		ldi r23,0
 2775 0086 80E0      		ldi r24,lo8(receivedBuffer)
 2776 0088 90E0      		ldi r25,hi8(receivedBuffer)
 2777 008a 00D0      		rcall strtol
 2778               	.LVL198:
 2779 008c 6B01      		movw r12,r22
 2780 008e 7C01      		movw r14,r24
 2781               	.LVL199:
 2782 0090 00C0      		rjmp .L106
 2783               	.L114:
 108:main.c        **** 		}
 109:main.c        **** 		
 110:main.c        **** 		// Read 64 bytes of ROM/RAM from address (and increment) until anything but 1 is received
 111:main.c        **** 		else if (receivedChar == READ_ROM_RAM) {
 2784               		.loc 3 111 0
 2785 0092 8235      		cpi r24,lo8(82)
 2786 0094 01F4      		brne .L115
 112:main.c        **** 			gb_mode();
 2787               		.loc 3 112 0
 2788 0096 00D0      		rcall gb_mode
 2789               	.LVL200:
 113:main.c        **** 			receivedChar = '1';
 2790               		.loc 3 113 0
 2791 0098 B1E3      		ldi r27,lo8(49)
 2792 009a B093 0000 		sts receivedChar,r27
 2793               	.LVL201:
 2794               	.L116:
 114:main.c        **** 			while (receivedChar == '1') {
 2795               		.loc 3 114 0
 2796 009e 8091 0000 		lds r24,receivedChar
 2797 00a2 8133      		cpi r24,lo8(49)
 2798 00a4 01F0      		breq .+2
 2799 00a6 00C0      		rjmp .L106
 115:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 2800               		.loc 3 115 0
 2801 00a8 939A      		sbi 0x12,3
 2802               	.LVL202:
 2803 00aa 00E0      		ldi r16,0
 2804 00ac 10E0      		ldi r17,0
 2805               	.LVL203:
 2806               	.L117:
 2807               	.LBB202:
 116:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 117:main.c        **** 					USART_Transmit(read_8bit_data(address));
 2808               		.loc 3 117 0 discriminator 3
 2809 00ae C801      		movw r24,r16
 2810 00b0 8C0D      		add r24,r12
 2811 00b2 9D1D      		adc r25,r13
 2812 00b4 00D0      		rcall read_8bit_data
 2813               	.LVL204:
 2814 00b6 00D0      		rcall USART_Transmit
 2815               	.LVL205:
 2816 00b8 0F5F      		subi r16,-1
 2817 00ba 1F4F      		sbci r17,-1
 2818               	.LVL206:
 116:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 2819               		.loc 3 116 0 discriminator 3
 2820 00bc 0034      		cpi r16,64
 2821 00be 1105      		cpc r17,__zero_reg__
 2822 00c0 01F4      		brne .L117
 2823 00c2 E0E4      		ldi r30,64
 2824 00c4 CE0E      		add r12,r30
 2825 00c6 D11C      		adc r13,__zero_reg__
 2826 00c8 E11C      		adc r14,__zero_reg__
 2827 00ca F11C      		adc r15,__zero_reg__
 2828               	.LBE202:
 118:main.c        **** 					address++;
 119:main.c        **** 				}
 120:main.c        **** 				
 121:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 2829               		.loc 3 121 0
 2830 00cc 9398      		cbi 0x12,3
 122:main.c        **** 				receivedChar = USART_Receive();
 2831               		.loc 3 122 0
 2832 00ce 00D0      		rcall USART_Receive
 2833               	.LVL207:
 2834 00d0 8093 0000 		sts receivedChar,r24
 2835 00d4 00C0      		rjmp .L116
 2836               	.LVL208:
 2837               	.L115:
 123:main.c        **** 			}
 124:main.c        **** 		}
 125:main.c        **** 		
 126:main.c        **** 		// Read and send 0x4000 bytes of data
 127:main.c        **** 		else if (receivedChar == READ_ROM_4000H) {
 2838               		.loc 3 127 0
 2839 00d6 8135      		cpi r24,lo8(81)
 2840 00d8 01F4      		brne .L119
 128:main.c        **** 			gb_mode();
 2841               		.loc 3 128 0
 2842 00da 00D0      		rcall gb_mode
 2843               	.LVL209:
 129:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2844               		.loc 3 129 0
 2845 00dc 939A      		sbi 0x12,3
 2846               	.LVL210:
 2847               	.LBB203:
 130:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2848               		.loc 3 130 0
 2849 00de 00E0      		ldi r16,0
 2850 00e0 10E0      		ldi r17,0
 2851               	.LVL211:
 2852               	.L120:
 131:main.c        **** 				USART_Transmit(read_8bit_data(address));
 2853               		.loc 3 131 0 discriminator 3
 2854 00e2 C801      		movw r24,r16
 2855 00e4 8C0D      		add r24,r12
 2856 00e6 9D1D      		adc r25,r13
 2857 00e8 00D0      		rcall read_8bit_data
 2858               	.LVL212:
 2859 00ea 00D0      		rcall USART_Transmit
 2860               	.LVL213:
 130:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 2861               		.loc 3 130 0 discriminator 3
 2862 00ec 0F5F      		subi r16,-1
 2863 00ee 1F4F      		sbci r17,-1
 2864               	.LVL214:
 2865 00f0 0115      		cp r16,__zero_reg__
 2866 00f2 F0E4      		ldi r31,64
 2867 00f4 1F07      		cpc r17,r31
 2868 00f6 01F4      		brne .L120
 2869 00f8 20E4      		ldi r18,64
 2870 00fa D20E      		add r13,r18
 2871 00fc E11C      		adc r14,__zero_reg__
 2872 00fe F11C      		adc r15,__zero_reg__
 2873 0100 00C0      		rjmp .L243
 2874               	.LVL215:
 2875               	.L119:
 2876               	.LBE203:
 132:main.c        **** 				address++;
 133:main.c        **** 			}
 134:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 135:main.c        **** 		}
 136:main.c        **** 		
 137:main.c        **** 		// Write 64 bytes to RAM on address (and increment)
 138:main.c        **** 		else if (receivedChar == WRITE_RAM) {
 2877               		.loc 3 138 0
 2878 0102 8735      		cpi r24,lo8(87)
 2879 0104 01F4      		brne .L121
 139:main.c        **** 			gb_mode();
 2880               		.loc 3 139 0
 2881 0106 00D0      		rcall gb_mode
 2882               	.LVL216:
 140:main.c        **** 			
 141:main.c        **** 			// Read 64 bytes first as CH340G sends them all at once
 142:main.c        **** 			usart_read_bytes(64);
 2883               		.loc 3 142 0
 2884 0108 80E4      		ldi r24,lo8(64)
 2885 010a 90E0      		ldi r25,0
 2886 010c 00D0      		rcall usart_read_bytes
 2887               	.LVL217:
 143:main.c        **** 			
 144:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 2888               		.loc 3 144 0
 2889 010e 939A      		sbi 0x12,3
 2890               	.LVL218:
 2891 0110 20E0      		ldi r18,lo8(receivedBuffer)
 2892 0112 A22E      		mov r10,r18
 2893 0114 20E0      		ldi r18,hi8(receivedBuffer)
 2894 0116 B22E      		mov r11,r18
 2895 0118 00E0      		ldi r16,0
 2896 011a 10E0      		ldi r17,0
 2897               	.LVL219:
 2898               	.L122:
 2899               	.LBB204:
 145:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 146:main.c        **** 				write_8bit_data(address, receivedBuffer[x], MEMORY_WRITE);
 2900               		.loc 3 146 0 discriminator 3
 2901 011c D501      		movw r26,r10
 2902 011e 6D91      		ld r22,X+
 2903 0120 5D01      		movw r10,r26
 2904 0122 C801      		movw r24,r16
 2905 0124 8C0D      		add r24,r12
 2906 0126 9D1D      		adc r25,r13
 2907 0128 41E0      		ldi r20,lo8(1)
 2908 012a 00D0      		rcall write_8bit_data
 2909               	.LVL220:
 2910 012c 0F5F      		subi r16,-1
 2911 012e 1F4F      		sbci r17,-1
 2912               	.LVL221:
 145:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 2913               		.loc 3 145 0 discriminator 3
 2914 0130 0034      		cpi r16,64
 2915 0132 1105      		cpc r17,__zero_reg__
 2916 0134 01F4      		brne .L122
 2917 0136 B0E4      		ldi r27,64
 2918 0138 CB0E      		add r12,r27
 2919 013a D11C      		adc r13,__zero_reg__
 2920 013c E11C      		adc r14,__zero_reg__
 2921 013e F11C      		adc r15,__zero_reg__
 2922 0140 00C0      		rjmp .L334
 2923               	.LVL222:
 2924               	.L121:
 2925               	.LBE204:
 147:main.c        **** 				address++;
 148:main.c        **** 			}
 149:main.c        **** 			
 150:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 151:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 152:main.c        **** 		}
 153:main.c        **** 		
 154:main.c        **** 		// Set bank address and write a byte
 155:main.c        **** 		else if (receivedChar == SET_BANK) {
 2926               		.loc 3 155 0
 2927 0142 8234      		cpi r24,lo8(66)
 2928 0144 01F4      		brne .L123
 2929               	.LBB205:
 156:main.c        **** 			gb_mode();
 2930               		.loc 3 156 0
 2931 0146 00D0      		rcall gb_mode
 2932               	.LVL223:
 157:main.c        **** 			
 158:main.c        **** 			usart_read_chars(); // Read start address
 2933               		.loc 3 158 0
 2934 0148 00D0      		rcall usart_read_chars
 2935               	.LVL224:
 159:main.c        **** 			uint16_t bankaddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to dec
 2936               		.loc 3 159 0
 2937 014a 40E1      		ldi r20,lo8(16)
 2938 014c 50E0      		ldi r21,0
 2939 014e 60E0      		ldi r22,0
 2940 0150 70E0      		ldi r23,0
 2941 0152 80E0      		ldi r24,lo8(receivedBuffer)
 2942 0154 90E0      		ldi r25,hi8(receivedBuffer)
 2943 0156 00D0      		rcall strtol
 2944               	.LVL225:
 2945 0158 4B01      		movw r8,r22
 2946 015a 5C01      		movw r10,r24
 2947               	.LVL226:
 160:main.c        **** 			
 161:main.c        **** 			receivedChar = USART_Receive(); // Wait for bank number
 2948               		.loc 3 161 0
 2949 015c 00D0      		rcall USART_Receive
 2950               	.LVL227:
 2951 015e 8093 0000 		sts receivedChar,r24
 162:main.c        **** 			if (receivedChar == 'B') {
 2952               		.loc 3 162 0
 2953 0162 8234      		cpi r24,lo8(66)
 2954 0164 01F0      		breq .+2
 2955 0166 00C0      		rjmp .L106
 2956               	.LBB206:
 163:main.c        **** 				usart_read_chars(); // Read data
 2957               		.loc 3 163 0
 2958 0168 00D0      		rcall usart_read_chars
 2959               	.LVL228:
 164:main.c        **** 				uint8_t data = atoi(receivedBuffer); // Convert data string to dec
 2960               		.loc 3 164 0
 2961 016a 80E0      		ldi r24,lo8(receivedBuffer)
 2962 016c 90E0      		ldi r25,hi8(receivedBuffer)
 2963 016e 00D0      		rcall atoi
 2964               	.LVL229:
 165:main.c        **** 				lastBankAccessed = data; // Store the last bank accessed (used for flash carts that need it)
 2965               		.loc 3 165 0
 2966 0170 8093 0000 		sts lastBankAccessed,r24
 166:main.c        **** 				
 167:main.c        **** 				write_8bit_data(bankaddress, data, BANK_WRITE);
 2967               		.loc 3 167 0
 2968 0174 40E0      		ldi r20,0
 2969 0176 682F      		mov r22,r24
 2970 0178 C401      		movw r24,r8
 2971               	.LVL230:
 2972 017a 00D0      		rcall write_8bit_data
 2973               	.LVL231:
 2974 017c 00C0      		rjmp .L106
 2975               	.LVL232:
 2976               	.L123:
 2977               	.LBE206:
 2978               	.LBE205:
 168:main.c        **** 			}
 169:main.c        **** 		}
 170:main.c        **** 		
 171:main.c        **** 		
 172:main.c        **** 		// ****** Gameboy Advance ******
 173:main.c        **** 		
 174:main.c        **** 		// ---------- ROM ----------
 175:main.c        **** 		// Read one 16bit byte from ROM using address (and increment) until anything but 1 is received
 176:main.c        **** 		else if (receivedChar == GBA_READ_ROM || receivedChar == GBA_READ_ROM_256BYTE) {
 2979               		.loc 3 176 0
 2980 017e 8237      		cpi r24,lo8(114)
 2981 0180 01F0      		breq .L124
 2982               		.loc 3 176 0 is_stmt 0 discriminator 1
 2983 0182 8A36      		cpi r24,lo8(106)
 2984 0184 01F4      		brne .L125
 2985               	.L124:
 2986               	.LBB207:
 177:main.c        **** 			gba_mode();
 2987               		.loc 3 177 0 is_stmt 1
 2988 0186 00D0      		rcall gba_mode
 2989               	.LVL233:
 178:main.c        **** 			
 179:main.c        **** 			uint8_t readEnd = 32;
 180:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2990               		.loc 3 180 0
 2991 0188 8091 0000 		lds r24,receivedChar
 2992 018c 8A36      		cpi r24,lo8(106)
 2993 018e 01F4      		brne .L252
 181:main.c        **** 				readEnd = 128;
 2994               		.loc 3 181 0
 2995 0190 10E8      		ldi r17,lo8(-128)
 2996 0192 00C0      		rjmp .L126
 2997               	.L252:
 179:main.c        **** 			if (receivedChar == GBA_READ_ROM_256BYTE) {
 2998               		.loc 3 179 0
 2999 0194 10E2      		ldi r17,lo8(32)
 3000               	.L126:
 3001               	.LVL234:
 182:main.c        **** 			}
 183:main.c        **** 			
 184:main.c        **** 			receivedChar = '1';
 3002               		.loc 3 184 0
 3003 0196 E1E3      		ldi r30,lo8(49)
 3004 0198 E093 0000 		sts receivedChar,r30
 3005 019c 8824      		clr r8
 3006 019e 8A94      		dec r8
 3007 01a0 810E      		add r8,r17
 3008 01a2 912C      		mov r9,__zero_reg__
 3009 01a4 A12C      		mov r10,__zero_reg__
 3010 01a6 B12C      		mov r11,__zero_reg__
 3011 01a8 FFEF      		ldi r31,-1
 3012 01aa 8F1A      		sub r8,r31
 3013 01ac 9F0A      		sbc r9,r31
 3014 01ae AF0A      		sbc r10,r31
 3015 01b0 BF0A      		sbc r11,r31
 3016               	.LVL235:
 3017               	.L127:
 185:main.c        **** 			while (receivedChar == '1') {
 3018               		.loc 3 185 0
 3019 01b2 8091 0000 		lds r24,receivedChar
 3020 01b6 8133      		cpi r24,lo8(49)
 3021 01b8 01F0      		breq .+2
 3022 01ba 00C0      		rjmp .L106
 186:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3023               		.loc 3 186 0
 3024 01bc 939A      		sbi 0x12,3
 3025               	.LVL236:
 3026 01be 2601      		movw r4,r12
 3027 01c0 3701      		movw r6,r14
 3028               	.LVL237:
 3029               	.L128:
 3030               	.LBB208:
 3031               	.LBB209:
 187:main.c        **** 				
 188:main.c        **** 				for (uint8_t x = 0; x < readEnd; x++) {
 189:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 3032               		.loc 3 189 0 discriminator 3
 3033 01c2 C301      		movw r24,r6
 3034 01c4 B201      		movw r22,r4
 3035 01c6 00D0      		rcall gba_read_16bit_data
 3036               	.LVL238:
 3037 01c8 092F      		mov r16,r25
 3038               	.LVL239:
 190:main.c        **** 					
 191:main.c        **** 					// Low byte & High byte
 192:main.c        **** 					USART_Transmit(dataRead & 0xFF);
 3039               		.loc 3 192 0 discriminator 3
 3040 01ca 00D0      		rcall USART_Transmit
 3041               	.LVL240:
 193:main.c        **** 					USART_Transmit(dataRead >> 8);
 3042               		.loc 3 193 0 discriminator 3
 3043 01cc 802F      		mov r24,r16
 3044 01ce 00D0      		rcall USART_Transmit
 3045               	.LVL241:
 194:main.c        **** 					
 195:main.c        **** 					address++;
 3046               		.loc 3 195 0 discriminator 3
 3047 01d0 2FEF      		ldi r18,-1
 3048 01d2 421A      		sub r4,r18
 3049 01d4 520A      		sbc r5,r18
 3050 01d6 620A      		sbc r6,r18
 3051 01d8 720A      		sbc r7,r18
 3052               	.LVL242:
 3053               	.LBE209:
 188:main.c        **** 					uint16_t dataRead = gba_read_16bit_data(address);
 3054               		.loc 3 188 0 discriminator 3
 3055 01da 842D      		mov r24,r4
 3056 01dc 8C19      		sub r24,r12
 3057 01de 8117      		cp r24,r17
 3058 01e0 00F0      		brlo .L128
 3059 01e2 C80C      		add r12,r8
 3060 01e4 D91C      		adc r13,r9
 3061 01e6 EA1C      		adc r14,r10
 3062 01e8 FB1C      		adc r15,r11
 3063               	.LVL243:
 3064               	.LBE208:
 196:main.c        **** 				}
 197:main.c        **** 				
 198:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3065               		.loc 3 198 0
 3066 01ea 9398      		cbi 0x12,3
 199:main.c        **** 				receivedChar = USART_Receive();
 3067               		.loc 3 199 0
 3068 01ec 00D0      		rcall USART_Receive
 3069               	.LVL244:
 3070 01ee 8093 0000 		sts receivedChar,r24
 3071 01f2 00C0      		rjmp .L127
 3072               	.LVL245:
 3073               	.L125:
 3074               	.LBE207:
 200:main.c        **** 			}
 201:main.c        **** 		}
 202:main.c        **** 		
 203:main.c        **** 		// Read and send 0x10000 bytes of data
 204:main.c        **** 		else if (receivedChar == GBA_READ_ROM_8000H) {
 3075               		.loc 3 204 0
 3076 01f4 8A35      		cpi r24,lo8(90)
 3077 01f6 01F4      		brne .L130
 205:main.c        **** 			gba_mode();
 3078               		.loc 3 205 0
 3079 01f8 00D0      		rcall gba_mode
 3080               	.LVL246:
 206:main.c        **** 			
 207:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3081               		.loc 3 207 0
 3082 01fa 939A      		sbi 0x12,3
 208:main.c        **** 			gba_set_24bit_address(address);
 3083               		.loc 3 208 0
 3084 01fc C701      		movw r24,r14
 3085 01fe B601      		movw r22,r12
 3086 0200 00D0      		rcall gba_set_24bit_address
 3087               	.LVL247:
 209:main.c        **** 			cs_mreqPin_low;
 3088               		.loc 3 209 0
 3089 0202 9498      		cbi 0x12,4
 210:main.c        **** 			
 211:main.c        **** 			GBA_PORT_ROM_ADDR15_8 = 0;
 3090               		.loc 3 211 0
 3091 0204 1BBA      		out 0x1b,__zero_reg__
 212:main.c        **** 			GBA_PORT_ROM_ADDR7_0 = 0;
 3092               		.loc 3 212 0
 3093 0206 18BA      		out 0x18,__zero_reg__
 213:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0;
 3094               		.loc 3 213 0
 3095 0208 1ABA      		out 0x1a,__zero_reg__
 214:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0;
 3096               		.loc 3 214 0
 3097 020a 17BA      		out 0x17,__zero_reg__
 3098               	.LVL248:
 3099               	.LBB210:
 215:main.c        **** 			
 216:main.c        **** 			for (uint16_t x = 0; x < 0x8000; x++) {
 3100               		.loc 3 216 0
 3101 020c 00E0      		ldi r16,0
 3102 020e 10E0      		ldi r17,0
 3103               	.LVL249:
 3104               	.L131:
 3105               		.loc 3 216 0 is_stmt 0 discriminator 1
 3106 0210 17FD      		sbrc r17,7
 3107 0212 00C0      		rjmp .L335
 217:main.c        **** 				rdPin_low;
 3108               		.loc 3 217 0 is_stmt 1 discriminator 3
 3109 0214 9598      		cbi 0x12,5
 218:main.c        **** 				asm volatile("nop");
 3110               		.loc 3 218 0 discriminator 3
 3111               	/* #APP */
 3112               	 ;  218 "main.c" 1
 3113 0216 0000      		nop
 3114               	 ;  0 "" 2
 219:main.c        **** 				
 220:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA7_0);
 3115               		.loc 3 220 0 discriminator 3
 3116               	/* #NOAPP */
 3117 0218 86B3      		in r24,0x16
 3118 021a 00D0      		rcall USART_Transmit
 3119               	.LVL250:
 221:main.c        **** 				USART_Transmit(GBA_PIN_ROM_DATA15_8);
 3120               		.loc 3 221 0 discriminator 3
 3121 021c 89B3      		in r24,0x19
 3122 021e 00D0      		rcall USART_Transmit
 3123               	.LVL251:
 222:main.c        **** 				rdPin_high;
 3124               		.loc 3 222 0 discriminator 3
 3125 0220 959A      		sbi 0x12,5
 216:main.c        **** 				rdPin_low;
 3126               		.loc 3 216 0 discriminator 3
 3127 0222 0F5F      		subi r16,-1
 3128 0224 1F4F      		sbci r17,-1
 3129               	.LVL252:
 3130 0226 00C0      		rjmp .L131
 3131               	.L335:
 3132               	.LBE210:
 223:main.c        **** 			}
 224:main.c        **** 			address += 0x8000;
 3133               		.loc 3 224 0
 3134 0228 80E8      		ldi r24,-128
 3135 022a D80E      		add r13,r24
 3136 022c E11C      		adc r14,__zero_reg__
 3137 022e F11C      		adc r15,__zero_reg__
 3138               	.LVL253:
 3139 0230 00C0      		rjmp .L243
 3140               	.LVL254:
 3141               	.L130:
 225:main.c        **** 			
 226:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 227:main.c        **** 		}
 228:main.c        **** 		
 229:main.c        **** 		// ---------- SRAM ----------
 230:main.c        **** 		// Read RAM from address (and increment) until anything but 1 is received
 231:main.c        **** 		else if (receivedChar == GBA_READ_SRAM) {
 3142               		.loc 3 231 0
 3143 0232 8D36      		cpi r24,lo8(109)
 3144 0234 01F4      		brne .L133
 232:main.c        **** 			gb_mode(); // Set GB mode as it uses 16 bit address with 8 bit data
 3145               		.loc 3 232 0
 3146 0236 00D0      		rcall gb_mode
 3147               	.LVL255:
 233:main.c        **** 			
 234:main.c        **** 			receivedChar = '1';
 3148               		.loc 3 234 0
 3149 0238 91E3      		ldi r25,lo8(49)
 3150 023a 9093 0000 		sts receivedChar,r25
 3151               	.LVL256:
 3152               	.L134:
 235:main.c        **** 			while (receivedChar == '1') {
 3153               		.loc 3 235 0
 3154 023e 8091 0000 		lds r24,receivedChar
 3155 0242 8133      		cpi r24,lo8(49)
 3156 0244 01F4      		brne .L319
 236:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3157               		.loc 3 236 0
 3158 0246 939A      		sbi 0x12,3
 3159               	.LVL257:
 3160 0248 00E0      		ldi r16,0
 3161 024a 10E0      		ldi r17,0
 3162               	.LVL258:
 3163               	.L135:
 3164               	.LBB211:
 237:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 238:main.c        **** 					USART_Transmit(gba_read_ram_8bit_data(address));
 3165               		.loc 3 238 0 discriminator 3
 3166 024c C801      		movw r24,r16
 3167 024e 8C0D      		add r24,r12
 3168 0250 9D1D      		adc r25,r13
 3169 0252 00D0      		rcall gba_read_ram_8bit_data
 3170               	.LVL259:
 3171 0254 00D0      		rcall USART_Transmit
 3172               	.LVL260:
 3173 0256 0F5F      		subi r16,-1
 3174 0258 1F4F      		sbci r17,-1
 3175               	.LVL261:
 237:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3176               		.loc 3 237 0 discriminator 3
 3177 025a 0034      		cpi r16,64
 3178 025c 1105      		cpc r17,__zero_reg__
 3179 025e 01F4      		brne .L135
 3180 0260 A0E4      		ldi r26,64
 3181 0262 CA0E      		add r12,r26
 3182 0264 D11C      		adc r13,__zero_reg__
 3183 0266 E11C      		adc r14,__zero_reg__
 3184 0268 F11C      		adc r15,__zero_reg__
 3185               	.LBE211:
 239:main.c        **** 					address++;
 240:main.c        **** 				}
 241:main.c        **** 				
 242:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3186               		.loc 3 242 0
 3187 026a 9398      		cbi 0x12,3
 243:main.c        **** 				receivedChar = USART_Receive();
 3188               		.loc 3 243 0
 3189 026c 00D0      		rcall USART_Receive
 3190               	.LVL262:
 3191 026e 8093 0000 		sts receivedChar,r24
 3192 0272 00C0      		rjmp .L134
 3193               	.LVL263:
 3194               	.L133:
 244:main.c        **** 			}
 245:main.c        **** 			
 246:main.c        **** 			gba_mode(); // Set back
 247:main.c        **** 		}
 248:main.c        **** 		
 249:main.c        **** 		// Write to RAM on address (and increment) with 64 bytes of data
 250:main.c        **** 		else if (receivedChar == GBA_WRITE_SRAM) {
 3195               		.loc 3 250 0
 3196 0274 8737      		cpi r24,lo8(119)
 3197 0276 01F4      		brne .L137
 251:main.c        **** 			gb_mode();
 3198               		.loc 3 251 0
 3199 0278 00D0      		rcall gb_mode
 3200               	.LVL264:
 252:main.c        **** 			
 253:main.c        **** 			usart_read_bytes(64);
 3201               		.loc 3 253 0
 3202 027a 80E4      		ldi r24,lo8(64)
 3203 027c 90E0      		ldi r25,0
 3204 027e 00D0      		rcall usart_read_bytes
 3205               	.LVL265:
 254:main.c        **** 			
 255:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3206               		.loc 3 255 0
 3207 0280 939A      		sbi 0x12,3
 3208               	.LVL266:
 3209 0282 90E0      		ldi r25,lo8(receivedBuffer)
 3210 0284 A92E      		mov r10,r25
 3211 0286 90E0      		ldi r25,hi8(receivedBuffer)
 3212 0288 B92E      		mov r11,r25
 3213 028a 00E0      		ldi r16,0
 3214 028c 10E0      		ldi r17,0
 3215               	.LVL267:
 3216               	.L138:
 3217               	.LBB212:
 256:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 257:main.c        **** 				gba_write_ram_8bit_data(address, receivedBuffer[x]);
 3218               		.loc 3 257 0 discriminator 3
 3219 028e F501      		movw r30,r10
 3220 0290 6191      		ld r22,Z+
 3221 0292 5F01      		movw r10,r30
 3222 0294 C801      		movw r24,r16
 3223 0296 8C0D      		add r24,r12
 3224 0298 9D1D      		adc r25,r13
 3225 029a 00D0      		rcall gba_write_ram_8bit_data
 3226               	.LVL268:
 3227 029c 0F5F      		subi r16,-1
 3228 029e 1F4F      		sbci r17,-1
 3229               	.LVL269:
 256:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3230               		.loc 3 256 0 discriminator 3
 3231 02a0 0034      		cpi r16,64
 3232 02a2 1105      		cpc r17,__zero_reg__
 3233 02a4 01F4      		brne .L138
 3234 02a6 F0E4      		ldi r31,64
 3235 02a8 CF0E      		add r12,r31
 3236 02aa D11C      		adc r13,__zero_reg__
 3237 02ac E11C      		adc r14,__zero_reg__
 3238 02ae F11C      		adc r15,__zero_reg__
 3239               	.LVL270:
 3240               	.L320:
 3241               	.LBE212:
 258:main.c        **** 				address++;
 259:main.c        **** 			}
 260:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3242               		.loc 3 260 0
 3243 02b0 81E3      		ldi r24,lo8(49)
 3244 02b2 00D0      		rcall USART_Transmit
 3245               	.LVL271:
 261:main.c        **** 			
 262:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 3246               		.loc 3 262 0
 3247 02b4 9398      		cbi 0x12,3
 3248               	.L319:
 263:main.c        **** 			gba_mode(); // Set back
 3249               		.loc 3 263 0
 3250 02b6 00D0      		rcall gba_mode
 3251               	.LVL272:
 3252 02b8 00C0      		rjmp .L106
 3253               	.LVL273:
 3254               	.L137:
 264:main.c        **** 		}
 265:main.c        **** 		
 266:main.c        **** 		// Write 1 byte to SRAM address
 267:main.c        **** 		else if (receivedChar == GBA_WRITE_ONE_BYTE_SRAM) {
 3255               		.loc 3 267 0
 3256 02ba 8F36      		cpi r24,lo8(111)
 3257 02bc 01F4      		brne .L139
 3258               	.LBB213:
 268:main.c        **** 			gb_mode();
 3259               		.loc 3 268 0
 3260 02be 00D0      		rcall gb_mode
 3261               	.LVL274:
 269:main.c        **** 			
 270:main.c        **** 			uint8_t data = USART_Receive();
 3262               		.loc 3 270 0
 3263 02c0 00D0      		rcall USART_Receive
 3264               	.LVL275:
 271:main.c        **** 			gba_write_ram_8bit_data(address, data);
 3265               		.loc 3 271 0
 3266 02c2 682F      		mov r22,r24
 3267 02c4 C601      		movw r24,r12
 3268               	.LVL276:
 3269 02c6 00D0      		rcall gba_write_ram_8bit_data
 3270               	.LVL277:
 3271 02c8 00C0      		rjmp .L322
 3272               	.L139:
 3273               	.LBE213:
 272:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 273:main.c        **** 			
 274:main.c        **** 			gba_mode(); // Set back
 275:main.c        **** 		}
 276:main.c        **** 		
 277:main.c        **** 		
 278:main.c        **** 		// ---------- FLASH ----------
 279:main.c        **** 		// Read the Flash Manufacturer and Device ID
 280:main.c        **** 		else if (receivedChar == GBA_FLASH_READ_ID) {
 3274               		.loc 3 280 0
 3275 02ca 8936      		cpi r24,lo8(105)
 3276 02cc 01F4      		brne .L140
 281:main.c        **** 			gb_mode();
 3277               		.loc 3 281 0
 3278 02ce 00D0      		rcall gb_mode
 3279               	.LVL278:
 282:main.c        **** 			
 283:main.c        **** 			flash_read_chip_id();
 3280               		.loc 3 283 0
 3281 02d0 00D0      		rcall flash_read_chip_id
 3282               	.LVL279:
 284:main.c        **** 			USART_Transmit(flashChipIdBuffer[0]);
 3283               		.loc 3 284 0
 3284 02d2 8091 0000 		lds r24,flashChipIdBuffer
 3285 02d6 00D0      		rcall USART_Transmit
 3286               	.LVL280:
 285:main.c        **** 			USART_Transmit(flashChipIdBuffer[1]);
 3287               		.loc 3 285 0
 3288 02d8 8091 0000 		lds r24,flashChipIdBuffer+1
 3289               	.L321:
 3290 02dc 00D0      		rcall USART_Transmit
 3291               	.LVL281:
 3292 02de 00C0      		rjmp .L319
 3293               	.L140:
 286:main.c        **** 			
 287:main.c        **** 			gba_mode(); // Set back
 288:main.c        **** 		}
 289:main.c        **** 		
 290:main.c        **** 		// Change bank
 291:main.c        **** 		else if (receivedChar == GBA_FLASH_SET_BANK) {
 3294               		.loc 3 291 0
 3295 02e0 8B36      		cpi r24,lo8(107)
 3296 02e2 01F4      		brne .L141
 3297               	.LBB214:
 292:main.c        **** 			usart_read_chars(); // Read data
 3298               		.loc 3 292 0
 3299 02e4 00D0      		rcall usart_read_chars
 3300               	.LVL282:
 293:main.c        **** 			uint8_t bank = atoi(receivedBuffer); // Convert data string to dec
 3301               		.loc 3 293 0
 3302 02e6 80E0      		ldi r24,lo8(receivedBuffer)
 3303 02e8 90E0      		ldi r25,hi8(receivedBuffer)
 3304 02ea 00D0      		rcall atoi
 3305               	.LVL283:
 3306 02ec 182F      		mov r17,r24
 3307               	.LVL284:
 294:main.c        **** 			
 295:main.c        **** 			gb_mode();
 3308               		.loc 3 295 0
 3309 02ee 00D0      		rcall gb_mode
 3310               	.LVL285:
 296:main.c        **** 			flash_switch_bank(bank);
 3311               		.loc 3 296 0
 3312 02f0 812F      		mov r24,r17
 3313 02f2 00D0      		rcall flash_switch_bank
 3314               	.LVL286:
 3315 02f4 00C0      		rjmp .L319
 3316               	.LVL287:
 3317               	.L141:
 3318               	.LBE214:
 297:main.c        **** 			
 298:main.c        **** 			gba_mode(); // Set back
 299:main.c        **** 		}
 300:main.c        **** 		
 301:main.c        **** 		// Erase 4K sector on Flash (sector 0 to 15 for 512Kbit)
 302:main.c        **** 		else if (receivedChar == GBA_FLASH_4K_SECTOR_ERASE) {
 3319               		.loc 3 302 0
 3320 02f6 8337      		cpi r24,lo8(115)
 3321 02f8 01F4      		brne .L142
 3322               	.LBB215:
 303:main.c        **** 			gb_mode();
 3323               		.loc 3 303 0
 3324 02fa 00D0      		rcall gb_mode
 3325               	.LVL288:
 304:main.c        **** 			
 305:main.c        **** 			usart_read_chars(); // Read sector
 3326               		.loc 3 305 0
 3327 02fc 00D0      		rcall usart_read_chars
 3328               	.LVL289:
 306:main.c        **** 			uint8_t sectorAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 3329               		.loc 3 306 0
 3330 02fe 40E1      		ldi r20,lo8(16)
 3331 0300 50E0      		ldi r21,0
 3332 0302 60E0      		ldi r22,0
 3333 0304 70E0      		ldi r23,0
 3334 0306 80E0      		ldi r24,lo8(receivedBuffer)
 3335 0308 90E0      		ldi r25,hi8(receivedBuffer)
 3336 030a 00D0      		rcall strtol
 3337               	.LVL290:
 3338 030c 862F      		mov r24,r22
 3339               	.LVL291:
 307:main.c        **** 			
 308:main.c        **** 			flash_erase_4k_sector(sectorAddress);
 3340               		.loc 3 308 0
 3341 030e 00D0      		rcall flash_erase_4k_sector
 3342               	.LVL292:
 3343               	.L322:
 309:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 3344               		.loc 3 309 0
 3345 0310 81E3      		ldi r24,lo8(49)
 3346 0312 00C0      		rjmp .L321
 3347               	.L142:
 3348               	.LBE215:
 310:main.c        **** 			
 311:main.c        **** 			gba_mode(); // Set back
 312:main.c        **** 		}
 313:main.c        **** 		
 314:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment)
 315:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_BYTE) {
 3349               		.loc 3 315 0
 3350 0314 8236      		cpi r24,lo8(98)
 3351 0316 01F4      		brne .L143
 316:main.c        **** 			gb_mode();
 3352               		.loc 3 316 0
 3353 0318 00D0      		rcall gb_mode
 3354               	.LVL293:
 317:main.c        **** 			
 318:main.c        **** 			usart_read_bytes(64);
 3355               		.loc 3 318 0
 3356 031a 80E4      		ldi r24,lo8(64)
 3357 031c 90E0      		ldi r25,0
 3358 031e 00D0      		rcall usart_read_bytes
 3359               	.LVL294:
 319:main.c        **** 			
 320:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3360               		.loc 3 320 0
 3361 0320 939A      		sbi 0x12,3
 3362               	.LVL295:
 3363 0322 80E0      		ldi r24,lo8(receivedBuffer)
 3364 0324 A82E      		mov r10,r24
 3365 0326 80E0      		ldi r24,hi8(receivedBuffer)
 3366 0328 B82E      		mov r11,r24
 3367 032a 00E0      		ldi r16,0
 3368 032c 10E0      		ldi r17,0
 3369               	.LVL296:
 3370               	.L144:
 3371               	.LBB216:
 321:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 322:main.c        **** 				flash_write_byte(address, receivedBuffer[x]);
 3372               		.loc 3 322 0 discriminator 3
 3373 032e D501      		movw r26,r10
 3374 0330 6D91      		ld r22,X+
 3375 0332 5D01      		movw r10,r26
 3376 0334 C801      		movw r24,r16
 3377 0336 8C0D      		add r24,r12
 3378 0338 9D1D      		adc r25,r13
 3379 033a 00D0      		rcall flash_write_byte
 3380               	.LVL297:
 3381 033c 0F5F      		subi r16,-1
 3382 033e 1F4F      		sbci r17,-1
 3383               	.LVL298:
 321:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3384               		.loc 3 321 0 discriminator 3
 3385 0340 0034      		cpi r16,64
 3386 0342 1105      		cpc r17,__zero_reg__
 3387 0344 01F4      		brne .L144
 3388 0346 B0E4      		ldi r27,64
 3389 0348 CB0E      		add r12,r27
 3390 034a D11C      		adc r13,__zero_reg__
 3391 034c E11C      		adc r14,__zero_reg__
 3392 034e F11C      		adc r15,__zero_reg__
 3393 0350 00C0      		rjmp .L320
 3394               	.LVL299:
 3395               	.L143:
 3396               	.LBE216:
 323:main.c        **** 				address++;
 324:main.c        **** 			}
 325:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 326:main.c        **** 			
 327:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 328:main.c        **** 			gba_mode(); // Set back
 329:main.c        **** 		}
 330:main.c        **** 		
 331:main.c        **** 		// Write 128 bytes to flash sector for Atmel flash (and increment)
 332:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_ATMEL) {
 3397               		.loc 3 332 0
 3398 0352 8136      		cpi r24,lo8(97)
 3399 0354 01F4      		brne .L145
 333:main.c        **** 			gb_mode();
 3400               		.loc 3 333 0
 3401 0356 00D0      		rcall gb_mode
 3402               	.LVL300:
 334:main.c        **** 			
 335:main.c        **** 			usart_read_bytes(128);
 3403               		.loc 3 335 0
 3404 0358 80E8      		ldi r24,lo8(-128)
 3405 035a 90E0      		ldi r25,0
 3406 035c 00D0      		rcall usart_read_bytes
 3407               	.LVL301:
 336:main.c        **** 			
 337:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3408               		.loc 3 337 0
 3409 035e 939A      		sbi 0x12,3
 338:main.c        **** 			flash_write_sector(address); // Address used as sector number
 3410               		.loc 3 338 0
 3411 0360 C601      		movw r24,r12
 3412 0362 00D0      		rcall flash_write_sector
 3413               	.LVL302:
 339:main.c        **** 			address++;
 3414               		.loc 3 339 0
 3415 0364 EFEF      		ldi r30,-1
 3416 0366 CE1A      		sub r12,r30
 3417 0368 DE0A      		sbc r13,r30
 3418 036a EE0A      		sbc r14,r30
 3419 036c FE0A      		sbc r15,r30
 3420               	.LVL303:
 3421 036e 00C0      		rjmp .L320
 3422               	.L145:
 340:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 341:main.c        **** 			
 342:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 343:main.c        **** 			gba_mode(); // Set back
 344:main.c        **** 		}
 345:main.c        **** 		
 346:main.c        **** 		
 347:main.c        **** 		// ---------- EEPROM ----------
 348:main.c        **** 		// Set EEPROM size
 349:main.c        **** 		else if (receivedChar == GBA_SET_EEPROM_SIZE) {
 3423               		.loc 3 349 0
 3424 0370 8335      		cpi r24,lo8(83)
 3425 0372 01F4      		brne .L146
 350:main.c        **** 			usart_read_chars(); // Read size
 3426               		.loc 3 350 0
 3427 0374 00D0      		rcall usart_read_chars
 3428               	.LVL304:
 351:main.c        **** 			eepromSize = strtol(receivedBuffer, NULL, 16); // Convert size to dec
 3429               		.loc 3 351 0
 3430 0376 40E1      		ldi r20,lo8(16)
 3431 0378 50E0      		ldi r21,0
 3432 037a 60E0      		ldi r22,0
 3433 037c 70E0      		ldi r23,0
 3434 037e 80E0      		ldi r24,lo8(receivedBuffer)
 3435 0380 90E0      		ldi r25,hi8(receivedBuffer)
 3436 0382 00D0      		rcall strtol
 3437               	.LVL305:
 3438 0384 6887      		std Y+8,r22
 3439               	.LVL306:
 3440 0386 00C0      		rjmp .L106
 3441               	.LVL307:
 3442               	.L146:
 352:main.c        **** 		}
 353:main.c        **** 		
 354:main.c        **** 		// Read the EEPROM on address (and increment) until anything but 1 is received
 355:main.c        **** 		else if (receivedChar == GBA_READ_EEPROM) {
 3443               		.loc 3 355 0
 3444 0388 8536      		cpi r24,lo8(101)
 3445 038a 01F4      		brne .L147
 356:main.c        **** 			gba_eeprom_mode();
 3446               		.loc 3 356 0
 3447 038c 00D0      		rcall gba_eeprom_mode
 3448               	.LVL308:
 357:main.c        **** 			
 358:main.c        **** 			receivedChar = '1';
 3449               		.loc 3 358 0
 3450 038e F1E3      		ldi r31,lo8(49)
 3451 0390 F093 0000 		sts receivedChar,r31
 3452               	.L148:
 359:main.c        **** 			while (receivedChar == '1') {
 3453               		.loc 3 359 0
 3454 0394 8091 0000 		lds r24,receivedChar
 3455 0398 8133      		cpi r24,lo8(49)
 3456 039a 01F0      		breq .+2
 3457 039c 00C0      		rjmp .L319
 360:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 3458               		.loc 3 360 0
 3459 039e 939A      		sbi 0x12,3
 361:main.c        **** 				gba_eeprom_read(address, eepromSize);
 3460               		.loc 3 361 0
 3461 03a0 6885      		ldd r22,Y+8
 3462 03a2 C601      		movw r24,r12
 3463 03a4 00D0      		rcall gba_eeprom_read
 3464               	.LVL309:
 3465 03a6 00E0      		ldi r16,lo8(eepromBuffer)
 3466 03a8 10E0      		ldi r17,hi8(eepromBuffer)
 3467               	.LVL310:
 3468               	.L149:
 3469               	.LBB217:
 362:main.c        **** 				
 363:main.c        **** 				// Send back the 8 bytes of data
 364:main.c        **** 				for (uint8_t c = 0; c < 8; c++) {
 365:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3470               		.loc 3 365 0 discriminator 3
 3471 03aa D801      		movw r26,r16
 3472 03ac 8D91      		ld r24,X+
 3473 03ae 8D01      		movw r16,r26
 3474               	.LVL311:
 3475 03b0 00D0      		rcall USART_Transmit
 3476               	.LVL312:
 364:main.c        **** 					USART_Transmit(eepromBuffer[c]);
 3477               		.loc 3 364 0 discriminator 3
 3478 03b2 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3479 03b4 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3480 03b6 E017      		cp r30,r16
 3481 03b8 F107      		cpc r31,r17
 3482 03ba 01F4      		brne .L149
 3483               	.LBE217:
 366:main.c        **** 				}
 367:main.c        **** 				address++; // Increment to next 8 bytes
 3484               		.loc 3 367 0
 3485 03bc FFEF      		ldi r31,-1
 3486 03be CF1A      		sub r12,r31
 3487 03c0 DF0A      		sbc r13,r31
 3488 03c2 EF0A      		sbc r14,r31
 3489 03c4 FF0A      		sbc r15,r31
 3490               	.LVL313:
 368:main.c        **** 				
 369:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 3491               		.loc 3 369 0
 3492 03c6 9398      		cbi 0x12,3
 370:main.c        **** 				receivedChar = USART_Receive();
 3493               		.loc 3 370 0
 3494 03c8 00D0      		rcall USART_Receive
 3495               	.LVL314:
 3496 03ca 8093 0000 		sts receivedChar,r24
 3497 03ce 00C0      		rjmp .L148
 3498               	.LVL315:
 3499               	.L147:
 371:main.c        **** 			}
 372:main.c        **** 			
 373:main.c        **** 			gba_mode(); // Set back
 374:main.c        **** 		}
 375:main.c        **** 		
 376:main.c        **** 		// Write 8 bytes to the EEPROM address (and increment)
 377:main.c        **** 		else if (receivedChar == GBA_WRITE_EEPROM) {
 3500               		.loc 3 377 0
 3501 03d0 8037      		cpi r24,lo8(112)
 3502 03d2 01F4      		brne .L151
 378:main.c        **** 			gba_eeprom_mode();
 3503               		.loc 3 378 0
 3504 03d4 00D0      		rcall gba_eeprom_mode
 3505               	.LVL316:
 3506 03d6 00E0      		ldi r16,lo8(eepromBuffer)
 3507 03d8 10E0      		ldi r17,hi8(eepromBuffer)
 3508               	.LVL317:
 3509               	.L152:
 3510               	.LBB218:
 379:main.c        **** 			
 380:main.c        **** 			// Read 8 bytes from USART and place in buffer
 381:main.c        **** 			for (uint8_t x = 0; x < 8; x++) {
 382:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3511               		.loc 3 382 0 discriminator 3
 3512 03da 00D0      		rcall USART_Receive
 3513               	.LVL318:
 3514 03dc D801      		movw r26,r16
 3515 03de 8D93      		st X+,r24
 3516 03e0 8D01      		movw r16,r26
 3517               	.LVL319:
 381:main.c        **** 				eepromBuffer[x] = USART_Receive();
 3518               		.loc 3 381 0 discriminator 3
 3519 03e2 E0E0      		ldi r30,lo8(eepromBuffer+8)
 3520 03e4 F0E0      		ldi r31,hi8(eepromBuffer+8)
 3521 03e6 EA17      		cp r30,r26
 3522 03e8 FB07      		cpc r31,r27
 3523 03ea 01F4      		brne .L152
 3524               	.LBE218:
 383:main.c        **** 			}
 384:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3525               		.loc 3 384 0
 3526 03ec 939A      		sbi 0x12,3
 385:main.c        **** 			
 386:main.c        **** 			gba_eeprom_write(address, eepromSize);
 3527               		.loc 3 386 0
 3528 03ee 6885      		ldd r22,Y+8
 3529 03f0 C601      		movw r24,r12
 3530 03f2 00D0      		rcall gba_eeprom_write
 3531               	.LVL320:
 387:main.c        **** 			address++;
 3532               		.loc 3 387 0
 3533 03f4 FFEF      		ldi r31,-1
 3534 03f6 CF1A      		sub r12,r31
 3535 03f8 DF0A      		sbc r13,r31
 3536 03fa EF0A      		sbc r14,r31
 3537 03fc FF0A      		sbc r15,r31
 3538               	.LVL321:
 3539               	.LBB219:
 3540               	.LBB220:
 187:c:\winavr-20100110\avr\include\util\delay.h **** 
 3541               		.loc 2 187 0
 3542 03fe 8FE7      		ldi r24,lo8(15999)
 3543 0400 9EE3      		ldi r25,hi8(15999)
 3544 0402 0197      	1:	sbiw r24,1
 3545 0404 01F4      		brne 1b
 3546 0406 00C0      		rjmp .
 3547 0408 0000      		nop
 3548               	.LVL322:
 3549 040a 00C0      		rjmp .L320
 3550               	.LVL323:
 3551               	.L151:
 3552               	.LBE220:
 3553               	.LBE219:
 388:main.c        **** 			
 389:main.c        **** 			_delay_ms(8); // Wait for EEPROM to write data (8ms)
 390:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 391:main.c        **** 			
 392:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 393:main.c        **** 			gba_mode(); // Set back
 394:main.c        **** 		}
 395:main.c        **** 		
 396:main.c        **** 		
 397:main.c        **** 		// ---------- GB FLASH CARTS ----------
 398:main.c        **** 		// Select which pin need to pulse as WE (Audio or WR)
 399:main.c        **** 		else if (receivedChar == GB_FLASH_WE_PIN) {
 3554               		.loc 3 399 0
 3555 040c 8035      		cpi r24,lo8(80)
 3556 040e 01F4      		brne .L153
 400:main.c        **** 			flashWriteWePin = USART_Receive();
 3557               		.loc 3 400 0
 3558 0410 00D0      		rcall USART_Receive
 3559               	.LVL324:
 3560 0412 8093 0000 		sts flashWriteWePin,r24
 401:main.c        **** 			
 402:main.c        **** 			if (flashWriteWePin == WE_AS_AUDIO_PIN) {
 3561               		.loc 3 402 0
 3562 0416 8134      		cpi r24,lo8(65)
 3563 0418 01F0      		breq .+2
 3564 041a 00C0      		rjmp .L106
 403:main.c        **** 				DDRE |= (1<<AUDIO_PIN);
 3565               		.loc 3 403 0
 3566 041c 319A      		sbi 0x6,1
 404:main.c        **** 				audioPin_high;
 3567               		.loc 3 404 0
 3568 041e 399A      		sbi 0x7,1
 3569 0420 00C0      		rjmp .L106
 3570               	.L153:
 405:main.c        **** 			}
 406:main.c        **** 		}
 407:main.c        **** 		
 408:main.c        **** 		// Some flash carts may require changing the bank back to 1 in order to accept flash chip command
 409:main.c        **** 		else if (receivedChar == GB_FLASH_BANK_1_COMMAND_WRITES) {
 3571               		.loc 3 409 0
 3572 0422 8E34      		cpi r24,lo8(78)
 3573 0424 01F4      		brne .L154
 410:main.c        **** 			flashBank1CommandWrites = 1;
 3574               		.loc 3 410 0
 3575 0426 81E0      		ldi r24,lo8(1)
 3576 0428 8093 0000 		sts flashBank1CommandWrites,r24
 3577 042c 00C0      		rjmp .L106
 3578               	.L154:
 411:main.c        **** 		}
 412:main.c        **** 		
 413:main.c        **** 		// Load the program method to use
 414:main.c        **** 		else if (receivedChar == GB_FLASH_PROGRAM_METHOD) {
 3579               		.loc 3 414 0
 3580 042e 8534      		cpi r24,lo8(69)
 3581 0430 01F4      		brne .L155
 3582 0432 00E0      		ldi r16,lo8(flashWriteCycle)
 3583 0434 10E0      		ldi r17,hi8(flashWriteCycle)
 3584               	.L156:
 3585               	.LBB221:
 415:main.c        **** 			for (uint8_t x = 0; x < 3; x++) {
 416:main.c        **** 				usart_read_chars(); // Address
 3586               		.loc 3 416 0 discriminator 3
 3587 0436 00D0      		rcall usart_read_chars
 3588               	.LVL325:
 417:main.c        **** 				flashWriteCycle[x][0] = strtol(receivedBuffer, NULL, 16);
 3589               		.loc 3 417 0 discriminator 3
 3590 0438 40E1      		ldi r20,lo8(16)
 3591 043a 50E0      		ldi r21,0
 3592 043c 60E0      		ldi r22,0
 3593 043e 70E0      		ldi r23,0
 3594 0440 80E0      		ldi r24,lo8(receivedBuffer)
 3595 0442 90E0      		ldi r25,hi8(receivedBuffer)
 3596 0444 00D0      		rcall strtol
 3597               	.LVL326:
 3598 0446 D801      		movw r26,r16
 3599 0448 6D93      		st X+,r22
 3600 044a 7C93      		st X,r23
 418:main.c        **** 				USART_Transmit(SEND_ACK);
 3601               		.loc 3 418 0 discriminator 3
 3602 044c 81E3      		ldi r24,lo8(49)
 3603 044e 00D0      		rcall USART_Transmit
 3604               	.LVL327:
 419:main.c        **** 				
 420:main.c        **** 				usart_read_chars(); // Data
 3605               		.loc 3 420 0 discriminator 3
 3606 0450 00D0      		rcall usart_read_chars
 3607               	.LVL328:
 421:main.c        **** 				flashWriteCycle[x][1] = strtol(receivedBuffer, NULL, 16);
 3608               		.loc 3 421 0 discriminator 3
 3609 0452 40E1      		ldi r20,lo8(16)
 3610 0454 50E0      		ldi r21,0
 3611 0456 60E0      		ldi r22,0
 3612 0458 70E0      		ldi r23,0
 3613 045a 80E0      		ldi r24,lo8(receivedBuffer)
 3614 045c 90E0      		ldi r25,hi8(receivedBuffer)
 3615 045e 00D0      		rcall strtol
 3616               	.LVL329:
 3617 0460 F801      		movw r30,r16
 3618 0462 7383      		std Z+3,r23
 3619 0464 6283      		std Z+2,r22
 422:main.c        **** 				USART_Transmit(SEND_ACK);
 3620               		.loc 3 422 0 discriminator 3
 3621 0466 81E3      		ldi r24,lo8(49)
 3622 0468 00D0      		rcall USART_Transmit
 3623               	.LVL330:
 3624 046a 0C5F      		subi r16,-4
 3625 046c 1F4F      		sbci r17,-1
 415:main.c        **** 				usart_read_chars(); // Address
 3626               		.loc 3 415 0 discriminator 3
 3627 046e 80E0      		ldi r24,lo8(flashWriteCycle+12)
 3628 0470 90E0      		ldi r25,hi8(flashWriteCycle+12)
 3629 0472 8017      		cp r24,r16
 3630 0474 9107      		cpc r25,r17
 3631 0476 01F4      		brne .L156
 3632 0478 00C0      		rjmp .L106
 3633               	.L155:
 3634               	.LBE221:
 423:main.c        **** 			}
 424:main.c        **** 		}
 425:main.c        **** 		
 426:main.c        **** 		// Write address and one byte to Flash, pulse a pin
 427:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BYTE) {
 3635               		.loc 3 427 0
 3636 047a 8634      		cpi r24,lo8(70)
 3637 047c 01F4      		brne .L157
 3638               	.LBB222:
 428:main.c        **** 			usart_read_chars(); // Read address
 3639               		.loc 3 428 0
 3640 047e 00D0      		rcall usart_read_chars
 3641               	.LVL331:
 429:main.c        **** 			uint16_t flashAddress = strtol(receivedBuffer, NULL, 16);
 3642               		.loc 3 429 0
 3643 0480 40E1      		ldi r20,lo8(16)
 3644 0482 50E0      		ldi r21,0
 3645 0484 60E0      		ldi r22,0
 3646 0486 70E0      		ldi r23,0
 3647 0488 80E0      		ldi r24,lo8(receivedBuffer)
 3648 048a 90E0      		ldi r25,hi8(receivedBuffer)
 3649 048c 00D0      		rcall strtol
 3650               	.LVL332:
 3651 048e 4B01      		movw r8,r22
 3652 0490 5C01      		movw r10,r24
 3653               	.LVL333:
 430:main.c        **** 			
 431:main.c        **** 			usart_read_chars(); // Read data byte
 3654               		.loc 3 431 0
 3655 0492 00D0      		rcall usart_read_chars
 3656               	.LVL334:
 432:main.c        **** 			uint8_t flashByte = strtol(receivedBuffer, NULL, 16);
 3657               		.loc 3 432 0
 3658 0494 40E1      		ldi r20,lo8(16)
 3659 0496 50E0      		ldi r21,0
 3660 0498 60E0      		ldi r22,0
 3661 049a 70E0      		ldi r23,0
 3662 049c 80E0      		ldi r24,lo8(receivedBuffer)
 3663 049e 90E0      		ldi r25,hi8(receivedBuffer)
 3664 04a0 00D0      		rcall strtol
 3665               	.LVL335:
 433:main.c        **** 			
 434:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3666               		.loc 3 434 0
 3667 04a2 939A      		sbi 0x12,3
 435:main.c        **** 			gb_flash_write_bus_cycle(flashAddress, flashByte);
 3668               		.loc 3 435 0
 3669 04a4 C401      		movw r24,r8
 3670 04a6 00D0      		rcall gb_flash_write_bus_cycle
 3671               	.LVL336:
 3672 04a8 00C0      		rjmp .L334
 3673               	.LVL337:
 3674               	.L157:
 3675               	.LBE222:
 436:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 437:main.c        **** 			
 438:main.c        **** 			USART_Transmit(SEND_ACK);
 439:main.c        **** 		}
 440:main.c        **** 		
 441:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time (and increment), pulse a pin
 442:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE) {
 3676               		.loc 3 442 0
 3677 04aa 8435      		cpi r24,lo8(84)
 3678 04ac 01F4      		brne .L158
 443:main.c        **** 			usart_read_bytes(64);
 3679               		.loc 3 443 0
 3680 04ae 80E4      		ldi r24,lo8(64)
 3681 04b0 90E0      		ldi r25,0
 3682 04b2 00D0      		rcall usart_read_bytes
 3683               	.LVL338:
 444:main.c        **** 			start_timeout_timer();
 3684               		.loc 3 444 0
 3685 04b4 00D0      		rcall start_timeout_timer
 3686               	.LVL339:
 445:main.c        **** 			
 446:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3687               		.loc 3 446 0
 3688 04b6 939A      		sbi 0x12,3
 447:main.c        **** 			if (flashBank1CommandWrites == 0) {
 3689               		.loc 3 447 0
 3690 04b8 8091 0000 		lds r24,flashBank1CommandWrites
 3691 04bc 00E0      		ldi r16,lo8(receivedBuffer)
 3692 04be A02E      		mov r10,r16
 3693 04c0 00E0      		ldi r16,hi8(receivedBuffer)
 3694 04c2 B02E      		mov r11,r16
 3695 04c4 00E0      		ldi r16,0
 3696 04c6 10E0      		ldi r17,0
 3697 04c8 8111      		cpse r24,__zero_reg__
 3698 04ca 00C0      		rjmp .L164
 3699               	.LVL340:
 3700               	.L161:
 3701               	.LBB223:
 448:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 449:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3702               		.loc 3 449 0
 3703 04cc D501      		movw r26,r10
 3704 04ce 6D91      		ld r22,X+
 3705 04d0 5D01      		movw r10,r26
 3706 04d2 6F3F      		cpi r22,lo8(-1)
 3707 04d4 01F0      		breq .L160
 450:main.c        **** 						gb_flash_write_byte(address, receivedBuffer[x]);
 3708               		.loc 3 450 0
 3709 04d6 C801      		movw r24,r16
 3710 04d8 8C0D      		add r24,r12
 3711 04da 9D1D      		adc r25,r13
 3712 04dc 00D0      		rcall gb_flash_write_byte
 3713               	.LVL341:
 3714               	.L160:
 3715 04de 0F5F      		subi r16,-1
 3716 04e0 1F4F      		sbci r17,-1
 3717               	.LVL342:
 448:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 3718               		.loc 3 448 0 discriminator 2
 3719 04e2 0034      		cpi r16,64
 3720 04e4 1105      		cpc r17,__zero_reg__
 3721 04e6 01F4      		brne .L161
 3722 04e8 00C0      		rjmp .L323
 3723               	.LVL343:
 3724               	.L164:
 3725               	.LBE223:
 3726               	.LBB224:
 451:main.c        **** 					}
 452:main.c        **** 					address++;
 453:main.c        **** 				}
 454:main.c        **** 			}
 455:main.c        **** 			else { // Some flash carts need to change to bank 1 to issue flash commands
 456:main.c        **** 				for (uint8_t x = 0; x < 64; x++) {
 457:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3727               		.loc 3 457 0
 3728 04ea F501      		movw r30,r10
 3729 04ec 6191      		ld r22,Z+
 3730 04ee 5F01      		movw r10,r30
 3731 04f0 6F3F      		cpi r22,lo8(-1)
 3732 04f2 01F0      		breq .L163
 458:main.c        **** 						gb_flash_write_byte_bank1_commands(address, receivedBuffer[x]);
 3733               		.loc 3 458 0
 3734 04f4 C801      		movw r24,r16
 3735 04f6 8C0D      		add r24,r12
 3736 04f8 9D1D      		adc r25,r13
 3737 04fa 00D0      		rcall gb_flash_write_byte_bank1_commands
 3738               	.LVL344:
 3739               	.L163:
 3740 04fc 0F5F      		subi r16,-1
 3741 04fe 1F4F      		sbci r17,-1
 3742               	.LVL345:
 456:main.c        **** 					if (receivedBuffer[x] != 0xFF) {
 3743               		.loc 3 456 0 discriminator 2
 3744 0500 0034      		cpi r16,64
 3745 0502 1105      		cpc r17,__zero_reg__
 3746 0504 01F4      		brne .L164
 3747 0506 F0E4      		ldi r31,64
 3748 0508 CF0E      		add r12,r31
 3749 050a D11C      		adc r13,__zero_reg__
 3750 050c E11C      		adc r14,__zero_reg__
 3751 050e F11C      		adc r15,__zero_reg__
 3752               	.LVL346:
 3753 0510 00C0      		rjmp .L317
 3754               	.LVL347:
 3755               	.L158:
 3756               	.LBE224:
 459:main.c        **** 					}
 460:main.c        **** 					address++;
 461:main.c        **** 				}
 462:main.c        **** 			}
 463:main.c        **** 			
 464:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 465:main.c        **** 		}
 466:main.c        **** 		
 467:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 468:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_BUFFERED_32BYTE) {
 3757               		.loc 3 468 0
 3758 0512 8935      		cpi r24,lo8(89)
 3759 0514 01F0      		breq .+2
 3760 0516 00C0      		rjmp .L165
 3761               	.LBB225:
 469:main.c        **** 			usart_read_bytes(32);
 3762               		.loc 3 469 0
 3763 0518 80E2      		ldi r24,lo8(32)
 3764 051a 90E0      		ldi r25,0
 3765 051c 00D0      		rcall usart_read_bytes
 3766               	.LVL348:
 470:main.c        **** 			start_timeout_timer();
 3767               		.loc 3 470 0
 3768 051e 00D0      		rcall start_timeout_timer
 3769               	.LVL349:
 471:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3770               		.loc 3 471 0
 3771 0520 939A      		sbi 0x12,3
 472:main.c        **** 			
 473:main.c        **** 			// Setup buffered write
 474:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xAA);
 3772               		.loc 3 474 0
 3773 0522 6AEA      		ldi r22,lo8(-86)
 3774 0524 8AEA      		ldi r24,lo8(-86)
 3775 0526 9AE0      		ldi r25,lo8(10)
 3776 0528 00D0      		rcall gb_flash_write_bus_cycle
 3777               	.LVL350:
 475:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x55);
 3778               		.loc 3 475 0
 3779 052a 65E5      		ldi r22,lo8(85)
 3780 052c 85E5      		ldi r24,lo8(85)
 3781 052e 95E0      		ldi r25,lo8(5)
 3782 0530 00D0      		rcall gb_flash_write_bus_cycle
 3783               	.LVL351:
 476:main.c        **** 			gb_flash_write_bus_cycle(address, 0x25);
 3784               		.loc 3 476 0
 3785 0532 5601      		movw r10,r12
 3786 0534 65E2      		ldi r22,lo8(37)
 3787 0536 C601      		movw r24,r12
 3788 0538 00D0      		rcall gb_flash_write_bus_cycle
 3789               	.LVL352:
 477:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F); // Length
 3790               		.loc 3 477 0
 3791 053a 6FE1      		ldi r22,lo8(31)
 3792 053c C601      		movw r24,r12
 3793 053e 00D0      		rcall gb_flash_write_bus_cycle
 3794               	.LVL353:
 3795               	.LBB226:
 3796               	.LBB227:
 3797               		.loc 2 276 0
 3798 0540 22E0      		ldi r18,lo8(2)
 3799 0542 2A95      	1:	dec r18
 3800 0544 01F4      		brne 1b
 3801 0546 00C0      		rjmp .
 3802               	.LVL354:
 3803 0548 00E0      		ldi r16,lo8(receivedBuffer)
 3804 054a 10E0      		ldi r17,hi8(receivedBuffer)
 3805 054c 812C      		mov r8,__zero_reg__
 3806 054e 912C      		mov r9,__zero_reg__
 3807               	.LVL355:
 3808               	.L166:
 3809               	.LBE227:
 3810               	.LBE226:
 3811               	.LBB228:
 478:main.c        **** 			_delay_us(1);
 479:main.c        **** 			
 480:main.c        **** 			// Write data
 481:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 482:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3812               		.loc 3 482 0 discriminator 3
 3813 0550 D801      		movw r26,r16
 3814 0552 6D91      		ld r22,X+
 3815 0554 8D01      		movw r16,r26
 3816 0556 C401      		movw r24,r8
 3817 0558 8A0D      		add r24,r10
 3818 055a 9B1D      		adc r25,r11
 3819 055c 00D0      		rcall gb_flash_write_bus_cycle
 3820               	.LVL356:
 3821 055e BFEF      		ldi r27,-1
 3822 0560 8B1A      		sub r8,r27
 3823 0562 9B0A      		sbc r9,r27
 3824               	.LVL357:
 481:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 3825               		.loc 3 481 0 discriminator 3
 3826 0564 E0E2      		ldi r30,32
 3827 0566 8E16      		cp r8,r30
 3828 0568 9104      		cpc r9,__zero_reg__
 3829 056a 01F4      		brne .L166
 3830 056c F0E2      		ldi r31,32
 3831 056e CF0E      		add r12,r31
 3832 0570 D11C      		adc r13,__zero_reg__
 3833 0572 E11C      		adc r14,__zero_reg__
 3834 0574 F11C      		adc r15,__zero_reg__
 3835               	.LBE228:
 483:main.c        **** 				address++;
 484:main.c        **** 			}
 485:main.c        **** 			
 486:main.c        **** 			// Write buffer to flash
 487:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0x29);
 3836               		.loc 3 487 0
 3837 0576 C601      		movw r24,r12
 3838 0578 8097      		sbiw r24,32
 3839 057a 69E2      		ldi r22,lo8(41)
 3840 057c 00D0      		rcall gb_flash_write_bus_cycle
 3841               	.LVL358:
 3842               	.LBB229:
 3843               	.LBB230:
 3844               		.loc 2 276 0
 3845 057e 8FE8      		ldi r24,lo8(399)
 3846 0580 91E0      		ldi r25,hi8(399)
 3847 0582 0197      	1:	sbiw r24,1
 3848 0584 01F4      		brne 1b
 3849 0586 00C0      		rjmp .
 3850 0588 0000      		nop
 3851               	.LVL359:
 3852               	.LBE230:
 3853               	.LBE229:
 488:main.c        **** 			_delay_us(200);
 489:main.c        **** 			
 490:main.c        **** 			// Verify last byte written
 491:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 3854               		.loc 3 491 0
 3855 058a 8601      		movw r16,r12
 3856 058c 0150      		subi r16,1
 3857 058e 1109      		sbc r17,__zero_reg__
 3858 0590 C801      		movw r24,r16
 3859 0592 00D0      		rcall gb_flash_read_byte
 3860               	.LVL360:
 3861               	.L167:
 492:main.c        **** 			while (dataVerify != receivedBuffer[31]) {
 3862               		.loc 3 492 0
 3863 0594 9091 0000 		lds r25,receivedBuffer+31
 3864 0598 8917      		cp r24,r25
 3865 059a 01F4      		brne .+2
 3866 059c 00C0      		rjmp .L317
 493:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 3867               		.loc 3 493 0
 3868 059e C801      		movw r24,r16
 3869               	.LVL361:
 3870 05a0 00D0      		rcall gb_flash_read_byte
 3871               	.LVL362:
 3872               	.LBB231:
 3873               	.LBB232:
 3874               		.loc 2 276 0
 3875 05a2 9DE0      		ldi r25,lo8(13)
 3876 05a4 9A95      	1:	dec r25
 3877 05a6 01F4      		brne 1b
 3878 05a8 0000      		nop
 3879               	.LVL363:
 3880               	.LBE232:
 3881               	.LBE231:
 494:main.c        **** 				_delay_us(5);
 495:main.c        **** 				if (writingTimedout == 1) {
 3882               		.loc 3 495 0
 3883 05aa 9091 0000 		lds r25,writingTimedout
 3884 05ae 9130      		cpi r25,lo8(1)
 3885 05b0 01F4      		brne .L167
 3886 05b2 00C0      		rjmp .L317
 3887               	.LVL364:
 3888               	.L165:
 3889               	.LBE225:
 496:main.c        **** 					break;
 497:main.c        **** 				}
 498:main.c        **** 			}
 499:main.c        **** 			
 500:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 501:main.c        **** 		}
 502:main.c        **** 		
 503:main.c        **** 		// Write 64 bytes to Flash address one byte write at a time, increment and pulse the reset pin af
 504:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_64BYTE_PULSE_RESET) {
 3890               		.loc 3 504 0
 3891 05b4 8A34      		cpi r24,lo8(74)
 3892 05b6 01F4      		brne .L170
 505:main.c        **** 			usart_read_bytes(64);
 3893               		.loc 3 505 0
 3894 05b8 80E4      		ldi r24,lo8(64)
 3895 05ba 90E0      		ldi r25,0
 3896 05bc 00D0      		rcall usart_read_bytes
 3897               	.LVL365:
 506:main.c        **** 			start_timeout_timer();
 3898               		.loc 3 506 0
 3899 05be 00D0      		rcall start_timeout_timer
 3900               	.LVL366:
 507:main.c        **** 			
 508:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3901               		.loc 3 508 0
 3902 05c0 939A      		sbi 0x12,3
 3903               	.LVL367:
 3904 05c2 10E0      		ldi r17,lo8(receivedBuffer)
 3905 05c4 A12E      		mov r10,r17
 3906 05c6 10E0      		ldi r17,hi8(receivedBuffer)
 3907 05c8 B12E      		mov r11,r17
 3908 05ca 00E0      		ldi r16,0
 3909 05cc 10E0      		ldi r17,0
 3910               	.LVL368:
 3911               	.L172:
 3912               	.LBB233:
 509:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 510:main.c        **** 				if (receivedBuffer[x] != 0xFF) {
 3913               		.loc 3 510 0
 3914 05ce D501      		movw r26,r10
 3915 05d0 6D91      		ld r22,X+
 3916 05d2 5D01      		movw r10,r26
 3917 05d4 6F3F      		cpi r22,lo8(-1)
 3918 05d6 01F0      		breq .L171
 511:main.c        **** 					gb_flash_write_byte_special(address, receivedBuffer[x]);
 3919               		.loc 3 511 0
 3920 05d8 C801      		movw r24,r16
 3921 05da 8C0D      		add r24,r12
 3922 05dc 9D1D      		adc r25,r13
 3923 05de 00D0      		rcall gb_flash_write_byte_special
 3924               	.LVL369:
 3925               	.L171:
 3926 05e0 0F5F      		subi r16,-1
 3927 05e2 1F4F      		sbci r17,-1
 3928               	.LVL370:
 509:main.c        **** 			for (uint8_t x = 0; x < 64; x++) {
 3929               		.loc 3 509 0 discriminator 2
 3930 05e4 0034      		cpi r16,64
 3931 05e6 1105      		cpc r17,__zero_reg__
 3932 05e8 01F4      		brne .L172
 3933               	.LVL371:
 3934               	.L323:
 3935 05ea B0E4      		ldi r27,64
 3936 05ec CB0E      		add r12,r27
 3937 05ee D11C      		adc r13,__zero_reg__
 3938 05f0 E11C      		adc r14,__zero_reg__
 3939 05f2 F11C      		adc r15,__zero_reg__
 3940 05f4 00C0      		rjmp .L317
 3941               	.LVL372:
 3942               	.L170:
 3943               	.LBE233:
 512:main.c        **** 				}
 513:main.c        **** 				address++;
 514:main.c        **** 			}
 515:main.c        **** 			
 516:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 517:main.c        **** 		}
 518:main.c        **** 		
 519:main.c        **** 		// Buffered programming, write 256 bytes to Flash address
 520:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_256BYTE) {
 3944               		.loc 3 520 0
 3945 05f6 8835      		cpi r24,lo8(88)
 3946 05f8 01F0      		breq .+2
 3947 05fa 00C0      		rjmp .L173
 3948               	.LBB234:
 521:main.c        **** 			usart_read_bytes(256);
 3949               		.loc 3 521 0
 3950 05fc 80E0      		ldi r24,0
 3951 05fe 91E0      		ldi r25,lo8(1)
 3952 0600 00D0      		rcall usart_read_bytes
 3953               	.LVL373:
 522:main.c        **** 			start_timeout_timer();
 3954               		.loc 3 522 0
 3955 0602 00D0      		rcall start_timeout_timer
 3956               	.LVL374:
 523:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 3957               		.loc 3 523 0
 3958 0604 939A      		sbi 0x12,3
 524:main.c        **** 			
 525:main.c        **** 			// Setup buffered write
 526:main.c        **** 			gb_flash_write_bus_cycle(0xAAA, 0xA9);
 3959               		.loc 3 526 0
 3960 0606 69EA      		ldi r22,lo8(-87)
 3961 0608 8AEA      		ldi r24,lo8(-86)
 3962 060a 9AE0      		ldi r25,lo8(10)
 3963 060c 00D0      		rcall gb_flash_write_bus_cycle
 3964               	.LVL375:
 527:main.c        **** 			gb_flash_write_bus_cycle(0x555, 0x56);
 3965               		.loc 3 527 0
 3966 060e 66E5      		ldi r22,lo8(86)
 3967 0610 85E5      		ldi r24,lo8(85)
 3968 0612 95E0      		ldi r25,lo8(5)
 3969 0614 00D0      		rcall gb_flash_write_bus_cycle
 3970               	.LVL376:
 528:main.c        **** 			gb_flash_write_bus_cycle(address, 0x26);
 3971               		.loc 3 528 0
 3972 0616 5601      		movw r10,r12
 3973 0618 66E2      		ldi r22,lo8(38)
 3974 061a C601      		movw r24,r12
 3975 061c 00D0      		rcall gb_flash_write_bus_cycle
 3976               	.LVL377:
 529:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF); // Length
 3977               		.loc 3 529 0
 3978 061e 6FEF      		ldi r22,lo8(-1)
 3979 0620 C601      		movw r24,r12
 3980 0622 00D0      		rcall gb_flash_write_bus_cycle
 3981               	.LVL378:
 3982               	.LBB235:
 3983               	.LBB236:
 3984               		.loc 2 276 0
 3985 0624 E5E8      		ldi r30,lo8(-123)
 3986 0626 EA95      	1:	dec r30
 3987 0628 01F4      		brne 1b
 3988 062a 0000      		nop
 3989               	.LVL379:
 3990 062c 00E0      		ldi r16,lo8(receivedBuffer)
 3991 062e 10E0      		ldi r17,hi8(receivedBuffer)
 3992               	.LBE236:
 3993               	.LBE235:
 3994               	.LBB237:
 530:main.c        **** 			_delay_us(50);
 531:main.c        **** 			
 532:main.c        **** 			// Write data
 533:main.c        **** 			for (int x = 0; x < 256; x++) {
 3995               		.loc 3 533 0
 3996 0630 812C      		mov r8,__zero_reg__
 3997 0632 912C      		mov r9,__zero_reg__
 3998               	.LVL380:
 3999               	.L174:
 534:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4000               		.loc 3 534 0 discriminator 3
 4001 0634 D801      		movw r26,r16
 4002 0636 6D91      		ld r22,X+
 4003 0638 8D01      		movw r16,r26
 4004 063a C401      		movw r24,r8
 4005 063c 8A0D      		add r24,r10
 4006 063e 9B1D      		adc r25,r11
 4007 0640 00D0      		rcall gb_flash_write_bus_cycle
 4008               	.LVL381:
 533:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4009               		.loc 3 533 0 discriminator 3
 4010 0642 BFEF      		ldi r27,-1
 4011 0644 8B1A      		sub r8,r27
 4012 0646 9B0A      		sbc r9,r27
 4013               	.LVL382:
 4014 0648 8114      		cp r8,__zero_reg__
 4015 064a E1E0      		ldi r30,1
 4016 064c 9E06      		cpc r9,r30
 4017 064e 01F4      		brne .L174
 4018 0650 FFEF      		ldi r31,-1
 4019 0652 DF1A      		sub r13,r31
 4020 0654 EF0A      		sbc r14,r31
 4021 0656 FF0A      		sbc r15,r31
 4022               	.LBE237:
 535:main.c        **** 				address++;
 536:main.c        **** 			}
 537:main.c        **** 			
 538:main.c        **** 			// Write buffer to flash
 539:main.c        **** 			gb_flash_write_bus_cycle(address-256, 0x2A);
 4023               		.loc 3 539 0
 4024 0658 C601      		movw r24,r12
 4025 065a 9A95      		dec r25
 4026 065c 6AE2      		ldi r22,lo8(42)
 4027 065e 00D0      		rcall gb_flash_write_bus_cycle
 4028               	.LVL383:
 540:main.c        **** 			
 541:main.c        **** 			// Verify last byte written
 542:main.c        **** 			uint8_t dataVerify = gb_flash_read_byte(address-1);
 4029               		.loc 3 542 0
 4030 0660 8601      		movw r16,r12
 4031 0662 0150      		subi r16,1
 4032 0664 1109      		sbc r17,__zero_reg__
 4033 0666 C801      		movw r24,r16
 4034 0668 00D0      		rcall gb_flash_read_byte
 4035               	.LVL384:
 4036               	.L175:
 543:main.c        **** 			while (dataVerify != receivedBuffer[255]) {
 4037               		.loc 3 543 0
 4038 066a 9091 0000 		lds r25,receivedBuffer+255
 4039 066e 8917      		cp r24,r25
 4040 0670 01F4      		brne .+2
 4041 0672 00C0      		rjmp .L317
 544:main.c        **** 				dataVerify = gb_flash_read_byte(address-1);
 4042               		.loc 3 544 0
 4043 0674 C801      		movw r24,r16
 4044               	.LVL385:
 4045 0676 00D0      		rcall gb_flash_read_byte
 4046               	.LVL386:
 4047               	.LBB238:
 4048               	.LBB239:
 4049               		.loc 2 276 0
 4050 0678 2DE0      		ldi r18,lo8(13)
 4051 067a 2A95      	1:	dec r18
 4052 067c 01F4      		brne 1b
 4053 067e 0000      		nop
 4054               	.LVL387:
 4055               	.LBE239:
 4056               	.LBE238:
 545:main.c        **** 				_delay_us(5);
 546:main.c        **** 				if (writingTimedout == 1) {
 4057               		.loc 3 546 0
 4058 0680 9091 0000 		lds r25,writingTimedout
 4059 0684 9130      		cpi r25,lo8(1)
 4060 0686 01F4      		brne .L175
 4061 0688 00C0      		rjmp .L317
 4062               	.LVL388:
 4063               	.L173:
 4064               	.LBE234:
 547:main.c        **** 					break;
 548:main.c        **** 				}
 549:main.c        **** 			}
 550:main.c        **** 			
 551:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 552:main.c        **** 		}
 553:main.c        **** 		
 554:main.c        **** 		// Nintendo Power 1MB Cart, Write 128 bytes to flash
 555:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_NP_128BYTE) {
 556:main.c        **** 			usart_read_bytes(128);
 557:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 558:main.c        **** 			
 559:main.c        **** 			// Enable flash chip access
 560:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x09);
 561:main.c        **** 			gb_flash_write_bus_cycle(0x121, 0xaa);
 562:main.c        **** 			gb_flash_write_bus_cycle(0x122, 0x55);
 563:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 564:main.c        **** 			_delay_us(5);
 565:main.c        **** 			
 566:main.c        **** 			// Re-Enable writes to MBC registers
 567:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x11);
 568:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 569:main.c        **** 			_delay_us(5);
 570:main.c        **** 			
 571:main.c        **** 			// Bank 1 for commands
 572:main.c        **** 			gb_flash_write_bus_cycle(0x2100, 0x01);
 573:main.c        **** 			_delay_us(5);
 574:main.c        **** 			
 575:main.c        **** 			
 576:main.c        **** 			// Write setup
 577:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 578:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 579:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 580:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xAA);
 581:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 582:main.c        **** 			_delay_us(5);
 583:main.c        **** 			
 584:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 585:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x2A);
 586:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0xAA);
 587:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0x55);
 588:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 589:main.c        **** 			_delay_us(5);
 590:main.c        **** 			
 591:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x0F);
 592:main.c        **** 			gb_flash_write_bus_cycle(0x125, 0x55);
 593:main.c        **** 			gb_flash_write_bus_cycle(0x126, 0x55);
 594:main.c        **** 			gb_flash_write_bus_cycle(0x127, 0xA0);
 595:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xA5);
 596:main.c        **** 			_delay_us(5);
 597:main.c        **** 			
 598:main.c        **** 			// Set bank back
 599:main.c        **** 			write_8bit_data(0x2100, lastBankAccessed, BANK_WRITE);
 600:main.c        **** 			_delay_us(5);
 601:main.c        **** 			
 602:main.c        **** 			// Disable writes to MBC registers
 603:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x10);
 604:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 605:main.c        **** 			_delay_us(5);
 606:main.c        **** 			
 607:main.c        **** 			// Undo Wakeup
 608:main.c        **** 			gb_flash_write_bus_cycle(0x120, 0x08);
 609:main.c        **** 			gb_flash_write_bus_cycle(0x13f, 0xa5);
 610:main.c        **** 			_delay_us(5);
 611:main.c        **** 			
 612:main.c        **** 			
 613:main.c        **** 			// Write data
 614:main.c        **** 			for (uint8_t x = 0; x < 128; x++) {
 615:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 616:main.c        **** 				_delay_us(5);
 617:main.c        **** 				address++;
 618:main.c        **** 			}
 619:main.c        **** 			
 620:main.c        **** 			// Write buffer to flash
 621:main.c        **** 			address--;
 622:main.c        **** 			gb_flash_write_bus_cycle(address, 0xFF);
 623:main.c        **** 			address++;
 624:main.c        **** 			_delay_ms(10);
 625:main.c        **** 			
 626:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 627:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 628:main.c        **** 		}
 629:main.c        **** 		
 630:main.c        **** 		// Buffered programming, write 32 bytes to Flash address
 631:main.c        **** 		// Intel chips such as 28F640J5 (Thanks to lesserkuma for adding support)
 632:main.c        **** 		else if (receivedChar == GB_FLASH_WRITE_INTEL_BUFFERED_32BYTE) {
 4065               		.loc 3 632 0
 4066 068a 8937      		cpi r24,lo8(121)
 4067 068c 01F4      		brne .L178
 633:main.c        **** 			usart_read_bytes(32);
 4068               		.loc 3 633 0
 4069 068e 80E2      		ldi r24,lo8(32)
 4070 0690 90E0      		ldi r25,0
 4071 0692 00D0      		rcall usart_read_bytes
 4072               	.LVL389:
 634:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4073               		.loc 3 634 0
 4074 0694 939A      		sbi 0x12,3
 635:main.c        **** 			
 636:main.c        **** 			// Setup buffered write
 637:main.c        **** 			gb_flash_write_bus_cycle(address, 0xE8);
 4075               		.loc 3 637 0
 4076 0696 5601      		movw r10,r12
 4077 0698 68EE      		ldi r22,lo8(-24)
 4078 069a C601      		movw r24,r12
 4079 069c 00D0      		rcall gb_flash_write_bus_cycle
 4080               	.LVL390:
 4081               	.L179:
 638:main.c        **** 			
 639:main.c        **** 			// Wait until ready
 640:main.c        **** 			//do { status = gb_flash_read_byte(address); } while(status != 0x80);
 641:main.c        **** 			while (gb_flash_read_byte(address) != 0x80);
 4082               		.loc 3 641 0 discriminator 1
 4083 069e C501      		movw r24,r10
 4084 06a0 00D0      		rcall gb_flash_read_byte
 4085               	.LVL391:
 4086 06a2 8038      		cpi r24,lo8(-128)
 4087 06a4 01F4      		brne .L179
 642:main.c        **** 			
 643:main.c        **** 			// Set buffer size
 644:main.c        **** 			gb_flash_write_bus_cycle(address, 0x1F);
 4088               		.loc 3 644 0
 4089 06a6 6FE1      		ldi r22,lo8(31)
 4090 06a8 C501      		movw r24,r10
 4091 06aa 00D0      		rcall gb_flash_write_bus_cycle
 4092               	.LVL392:
 4093 06ac 00E0      		ldi r16,lo8(receivedBuffer)
 4094 06ae 10E0      		ldi r17,hi8(receivedBuffer)
 4095 06b0 812C      		mov r8,__zero_reg__
 4096 06b2 912C      		mov r9,__zero_reg__
 4097               	.LVL393:
 4098               	.L180:
 4099               	.LBB240:
 645:main.c        **** 			
 646:main.c        **** 			// Write data to buffer
 647:main.c        **** 			for (uint8_t x = 0; x < 32; x++) {
 648:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4100               		.loc 3 648 0 discriminator 3
 4101 06b4 D801      		movw r26,r16
 4102 06b6 6D91      		ld r22,X+
 4103 06b8 8D01      		movw r16,r26
 4104 06ba C501      		movw r24,r10
 4105 06bc 880D      		add r24,r8
 4106 06be 991D      		adc r25,r9
 4107 06c0 00D0      		rcall gb_flash_write_bus_cycle
 4108               	.LVL394:
 4109 06c2 BFEF      		ldi r27,-1
 4110 06c4 8B1A      		sub r8,r27
 4111 06c6 9B0A      		sbc r9,r27
 4112               	.LVL395:
 647:main.c        **** 				gb_flash_write_bus_cycle(address, receivedBuffer[x]);
 4113               		.loc 3 647 0 discriminator 3
 4114 06c8 E0E2      		ldi r30,32
 4115 06ca 8E16      		cp r8,r30
 4116 06cc 9104      		cpc r9,__zero_reg__
 4117 06ce 01F4      		brne .L180
 4118 06d0 F0E2      		ldi r31,32
 4119 06d2 CF0E      		add r12,r31
 4120 06d4 D11C      		adc r13,__zero_reg__
 4121 06d6 E11C      		adc r14,__zero_reg__
 4122 06d8 F11C      		adc r15,__zero_reg__
 4123               	.LBE240:
 649:main.c        **** 				address++;
 650:main.c        **** 			}
 651:main.c        **** 			
 652:main.c        **** 			// Write buffer to flash
 653:main.c        **** 			gb_flash_write_bus_cycle(address-32, 0xD0);
 4124               		.loc 3 653 0
 4125 06da 8601      		movw r16,r12
 4126 06dc 0052      		subi r16,32
 4127 06de 1109      		sbc r17,__zero_reg__
 4128 06e0 60ED      		ldi r22,lo8(-48)
 4129 06e2 C801      		movw r24,r16
 4130 06e4 00D0      		rcall gb_flash_write_bus_cycle
 4131               	.LVL396:
 4132               	.LBB241:
 4133               	.LBB242:
 4134               		.loc 2 276 0
 4135 06e6 87E8      		ldi r24,lo8(391)
 4136 06e8 91E0      		ldi r25,hi8(391)
 4137 06ea 0197      	1:	sbiw r24,1
 4138 06ec 01F4      		brne 1b
 4139 06ee 00C0      		rjmp .
 4140 06f0 0000      		nop
 4141               	.L181:
 4142               	.LBE242:
 4143               	.LBE241:
 654:main.c        **** 			_delay_us(196);
 655:main.c        **** 			
 656:main.c        **** 			// Wait until ready
 657:main.c        **** 			//do { status = gb_flash_read_byte(address-32); } while(status != 0x80);
 658:main.c        **** 			while (gb_flash_read_byte(address-32) != 0x80);
 4144               		.loc 3 658 0 discriminator 1
 4145 06f2 C801      		movw r24,r16
 4146 06f4 00D0      		rcall gb_flash_read_byte
 4147               	.LVL397:
 4148 06f6 8038      		cpi r24,lo8(-128)
 4149 06f8 01F4      		brne .L181
 659:main.c        **** 			
 660:main.c        **** 			USART_Transmit(SEND_ACK); // Send back acknowledgement
 4150               		.loc 3 660 0
 4151 06fa 81E3      		ldi r24,lo8(49)
 4152 06fc 00C0      		rjmp .L318
 4153               	.LVL398:
 4154               	.L178:
 661:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 662:main.c        **** 		}
 663:main.c        **** 		
 664:main.c        **** 		
 665:main.c        **** 		// ---------- GBA FLASH CARTS ----------
 666:main.c        **** 		// Write 24 bit address, 16 bit data and pulse a pin
 667:main.c        **** 		else if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4155               		.loc 3 667 0
 4156 06fe 8E36      		cpi r24,lo8(110)
 4157 0700 01F4      		brne .L182
 4158               	.LBB243:
 668:main.c        **** 			usart_read_chars(); // Read address
 4159               		.loc 3 668 0
 4160 0702 00D0      		rcall usart_read_chars
 4161               	.LVL399:
 669:main.c        **** 			uint32_t flashAddress = strtol(receivedBuffer, NULL, 16); // Convert address string in hex to de
 4162               		.loc 3 669 0
 4163 0704 40E1      		ldi r20,lo8(16)
 4164 0706 50E0      		ldi r21,0
 4165 0708 60E0      		ldi r22,0
 4166 070a 70E0      		ldi r23,0
 4167 070c 80E0      		ldi r24,lo8(receivedBuffer)
 4168 070e 90E0      		ldi r25,hi8(receivedBuffer)
 4169 0710 00D0      		rcall strtol
 4170               	.LVL400:
 4171 0712 4B01      		movw r8,r22
 4172 0714 5C01      		movw r10,r24
 4173               	.LVL401:
 670:main.c        **** 			
 671:main.c        **** 			receivedChar = USART_Receive(); // Wait for byte
 4174               		.loc 3 671 0
 4175 0716 00D0      		rcall USART_Receive
 4176               	.LVL402:
 4177 0718 8093 0000 		sts receivedChar,r24
 672:main.c        **** 			if (receivedChar == GBA_FLASH_CART_WRITE_BYTE) {
 4178               		.loc 3 672 0
 4179 071c 8E36      		cpi r24,lo8(110)
 4180 071e 01F0      		breq .+2
 4181 0720 00C0      		rjmp .L106
 4182               	.LBB244:
 673:main.c        **** 				usart_read_chars(); // Read data
 4183               		.loc 3 673 0
 4184 0722 00D0      		rcall usart_read_chars
 4185               	.LVL403:
 674:main.c        **** 				uint16_t flashByte = strtol(receivedBuffer, NULL, 16); // Convert data byte in hex to dec
 4186               		.loc 3 674 0
 4187 0724 40E1      		ldi r20,lo8(16)
 4188 0726 50E0      		ldi r21,0
 4189 0728 60E0      		ldi r22,0
 4190 072a 70E0      		ldi r23,0
 4191 072c 80E0      		ldi r24,lo8(receivedBuffer)
 4192 072e 90E0      		ldi r25,hi8(receivedBuffer)
 4193 0730 00D0      		rcall strtol
 4194               	.LVL404:
 675:main.c        **** 				
 676:main.c        **** 				PORTD |= (1<<ACTIVITY_LED);
 4195               		.loc 3 676 0
 4196 0732 939A      		sbi 0x12,3
 677:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4197               		.loc 3 677 0
 4198 0734 AFEF      		ldi r26,lo8(-1)
 4199 0736 A4BB      		out 0x14,r26
 678:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4200               		.loc 3 678 0
 4201 0738 AABB      		out 0x1a,r26
 679:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4202               		.loc 3 679 0
 4203 073a A7BB      		out 0x17,r26
 680:main.c        **** 				gba_flash_write_bus_cycle(flashAddress, flashByte);
 4204               		.loc 3 680 0
 4205 073c AB01      		movw r20,r22
 4206 073e C501      		movw r24,r10
 4207 0740 B401      		movw r22,r8
 4208               	.LVL405:
 4209 0742 00D0      		rcall gba_flash_write_bus_cycle
 4210               	.LVL406:
 4211               	.L334:
 681:main.c        **** 				PORTD &= ~(1<<ACTIVITY_LED);
 4212               		.loc 3 681 0
 4213 0744 9398      		cbi 0x12,3
 682:main.c        **** 				
 683:main.c        **** 				USART_Transmit(SEND_ACK); // Send back acknowledgement
 4214               		.loc 3 683 0
 4215 0746 81E3      		ldi r24,lo8(49)
 4216 0748 00C0      		rjmp .L315
 4217               	.LVL407:
 4218               	.L182:
 4219               	.LBE244:
 4220               	.LBE243:
 684:main.c        **** 			}
 685:main.c        **** 		}
 686:main.c        **** 		
 687:main.c        **** 		// Write 64 or 256 bytes to Flash address (swapped command data bytes), combine 2 bytes and write
 688:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_64BYTE_SWAPPED_D0D1 || receivedChar == GBA_FLASH_WRITE_2
 4221               		.loc 3 688 0
 4222 074a 8137      		cpi r24,lo8(113)
 4223 074c 01F0      		breq .L183
 4224               		.loc 3 688 0 is_stmt 0 discriminator 1
 4225 074e 8437      		cpi r24,lo8(116)
 4226 0750 01F4      		brne .L184
 4227               	.L183:
 4228               	.LBB245:
 689:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4229               		.loc 3 689 0 is_stmt 1
 4230 0752 939A      		sbi 0x12,3
 4231               	.LVL408:
 690:main.c        **** 			
 691:main.c        **** 			int readLength = 64;
 692:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4232               		.loc 3 692 0
 4233 0754 8091 0000 		lds r24,receivedChar
 4234 0758 8437      		cpi r24,lo8(116)
 4235 075a 01F4      		brne .L253
 693:main.c        **** 				readLength = 256;
 4236               		.loc 3 693 0
 4237 075c 00E0      		ldi r16,0
 4238 075e 11E0      		ldi r17,lo8(1)
 4239 0760 00C0      		rjmp .L185
 4240               	.L253:
 691:main.c        **** 			if (receivedChar == GBA_FLASH_WRITE_256BYTE_SWAPPED_D0D1) {
 4241               		.loc 3 691 0
 4242 0762 00E4      		ldi r16,lo8(64)
 4243 0764 10E0      		ldi r17,0
 4244               	.L185:
 4245               	.LVL409:
 694:main.c        **** 			}
 695:main.c        **** 			usart_read_bytes(readLength);
 4246               		.loc 3 695 0
 4247 0766 C801      		movw r24,r16
 4248 0768 00D0      		rcall usart_read_bytes
 4249               	.LVL410:
 696:main.c        **** 			start_timeout_timer();
 4250               		.loc 3 696 0
 4251 076a 00D0      		rcall start_timeout_timer
 4252               	.LVL411:
 4253 076c B0E0      		ldi r27,lo8(receivedBuffer)
 4254 076e AB2E      		mov r10,r27
 4255 0770 B0E0      		ldi r27,hi8(receivedBuffer)
 4256 0772 BB2E      		mov r11,r27
 4257 0774 2601      		movw r4,r12
 4258 0776 3701      		movw r6,r14
 4259               	.LVL412:
 4260               	.L187:
 4261               	.LBB246:
 4262               	.LBB247:
 697:main.c        **** 			
 698:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 699:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4263               		.loc 3 699 0
 4264 0778 F501      		movw r30,r10
 4265 077a 4181      		ldd r20,Z+1
 4266 077c 50E0      		ldi r21,0
 4267 077e 542F      		mov r21,r20
 4268 0780 4427      		clr r20
 4269 0782 8081      		ld r24,Z
 4270 0784 482B      		or r20,r24
 4271               	.LVL413:
 700:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4272               		.loc 3 700 0
 4273 0786 4F3F      		cpi r20,-1
 4274 0788 FFEF      		ldi r31,-1
 4275 078a 5F07      		cpc r21,r31
 4276 078c 01F0      		breq .L186
 701:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_SWAPPED);
 4277               		.loc 3 701 0
 4278 078e 21E0      		ldi r18,lo8(1)
 4279 0790 C301      		movw r24,r6
 4280 0792 B201      		movw r22,r4
 4281 0794 00D0      		rcall gba_flash_write_byte
 4282               	.LVL414:
 4283               	.L186:
 702:main.c        **** 				}
 703:main.c        **** 				address++;
 4284               		.loc 3 703 0 discriminator 2
 4285 0796 2FEF      		ldi r18,-1
 4286 0798 421A      		sub r4,r18
 4287 079a 520A      		sbc r5,r18
 4288 079c 620A      		sbc r6,r18
 4289 079e 720A      		sbc r7,r18
 4290               	.LVL415:
 4291 07a0 82E0      		ldi r24,2
 4292 07a2 A80E      		add r10,r24
 4293 07a4 B11C      		adc r11,__zero_reg__
 4294               	.LVL416:
 4295               	.LBE247:
 698:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4296               		.loc 3 698 0 discriminator 2
 4297 07a6 C501      		movw r24,r10
 4298 07a8 8050      		subi r24,lo8(receivedBuffer)
 4299 07aa 9040      		sbci r25,hi8(receivedBuffer)
 4300 07ac 8017      		cp r24,r16
 4301 07ae 9107      		cpc r25,r17
 4302 07b0 04F0      		brlt .L187
 4303 07b2 9FEF      		ldi r25,-1
 4304 07b4 C91A      		sub r12,r25
 4305 07b6 D90A      		sbc r13,r25
 4306 07b8 E90A      		sbc r14,r25
 4307 07ba F90A      		sbc r15,r25
 4308 07bc 0150      		subi r16,1
 4309 07be 1109      		sbc r17,__zero_reg__
 4310               	.LVL417:
 4311 07c0 1695      		lsr r17
 4312 07c2 0795      		ror r16
 4313               	.LVL418:
 4314 07c4 C00E      		add r12,r16
 4315 07c6 D11E      		adc r13,r17
 4316 07c8 E11C      		adc r14,__zero_reg__
 4317 07ca F11C      		adc r15,__zero_reg__
 4318 07cc 00C0      		rjmp .L317
 4319               	.LVL419:
 4320               	.L184:
 4321               	.LBE246:
 4322               	.LBE245:
 704:main.c        **** 			}
 705:main.c        **** 			
 706:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 707:main.c        **** 		}
 708:main.c        **** 		
 709:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 710:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_256BYTE) {
 4323               		.loc 3 710 0
 4324 07ce 8636      		cpi r24,lo8(102)
 4325 07d0 01F4      		brne .L188
 4326               	.LBB248:
 711:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4327               		.loc 3 711 0
 4328 07d2 939A      		sbi 0x12,3
 4329               	.LVL420:
 712:main.c        **** 			
 713:main.c        **** 			int readLength = 256;
 714:main.c        **** 			usart_read_bytes(readLength);
 4330               		.loc 3 714 0
 4331 07d4 80E0      		ldi r24,0
 4332 07d6 91E0      		ldi r25,lo8(1)
 4333 07d8 00D0      		rcall usart_read_bytes
 4334               	.LVL421:
 715:main.c        **** 			start_timeout_timer();
 4335               		.loc 3 715 0
 4336 07da 00D0      		rcall start_timeout_timer
 4337               	.LVL422:
 4338 07dc 00E0      		ldi r16,lo8(receivedBuffer)
 4339 07de 10E0      		ldi r17,hi8(receivedBuffer)
 4340 07e0 4601      		movw r8,r12
 4341 07e2 5701      		movw r10,r14
 4342               	.LVL423:
 4343               	.L190:
 4344               	.LBB249:
 4345               	.LBB250:
 716:main.c        **** 			
 717:main.c        **** 			for (int x = 0; x < readLength; x += 2) {
 718:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4346               		.loc 3 718 0
 4347 07e4 D801      		movw r26,r16
 4348 07e6 1196      		adiw r26,1
 4349 07e8 4C91      		ld r20,X
 4350 07ea 1197      		sbiw r26,1
 4351 07ec 50E0      		ldi r21,0
 4352 07ee 542F      		mov r21,r20
 4353 07f0 4427      		clr r20
 4354 07f2 8C91      		ld r24,X
 4355 07f4 482B      		or r20,r24
 4356               	.LVL424:
 719:main.c        **** 				if (combinedBytes != 0xFFFF) {
 4357               		.loc 3 719 0
 4358 07f6 4F3F      		cpi r20,-1
 4359 07f8 BFEF      		ldi r27,-1
 4360 07fa 5B07      		cpc r21,r27
 4361 07fc 01F0      		breq .L189
 720:main.c        **** 					gba_flash_write_byte(address, combinedBytes, D0D1_NOT_SWAPPED);
 4362               		.loc 3 720 0
 4363 07fe 20E0      		ldi r18,0
 4364 0800 C501      		movw r24,r10
 4365 0802 B401      		movw r22,r8
 4366 0804 00D0      		rcall gba_flash_write_byte
 4367               	.LVL425:
 4368               	.L189:
 721:main.c        **** 				}
 722:main.c        **** 				address++;
 4369               		.loc 3 722 0 discriminator 2
 4370 0806 EFEF      		ldi r30,-1
 4371 0808 8E1A      		sub r8,r30
 4372 080a 9E0A      		sbc r9,r30
 4373 080c AE0A      		sbc r10,r30
 4374 080e BE0A      		sbc r11,r30
 4375               	.LVL426:
 4376 0810 0E5F      		subi r16,-2
 4377 0812 1F4F      		sbci r17,-1
 4378               	.LVL427:
 4379               	.LBE250:
 717:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4380               		.loc 3 717 0 discriminator 2
 4381 0814 F0E0      		ldi r31,hi8(receivedBuffer+256)
 4382 0816 0030      		cpi r16,lo8(receivedBuffer+256)
 4383 0818 1F07      		cpc r17,r31
 4384 081a 01F4      		brne .L190
 4385 081c 20E8      		ldi r18,-128
 4386 081e C20E      		add r12,r18
 4387 0820 D11C      		adc r13,__zero_reg__
 4388 0822 E11C      		adc r14,__zero_reg__
 4389 0824 F11C      		adc r15,__zero_reg__
 4390 0826 00C0      		rjmp .L317
 4391               	.LVL428:
 4392               	.L188:
 4393               	.LBE249:
 4394               	.LBE248:
 723:main.c        **** 			}
 724:main.c        **** 			
 725:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 726:main.c        **** 		}
 727:main.c        **** 		
 728:main.c        **** 		// Intel flash command based chips
 729:main.c        **** 		// Write 64 bytes to Flash address, combine 2 bytes and write one at a time (and increment addres
 730:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE) {
 4395               		.loc 3 730 0
 4396 0828 8C36      		cpi r24,lo8(108)
 4397 082a 01F0      		breq .+2
 4398 082c 00C0      		rjmp .L191
 4399               	.LBB251:
 731:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4400               		.loc 3 731 0
 4401 082e 939A      		sbi 0x12,3
 732:main.c        **** 			usart_read_bytes(64);
 4402               		.loc 3 732 0
 4403 0830 80E4      		ldi r24,lo8(64)
 4404 0832 90E0      		ldi r25,0
 4405 0834 00D0      		rcall usart_read_bytes
 4406               	.LVL429:
 733:main.c        **** 			start_timeout_timer();
 4407               		.loc 3 733 0
 4408 0836 00D0      		rcall start_timeout_timer
 4409               	.LVL430:
 734:main.c        **** 			
 735:main.c        **** 			// Set address lines as outputs
 736:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4410               		.loc 3 736 0
 4411 0838 8FEF      		ldi r24,lo8(-1)
 4412 083a 84BB      		out 0x14,r24
 737:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4413               		.loc 3 737 0
 4414 083c 8ABB      		out 0x1a,r24
 738:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4415               		.loc 3 738 0
 4416 083e 87BB      		out 0x17,r24
 739:main.c        **** 			
 740:main.c        **** 			// Unlock
 741:main.c        **** 			gba_flash_write_bus_cycle(address, 0x60);
 4417               		.loc 3 741 0
 4418 0840 40E6      		ldi r20,lo8(96)
 4419 0842 50E0      		ldi r21,0
 4420 0844 C701      		movw r24,r14
 4421 0846 B601      		movw r22,r12
 4422 0848 00D0      		rcall gba_flash_write_bus_cycle
 4423               	.LVL431:
 742:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4424               		.loc 3 742 0
 4425 084a 40ED      		ldi r20,lo8(-48)
 4426 084c 50E0      		ldi r21,0
 4427 084e C701      		movw r24,r14
 4428 0850 B601      		movw r22,r12
 4429 0852 00D0      		rcall gba_flash_write_bus_cycle
 4430               	.LVL432:
 743:main.c        **** 			
 744:main.c        **** 			// Buffered write command
 745:main.c        **** 			gba_flash_write_bus_cycle(address, 0xE8);
 4431               		.loc 3 745 0
 4432 0854 48EE      		ldi r20,lo8(-24)
 4433 0856 50E0      		ldi r21,0
 4434 0858 C701      		movw r24,r14
 4435 085a B601      		movw r22,r12
 4436 085c 00D0      		rcall gba_flash_write_bus_cycle
 4437               	.LVL433:
 4438               	.LBB252:
 4439               	.LBB253:
 4440               		.loc 2 276 0
 4441 085e 95E8      		ldi r25,lo8(-123)
 4442 0860 9A95      	1:	dec r25
 4443 0862 01F4      		brne 1b
 4444 0864 0000      		nop
 4445               	.LVL434:
 4446               	.LBE253:
 4447               	.LBE252:
 746:main.c        **** 			_delay_us(50);
 747:main.c        **** 			
 748:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 749:main.c        **** 			uint16_t dataVerify = gba_read_16bit_data(address);
 4448               		.loc 3 749 0
 4449 0866 C701      		movw r24,r14
 4450 0868 B601      		movw r22,r12
 4451 086a 00D0      		rcall gba_read_16bit_data
 4452               	.LVL435:
 4453               	.L192:
 750:main.c        **** 			while (dataVerify != 0x0080) {
 4454               		.loc 3 750 0
 4455 086c 8038      		cpi r24,-128
 4456 086e 9105      		cpc r25,__zero_reg__
 4457 0870 01F0      		breq .L195
 751:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4458               		.loc 3 751 0
 4459 0872 C701      		movw r24,r14
 4460 0874 B601      		movw r22,r12
 4461 0876 00D0      		rcall gba_read_16bit_data
 4462               	.LVL436:
 4463               	.LBB254:
 4464               	.LBB255:
 4465               		.loc 2 276 0
 4466 0878 A5E8      		ldi r26,lo8(-123)
 4467 087a AA95      	1:	dec r26
 4468 087c 01F4      		brne 1b
 4469 087e 0000      		nop
 4470               	.LVL437:
 4471               	.LBE255:
 4472               	.LBE254:
 752:main.c        **** 				_delay_us(50);
 753:main.c        **** 				if (writingTimedout == 1) {
 4473               		.loc 3 753 0
 4474 0880 2091 0000 		lds r18,writingTimedout
 4475 0884 2130      		cpi r18,lo8(1)
 4476 0886 01F4      		brne .L192
 4477               	.L195:
 754:main.c        **** 					break;
 755:main.c        **** 				}
 756:main.c        **** 			}
 757:main.c        **** 			
 758:main.c        **** 			
 759:main.c        **** 			// Set address lines as outputs
 760:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4478               		.loc 3 760 0
 4479 0888 BFEF      		ldi r27,lo8(-1)
 4480 088a B4BB      		out 0x14,r27
 761:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4481               		.loc 3 761 0
 4482 088c BABB      		out 0x1a,r27
 762:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4483               		.loc 3 762 0
 4484 088e B7BB      		out 0x17,r27
 763:main.c        **** 			
 764:main.c        **** 			// Set length
 765:main.c        **** 			gba_flash_write_bus_cycle(address, 0x1F);
 4485               		.loc 3 765 0
 4486 0890 4FE1      		ldi r20,lo8(31)
 4487 0892 50E0      		ldi r21,0
 4488 0894 C701      		movw r24,r14
 4489 0896 B601      		movw r22,r12
 4490 0898 00D0      		rcall gba_flash_write_bus_cycle
 4491               	.LVL438:
 4492 089a 00E0      		ldi r16,lo8(receivedBuffer)
 4493 089c 10E0      		ldi r17,hi8(receivedBuffer)
 4494 089e 4601      		movw r8,r12
 4495 08a0 5701      		movw r10,r14
 4496               	.LVL439:
 4497               	.L193:
 4498               	.LBB256:
 4499               	.LBB257:
 766:main.c        **** 			
 767:main.c        **** 			// Write data
 768:main.c        **** 			for (int x = 0; x < 64; x += 2) {
 769:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 770:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4500               		.loc 3 770 0 discriminator 3
 4501 08a2 F801      		movw r30,r16
 4502 08a4 4181      		ldd r20,Z+1
 4503 08a6 50E0      		ldi r21,0
 4504 08a8 542F      		mov r21,r20
 4505 08aa 4427      		clr r20
 4506 08ac 8081      		ld r24,Z
 4507 08ae 482B      		or r20,r24
 4508 08b0 C501      		movw r24,r10
 4509 08b2 B401      		movw r22,r8
 4510 08b4 00D0      		rcall gba_flash_write_bus_cycle
 4511               	.LVL440:
 771:main.c        **** 				address++;
 4512               		.loc 3 771 0 discriminator 3
 4513 08b6 FFEF      		ldi r31,-1
 4514 08b8 8F1A      		sub r8,r31
 4515 08ba 9F0A      		sbc r9,r31
 4516 08bc AF0A      		sbc r10,r31
 4517 08be BF0A      		sbc r11,r31
 4518               	.LVL441:
 4519 08c0 0E5F      		subi r16,-2
 4520 08c2 1F4F      		sbci r17,-1
 4521               	.LVL442:
 4522               	.LBE257:
 768:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4523               		.loc 3 768 0 discriminator 3
 4524 08c4 80E0      		ldi r24,lo8(receivedBuffer+64)
 4525 08c6 90E0      		ldi r25,hi8(receivedBuffer+64)
 4526 08c8 8017      		cp r24,r16
 4527 08ca 9107      		cpc r25,r17
 4528 08cc 01F4      		brne .L193
 4529 08ce 90E2      		ldi r25,32
 4530 08d0 C90E      		add r12,r25
 4531 08d2 D11C      		adc r13,__zero_reg__
 4532 08d4 E11C      		adc r14,__zero_reg__
 4533 08d6 F11C      		adc r15,__zero_reg__
 4534               	.LBE256:
 772:main.c        **** 			}
 773:main.c        **** 			
 774:main.c        **** 			// Write buffer to flash
 775:main.c        **** 			gba_flash_write_bus_cycle(address, 0xD0);
 4535               		.loc 3 775 0
 4536 08d8 40ED      		ldi r20,lo8(-48)
 4537 08da 50E0      		ldi r21,0
 4538 08dc C701      		movw r24,r14
 4539 08de B601      		movw r22,r12
 4540 08e0 00D0      		rcall gba_flash_write_bus_cycle
 4541               	.LVL443:
 4542               	.LBB258:
 4543               	.LBB259:
 4544               		.loc 2 276 0
 4545 08e2 AFE6      		ldi r26,lo8(879)
 4546 08e4 B3E0      		ldi r27,hi8(879)
 4547 08e6 1197      	1:	sbiw r26,1
 4548 08e8 01F4      		brne 1b
 4549 08ea 00C0      		rjmp .
 4550 08ec 0000      		nop
 4551               	.LVL444:
 4552               	.LBE259:
 4553               	.LBE258:
 776:main.c        **** 			_delay_us(440);
 777:main.c        **** 			
 778:main.c        **** 			// Wait for first 2 bytes to be 0x80, 0x00
 779:main.c        **** 			dataVerify = gba_read_16bit_data(address);
 4554               		.loc 3 779 0
 4555 08ee C701      		movw r24,r14
 4556 08f0 B601      		movw r22,r12
 4557 08f2 00D0      		rcall gba_read_16bit_data
 4558               	.LVL445:
 4559               	.L196:
 780:main.c        **** 			while (dataVerify != 0x0080) {
 4560               		.loc 3 780 0
 4561 08f4 8038      		cpi r24,-128
 4562 08f6 9105      		cpc r25,__zero_reg__
 4563 08f8 01F0      		breq .L198
 781:main.c        **** 				dataVerify = gba_read_16bit_data(address);
 4564               		.loc 3 781 0
 4565 08fa C701      		movw r24,r14
 4566 08fc B601      		movw r22,r12
 4567 08fe 00D0      		rcall gba_read_16bit_data
 4568               	.LVL446:
 4569               	.LBB260:
 4570               	.LBB261:
 4571               		.loc 2 276 0
 4572 0900 B5E8      		ldi r27,lo8(-123)
 4573 0902 BA95      	1:	dec r27
 4574 0904 01F4      		brne 1b
 4575 0906 0000      		nop
 4576               	.LVL447:
 4577               	.LBE261:
 4578               	.LBE260:
 782:main.c        **** 				_delay_us(50);
 783:main.c        **** 				if (writingTimedout == 1) {
 4579               		.loc 3 783 0
 4580 0908 2091 0000 		lds r18,writingTimedout
 4581 090c 2130      		cpi r18,lo8(1)
 4582 090e 01F4      		brne .L196
 4583               	.L198:
 784:main.c        **** 					break;
 785:main.c        **** 				}
 786:main.c        **** 			}
 787:main.c        **** 			
 788:main.c        **** 			
 789:main.c        **** 			// Set address lines as outputs
 790:main.c        **** 			GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4584               		.loc 3 790 0
 4585 0910 EFEF      		ldi r30,lo8(-1)
 4586 0912 E4BB      		out 0x14,r30
 791:main.c        **** 			GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4587               		.loc 3 791 0
 4588 0914 EABB      		out 0x1a,r30
 792:main.c        **** 			GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4589               		.loc 3 792 0
 4590 0916 E7BB      		out 0x17,r30
 793:main.c        **** 			
 794:main.c        **** 			// Back to reading mode
 795:main.c        **** 			gba_flash_write_bus_cycle(address, 0xFF);
 4591               		.loc 3 795 0
 4592 0918 4FEF      		ldi r20,lo8(-1)
 4593 091a 50E0      		ldi r21,0
 4594 091c C701      		movw r24,r14
 4595 091e B601      		movw r22,r12
 4596 0920 00D0      		rcall gba_flash_write_bus_cycle
 4597               	.LVL448:
 4598 0922 00C0      		rjmp .L317
 4599               	.LVL449:
 4600               	.L191:
 4601               	.LBE251:
 796:main.c        **** 			
 797:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 798:main.c        **** 		}
 799:main.c        **** 		
 800:main.c        **** 		// Intel word programming
 801:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_64BYTE_WORD) {
 4602               		.loc 3 801 0
 4603 0924 8537      		cpi r24,lo8(117)
 4604 0926 01F0      		breq .+2
 4605 0928 00C0      		rjmp .L199
 802:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4606               		.loc 3 802 0
 4607 092a 939A      		sbi 0x12,3
 803:main.c        **** 			usart_read_bytes(64);
 4608               		.loc 3 803 0
 4609 092c 80E4      		ldi r24,lo8(64)
 4610 092e 90E0      		ldi r25,0
 4611 0930 00D0      		rcall usart_read_bytes
 4612               	.LVL450:
 804:main.c        **** 			start_timeout_timer();
 4613               		.loc 3 804 0
 4614 0932 00D0      		rcall start_timeout_timer
 4615               	.LVL451:
 4616 0934 50E0      		ldi r21,lo8(receivedBuffer)
 4617 0936 A52E      		mov r10,r21
 4618 0938 50E0      		ldi r21,hi8(receivedBuffer)
 4619 093a B52E      		mov r11,r21
 4620 093c 2601      		movw r4,r12
 4621 093e 3701      		movw r6,r14
 4622               	.LVL452:
 4623               	.L201:
 4624               	.LBB262:
 4625               	.LBB263:
 805:main.c        **** 			
 806:main.c        **** 			// Write data
 807:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 808:main.c        **** 				// Set address lines as outputs
 809:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4626               		.loc 3 809 0
 4627 0940 FFEF      		ldi r31,lo8(-1)
 4628 0942 F4BB      		out 0x14,r31
 810:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4629               		.loc 3 810 0
 4630 0944 FABB      		out 0x1a,r31
 811:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4631               		.loc 3 811 0
 4632 0946 F7BB      		out 0x17,r31
 812:main.c        **** 				
 813:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4633               		.loc 3 813 0
 4634 0948 D501      		movw r26,r10
 4635 094a 1196      		adiw r26,1
 4636 094c 0C91      		ld r16,X
 4637 094e 1197      		sbiw r26,1
 4638 0950 10E0      		ldi r17,0
 4639 0952 102F      		mov r17,r16
 4640 0954 0027      		clr r16
 4641 0956 8C91      		ld r24,X
 4642 0958 082B      		or r16,r24
 4643               	.LVL453:
 814:main.c        **** 				gba_flash_write_bus_cycle(address, 0x40);
 4644               		.loc 3 814 0
 4645 095a 40E4      		ldi r20,lo8(64)
 4646 095c 50E0      		ldi r21,0
 4647 095e C301      		movw r24,r6
 4648 0960 B201      		movw r22,r4
 4649 0962 00D0      		rcall gba_flash_write_bus_cycle
 4650               	.LVL454:
 815:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 4651               		.loc 3 815 0
 4652 0964 A801      		movw r20,r16
 4653 0966 C301      		movw r24,r6
 4654 0968 B201      		movw r22,r4
 4655 096a 00D0      		rcall gba_flash_write_bus_cycle
 4656               	.LVL455:
 816:main.c        **** 				
 817:main.c        **** 				// Verify status ok
 818:main.c        **** 				uint16_t status = gba_read_16bit_data(address);
 4657               		.loc 3 818 0
 4658 096c C301      		movw r24,r6
 4659 096e B201      		movw r22,r4
 4660 0970 00D0      		rcall gba_read_16bit_data
 4661               	.LVL456:
 4662               	.L200:
 819:main.c        **** 				while ((status & 0x80) == 0) {
 4663               		.loc 3 819 0
 4664 0972 87FD      		sbrc r24,7
 4665 0974 00C0      		rjmp .L204
 820:main.c        **** 					status = gba_read_16bit_data(address);
 4666               		.loc 3 820 0
 4667 0976 C301      		movw r24,r6
 4668 0978 B201      		movw r22,r4
 4669 097a 00D0      		rcall gba_read_16bit_data
 4670               	.LVL457:
 4671               	.LBB264:
 4672               	.LBB265:
 4673               		.loc 2 276 0
 4674 097c B5E0      		ldi r27,lo8(5)
 4675 097e BA95      	1:	dec r27
 4676 0980 01F4      		brne 1b
 4677 0982 0000      		nop
 4678               	.LVL458:
 4679               	.LBE265:
 4680               	.LBE264:
 821:main.c        **** 					_delay_us(2);
 822:main.c        **** 					if (writingTimedout == 1) {
 4681               		.loc 3 822 0
 4682 0984 9091 0000 		lds r25,writingTimedout
 4683 0988 9130      		cpi r25,lo8(1)
 4684 098a 01F4      		brne .L200
 4685               	.L204:
 823:main.c        **** 						break;
 824:main.c        **** 					}
 825:main.c        **** 				}
 826:main.c        **** 				address++;
 4686               		.loc 3 826 0
 4687 098c EFEF      		ldi r30,-1
 4688 098e 4E1A      		sub r4,r30
 4689 0990 5E0A      		sbc r5,r30
 4690 0992 6E0A      		sbc r6,r30
 4691 0994 7E0A      		sbc r7,r30
 4692               	.LVL459:
 4693 0996 F2E0      		ldi r31,2
 4694 0998 AF0E      		add r10,r31
 4695 099a B11C      		adc r11,__zero_reg__
 4696               	.LVL460:
 4697               	.LBE263:
 807:main.c        **** 				// Set address lines as outputs
 4698               		.loc 3 807 0
 4699 099c 20E0      		ldi r18,lo8(receivedBuffer+64)
 4700 099e A216      		cp r10,r18
 4701 09a0 20E0      		ldi r18,hi8(receivedBuffer+64)
 4702 09a2 B206      		cpc r11,r18
 4703 09a4 01F4      		brne .L201
 4704 09a6 80E2      		ldi r24,32
 4705 09a8 C80E      		add r12,r24
 4706 09aa D11C      		adc r13,__zero_reg__
 4707 09ac E11C      		adc r14,__zero_reg__
 4708 09ae F11C      		adc r15,__zero_reg__
 4709 09b0 00C0      		rjmp .L317
 4710               	.LVL461:
 4711               	.L199:
 4712               	.LBE262:
 827:main.c        **** 			}
 828:main.c        **** 			
 829:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 830:main.c        **** 		}
 831:main.c        **** 		
 832:main.c        **** 		// Intel flash command based chips, two chips interleaved (Flash2Advance 256M cart)
 833:main.c        **** 		// Write 256 bytes to Flash address, combine 2 bytes and write one at a time (and increment addre
 834:main.c        **** 		// Thanks to lesserkuma for adding support
 835:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_INTEL_INTERLEAVED_256BYTE) {
 4713               		.loc 3 835 0
 4714 09b2 8637      		cpi r24,lo8(118)
 4715 09b4 01F0      		breq .+2
 4716 09b6 00C0      		rjmp .L205
 836:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4717               		.loc 3 836 0
 4718 09b8 939A      		sbi 0x12,3
 837:main.c        **** 			usart_read_bytes(256);
 4719               		.loc 3 837 0
 4720 09ba 80E0      		ldi r24,0
 4721 09bc 91E0      		ldi r25,lo8(1)
 4722 09be 00D0      		rcall usart_read_bytes
 4723               	.LVL462:
 838:main.c        **** 			start_timeout_timer();
 4724               		.loc 3 838 0
 4725 09c0 00D0      		rcall start_timeout_timer
 4726               	.LVL463:
 4727 09c2 30E0      		ldi r19,lo8(receivedBuffer)
 4728 09c4 232E      		mov r2,r19
 4729 09c6 30E0      		ldi r19,hi8(receivedBuffer)
 4730 09c8 332E      		mov r3,r19
 4731 09ca 4601      		movw r8,r12
 4732 09cc 5701      		movw r10,r14
 4733               	.LVL464:
 4734               	.L211:
 4735               	.LBB266:
 4736               	.LBB267:
 839:main.c        **** 			
 840:main.c        **** 			// Loop four times, transferring 256 bytes over USB at once is faster than doing four transfers
 841:main.c        **** 			for (int c = 0; c < 4; c++) {
 842:main.c        **** 				// Set address lines as outputs
 843:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4737               		.loc 3 843 0
 4738 09ce 9FEF      		ldi r25,lo8(-1)
 4739 09d0 94BB      		out 0x14,r25
 844:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4740               		.loc 3 844 0
 4741 09d2 9ABB      		out 0x1a,r25
 845:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4742               		.loc 3 845 0
 4743 09d4 97BB      		out 0x17,r25
 846:main.c        **** 				
 847:main.c        **** 				// Setup buffered write
 848:main.c        **** 				gba_flash_write_bus_cycle(address, 0xE8);
 4744               		.loc 3 848 0
 4745 09d6 48EE      		ldi r20,lo8(-24)
 4746 09d8 50E0      		ldi r21,0
 4747 09da C501      		movw r24,r10
 4748 09dc B401      		movw r22,r8
 4749 09de 00D0      		rcall gba_flash_write_bus_cycle
 4750               	.LVL465:
 4751 09e0 D501      		movw r26,r10
 4752 09e2 C401      		movw r24,r8
 4753 09e4 0196      		adiw r24,1
 4754 09e6 A11D      		adc r26,__zero_reg__
 4755 09e8 B11D      		adc r27,__zero_reg__
 4756 09ea 8983      		std Y+1,r24
 4757 09ec 9A83      		std Y+2,r25
 4758 09ee AB83      		std Y+3,r26
 4759 09f0 BC83      		std Y+4,r27
 849:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0xE8);
 4760               		.loc 3 849 0
 4761 09f2 48EE      		ldi r20,lo8(-24)
 4762 09f4 50E0      		ldi r21,0
 4763 09f6 BC01      		movw r22,r24
 4764 09f8 CD01      		movw r24,r26
 4765 09fa 00D0      		rcall gba_flash_write_bus_cycle
 4766               	.LVL466:
 4767               	.L206:
 850:main.c        **** 				
 851:main.c        **** 				// Wait until both chips are ready
 852:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4768               		.loc 3 852 0 discriminator 1
 4769 09fc C501      		movw r24,r10
 4770 09fe B401      		movw r22,r8
 4771 0a00 00D0      		rcall gba_read_16bit_data
 4772               	.LVL467:
 4773 0a02 8038      		cpi r24,-128
 4774 0a04 9105      		cpc r25,__zero_reg__
 4775 0a06 01F4      		brne .L206
 4776               	.L207:
 853:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4777               		.loc 3 853 0 discriminator 1
 4778 0a08 6981      		ldd r22,Y+1
 4779 0a0a 7A81      		ldd r23,Y+2
 4780 0a0c 8B81      		ldd r24,Y+3
 4781 0a0e 9C81      		ldd r25,Y+4
 4782 0a10 00D0      		rcall gba_read_16bit_data
 4783               	.LVL468:
 4784 0a12 8038      		cpi r24,-128
 4785 0a14 9105      		cpc r25,__zero_reg__
 4786 0a16 01F4      		brne .L207
 854:main.c        **** 				
 855:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 856:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 857:main.c        **** 				
 858:main.c        **** 				// Set address lines as outputs
 859:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4787               		.loc 3 859 0
 4788 0a18 9FEF      		ldi r25,lo8(-1)
 4789 0a1a 94BB      		out 0x14,r25
 860:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4790               		.loc 3 860 0
 4791 0a1c 9ABB      		out 0x1a,r25
 861:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4792               		.loc 3 861 0
 4793 0a1e 97BB      		out 0x17,r25
 862:main.c        **** 				
 863:main.c        **** 				// Set length (number of words+1 to write)
 864:main.c        **** 				gba_flash_write_bus_cycle(address, 0x0F); // 16 words
 4794               		.loc 3 864 0
 4795 0a20 4FE0      		ldi r20,lo8(15)
 4796 0a22 50E0      		ldi r21,0
 4797 0a24 C501      		movw r24,r10
 4798 0a26 B401      		movw r22,r8
 4799 0a28 00D0      		rcall gba_flash_write_bus_cycle
 4800               	.LVL469:
 865:main.c        **** 				gba_flash_write_bus_cycle(address+1, 0x0F); // 16 words
 4801               		.loc 3 865 0
 4802 0a2a 4FE0      		ldi r20,lo8(15)
 4803 0a2c 50E0      		ldi r21,0
 4804 0a2e 6981      		ldd r22,Y+1
 4805 0a30 7A81      		ldd r23,Y+2
 4806 0a32 8B81      		ldd r24,Y+3
 4807 0a34 9C81      		ldd r25,Y+4
 4808 0a36 00D0      		rcall gba_flash_write_bus_cycle
 4809               	.LVL470:
 4810 0a38 8101      		movw r16,r2
 4811 0a3a 2401      		movw r4,r8
 4812 0a3c 3501      		movw r6,r10
 4813               	.LBB268:
 866:main.c        **** 				
 867:main.c        **** 				// Write data (32 words total)
 868:main.c        **** 				uint16_t combinedBytes;
 869:main.c        **** 				for (int x = 0; x < 64; x += 2) {
 4814               		.loc 3 869 0
 4815 0a3e 1F82      		std Y+7,__zero_reg__
 4816 0a40 1E82      		std Y+6,__zero_reg__
 4817               	.LVL471:
 4818               	.L208:
 870:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 871:main.c        **** 					gba_flash_write_bus_cycle(address, combinedBytes);
 4819               		.loc 3 871 0 discriminator 3
 4820 0a42 D801      		movw r26,r16
 4821 0a44 1196      		adiw r26,1
 4822 0a46 4C91      		ld r20,X
 4823 0a48 1197      		sbiw r26,1
 4824 0a4a 50E0      		ldi r21,0
 4825 0a4c 542F      		mov r21,r20
 4826 0a4e 4427      		clr r20
 4827 0a50 8C91      		ld r24,X
 4828 0a52 482B      		or r20,r24
 4829 0a54 C301      		movw r24,r6
 4830 0a56 B201      		movw r22,r4
 4831 0a58 00D0      		rcall gba_flash_write_bus_cycle
 4832               	.LVL472:
 872:main.c        **** 					address++;
 4833               		.loc 3 872 0 discriminator 3
 4834 0a5a BFEF      		ldi r27,-1
 4835 0a5c 4B1A      		sub r4,r27
 4836 0a5e 5B0A      		sbc r5,r27
 4837 0a60 6B0A      		sbc r6,r27
 4838 0a62 7B0A      		sbc r7,r27
 4839               	.LVL473:
 869:main.c        **** 					combinedBytes = (uint16_t) receivedBuffer[c*64+x+1] << 8 | (uint16_t) receivedBuffer[c*64+x];
 4840               		.loc 3 869 0 discriminator 3
 4841 0a64 EE81      		ldd r30,Y+6
 4842 0a66 FF81      		ldd r31,Y+7
 4843 0a68 3296      		adiw r30,2
 4844 0a6a FF83      		std Y+7,r31
 4845 0a6c EE83      		std Y+6,r30
 4846               	.LVL474:
 4847 0a6e 0E5F      		subi r16,-2
 4848 0a70 1F4F      		sbci r17,-1
 4849 0a72 E034      		cpi r30,64
 4850 0a74 F105      		cpc r31,__zero_reg__
 4851 0a76 01F4      		brne .L208
 4852 0a78 2401      		movw r4,r8
 4853 0a7a 3501      		movw r6,r10
 4854               	.LVL475:
 4855 0a7c F0E2      		ldi r31,32
 4856 0a7e 4F0E      		add r4,r31
 4857 0a80 511C      		adc r5,__zero_reg__
 4858 0a82 611C      		adc r6,__zero_reg__
 4859 0a84 711C      		adc r7,__zero_reg__
 4860               	.LBE268:
 873:main.c        **** 				}
 874:main.c        **** 				
 875:main.c        **** 				// Write buffer to flash
 876:main.c        **** 				gba_flash_write_bus_cycle(address-32, 0xD0);
 4861               		.loc 3 876 0
 4862 0a86 40ED      		ldi r20,lo8(-48)
 4863 0a88 50E0      		ldi r21,0
 4864 0a8a C501      		movw r24,r10
 4865 0a8c B401      		movw r22,r8
 4866 0a8e 00D0      		rcall gba_flash_write_bus_cycle
 4867               	.LVL476:
 877:main.c        **** 				gba_flash_write_bus_cycle(address-32+1, 0xD0);
 4868               		.loc 3 877 0
 4869 0a90 40ED      		ldi r20,lo8(-48)
 4870 0a92 50E0      		ldi r21,0
 4871 0a94 6981      		ldd r22,Y+1
 4872 0a96 7A81      		ldd r23,Y+2
 4873 0a98 8B81      		ldd r24,Y+3
 4874 0a9a 9C81      		ldd r25,Y+4
 4875 0a9c 00D0      		rcall gba_flash_write_bus_cycle
 4876               	.LVL477:
 4877               	.L209:
 878:main.c        **** 				
 879:main.c        **** 				// Wait until ready
 880:main.c        **** 				while (gba_read_16bit_data(address) != 0x80);
 4878               		.loc 3 880 0 discriminator 1
 4879 0a9e C301      		movw r24,r6
 4880 0aa0 B201      		movw r22,r4
 4881 0aa2 00D0      		rcall gba_read_16bit_data
 4882               	.LVL478:
 4883 0aa4 8038      		cpi r24,-128
 4884 0aa6 9105      		cpc r25,__zero_reg__
 4885 0aa8 01F4      		brne .L209
 881:main.c        **** 				while (gba_read_16bit_data(address+1) != 0x80);
 4886               		.loc 3 881 0
 4887 0aaa 21E2      		ldi r18,33
 4888 0aac 820E      		add r8,r18
 4889 0aae 911C      		adc r9,__zero_reg__
 4890 0ab0 A11C      		adc r10,__zero_reg__
 4891 0ab2 B11C      		adc r11,__zero_reg__
 4892               	.L210:
 4893               		.loc 3 881 0 is_stmt 0 discriminator 1
 4894 0ab4 C501      		movw r24,r10
 4895 0ab6 B401      		movw r22,r8
 4896 0ab8 00D0      		rcall gba_read_16bit_data
 4897               	.LVL479:
 4898 0aba 8038      		cpi r24,-128
 4899 0abc 9105      		cpc r25,__zero_reg__
 4900 0abe 01F4      		brne .L210
 4901               	.LVL480:
 4902 0ac0 80E4      		ldi r24,64
 4903 0ac2 280E      		add r2,r24
 4904 0ac4 311C      		adc r3,__zero_reg__
 4905               	.LBE267:
 841:main.c        **** 				// Set address lines as outputs
 4906               		.loc 3 841 0 is_stmt 1 discriminator 2
 4907 0ac6 90E0      		ldi r25,lo8(receivedBuffer+256)
 4908 0ac8 2916      		cp r2,r25
 4909 0aca 90E0      		ldi r25,hi8(receivedBuffer+256)
 4910 0acc 3906      		cpc r3,r25
 4911 0ace 01F0      		breq .L336
 4912               	.LBB270:
 4913               	.LBB269:
 872:main.c        **** 				}
 4914               		.loc 3 872 0
 4915 0ad0 5301      		movw r10,r6
 4916 0ad2 4201      		movw r8,r4
 4917 0ad4 00C0      		rjmp .L211
 4918               	.L336:
 4919 0ad6 A0E8      		ldi r26,-128
 4920 0ad8 CA0E      		add r12,r26
 4921 0ada D11C      		adc r13,__zero_reg__
 4922 0adc E11C      		adc r14,__zero_reg__
 4923 0ade F11C      		adc r15,__zero_reg__
 4924 0ae0 00C0      		rjmp .L317
 4925               	.LVL481:
 4926               	.L205:
 4927               	.LBE269:
 4928               	.LBE270:
 4929               	.LBE266:
 882:main.c        **** 				//do { status = gba_read_16bit_data(address); } while (status != 0x80);
 883:main.c        **** 				//do { status = gba_read_16bit_data(address+1); } while (status != 0x80);
 884:main.c        **** 			}
 885:main.c        **** 			
 886:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 887:main.c        **** 		}
 888:main.c        **** 
 889:main.c        **** 		// Sharp LH28F320BJE programming (Thanks to lesserkuma for adding support)
 890:main.c        **** 		else if (receivedChar == GBA_FLASH_WRITE_SHARP_64BYTE) {
 4930               		.loc 3 890 0
 4931 0ae2 8837      		cpi r24,lo8(120)
 4932 0ae4 01F0      		breq .+2
 4933 0ae6 00C0      		rjmp .L212
 4934               	.LVL482:
 4935               	.LBB271:
 891:main.c        **** 			uint16_t status = 0;
 892:main.c        **** 			
 893:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 4936               		.loc 3 893 0
 4937 0ae8 939A      		sbi 0x12,3
 894:main.c        **** 			usart_read_bytes(64);
 4938               		.loc 3 894 0
 4939 0aea 80E4      		ldi r24,lo8(64)
 4940 0aec 90E0      		ldi r25,0
 4941 0aee 00D0      		rcall usart_read_bytes
 4942               	.LVL483:
 895:main.c        **** 			start_timeout_timer();
 4943               		.loc 3 895 0
 4944 0af0 00D0      		rcall start_timeout_timer
 4945               	.LVL484:
 4946 0af2 90E0      		ldi r25,lo8(receivedBuffer)
 4947 0af4 A92E      		mov r10,r25
 4948 0af6 90E0      		ldi r25,hi8(receivedBuffer)
 4949 0af8 B92E      		mov r11,r25
 4950 0afa 2601      		movw r4,r12
 4951 0afc 3701      		movw r6,r14
 891:main.c        **** 			uint16_t status = 0;
 4952               		.loc 3 891 0
 4953 0afe 912C      		mov r9,__zero_reg__
 4954               	.LVL485:
 4955               	.L216:
 4956               	.LBB272:
 4957               	.LBB273:
 896:main.c        **** 			
 897:main.c        **** 			// Write data
 898:main.c        **** 			for (uint8_t x = 0; x < 64; x += 2) {
 899:main.c        **** 				// Wait until ready
 900:main.c        **** 				while ((status & 0x80) != 0x80) {
 4958               		.loc 3 900 0
 4959 0b00 97FC      		sbrc r9,7
 4960 0b02 00C0      		rjmp .L337
 901:main.c        **** 					// Set address lines as outputs
 902:main.c        **** 					GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4961               		.loc 3 902 0
 4962 0b04 BFEF      		ldi r27,lo8(-1)
 4963 0b06 B4BB      		out 0x14,r27
 903:main.c        **** 					GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4964               		.loc 3 903 0
 4965 0b08 BABB      		out 0x1a,r27
 904:main.c        **** 					GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4966               		.loc 3 904 0
 4967 0b0a B7BB      		out 0x17,r27
 905:main.c        **** 					
 906:main.c        **** 					gba_flash_write_bus_cycle(address, 0x70); // Query status register
 4968               		.loc 3 906 0
 4969 0b0c 40E7      		ldi r20,lo8(112)
 4970 0b0e 50E0      		ldi r21,0
 4971 0b10 C301      		movw r24,r6
 4972 0b12 B201      		movw r22,r4
 4973 0b14 00D0      		rcall gba_flash_write_bus_cycle
 4974               	.LVL486:
 907:main.c        **** 					status = gba_read_16bit_data(address);
 4975               		.loc 3 907 0
 4976 0b16 C301      		movw r24,r6
 4977 0b18 B201      		movw r22,r4
 4978 0b1a 00D0      		rcall gba_read_16bit_data
 4979               	.LVL487:
 4980 0b1c 982E      		mov r9,r24
 4981 0b1e 00C0      		rjmp .L216
 4982               	.L337:
 908:main.c        **** 				}
 909:main.c        **** 				
 910:main.c        **** 				// Set address lines as outputs
 911:main.c        **** 				GBA_DDR_ROM_ADDR23_16 = 0xFF;
 4983               		.loc 3 911 0 discriminator 2
 4984 0b20 EFEF      		ldi r30,lo8(-1)
 4985 0b22 E4BB      		out 0x14,r30
 912:main.c        **** 				GBA_DDR_ROM_ADDR15_8 = 0xFF;
 4986               		.loc 3 912 0 discriminator 2
 4987 0b24 EABB      		out 0x1a,r30
 913:main.c        **** 				GBA_DDR_ROM_ADDR7_0 = 0xFF;
 4988               		.loc 3 913 0 discriminator 2
 4989 0b26 E7BB      		out 0x17,r30
 914:main.c        **** 				
 915:main.c        **** 				// Write one word to flash
 916:main.c        **** 				uint16_t combinedBytes = (uint16_t) receivedBuffer[x+1] << 8 | (uint16_t) receivedBuffer[x];
 4990               		.loc 3 916 0 discriminator 2
 4991 0b28 D501      		movw r26,r10
 4992 0b2a 1196      		adiw r26,1
 4993 0b2c 0C91      		ld r16,X
 4994 0b2e 1197      		sbiw r26,1
 4995 0b30 10E0      		ldi r17,0
 4996 0b32 102F      		mov r17,r16
 4997 0b34 0027      		clr r16
 4998 0b36 8C91      		ld r24,X
 4999 0b38 082B      		or r16,r24
 5000               	.LVL488:
 917:main.c        **** 				gba_flash_write_bus_cycle(address, 0x10);
 5001               		.loc 3 917 0 discriminator 2
 5002 0b3a 40E1      		ldi r20,lo8(16)
 5003 0b3c 50E0      		ldi r21,0
 5004 0b3e C301      		movw r24,r6
 5005 0b40 B201      		movw r22,r4
 5006 0b42 00D0      		rcall gba_flash_write_bus_cycle
 5007               	.LVL489:
 918:main.c        **** 				gba_flash_write_bus_cycle(address, combinedBytes);
 5008               		.loc 3 918 0 discriminator 2
 5009 0b44 A801      		movw r20,r16
 5010 0b46 C301      		movw r24,r6
 5011 0b48 B201      		movw r22,r4
 5012 0b4a 00D0      		rcall gba_flash_write_bus_cycle
 5013               	.LVL490:
 5014               	.LBB274:
 5015               	.LBB275:
 5016               		.loc 2 276 0 discriminator 2
 5017 0b4c BAE6      		ldi r27,lo8(106)
 5018 0b4e BA95      	1:	dec r27
 5019 0b50 01F4      		brne 1b
 5020 0b52 00C0      		rjmp .
 5021               	.LVL491:
 5022               	.LBE275:
 5023               	.LBE274:
 919:main.c        **** 				_delay_us(40);
 920:main.c        **** 				
 921:main.c        **** 				address++;
 5024               		.loc 3 921 0 discriminator 2
 5025 0b54 EFEF      		ldi r30,-1
 5026 0b56 4E1A      		sub r4,r30
 5027 0b58 5E0A      		sbc r5,r30
 5028 0b5a 6E0A      		sbc r6,r30
 5029 0b5c 7E0A      		sbc r7,r30
 5030               	.LVL492:
 5031 0b5e F2E0      		ldi r31,2
 5032 0b60 AF0E      		add r10,r31
 5033 0b62 B11C      		adc r11,__zero_reg__
 5034               	.LVL493:
 5035               	.LBE273:
 898:main.c        **** 				// Wait until ready
 5036               		.loc 3 898 0 discriminator 2
 5037 0b64 80E0      		ldi r24,lo8(receivedBuffer+64)
 5038 0b66 90E0      		ldi r25,hi8(receivedBuffer+64)
 5039 0b68 8A15      		cp r24,r10
 5040 0b6a 9B05      		cpc r25,r11
 5041 0b6c 01F4      		brne .L216
 5042 0b6e 90E2      		ldi r25,32
 5043 0b70 C90E      		add r12,r25
 5044 0b72 D11C      		adc r13,__zero_reg__
 5045 0b74 E11C      		adc r14,__zero_reg__
 5046 0b76 F11C      		adc r15,__zero_reg__
 5047               	.LVL494:
 5048               	.L317:
 5049               	.LBE272:
 922:main.c        **** 			}
 923:main.c        **** 			
 924:main.c        **** 			check_if_timed_out(); // Send ACK if successful write
 5050               		.loc 3 924 0
 5051 0b78 00D0      		rcall check_if_timed_out
 5052               	.LVL495:
 5053               	.LBE271:
 5054 0b7a 00C0      		rjmp .L106
 5055               	.LVL496:
 5056               	.L212:
 925:main.c        **** 		}
 926:main.c        **** 		
 927:main.c        **** 		// ---------- General commands ----------
 928:main.c        **** 		// Set any pin as input/output
 929:main.c        **** 		// Reads the DDR/PORT (e.g. DDRB/PORTB is 'B') and the hex value that represents pins to set to a
 930:main.c        **** 		else if (receivedChar == SET_INPUT || receivedChar == SET_OUTPUT) {
 5057               		.loc 3 930 0
 5058 0b7c 8934      		cpi r24,lo8(73)
 5059 0b7e 01F0      		breq .L217
 5060               		.loc 3 930 0 is_stmt 0 discriminator 1
 5061 0b80 8F34      		cpi r24,lo8(79)
 5062 0b82 01F0      		breq .+2
 5063 0b84 00C0      		rjmp .L218
 5064               	.L217:
 5065               	.LBB276:
 931:main.c        **** 			char portChar = USART_Receive();
 5066               		.loc 3 931 0 is_stmt 1
 5067 0b86 00D0      		rcall USART_Receive
 5068               	.LVL497:
 5069 0b88 182F      		mov r17,r24
 5070               	.LVL498:
 932:main.c        **** 			usart_read_chars();
 5071               		.loc 3 932 0
 5072 0b8a 00D0      		rcall usart_read_chars
 5073               	.LVL499:
 933:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5074               		.loc 3 933 0
 5075 0b8c 40E1      		ldi r20,lo8(16)
 5076 0b8e 50E0      		ldi r21,0
 5077 0b90 60E0      		ldi r22,0
 5078 0b92 70E0      		ldi r23,0
 5079 0b94 80E0      		ldi r24,lo8(receivedBuffer)
 5080 0b96 90E0      		ldi r25,hi8(receivedBuffer)
 5081 0b98 00D0      		rcall strtol
 5082               	.LVL500:
 934:main.c        **** 			
 935:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5083               		.loc 3 935 0
 5084 0b9a 939A      		sbi 0x12,3
 936:main.c        **** 			if (receivedChar == SET_INPUT) {
 5085               		.loc 3 936 0
 5086 0b9c 8091 0000 		lds r24,receivedChar
 5087 0ba0 8934      		cpi r24,lo8(73)
 5088 0ba2 01F4      		brne .L219
 937:main.c        **** 				if (portChar == 'A') {
 5089               		.loc 3 937 0
 5090 0ba4 1134      		cpi r17,lo8(65)
 5091 0ba6 01F4      		brne .L220
 938:main.c        **** 					DDRA &= ~(setValue);
 5092               		.loc 3 938 0
 5093 0ba8 8AB3      		in r24,0x1a
 5094 0baa 6095      		com r22
 5095               	.LVL501:
 5096 0bac 6823      		and r22,r24
 5097               	.LVL502:
 5098 0bae 00C0      		rjmp .L325
 5099               	.LVL503:
 5100               	.L220:
 939:main.c        **** 				}
 940:main.c        **** 				else if (portChar == 'B') {
 5101               		.loc 3 940 0
 5102 0bb0 1234      		cpi r17,lo8(66)
 5103 0bb2 01F4      		brne .L222
 941:main.c        **** 					DDRB &= ~(setValue);
 5104               		.loc 3 941 0
 5105 0bb4 87B3      		in r24,0x17
 5106 0bb6 6095      		com r22
 5107               	.LVL504:
 5108 0bb8 6823      		and r22,r24
 5109               	.LVL505:
 5110 0bba 00C0      		rjmp .L326
 5111               	.LVL506:
 5112               	.L222:
 942:main.c        **** 				}
 943:main.c        **** 				else if (portChar == 'C') {
 5113               		.loc 3 943 0
 5114 0bbc 1334      		cpi r17,lo8(67)
 5115 0bbe 01F4      		brne .L223
 944:main.c        **** 					DDRC &= ~(setValue);
 5116               		.loc 3 944 0
 5117 0bc0 84B3      		in r24,0x14
 5118 0bc2 6095      		com r22
 5119               	.LVL507:
 5120 0bc4 6823      		and r22,r24
 5121               	.LVL508:
 5122 0bc6 00C0      		rjmp .L331
 5123               	.LVL509:
 5124               	.L223:
 945:main.c        **** 				}
 946:main.c        **** 				else if (portChar == 'D') {
 5125               		.loc 3 946 0
 5126 0bc8 1434      		cpi r17,lo8(68)
 5127 0bca 01F4      		brne .L224
 947:main.c        **** 					DDRD &= ~(setValue);
 5128               		.loc 3 947 0
 5129 0bcc 81B3      		in r24,0x11
 5130 0bce 6095      		com r22
 5131               	.LVL510:
 5132 0bd0 6823      		and r22,r24
 5133               	.LVL511:
 5134 0bd2 00C0      		rjmp .L332
 5135               	.LVL512:
 5136               	.L224:
 948:main.c        **** 				}
 949:main.c        **** 				else if (portChar == 'E') {
 5137               		.loc 3 949 0
 5138 0bd4 1534      		cpi r17,lo8(69)
 5139 0bd6 01F0      		breq .+2
 5140 0bd8 00C0      		rjmp .L243
 950:main.c        **** 					DDRE &= ~(setValue);
 5141               		.loc 3 950 0
 5142 0bda 86B1      		in r24,0x6
 5143 0bdc 6095      		com r22
 5144               	.LVL513:
 5145 0bde 6823      		and r22,r24
 5146               	.LVL514:
 5147 0be0 00C0      		rjmp .L333
 5148               	.LVL515:
 5149               	.L219:
 951:main.c        **** 				}
 952:main.c        **** 			}
 953:main.c        **** 			else if (receivedChar == SET_OUTPUT) {
 5150               		.loc 3 953 0
 5151 0be2 8F34      		cpi r24,lo8(79)
 5152 0be4 01F0      		breq .+2
 5153 0be6 00C0      		rjmp .L243
 954:main.c        **** 				if (portChar == 'A') {
 5154               		.loc 3 954 0
 5155 0be8 1134      		cpi r17,lo8(65)
 5156 0bea 01F4      		brne .L225
 955:main.c        **** 					DDRA |= (setValue);
 5157               		.loc 3 955 0
 5158 0bec 8AB3      		in r24,0x1a
 5159 0bee 682B      		or r22,r24
 5160               	.LVL516:
 5161               	.L325:
 5162 0bf0 6ABB      		out 0x1a,r22
 5163 0bf2 00C0      		rjmp .L243
 5164               	.LVL517:
 5165               	.L225:
 956:main.c        **** 				}
 957:main.c        **** 				else if (portChar == 'B') {
 5166               		.loc 3 957 0
 5167 0bf4 1234      		cpi r17,lo8(66)
 5168 0bf6 01F4      		brne .L226
 958:main.c        **** 					DDRB |= (setValue);
 5169               		.loc 3 958 0
 5170 0bf8 87B3      		in r24,0x17
 5171 0bfa 682B      		or r22,r24
 5172               	.LVL518:
 5173               	.L326:
 5174 0bfc 67BB      		out 0x17,r22
 5175 0bfe 00C0      		rjmp .L243
 5176               	.LVL519:
 5177               	.L226:
 959:main.c        **** 				}
 960:main.c        **** 				else if (portChar == 'C') {
 5178               		.loc 3 960 0
 5179 0c00 1334      		cpi r17,lo8(67)
 5180 0c02 01F4      		brne .L227
 961:main.c        **** 					DDRC |= (setValue);
 5181               		.loc 3 961 0
 5182 0c04 84B3      		in r24,0x14
 5183 0c06 682B      		or r22,r24
 5184               	.LVL520:
 5185               	.L331:
 5186 0c08 64BB      		out 0x14,r22
 5187 0c0a 00C0      		rjmp .L243
 5188               	.LVL521:
 5189               	.L227:
 962:main.c        **** 				}
 963:main.c        **** 				else if (portChar == 'D') {
 5190               		.loc 3 963 0
 5191 0c0c 1434      		cpi r17,lo8(68)
 5192 0c0e 01F4      		brne .L228
 964:main.c        **** 					DDRD |= (setValue);
 5193               		.loc 3 964 0
 5194 0c10 81B3      		in r24,0x11
 5195 0c12 682B      		or r22,r24
 5196               	.LVL522:
 5197               	.L332:
 5198 0c14 61BB      		out 0x11,r22
 5199 0c16 00C0      		rjmp .L243
 5200               	.LVL523:
 5201               	.L228:
 965:main.c        **** 				}
 966:main.c        **** 				else if (portChar == 'E') {
 5202               		.loc 3 966 0
 5203 0c18 1534      		cpi r17,lo8(69)
 5204 0c1a 01F0      		breq .+2
 5205 0c1c 00C0      		rjmp .L243
 967:main.c        **** 					DDRE |= (setValue);
 5206               		.loc 3 967 0
 5207 0c1e 86B1      		in r24,0x6
 5208 0c20 682B      		or r22,r24
 5209               	.LVL524:
 5210               	.L333:
 5211 0c22 66B9      		out 0x6,r22
 5212 0c24 00C0      		rjmp .L243
 5213               	.LVL525:
 5214               	.L218:
 5215               	.LBE276:
 968:main.c        **** 				}
 969:main.c        **** 			}
 970:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 971:main.c        **** 		}
 972:main.c        **** 		
 973:main.c        **** 		// Set pin output as low
 974:main.c        **** 		else if (receivedChar == SET_OUTPUT_LOW) {
 5216               		.loc 3 974 0
 5217 0c26 8C34      		cpi r24,lo8(76)
 5218 0c28 01F4      		brne .L229
 5219               	.LBB277:
 975:main.c        **** 			char portChar = USART_Receive();			
 5220               		.loc 3 975 0
 5221 0c2a 00D0      		rcall USART_Receive
 5222               	.LVL526:
 5223 0c2c 182F      		mov r17,r24
 5224               	.LVL527:
 976:main.c        **** 			usart_read_chars();
 5225               		.loc 3 976 0
 5226 0c2e 00D0      		rcall usart_read_chars
 5227               	.LVL528:
 977:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5228               		.loc 3 977 0
 5229 0c30 40E1      		ldi r20,lo8(16)
 5230 0c32 50E0      		ldi r21,0
 5231 0c34 60E0      		ldi r22,0
 5232 0c36 70E0      		ldi r23,0
 5233 0c38 80E0      		ldi r24,lo8(receivedBuffer)
 5234 0c3a 90E0      		ldi r25,hi8(receivedBuffer)
 5235 0c3c 00D0      		rcall strtol
 5236               	.LVL529:
 978:main.c        **** 			
 979:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5237               		.loc 3 979 0
 5238 0c3e 939A      		sbi 0x12,3
 980:main.c        **** 			if (portChar == 'A') {
 5239               		.loc 3 980 0
 5240 0c40 1134      		cpi r17,lo8(65)
 5241 0c42 01F4      		brne .L230
 981:main.c        **** 				PORTA &= ~(setValue);
 5242               		.loc 3 981 0
 5243 0c44 8BB3      		in r24,0x1b
 5244 0c46 6095      		com r22
 5245               	.LVL530:
 5246 0c48 6823      		and r22,r24
 5247               	.LVL531:
 5248 0c4a 00C0      		rjmp .L330
 5249               	.LVL532:
 5250               	.L230:
 982:main.c        **** 			}
 983:main.c        **** 			else if (portChar == 'B') {
 5251               		.loc 3 983 0
 5252 0c4c 1234      		cpi r17,lo8(66)
 5253 0c4e 01F4      		brne .L232
 984:main.c        **** 				PORTB &= ~(setValue);
 5254               		.loc 3 984 0
 5255 0c50 88B3      		in r24,0x18
 5256 0c52 6095      		com r22
 5257               	.LVL533:
 5258 0c54 6823      		and r22,r24
 5259               	.LVL534:
 5260 0c56 00C0      		rjmp .L329
 5261               	.LVL535:
 5262               	.L232:
 985:main.c        **** 			}
 986:main.c        **** 			else if (portChar == 'C') {
 5263               		.loc 3 986 0
 5264 0c58 1334      		cpi r17,lo8(67)
 5265 0c5a 01F4      		brne .L233
 987:main.c        **** 				PORTC &= ~(setValue);
 5266               		.loc 3 987 0
 5267 0c5c 85B3      		in r24,0x15
 5268 0c5e 6095      		com r22
 5269               	.LVL536:
 5270 0c60 6823      		and r22,r24
 5271               	.LVL537:
 5272 0c62 00C0      		rjmp .L328
 5273               	.LVL538:
 5274               	.L233:
 988:main.c        **** 			}
 989:main.c        **** 			else if (portChar == 'D') {
 5275               		.loc 3 989 0
 5276 0c64 1434      		cpi r17,lo8(68)
 5277 0c66 01F4      		brne .L234
 990:main.c        **** 				PORTD &= ~(setValue);
 5278               		.loc 3 990 0
 5279 0c68 82B3      		in r24,0x12
 5280 0c6a 6095      		com r22
 5281               	.LVL539:
 5282 0c6c 6823      		and r22,r24
 5283               	.LVL540:
 5284 0c6e 00C0      		rjmp .L327
 5285               	.LVL541:
 5286               	.L234:
 991:main.c        **** 			}
 992:main.c        **** 			else if (portChar == 'E') {
 5287               		.loc 3 992 0
 5288 0c70 1534      		cpi r17,lo8(69)
 5289 0c72 01F0      		breq .+2
 5290 0c74 00C0      		rjmp .L243
 993:main.c        **** 				PORTE &= ~(setValue);
 5291               		.loc 3 993 0
 5292 0c76 87B1      		in r24,0x7
 5293 0c78 6095      		com r22
 5294               	.LVL542:
 5295 0c7a 6823      		and r22,r24
 5296               	.LVL543:
 5297 0c7c 00C0      		rjmp .L324
 5298               	.LVL544:
 5299               	.L229:
 5300               	.LBE277:
 994:main.c        **** 			}
 995:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 996:main.c        **** 		}
 997:main.c        **** 		
 998:main.c        **** 		// Set pin output as high
 999:main.c        **** 		else if (receivedChar == SET_OUTPUT_HIGH) {
 5301               		.loc 3 999 0
 5302 0c7e 8834      		cpi r24,lo8(72)
 5303 0c80 01F4      		brne .L235
 5304               	.LBB278:
1000:main.c        **** 			char portChar = USART_Receive();			
 5305               		.loc 3 1000 0
 5306 0c82 00D0      		rcall USART_Receive
 5307               	.LVL545:
 5308 0c84 182F      		mov r17,r24
 5309               	.LVL546:
1001:main.c        **** 			usart_read_chars();
 5310               		.loc 3 1001 0
 5311 0c86 00D0      		rcall usart_read_chars
 5312               	.LVL547:
1002:main.c        **** 			uint8_t setValue = strtol(receivedBuffer, NULL, 16);
 5313               		.loc 3 1002 0
 5314 0c88 40E1      		ldi r20,lo8(16)
 5315 0c8a 50E0      		ldi r21,0
 5316 0c8c 60E0      		ldi r22,0
 5317 0c8e 70E0      		ldi r23,0
 5318 0c90 80E0      		ldi r24,lo8(receivedBuffer)
 5319 0c92 90E0      		ldi r25,hi8(receivedBuffer)
 5320 0c94 00D0      		rcall strtol
 5321               	.LVL548:
1003:main.c        **** 			
1004:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5322               		.loc 3 1004 0
 5323 0c96 939A      		sbi 0x12,3
1005:main.c        **** 			if (portChar == 'A') {
 5324               		.loc 3 1005 0
 5325 0c98 1134      		cpi r17,lo8(65)
 5326 0c9a 01F4      		brne .L236
1006:main.c        **** 				PORTA |= (setValue);
 5327               		.loc 3 1006 0
 5328 0c9c 8BB3      		in r24,0x1b
 5329 0c9e 682B      		or r22,r24
 5330               	.LVL549:
 5331               	.L330:
 5332 0ca0 6BBB      		out 0x1b,r22
 5333 0ca2 00C0      		rjmp .L243
 5334               	.LVL550:
 5335               	.L236:
1007:main.c        **** 			}
1008:main.c        **** 			else if (portChar == 'B') {
 5336               		.loc 3 1008 0
 5337 0ca4 1234      		cpi r17,lo8(66)
 5338 0ca6 01F4      		brne .L238
1009:main.c        **** 				PORTB |= (setValue);
 5339               		.loc 3 1009 0
 5340 0ca8 88B3      		in r24,0x18
 5341 0caa 682B      		or r22,r24
 5342               	.LVL551:
 5343               	.L329:
 5344 0cac 68BB      		out 0x18,r22
 5345 0cae 00C0      		rjmp .L243
 5346               	.LVL552:
 5347               	.L238:
1010:main.c        **** 			}
1011:main.c        **** 			else if (portChar == 'C') {
 5348               		.loc 3 1011 0
 5349 0cb0 1334      		cpi r17,lo8(67)
 5350 0cb2 01F4      		brne .L239
1012:main.c        **** 				PORTC |= (setValue);
 5351               		.loc 3 1012 0
 5352 0cb4 85B3      		in r24,0x15
 5353 0cb6 682B      		or r22,r24
 5354               	.LVL553:
 5355               	.L328:
 5356 0cb8 65BB      		out 0x15,r22
 5357 0cba 00C0      		rjmp .L243
 5358               	.LVL554:
 5359               	.L239:
1013:main.c        **** 			}
1014:main.c        **** 			else if (portChar == 'D') {
 5360               		.loc 3 1014 0
 5361 0cbc 1434      		cpi r17,lo8(68)
 5362 0cbe 01F4      		brne .L240
1015:main.c        **** 				PORTD |= (setValue);
 5363               		.loc 3 1015 0
 5364 0cc0 82B3      		in r24,0x12
 5365 0cc2 682B      		or r22,r24
 5366               	.LVL555:
 5367               	.L327:
 5368 0cc4 62BB      		out 0x12,r22
 5369 0cc6 00C0      		rjmp .L243
 5370               	.LVL556:
 5371               	.L240:
1016:main.c        **** 			}
1017:main.c        **** 			else if (portChar == 'E') {
 5372               		.loc 3 1017 0
 5373 0cc8 1534      		cpi r17,lo8(69)
 5374 0cca 01F4      		brne .L243
1018:main.c        **** 				PORTE |= (setValue);
 5375               		.loc 3 1018 0
 5376 0ccc 87B1      		in r24,0x7
 5377 0cce 682B      		or r22,r24
 5378               	.LVL557:
 5379               	.L324:
 5380 0cd0 67B9      		out 0x7,r22
 5381 0cd2 00C0      		rjmp .L243
 5382               	.L235:
 5383               	.LBE278:
1019:main.c        **** 			}
1020:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
1021:main.c        **** 		}
1022:main.c        **** 		
1023:main.c        **** 		// Read all pins of a PORT and return the value
1024:main.c        **** 		else if (receivedChar == READ_INPUT) {
 5384               		.loc 3 1024 0
 5385 0cd4 8434      		cpi r24,lo8(68)
 5386 0cd6 01F4      		brne .L241
 5387               	.LBB279:
1025:main.c        **** 			char portChar = USART_Receive();			
 5388               		.loc 3 1025 0
 5389 0cd8 00D0      		rcall USART_Receive
 5390               	.LVL558:
1026:main.c        **** 			
1027:main.c        **** 			PORTD |= (1<<ACTIVITY_LED);
 5391               		.loc 3 1027 0
 5392 0cda 939A      		sbi 0x12,3
1028:main.c        **** 			if (portChar == 'A') {
 5393               		.loc 3 1028 0
 5394 0cdc 8134      		cpi r24,lo8(65)
 5395 0cde 01F4      		brne .L242
1029:main.c        **** 				USART_Transmit(PINA);
 5396               		.loc 3 1029 0
 5397 0ce0 89B3      		in r24,0x19
 5398               	.LVL559:
 5399 0ce2 00C0      		rjmp .L318
 5400               	.LVL560:
 5401               	.L242:
1030:main.c        **** 			}
1031:main.c        **** 			else if (portChar == 'B') {
 5402               		.loc 3 1031 0
 5403 0ce4 8234      		cpi r24,lo8(66)
 5404 0ce6 01F4      		brne .L244
1032:main.c        **** 				USART_Transmit(PINB);
 5405               		.loc 3 1032 0
 5406 0ce8 86B3      		in r24,0x16
 5407               	.LVL561:
 5408 0cea 00C0      		rjmp .L318
 5409               	.LVL562:
 5410               	.L244:
1033:main.c        **** 			}
1034:main.c        **** 			else if (portChar == 'C') {
 5411               		.loc 3 1034 0
 5412 0cec 8334      		cpi r24,lo8(67)
 5413 0cee 01F4      		brne .L245
1035:main.c        **** 				USART_Transmit(PINC);
 5414               		.loc 3 1035 0
 5415 0cf0 83B3      		in r24,0x13
 5416               	.LVL563:
 5417 0cf2 00C0      		rjmp .L318
 5418               	.LVL564:
 5419               	.L245:
1036:main.c        **** 			}
1037:main.c        **** 			else if (portChar == 'D') {
 5420               		.loc 3 1037 0
 5421 0cf4 8434      		cpi r24,lo8(68)
 5422 0cf6 01F4      		brne .L246
1038:main.c        **** 				USART_Transmit(PIND);
 5423               		.loc 3 1038 0
 5424 0cf8 80B3      		in r24,0x10
 5425               	.LVL565:
 5426 0cfa 00C0      		rjmp .L318
 5427               	.LVL566:
 5428               	.L246:
1039:main.c        **** 			}
1040:main.c        **** 			else if (portChar == 'E') {
 5429               		.loc 3 1040 0
 5430 0cfc 8534      		cpi r24,lo8(69)
 5431 0cfe 01F4      		brne .L243
1041:main.c        **** 				USART_Transmit(PINE);
 5432               		.loc 3 1041 0
 5433 0d00 85B1      		in r24,0x5
 5434               	.LVL567:
 5435               	.L318:
 5436 0d02 00D0      		rcall USART_Transmit
 5437               	.LVL568:
 5438               	.L243:
1042:main.c        **** 			}
1043:main.c        **** 			PORTD &= ~(1<<ACTIVITY_LED);
 5439               		.loc 3 1043 0
 5440 0d04 9398      		cbi 0x12,3
 5441               	.LBE279:
 5442 0d06 00C0      		rjmp .L106
 5443               	.LVL569:
 5444               	.L241:
1044:main.c        **** 		}
1045:main.c        **** 		
1046:main.c        **** 		// Set the reset common lines variable on or off, useful if you are controlling all the pins dire
1047:main.c        **** 		else if (receivedChar == RESET_COMMON_LINES) {
 5445               		.loc 3 1047 0
 5446 0d08 8D34      		cpi r24,lo8(77)
 5447 0d0a 01F4      		brne .L247
 5448               	.LBB280:
1048:main.c        **** 			char commonChar = USART_Receive();
 5449               		.loc 3 1048 0
 5450 0d0c 00D0      		rcall USART_Receive
 5451               	.LVL570:
1049:main.c        **** 			if (commonChar == '1') {
 5452               		.loc 3 1049 0
 5453 0d0e 8133      		cpi r24,lo8(49)
 5454 0d10 01F4      		brne .L338
1050:main.c        **** 				resetCommonLines = 1;
 5455               		.loc 3 1050 0
 5456 0d12 91E0      		ldi r25,lo8(1)
 5457 0d14 9D83      		std Y+5,r25
 5458 0d16 00C0      		rjmp .L313
 5459               	.L338:
1051:main.c        **** 			}
1052:main.c        **** 			else if (commonChar == '0') {
 5460               		.loc 3 1052 0
 5461 0d18 8033      		cpi r24,lo8(48)
 5462 0d1a 01F0      		breq .+2
 5463 0d1c 00C0      		rjmp .L106
1053:main.c        **** 				resetCommonLines = 0;
 5464               		.loc 3 1053 0
 5465 0d1e 1D82      		std Y+5,__zero_reg__
 5466 0d20 00C0      		rjmp .L107
 5467               	.LVL571:
 5468               	.L247:
 5469               	.LBE280:
1054:main.c        **** 			}
1055:main.c        **** 		}
1056:main.c        **** 		
1057:main.c        **** 		// Send back the PCB version number
1058:main.c        **** 		else if (receivedChar == READ_PCB_VERSION) {
 5470               		.loc 3 1058 0
 5471 0d22 8836      		cpi r24,lo8(104)
 5472 0d24 01F4      		brne .L248
1059:main.c        **** 			USART_Transmit(PCB_VERSION);
 5473               		.loc 3 1059 0
 5474 0d26 84E0      		ldi r24,lo8(4)
 5475 0d28 00C0      		rjmp .L315
 5476               	.L248:
1060:main.c        **** 		}
1061:main.c        **** 		
1062:main.c        **** 		// Send back the firmware version number
1063:main.c        **** 		else if (receivedChar == READ_FIRMWARE_VERSION) {
 5477               		.loc 3 1063 0
 5478 0d2a 8635      		cpi r24,lo8(86)
 5479 0d2c 01F4      		brne .L249
1064:main.c        **** 			USART_Transmit(FIRMWARE_VERSION);
 5480               		.loc 3 1064 0
 5481 0d2e 83E1      		ldi r24,lo8(19)
 5482               	.LVL572:
 5483               	.L315:
 5484 0d30 00D0      		rcall USART_Transmit
 5485               	.LVL573:
 5486 0d32 00C0      		rjmp .L106
 5487               	.LVL574:
 5488               	.L249:
1065:main.c        **** 		}
1066:main.c        **** 		
1067:main.c        **** 		// Send back 32KB for a speed test
1068:main.c        **** 		else if (receivedChar == FAST_READ_CHECK) {
 5489               		.loc 3 1068 0
 5490 0d34 8B32      		cpi r24,lo8(43)
 5491 0d36 01F4      		brne .L250
 5492 0d38 00E0      		ldi r16,0
 5493 0d3a 10E4      		ldi r17,lo8(64)
 5494               	.L251:
 5495               	.LVL575:
 5496               	.LBB281:
1069:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
1070:main.c        **** 				USART_Transmit('1');
 5497               		.loc 3 1070 0 discriminator 3
 5498 0d3c 81E3      		ldi r24,lo8(49)
 5499 0d3e 00D0      		rcall USART_Transmit
 5500               	.LVL576:
1071:main.c        **** 				USART_Transmit('0');
 5501               		.loc 3 1071 0 discriminator 3
 5502 0d40 80E3      		ldi r24,lo8(48)
 5503 0d42 00D0      		rcall USART_Transmit
 5504               	.LVL577:
 5505 0d44 0150      		subi r16,1
 5506 0d46 1109      		sbc r17,__zero_reg__
 5507               	.LVL578:
1069:main.c        **** 			for (uint16_t x = 0; x < 0x4000; x++) {
 5508               		.loc 3 1069 0 discriminator 3
 5509 0d48 01F4      		brne .L251
 5510 0d4a 00C0      		rjmp .L106
 5511               	.LVL579:
 5512               	.L250:
 5513               	.LBE281:
1072:main.c        **** 			}
1073:main.c        **** 		}
1074:main.c        **** 		
1075:main.c        **** 		// Reset the AVR if it matches the number
1076:main.c        **** 		else if (receivedChar == RESET_AVR) {
 5514               		.loc 3 1076 0
 5515 0d4c 8A32      		cpi r24,lo8(42)
 5516 0d4e 01F0      		breq .+2
 5517 0d50 00C0      		rjmp .L106
 5518               	.LBB282:
1077:main.c        **** 			usart_read_chars();
 5519               		.loc 3 1077 0
 5520 0d52 00D0      		rcall usart_read_chars
 5521               	.LVL580:
1078:main.c        **** 			uint32_t resetValue = strtol(receivedBuffer, NULL, 16);
 5522               		.loc 3 1078 0
 5523 0d54 40E1      		ldi r20,lo8(16)
 5524 0d56 50E0      		ldi r21,0
 5525 0d58 60E0      		ldi r22,0
 5526 0d5a 70E0      		ldi r23,0
 5527 0d5c 80E0      		ldi r24,lo8(receivedBuffer)
 5528 0d5e 90E0      		ldi r25,hi8(receivedBuffer)
 5529 0d60 00D0      		rcall strtol
 5530               	.LVL581:
1079:main.c        **** 			if (resetValue == RESET_VALUE) {
 5531               		.loc 3 1079 0
 5532 0d62 613E      		cpi r22,-31
 5533 0d64 754E      		sbci r23,-27
 5534 0d66 8740      		sbci r24,7
 5535 0d68 9105      		cpc r25,__zero_reg__
 5536 0d6a 01F0      		breq .+2
 5537 0d6c 00C0      		rjmp .L106
1080:main.c        **** 				// Clear watchdog flag
1081:main.c        **** 				MCUCSR &= ~(1<<WDRF);
 5538               		.loc 3 1081 0
 5539 0d6e 84B7      		in r24,0x34
 5540 0d70 877F      		andi r24,lo8(-9)
 5541 0d72 84BF      		out 0x34,r24
1082:main.c        **** 				
1083:main.c        **** 				// Start timed sequence
1084:main.c        **** 				WDTCR = (1<<WDCE) | (1<<WDE);
 5542               		.loc 3 1084 0
 5543 0d74 B8E1      		ldi r27,lo8(24)
 5544 0d76 B1BD      		out 0x21,r27
1085:main.c        **** 				
1086:main.c        **** 				// Reset in 250 ms
1087:main.c        **** 				WDTCR = (1<<WDP2) | (1<<WDE);
 5545               		.loc 3 1087 0
 5546 0d78 ECE0      		ldi r30,lo8(12)
 5547 0d7a E1BD      		out 0x21,r30
 5548               	.LVL582:
 5549               	.LBB283:
 5550               	.LBB284:
 5551               		.file 4 "c:\\winavr-20100110\\avr\\include\\util\\delay_basic.h"
   1:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay_basic.h ****    All rights reserved.
   4:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   5:c:\winavr-20100110\avr\include\util\delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:c:\winavr-20100110\avr\include\util\delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
   8:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  11:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:c:\winavr-20100110\avr\include\util\delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:c:\winavr-20100110\avr\include\util\delay_basic.h ****      the documentation and/or other materials provided with the
  14:c:\winavr-20100110\avr\include\util\delay_basic.h ****      distribution.
  15:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  16:c:\winavr-20100110\avr\include\util\delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:c:\winavr-20100110\avr\include\util\delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:c:\winavr-20100110\avr\include\util\delay_basic.h ****      from this software without specific prior written permission.
  19:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  20:c:\winavr-20100110\avr\include\util\delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:c:\winavr-20100110\avr\include\util\delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:c:\winavr-20100110\avr\include\util\delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:c:\winavr-20100110\avr\include\util\delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:c:\winavr-20100110\avr\include\util\delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:c:\winavr-20100110\avr\include\util\delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:c:\winavr-20100110\avr\include\util\delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:c:\winavr-20100110\avr\include\util\delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:c:\winavr-20100110\avr\include\util\delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  32:c:\winavr-20100110\avr\include\util\delay_basic.h **** /* $Id$ */
  33:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  34:c:\winavr-20100110\avr\include\util\delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:c:\winavr-20100110\avr\include\util\delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  37:c:\winavr-20100110\avr\include\util\delay_basic.h **** #include <inttypes.h>
  38:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  39:c:\winavr-20100110\avr\include\util\delay_basic.h **** #if !defined(__DOXYGEN__)
  40:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:c:\winavr-20100110\avr\include\util\delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:c:\winavr-20100110\avr\include\util\delay_basic.h **** #endif
  43:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  44:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \file */
  45:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \code
  47:c:\winavr-20100110\avr\include\util\delay_basic.h ****     #include <util/delay_basic.h>
  48:c:\winavr-20100110\avr\include\util\delay_basic.h ****     \endcode
  49:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  50:c:\winavr-20100110\avr\include\util\delay_basic.h ****     The functions in this header file implement simple delay loops
  51:c:\winavr-20100110\avr\include\util\delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:c:\winavr-20100110\avr\include\util\delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:c:\winavr-20100110\avr\include\util\delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:c:\winavr-20100110\avr\include\util\delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:c:\winavr-20100110\avr\include\util\delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:c:\winavr-20100110\avr\include\util\delay_basic.h ****     functions described here do not disable interrupts.
  57:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  58:c:\winavr-20100110\avr\include\util\delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:c:\winavr-20100110\avr\include\util\delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:c:\winavr-20100110\avr\include\util\delay_basic.h ****     concurrent processing of other events while the timer is
  61:c:\winavr-20100110\avr\include\util\delay_basic.h ****     running.  However, in particular for very short delays, the
  62:c:\winavr-20100110\avr\include\util\delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:c:\winavr-20100110\avr\include\util\delay_basic.h ****     to the overall delay time.
  64:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  65:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  67:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  68:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  69:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  70:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  71:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:c:\winavr-20100110\avr\include\util\delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:c:\winavr-20100110\avr\include\util\delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:c:\winavr-20100110\avr\include\util\delay_basic.h ****     register.
  76:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  77:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:c:\winavr-20100110\avr\include\util\delay_basic.h ****     can be achieved.
  79:c:\winavr-20100110\avr\include\util\delay_basic.h **** */
  80:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
  81:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
  83:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
  84:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"1: dec %0" "\n\t"
  85:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		"brne 1b"
  86:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "=r" (__count)
  87:c:\winavr-20100110\avr\include\util\delay_basic.h **** 		: "0" (__count)
  88:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	);
  89:c:\winavr-20100110\avr\include\util\delay_basic.h **** }
  90:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  91:c:\winavr-20100110\avr\include\util\delay_basic.h **** /** \ingroup util_delay_basic
  92:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  93:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:c:\winavr-20100110\avr\include\util\delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:c:\winavr-20100110\avr\include\util\delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:c:\winavr-20100110\avr\include\util\delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:c:\winavr-20100110\avr\include\util\delay_basic.h ****     counter register pair.
  98:c:\winavr-20100110\avr\include\util\delay_basic.h **** 
  99:c:\winavr-20100110\avr\include\util\delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:c:\winavr-20100110\avr\include\util\delay_basic.h ****     milliseconds can be achieved.
 101:c:\winavr-20100110\avr\include\util\delay_basic.h ****  */
 102:c:\winavr-20100110\avr\include\util\delay_basic.h **** void
 103:c:\winavr-20100110\avr\include\util\delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:c:\winavr-20100110\avr\include\util\delay_basic.h **** {
 105:c:\winavr-20100110\avr\include\util\delay_basic.h **** 	__asm__ volatile (
 5552               		.loc 4 105 0
 5553 0d7c 8FEF      		ldi r24,lo8(-1)
 5554 0d7e 9FEF      		ldi r25,lo8(-1)
 5555               	/* #APP */
 5556               	 ;  105 "c:\winavr-20100110\avr\include\util\delay_basic.h" 1
 5557 0d80 0197      		1: sbiw r24,1
 5558 0d82 01F4      		brne 1b
 5559               	 ;  0 "" 2
 5560               	.LVL583:
 5561               	/* #NOAPP */
 5562 0d84 00C0      		rjmp .L106
 5563               	.LBE284:
 5564               	.LBE283:
 5565               	.LBE282:
 5566               		.cfi_endproc
 5567               	.LFE51:
 5569               		.text
 5570               	.global	__vector_6
 5572               	__vector_6:
 5573               	.LFB52:
1088:main.c        **** 				
1089:main.c        **** 				// Wait for reset
1090:main.c        **** 				_delay_loop_2(65535);
1091:main.c        **** 			}
1092:main.c        **** 		}
1093:main.c        **** 	}
1094:main.c        **** }
1095:main.c        **** 
1096:main.c        **** // Timeout after ~500ms which also blinks the LED
1097:main.c        **** ISR(TIMER1_OVF_vect) {
 5574               		.loc 3 1097 0
 5575               		.cfi_startproc
 5576 07d0 1F92      		push r1
 5577               	.LCFI49:
 5578               		.cfi_def_cfa_offset 3
 5579               		.cfi_offset 1, -2
 5580 07d2 0F92      		push r0
 5581               	.LCFI50:
 5582               		.cfi_def_cfa_offset 4
 5583               		.cfi_offset 0, -3
 5584 07d4 0FB6      		in r0,__SREG__
 5585 07d6 0F92      		push r0
 5586 07d8 1124      		clr __zero_reg__
 5587 07da 8F93      		push r24
 5588               	.LCFI51:
 5589               		.cfi_def_cfa_offset 5
 5590               		.cfi_offset 24, -4
 5591 07dc 9F93      		push r25
 5592               	.LCFI52:
 5593               		.cfi_def_cfa_offset 6
 5594               		.cfi_offset 25, -5
 5595               	/* prologue: Signal */
 5596               	/* frame size = 0 */
 5597               	/* stack size = 5 */
 5598               	.L__stack_usage = 5
1098:main.c        **** 	PORTD ^= (1<<ACTIVITY_LED);
 5599               		.loc 3 1098 0
 5600 07de 92B3      		in r25,0x12
 5601 07e0 88E0      		ldi r24,lo8(8)
 5602 07e2 8927      		eor r24,r25
 5603 07e4 82BB      		out 0x12,r24
1099:main.c        **** 	writingTimedout = 1;
 5604               		.loc 3 1099 0
 5605 07e6 81E0      		ldi r24,lo8(1)
 5606 07e8 8093 0000 		sts writingTimedout,r24
 5607               	/* epilogue start */
1100:main.c        **** }...
 5608               		.loc 3 1100 0
 5609 07ec 9F91      		pop r25
 5610 07ee 8F91      		pop r24
 5611 07f0 0F90      		pop r0
 5612 07f2 0FBE      		out __SREG__,r0
 5613 07f4 0F90      		pop r0
 5614 07f6 1F90      		pop r1
 5615 07f8 1895      		reti
 5616               		.cfi_endproc
 5617               	.LFE52:
 5619               	.global	cartMode
 5620               		.data
 5623               	cartMode:
 5624 0000 02        		.byte	2
 5625               	.global	writingTimedout
 5626               		.section .bss
 5629               	writingTimedout:
 5630 0000 00        		.zero	1
 5631               	.global	lastBankAccessed
 5634               	lastBankAccessed:
 5635 0001 00        		.zero	1
 5636               	.global	flashBank1CommandWrites
 5639               	flashBank1CommandWrites:
 5640 0002 00        		.zero	1
 5641               		.comm	flashWriteCycle,12,1
 5642               		.comm	flashWriteWePin,1,1
 5643               		.comm	flashChipIdBuffer,2,1
 5644               		.comm	eepromBuffer,8,1
 5645               		.comm	receivedChar,1,1
 5646               		.comm	receivedBuffer,256,1
 5647               		.text
 5648               	.Letext0:
 5649               		.file 5 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 5650               		.file 6 "c:\\winavr-20100110\\avr\\include\\stdlib.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2      *ABS*:0000003e __SP_H__
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:3      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:4      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:12     .text:00000000 USART_Receive
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:34     .text:00000008 USART_Transmit
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:55     .text:00000010 usart_read_bytes
                            *COM*:00000100 receivedBuffer
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:118    .text:0000003a usart_read_chars
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:158    .text:00000050 rd_wr_csmreq_cs2_reset
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:180    .text:0000005a gb_mode
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:207    .text:0000006a set_16bit_address
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:226    .text:00000070 read_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:266    .text:00000082 write_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:331    .text:000000ae gba_mode
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:358    .text:000000be gba_set_24bit_address
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:411    .text:000000ea gba_read_16bit_data
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:459    .text:00000108 gba_read_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:499    .text:0000011a gba_write_ram_8bit_data
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:553    .text:0000013a gba_eeprom_mode
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:581    .text:0000014c gba_eeprom_set_address
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:720    .text:000001b4 gba_eeprom_read
                            *COM*:00000008 eepromBuffer
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:852    .text:0000020e gba_eeprom_write
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:968    .text:00000262 flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1014   .text:0000027c flash_read_chip_id
                            *COM*:00000002 flashChipIdBuffer
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1119   .text:000002e6 flash_switch_bank
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1168   .text:0000030c flash_erase_4k_sector
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1243   .text:00000354 flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1314   .text:0000038c flash_write_sector
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1427   .text:000003f8 gb_flash_read_byte
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1467   .text:0000040a gb_flash_read_byte_fast
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1499   .text:00000416 gb_flash_write_bus_cycle
                            *COM*:00000001 flashWriteWePin
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1578   .text:00000448 gb_flash_write_bus_cycle_fast
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1648   .text:0000046e gb_flash_write_byte
                            *COM*:0000000c flashWriteCycle
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:5629   .bss:00000000 writingTimedout
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1751   .text:000004d8 gb_flash_write_byte_special
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:5639   .bss:00000002 flashBank1CommandWrites
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:5634   .bss:00000001 lastBankAccessed
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:1876   .text:0000055a gb_flash_write_byte_bank1_commands
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2042   .text:000005f4 gba_flash_write_bus_cycle
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2108   .text:00000624 gba_flash_write_cycle_start_swapped
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2232   .text:00000684 gba_flash_write_cycle_start
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2354   .text:000006e0 gba_flash_write_byte
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2465   .text:0000073c start_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2488   .text:0000074c stop_timeout_timer
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2511   .text:0000075a check_if_timed_out
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2543   .text:0000076c setup
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:5623   .data:00000000 cartMode
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:2646   .text.startup:00000000 main
                            *COM*:00000001 receivedChar
C:\Users\Alex\AppData\Local\Temp\ccpfr8sm.s:5572   .text:000007d0 __vector_6

UNDEFINED SYMBOLS
strtol
atoi
__do_copy_data
__do_clear_bss
